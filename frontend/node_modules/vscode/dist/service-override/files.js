import { __decorate, __param } from '../node_modules/tslib/tslib.es6.js';
import '../missing-services.js';
import { StandaloneServices } from 'monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js';
import { SyncDescriptor } from 'monaco-editor/esm/vs/platform/instantiation/common/descriptors.js';
import { FileService } from '../vscode/vs/platform/files/common/fileService.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { InMemoryFileSystemProvider } from '../vscode/vs/platform/files/common/inMemoryFilesystemProvider.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { FileType, FilePermission } from '../vscode/vs/platform/files/common/files.js';
export { FileChangeType, FileSystemProviderCapabilities } from '../vscode/vs/platform/files/common/files.js';
import { createFileSystemProviderError, FileSystemProviderErrorCode, FileSystemProviderError, IFileService } from 'monaco-editor/esm/vs/platform/files/common/files.js';
export { FileSystemProviderError, FileSystemProviderErrorCode } from 'monaco-editor/esm/vs/platform/files/common/files.js';
import { Disposable, DisposableStore, toDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { extUri, joinPath } from 'monaco-editor/esm/vs/base/common/resources.js';
import { Emitter, Event } from 'monaco-editor/esm/vs/base/common/event.js';
export { HTMLFileSystemProvider } from 'monaco-editor/esm/vs/platform/files/browser/htmlFileSystemProvider.js';
import * as path from 'monaco-editor/esm/vs/base/common/path.js';
import '../vscode/vs/workbench/contrib/files/browser/files.contribution.js';
import { Schemas } from 'monaco-editor/esm/vs/base/common/network.js';
class RegisteredFile {
    constructor(uri, readonly) {
        this.uri = uri;
        this.readonly = readonly;
        this._onDidChange = new Emitter();
        this.onDidChange = this._onDidChange.event;
        this._onDidDelete = new Emitter();
        this.onDidDelete = this._onDidDelete.event;
        this._onDidRename = new Emitter();
        this.onDidRename = this._onDidRename.event;
        this.ctime = Date.now();
        this.mtime = Date.now();
        this.type = FileType.File;
    }
    async stats() {
        return {
            ctime: this.ctime,
            mtime: this.mtime,
            size: await this.getSize(),
            type: FileType.File,
            permissions: this.readonly ? FilePermission.Readonly : undefined
        };
    }
    async getSize() {
        return (await this.read()).length;
    }
    async delete() {
        this._onDidDelete.fire();
    }
    async rename(to) {
        const previousUri = this.uri;
        this.uri = to;
        this._onDidRename.fire({ from: previousUri, to });
    }
}
class RegisteredReadOnlyFile extends RegisteredFile {
    constructor(uri, read) {
        super(uri, true);
        this.read = read;
    }
    write() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.FileWriteLocked);
    }
    async delete() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.FileWriteLocked);
    }
    async rename() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.FileWriteLocked);
    }
}
class RegisteredMemoryFile extends RegisteredFile {
    constructor(uri, content) {
        super(uri, false);
        this.content = content;
    }
    async read() {
        return this.content;
    }
    async write(content) {
        this.content = content;
        this._onDidChange.fire();
    }
}
const encoder = new TextEncoder();
const decoder = new TextDecoder();
class RegisteredFileSystemProvider extends Disposable {
    constructor(readonly) {
        super();
        this.onDidChangeCapabilities = Event.None;
        this._onDidChangeFile = new Emitter();
        this.onDidChangeFile = this._onDidChangeFile.event;
        this.files = new Map();
        this.capabilities = 2  | 1024 ;
        if (readonly) {
            this.capabilities |= 2048 ;
        }
    }
    registerFile(file) {
        this.files.set(( file.uri.toString()), file);
        this._onDidChangeFile.fire([{
                resource: file.uri,
                type: 1
            }]);
        const disposableStore = new DisposableStore();
        disposableStore.add(toDisposable(() => {
            if (this.files.get(( file.uri.toString())) === file) {
                this.files.delete(( file.uri.toString()));
                this._onDidChangeFile.fire([{
                        resource: file.uri,
                        type: 2
                    }]);
            }
        }));
        disposableStore.add(file.onDidDelete(() => {
            disposableStore.dispose();
        }));
        disposableStore.add(file.onDidChange(() => {
            this._onDidChangeFile.fire([{
                    resource: file.uri,
                    type: 0
                }]);
        }));
        disposableStore.add(file.onDidRename(({ from, to }) => {
            if (this.files.get(( from.toString())) === file) {
                this.files.delete(( from.toString()));
                this._onDidChangeFile.fire([{
                        resource: from,
                        type: 2
                    }]);
                this.files.set(( to.toString()), file);
                this._onDidChangeFile.fire([{
                        resource: to,
                        type: 1
                    }]);
            }
        }));
        return disposableStore;
    }
    async stat(resource) {
        const resourceUri = ( resource.toString());
        const file = this.files.get(resourceUri);
        if (file != null) {
            return file.stats();
        }
        const handledUris = Array.from(( this.files.keys()));
        for (const handledUri of handledUris) {
            if (handledUri.startsWith(resourceUri + '/')) {
                return {
                    ctime: Date.now(),
                    mtime: Date.now(),
                    size: 0,
                    type: FileType.Directory
                };
            }
        }
        throw createFileSystemProviderError('file not found', FileSystemProviderErrorCode.FileNotFound);
    }
    async readdir(resource) {
        const includedPaths = ( Array.from(( this.files.keys()))
            .map(uri => path.relative(resource.path, ( URI.parse(uri)).path)))
            .filter(path => !path.startsWith('..'));
        const files = includedPaths.filter(path => !path.includes('/'));
        const directories = ( includedPaths.filter(path => path.includes('/')).map(path => path.slice(0, path.indexOf('/'))));
        return [
            ...( files.map(path => [
                path,
                FileType.File
            ])),
            ...( directories.map(path => [
                path,
                FileType.Directory
            ]))
        ];
    }
    async readFile(resource) {
        const file = this.files.get(( resource.toString()));
        if (file != null) {
            const data = await file.read();
            if (data instanceof Uint8Array) {
                return data;
            }
            else {
                return encoder.encode(data);
            }
        }
        throw FileSystemProviderError.create('file not found', FileSystemProviderErrorCode.FileNotFound);
    }
    watch() {
        return Disposable.None;
    }
    async writeFile(resource, content) {
        const file = this.files.get(( resource.toString()));
        if (file?.write != null) {
            await file.write(decoder.decode(content));
            return;
        }
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.NoPermissions);
    }
    async delete(resource) {
        const file = this.files.get(( resource.toString()));
        if (file != null) {
            await file.delete();
            return;
        }
        throw createFileSystemProviderError('File not found', FileSystemProviderErrorCode.FileNotFound);
    }
    async rename(from, to) {
        const file = this.files.get(( from.toString()));
        if (file != null) {
            await file.rename(to);
            return;
        }
        throw createFileSystemProviderError('File not found', FileSystemProviderErrorCode.FileNotFound);
    }
    async mkdir() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.NoPermissions);
    }
}
function isFullfiled(result) {
    return result.status === 'fulfilled';
}
class OverlayFileSystemProvider {
    constructor() {
        this.providers = [];
        this.onDidChangeCapabilities = Event.None;
        this._onDidChangeFile = new Emitter();
        this.onDidChangeFile = this._onDidChangeFile.event;
        this._onDidChangeOverlays = new Emitter();
        this.onDidChangeOverlays = this._onDidChangeOverlays.event;
        this.capabilities = 2  | 1024 ;
    }
    register(priority, provider) {
        const item = { priority, provider };
        this.providers.push(item);
        this.providers.sort((a, b) => b.priority - a.priority);
        const disposableStore = new DisposableStore();
        disposableStore.add(provider.onDidChangeFile(e => {
            this._onDidChangeFile.fire(e);
        }));
        disposableStore.add({
            dispose: () => {
                const index = this.providers.indexOf(item);
                if (index >= 0) {
                    this.providers.splice(index, 1);
                    this._onDidChangeOverlays.fire();
                }
            }
        });
        this._onDidChangeOverlays.fire();
        return disposableStore;
    }
    get delegates() {
        return ( this.providers.map(({ provider }) => provider));
    }
    async readFromDelegates(caller) {
        let firstError;
        for (const delegate of this.delegates) {
            try {
                return await caller(delegate);
            }
            catch (err) {
                firstError ?? (firstError = err);
                if (err instanceof FileSystemProviderError && [
                    FileSystemProviderErrorCode.NoPermissions,
                    FileSystemProviderErrorCode.FileNotFound,
                    FileSystemProviderErrorCode.Unavailable
                ].includes(err.code)) {
                    continue;
                }
                throw err;
            }
        }
        throw firstError;
    }
    async writeToDelegates(resource, caller) {
        for (const provider of this.delegates) {
            if (((provider.capabilities & 2048) ) > 0) {
                continue;
            }
            try {
                return await caller(provider);
            }
            catch (err) {
                if (err instanceof FileSystemProviderError && [
                    FileSystemProviderErrorCode.NoPermissions,
                    FileSystemProviderErrorCode.FileNotFound,
                    FileSystemProviderErrorCode.Unavailable
                ].includes(err.code)) {
                    continue;
                }
                throw err;
            }
        }
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.NoPermissions);
    }
    async stat(resource) {
        return this.readFromDelegates(async (delegate) => {
            const result = await delegate.stat(resource);
            const readOnly = ((delegate.capabilities & 2048) ) > 0;
            return {
                ...result,
                permissions: result.permissions ?? (readOnly ? FilePermission.Readonly : undefined)
            };
        });
    }
    async readFile(resource) {
        return this.readFromDelegates(delegate => delegate.readFile(resource));
    }
    async readdir(resource) {
        const results = await Promise.allSettled(( this.delegates.map(delegate => delegate.readdir(resource))));
        if (!( results.some(isFullfiled))) {
            throw results[0].reason;
        }
        return Object.entries(Object.fromEntries(( results.filter(isFullfiled).map(result => result.value)).flat()));
    }
    watch(resource, opts) {
        const store = new DisposableStore();
        for (const delegate of this.delegates) {
            store.add(delegate.watch(resource, opts));
        }
        return store;
    }
    async writeFile(resource, content, opts) {
        await this.writeToDelegates(resource, async (delegate) => {
            try {
                const stats = await delegate.stat(resource);
                if (((stats.permissions ?? 0) & FilePermission.Readonly) > 0) {
                    throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.NoPermissions);
                }
            }
            catch (err) {
            }
            return delegate.writeFile(resource, content, opts);
        });
    }
    async mkdir(resource) {
        await this.writeToDelegates(resource, delegate => delegate.mkdir(resource));
    }
    async delete(resource, opts) {
        await this.writeToDelegates(resource, delegate => delegate.delete(resource, opts));
    }
    async rename(from, to, opts) {
        await this.writeToDelegates(from, delegate => delegate.rename(from, to, opts));
    }
}
class MkdirpOnWriteInMemoryFileSystemProvider extends InMemoryFileSystemProvider {
    async writeFile(resource, content, opts) {
        await StandaloneServices.get(IFileService)['mkdirp'](this, extUri.dirname(resource));
        return super.writeFile(resource, content, opts);
    }
}
const fileSystemProvider = new OverlayFileSystemProvider();
fileSystemProvider.register(0, new MkdirpOnWriteInMemoryFileSystemProvider());
const extensionFileSystemProvider = new RegisteredFileSystemProvider(true);
let MemoryFileService = class MemoryFileService extends FileService {
    constructor(logService) {
        super(logService);
        const userMemoryFileSystem = new InMemoryFileSystemProvider();
        this.registerProvider('user', userMemoryFileSystem);
        this.registerProvider('extension', extensionFileSystemProvider);
        this.registerProvider('cache', new InMemoryFileSystemProvider());
        this.registerProvider('logs', new InMemoryFileSystemProvider());
        this.registerProvider(Schemas.vscodeUserData, new InMemoryFileSystemProvider());
        this.registerProvider(Schemas.tmp, new InMemoryFileSystemProvider());
        let fileSystemProviderDisposable = this.registerProvider('file', fileSystemProvider);
        fileSystemProvider.onDidChangeOverlays(() => {
            fileSystemProviderDisposable.dispose();
            fileSystemProviderDisposable = this.registerProvider('file', fileSystemProvider);
        });
    }
};
MemoryFileService = __decorate([
    ( __param(0, ILogService))
], MemoryFileService);
function getServiceOverride() {
    return {
        [( IFileService.toString())]: new SyncDescriptor(MemoryFileService, [], true)
    };
}
function registerExtensionFile(extensionLocation, filePath, getContent) {
    return extensionFileSystemProvider.registerFile(new RegisteredReadOnlyFile(joinPath(extensionLocation, filePath), getContent));
}
function registerFileSystemOverlay(priority, provider) {
    return fileSystemProvider.register(priority, provider);
}
export { FilePermission, FileType, InMemoryFileSystemProvider, RegisteredFile, RegisteredFileSystemProvider, RegisteredMemoryFile, RegisteredReadOnlyFile, getServiceOverride as default, registerExtensionFile, registerFileSystemOverlay };
