import { __decorate, __param } from '../../node_modules/tslib/tslib.es6.js';
import { StandaloneServices } from 'monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js';
import { ICodeEditorService } from 'monaco-editor/esm/vs/editor/browser/services/codeEditorService.js';
import { isPreferredGroup, SIDE_GROUP } from '../../vscode/vs/workbench/services/editor/common/editorService.js';
import { EditorCloseContext, isResourceEditorInput, isEditorInput } from '../../vscode/vs/workbench/common/editor.js';
import { applyTextEditorOptions } from '../../vscode/vs/workbench/common/editor/editorOptions.js';
import { DEFAULT_EDITOR_MIN_DIMENSIONS, DEFAULT_EDITOR_MAX_DIMENSIONS } from '../../vscode/vs/workbench/browser/parts/editor/editor.js';
import { ITextModelService } from 'monaco-editor/esm/vs/editor/common/services/resolverService.js';
import { StandaloneCodeEditor, StandaloneEditor } from 'monaco-editor/esm/vs/editor/standalone/browser/standaloneCodeEditor.js';
import { Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { EditorService } from '../../vscode/vs/workbench/services/editor/browser/editorService.js';
import { IEditorGroupsService } from '../../vscode/vs/workbench/services/editor/common/editorGroupsService.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { IWorkspaceTrustRequestService } from 'monaco-editor/esm/vs/platform/workspace/common/workspaceTrust.js';
import { IEditorResolverService } from '../../vscode/vs/workbench/services/editor/common/editorResolverService.js';
import { IUriIdentityService } from 'monaco-editor/esm/vs/platform/uriIdentity/common/uriIdentity.js';
import { IWorkspaceContextService } from 'monaco-editor/esm/vs/platform/workspace/common/workspace.js';
import { IFileService } from 'monaco-editor/esm/vs/platform/files/common/files.js';
import { ITextEditorService } from '../../vscode/vs/workbench/services/textfile/common/textEditorService.js';
import { IHostService } from '../../vscode/vs/workbench/services/host/browser/host.js';
import { Event, Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { TextResourceEditorInput } from '../../vscode/vs/workbench/common/editor/textResourceEditorInput.js';
import { IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { unsupported } from '../../tools.js';
class SimpleEditorPane {
    constructor(editor) {
        this.editor = editor;
        this.onDidChangeControl = Event.None;
        this.onDidChangeSizeConstraints = Event.None;
        this.onDidFocus = Event.None;
        this.onDidBlur = Event.None;
        this.input = undefined;
        this.options = undefined;
        this.group = undefined;
        this.scopedContextKeyService = undefined;
        this.getViewState = unsupported;
        this.isVisible = unsupported;
        this.hasFocus = unsupported;
        this.getId = unsupported;
        this.getTitle = unsupported;
        this.focus = unsupported;
    }
    get minimumWidth() { return DEFAULT_EDITOR_MIN_DIMENSIONS.width; }
    get maximumWidth() { return DEFAULT_EDITOR_MAX_DIMENSIONS.width; }
    get minimumHeight() { return DEFAULT_EDITOR_MIN_DIMENSIONS.height; }
    get maximumHeight() { return DEFAULT_EDITOR_MAX_DIMENSIONS.height; }
    getControl() {
        return this.editor;
    }
}
function wrapOpenEditor(textModelService, defaultBehavior, fallbackBahavior) {
    async function openEditor(editor, optionsOrPreferredGroup, preferredGroup) {
        const options = isEditorInput(editor) ? optionsOrPreferredGroup : editor.options;
        if (isPreferredGroup(optionsOrPreferredGroup)) {
            preferredGroup = optionsOrPreferredGroup;
        }
        const resource = isResourceEditorInput(editor) || isEditorInput(editor) ? editor.resource : undefined;
        if (resource == null || !textModelService.canHandleResource(resource)) {
            return defaultBehavior(editor, optionsOrPreferredGroup, preferredGroup);
        }
        let modelEditor;
        const codeEditors = StandaloneServices.get(ICodeEditorService).listCodeEditors();
        modelEditor = codeEditors.find(editor => editor instanceof StandaloneEditor && editor.getModel() != null && ( editor.getModel().uri.toString()) === ( resource.toString()));
        if (modelEditor == null) {
            const defaultBehaviorResult = await defaultBehavior(editor, optionsOrPreferredGroup, preferredGroup);
            if (defaultBehaviorResult != null) {
                return defaultBehaviorResult;
            }
            const modelRef = await textModelService.createModelReference(resource);
            modelEditor = await fallbackBahavior?.(modelRef, options, preferredGroup === SIDE_GROUP);
            if (modelEditor == null) {
                modelRef.dispose();
                return undefined;
            }
        }
        if (options != null) {
            applyTextEditorOptions(options, modelEditor, 1 );
        }
        if (!(options?.preserveFocus ?? false)) {
            modelEditor.focus();
            modelEditor.getContainerDomNode().scrollIntoView();
        }
        return new SimpleEditorPane(modelEditor);
    }
    return openEditor;
}
let MonacoEditorService = class MonacoEditorService extends EditorService {
    constructor(_openEditorFallback, _isEditorPartVisible, _editorGroupService, instantiationService, fileService, configurationService, contextService, uriIdentityService, editorResolverService, workspaceTrustRequestService, hostService, textEditorService, textModelService) {
        super(_editorGroupService, instantiationService, fileService, configurationService, contextService, uriIdentityService, editorResolverService, workspaceTrustRequestService, hostService, textEditorService);
        this._isEditorPartVisible = _isEditorPartVisible;
        this.openEditor = wrapOpenEditor(textModelService, this.openEditor.bind(this), _openEditorFallback);
    }
    get activeTextEditorControl() {
        const focusedCodeEditor = StandaloneServices.get(ICodeEditorService).getFocusedCodeEditor();
        if (focusedCodeEditor != null && focusedCodeEditor instanceof StandaloneCodeEditor) {
            return focusedCodeEditor;
        }
        return super.activeTextEditorControl;
    }
    async openEditor(editor, optionsOrPreferredGroup, preferredGroup) {
        if (!this._isEditorPartVisible()) {
            return undefined;
        }
        return super.openEditor(editor, optionsOrPreferredGroup, preferredGroup);
    }
};
MonacoEditorService = __decorate([
    ( __param(2, IEditorGroupsService)),
    ( __param(3, IInstantiationService)),
    ( __param(4, IFileService)),
    ( __param(5, IConfigurationService)),
    ( __param(6, IWorkspaceContextService)),
    ( __param(7, IUriIdentityService)),
    ( __param(8, IEditorResolverService)),
    ( __param(9, IWorkspaceTrustRequestService)),
    ( __param(10, IHostService)),
    ( __param(11, ITextEditorService)),
    ( __param(12, ITextModelService))
], MonacoEditorService);
class StandaloneEditorPane {
    constructor(editor, input, group) {
        this.editor = editor;
        this.input = input;
        this.group = group;
        this.onDidChangeControl = Event.None;
        this.options = undefined;
        this.minimumWidth = 0;
        this.maximumWidth = Number.POSITIVE_INFINITY;
        this.minimumHeight = 0;
        this.maximumHeight = Number.POSITIVE_INFINITY;
        this.onDidChangeSizeConstraints = Event.None;
        this.scopedContextKeyService = undefined;
        this.onDidFocus = this.editor.onDidFocusEditorWidget;
        this.onDidBlur = this.editor.onDidBlurEditorWidget;
    }
    getControl() {
        return this.editor;
    }
    getViewState() {
        return undefined;
    }
    isVisible() {
        return true;
    }
    hasFocus() {
        return this.editor.hasWidgetFocus();
    }
    getId() {
        return this.editor.getId();
    }
    getTitle() {
        return undefined;
    }
    focus() {
        this.editor.focus();
    }
}
let StandaloneEditorGroup = class StandaloneEditorGroup extends Disposable {
    constructor(editor, instantiationService, scopedContextKeyService) {
        super();
        this.editor = editor;
        this.scopedContextKeyService = scopedContextKeyService;
        this.active = false;
        this.onDidFocus = this.editor.onDidFocusEditorWidget;
        this.onDidOpenEditorFail = Event.None;
        this.whenRestored = Promise.resolve();
        this.disposed = false;
        this.notifyIndexChanged = unsupported;
        this.relayout = unsupported;
        this.toJSON = unsupported;
        this.minimumWidth = 0;
        this.maximumWidth = Number.POSITIVE_INFINITY;
        this.minimumHeight = 0;
        this.maximumHeight = Number.POSITIVE_INFINITY;
        this.onDidChange = this.editor.onDidLayoutChange;
        this.layout = () => this.editor.layout();
        this._onDidModelChange = new Emitter();
        this.onDidModelChange = this._onDidModelChange.event;
        this.onWillDispose = this.editor.onDidDispose;
        this._onDidActiveEditorChange = new Emitter();
        this.onDidActiveEditorChange = this._onDidActiveEditorChange.event;
        this.onWillCloseEditor = Event.None;
        this._onDidCloseEditor = new Emitter();
        this.onDidCloseEditor = this._onDidCloseEditor.event;
        this.onWillMoveEditor = Event.None;
        this._onWillOpenEditor = new Emitter();
        this.onWillOpenEditor = this._onWillOpenEditor.event;
        this.id = --StandaloneEditorGroup.idCounter;
        this.index = -1;
        this.label = `standalone editor ${this.editor.getId()}`;
        this.ariaLabel = `standalone editor ${this.editor.getId()}`;
        this.previewEditor = null;
        this.isLocked = true;
        this.stickyCount = 0;
        this.getEditors = () => this.editors;
        this.findEditors = (resource) => this.pane != null && ( resource.toString()) === ( this.pane.input.resource.toString()) ? [this.pane.input] : [];
        this.getEditorByIndex = (index) => this.pane != null && index === 0 ? this.pane.input : undefined;
        this.getIndexOfEditor = (editorInput) => this.pane != null && this.pane.input === editorInput ? 0 : -1;
        this.openEditor = unsupported;
        this.openEditors = unsupported;
        this.isPinned = () => false;
        this.isSticky = () => false;
        this.isActive = () => this.editor.hasWidgetFocus();
        this.contains = (candidate) => {
            return this.pane != null && this.pane.input === candidate;
        };
        this.moveEditor = unsupported;
        this.moveEditors = unsupported;
        this.copyEditor = unsupported;
        this.copyEditors = unsupported;
        this.closeEditor = unsupported;
        this.closeEditors = unsupported;
        this.closeAllEditors = unsupported;
        this.replaceEditors = unsupported;
        this.pinEditor = unsupported;
        this.stickEditor = unsupported;
        this.unstickEditor = unsupported;
        this.lock = unsupported;
        this.isFirst = unsupported;
        this.isLast = unsupported;
        const onNewModel = (uri) => {
            const editorInput = instantiationService.createInstance(TextResourceEditorInput, uri, undefined, undefined, undefined, undefined);
            this._onWillOpenEditor.fire({
                editor: editorInput,
                groupId: this.id
            });
            this.pane = new StandaloneEditorPane(editor, editorInput, this);
            this._onDidModelChange.fire({
                kind: 3 ,
                editor: editorInput,
                editorIndex: 0
            });
            this._onDidActiveEditorChange.fire({
                editor: editorInput
            });
        };
        const onRemovedModel = (uri) => {
            if (this.pane != null && ( this.pane.input.resource.toString()) === ( uri.toString())) {
                const pane = this.pane;
                this.pane = undefined;
                this._onDidModelChange.fire({
                    kind: 4 ,
                    editorIndex: 0
                });
                this._onDidActiveEditorChange.fire({
                    editor: undefined
                });
                this._onDidCloseEditor.fire({
                    context: EditorCloseContext.UNKNOWN,
                    editor: pane.input,
                    groupId: this.id,
                    index: 0,
                    sticky: false
                });
            }
        };
        editor.onDidChangeModel((e) => {
            if (e.oldModelUrl != null) {
                onRemovedModel(e.oldModelUrl);
            }
            if (e.newModelUrl != null) {
                onNewModel(e.newModelUrl);
            }
        });
        this._register({
            dispose: () => {
                const model = editor.getModel();
                if (model != null) {
                    onRemovedModel(model.uri);
                }
            }
        });
        const currentModel = editor.getModel();
        if (currentModel != null) {
            const editorInput = instantiationService.createInstance(TextResourceEditorInput, currentModel.uri, undefined, undefined, undefined, undefined);
            this.pane = new StandaloneEditorPane(editor, editorInput, this);
        }
    }
    get titleHeight() { return unsupported(); }
    setActive(isActive) {
        this.active = isActive;
    }
    get element() { return unsupported(); }
    get activeEditorPane() {
        return this.pane;
    }
    get activeEditor() {
        return this.pane?.input ?? null;
    }
    get count() {
        return this.pane != null ? 1 : 0;
    }
    get isEmpty() {
        return this.pane == null;
    }
    get editors() {
        return this.pane != null ? [this.pane.input] : [];
    }
    focus() {
        this.editor.focus();
    }
};
StandaloneEditorGroup.idCounter = 0;
StandaloneEditorGroup = __decorate([
    ( __param(1, IInstantiationService)),
    ( __param(2, IContextKeyService))
], StandaloneEditorGroup);
let MonacoDelegateEditorGroupsService = class MonacoDelegateEditorGroupsService extends Disposable {
    constructor(delegate, instantiationService) {
        super();
        this.delegate = delegate;
        this._serviceBrand = undefined;
        this.additionalGroups = [];
        this.activeGroupOverride = undefined;
        this._onDidChangeActiveGroup = new Emitter();
        this.onDidChangeActiveGroup = Event.any(this._onDidChangeActiveGroup.event, this.delegate.onDidChangeActiveGroup);
        this._onDidAddGroup = new Emitter();
        this.onDidAddGroup = Event.any(this._onDidAddGroup.event, this.delegate.onDidAddGroup);
        this._onDidRemoveGroup = new Emitter();
        this.onDidRemoveGroup = Event.any(this._onDidRemoveGroup.event, this.delegate.onDidRemoveGroup);
        this.onDidMoveGroup = this.delegate.onDidMoveGroup;
        this.onDidActivateGroup = this.delegate.onDidActivateGroup;
        this.onDidLayout = this.delegate.onDidLayout;
        this.onDidScroll = this.delegate.onDidScroll;
        this.onDidChangeGroupIndex = this.delegate.onDidChangeGroupIndex;
        this.onDidChangeGroupLocked = this.delegate.onDidChangeGroupLocked;
        this.getLayout = () => {
            return this.delegate.getLayout();
        };
        this.getGroups = (order) => {
            return [...this.additionalGroups, ...this.delegate.getGroups(order)];
        };
        this.getGroup = (identifier) => {
            return this.delegate.getGroup(identifier) ?? this.additionalGroups.find(group => group.id === identifier);
        };
        this.activateGroup = (...args) => {
            return this.delegate.activateGroup(...args);
        };
        this.getSize = (...args) => {
            return this.delegate.getSize(...args);
        };
        this.setSize = (...args) => {
            return this.delegate.setSize(...args);
        };
        this.arrangeGroups = (...args) => {
            return this.delegate.arrangeGroups(...args);
        };
        this.applyLayout = (...args) => {
            return this.delegate.applyLayout(...args);
        };
        this.centerLayout = (...args) => {
            return this.delegate.centerLayout(...args);
        };
        this.isLayoutCentered = (...args) => {
            return this.delegate.isLayoutCentered(...args);
        };
        this.setGroupOrientation = (...args) => {
            return this.delegate.setGroupOrientation(...args);
        };
        this.findGroup = (...args) => {
            return this.delegate.findGroup(...args);
        };
        this.addGroup = (...args) => {
            return this.delegate.addGroup(...args);
        };
        this.removeGroup = (...args) => {
            return this.delegate.removeGroup(...args);
        };
        this.moveGroup = (...args) => {
            return this.delegate.moveGroup(...args);
        };
        this.mergeGroup = (...args) => {
            return this.delegate.mergeGroup(...args);
        };
        this.mergeAllGroups = (...args) => {
            return this.delegate.mergeAllGroups(...args);
        };
        this.copyGroup = (...args) => {
            return this.delegate.copyGroup(...args);
        };
        this.enforcePartOptions = (...args) => {
            return this.delegate.enforcePartOptions(...args);
        };
        this.onDidChangeEditorPartOptions = this.delegate.onDidChangeEditorPartOptions;
        setTimeout(() => {
            const codeEditorService = StandaloneServices.get(ICodeEditorService);
            const handleCodeEditor = (editor) => {
                if (editor instanceof StandaloneEditor) {
                    const onEditorFocused = () => {
                        this.activeGroupOverride = this.additionalGroups.find(group => group.editor === editor);
                        this._onDidChangeActiveGroup.fire(this.activeGroup);
                    };
                    editor.onDidFocusEditorText(onEditorFocused);
                    editor.onDidFocusEditorWidget(onEditorFocused);
                    if (editor.hasWidgetFocus()) {
                        onEditorFocused();
                    }
                    const newGroup = instantiationService.createInstance(StandaloneEditorGroup, editor);
                    this.additionalGroups.push(newGroup);
                    this._onDidAddGroup.fire(newGroup);
                }
            };
            const handleCodeEditorRemoved = (editor) => {
                if (editor instanceof StandaloneEditor) {
                    const removedGroup = this.additionalGroups.find(group => group.editor === editor);
                    if (removedGroup != null) {
                        removedGroup.dispose();
                        if (this.activeGroupOverride === removedGroup) {
                            this.activeGroupOverride = undefined;
                            this._onDidChangeActiveGroup.fire(this.activeGroup);
                        }
                        this.additionalGroups = this.additionalGroups.filter(group => group !== removedGroup);
                        this._onDidRemoveGroup.fire(removedGroup);
                    }
                }
            };
            this._register(codeEditorService.onCodeEditorAdd(handleCodeEditor));
            this._register(codeEditorService.onCodeEditorRemove(handleCodeEditorRemoved));
            codeEditorService.listCodeEditors().forEach(handleCodeEditor);
        });
    }
    get groups() {
        return [...this.additionalGroups, ...this.delegate.groups];
    }
    get activeGroup() {
        return this.activeGroupOverride ?? this.delegate.activeGroup;
    }
    get contentDimension() { return this.delegate.contentDimension; }
    get sideGroup() { return this.delegate.sideGroup; }
    get count() { return this.delegate.count + this.additionalGroups.length; }
    get orientation() { return this.delegate.orientation; }
    get isReady() { return this.delegate.isReady; }
    get whenReady() { return this.delegate.whenReady; }
    get whenRestored() { return this.delegate.whenRestored; }
    get hasRestorableState() { return this.delegate.hasRestorableState; }
    get partOptions() { return this.delegate.partOptions; }
};
MonacoDelegateEditorGroupsService = __decorate([
    ( __param(1, IInstantiationService))
], MonacoDelegateEditorGroupsService);
export { MonacoDelegateEditorGroupsService, MonacoEditorService, wrapOpenEditor };
