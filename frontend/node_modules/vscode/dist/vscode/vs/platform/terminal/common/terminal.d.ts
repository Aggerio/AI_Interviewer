import { Event } from '../../../base/common/event.js';
import { OperatingSystem, IProcessEnvironment } from '../../../base/common/platform.js';
import { URI, UriComponents } from '../../../base/common/uri.js';
import { ISerializedCommandDetectionCapability } from './capabilities/capabilities.js';
import { IProcessDetails } from './terminalProcess.js';
import { ThemeIcon } from '../../../base/common/themables.js';
import { ISerializableEnvironmentVariableCollections } from './environmentVariable.js';
import { IWorkspaceFolder } from '../../workspace/common/workspace.js';
import { PerformanceMark } from '../../../base/common/performance.js';

declare const enum PosixShellType {
    PowerShell = "pwsh",
    Bash = "bash",
    Fish = "fish",
    Sh = "sh",
    Csh = "csh",
    Ksh = "ksh",
    Zsh = "zsh"
}
declare const enum WindowsShellType {
    CommandPrompt = "cmd",
    PowerShell = "pwsh",
    Wsl = "wsl",
    GitBash = "gitbash"
}
type TerminalShellType = PosixShellType | WindowsShellType;
interface IRawTerminalInstanceLayoutInfo<T> {
    relativeSize: number;
    terminal: T;
}
interface IRawTerminalTabLayoutInfo<T> {
    isActive: boolean;
    activePersistentProcessId: number | undefined;
    terminals: IRawTerminalInstanceLayoutInfo<T>[];
}
interface IRawTerminalsLayoutInfo<T> {
    tabs: IRawTerminalTabLayoutInfo<T>[];
}
interface IPtyHostAttachTarget {
    id: number;
    pid: number;
    title: string;
    titleSource: TitleEventSource;
    cwd: string;
    workspaceId: string;
    workspaceName: string;
    isOrphan: boolean;
    icon: TerminalIcon | undefined;
    fixedDimensions: IFixedTerminalDimensions | undefined;
    environmentVariableCollections: ISerializableEnvironmentVariableCollections | undefined;
    reconnectionProperties?: IReconnectionProperties;
    waitOnExit?: WaitOnExitValue;
    hideFromUser?: boolean;
    isFeatureTerminal?: boolean;
    type?: TerminalType;
    hasChildProcesses: boolean;
    shellIntegrationNonce: string;
}
interface IReconnectionProperties {
    ownerId: string;
    data?: unknown;
}
type TerminalType = 'Task' | 'Local' | undefined;
declare enum TitleEventSource {
    /** From the API or the rename command that overrides any other type */
    Api = 0,
    /** From the process name property*/
    Process = 1,
    /** From the VT sequence */
    Sequence = 2,
    /** Config changed */
    Config = 3
}
type ITerminalsLayoutInfo = IRawTerminalsLayoutInfo<IPtyHostAttachTarget | null>;
type ITerminalsLayoutInfoById = IRawTerminalsLayoutInfo<number>;
declare const enum ProcessPropertyType {
    Cwd = "cwd",
    InitialCwd = "initialCwd",
    FixedDimensions = "fixedDimensions",
    Title = "title",
    ShellType = "shellType",
    HasChildProcesses = "hasChildProcesses",
    ResolvedShellLaunchConfig = "resolvedShellLaunchConfig",
    OverrideDimensions = "overrideDimensions",
    FailedShellIntegrationActivation = "failedShellIntegrationActivation",
    UsedShellIntegrationInjection = "usedShellIntegrationInjection"
}
interface IProcessProperty<T extends ProcessPropertyType> {
    type: T;
    value: IProcessPropertyMap[T];
}
interface IProcessPropertyMap {
    [ProcessPropertyType.Cwd]: string;
    [ProcessPropertyType.InitialCwd]: string;
    [ProcessPropertyType.FixedDimensions]: IFixedTerminalDimensions;
    [ProcessPropertyType.Title]: string;
    [ProcessPropertyType.ShellType]: TerminalShellType | undefined;
    [ProcessPropertyType.HasChildProcesses]: boolean;
    [ProcessPropertyType.ResolvedShellLaunchConfig]: IShellLaunchConfig;
    [ProcessPropertyType.OverrideDimensions]: ITerminalDimensionsOverride | undefined;
    [ProcessPropertyType.FailedShellIntegrationActivation]: boolean | undefined;
    [ProcessPropertyType.UsedShellIntegrationInjection]: boolean | undefined;
}
interface IFixedTerminalDimensions {
    /**
     * The fixed columns of the terminal.
     */
    cols?: number;
    /**
     * The fixed rows of the terminal.
     */
    rows?: number;
}
interface IPtyHostLatencyMeasurement {
    label: string;
    latency: number;
}
interface IShellLaunchConfig {
    /**
     * The name of the terminal, if this is not set the name of the process will be used.
     */
    name?: string;
    /**
     * A string to follow the name of the terminal with, indicating the type of terminal
     */
    type?: 'Task' | 'Local';
    /**
     * The shell executable (bash, cmd, etc.).
     */
    executable?: string;
    /**
     * The CLI arguments to use with executable, a string[] is in argv format and will be escaped,
     * a string is in "CommandLine" pre-escaped format and will be used as is. The string option is
     * only supported on Windows and will throw an exception if used on macOS or Linux.
     */
    args?: string[] | string;
    /**
     * The current working directory of the terminal, this overrides the `terminal.integrated.cwd`
     * settings key.
     */
    cwd?: string | URI;
    /**
     * A custom environment for the terminal, if this is not set the environment will be inherited
     * from the VS Code process.
     */
    env?: ITerminalEnvironment;
    /**
     * Whether to ignore a custom cwd from the `terminal.integrated.cwd` settings key (e.g. if the
     * shell is being launched by an extension).
     */
    ignoreConfigurationCwd?: boolean;
    /**
     * The reconnection properties for this terminal
     */
    reconnectionProperties?: IReconnectionProperties;
    /** Whether to wait for a key press before closing the terminal. */
    waitOnExit?: WaitOnExitValue;
    /**
     * A string including ANSI escape sequences that will be written to the terminal emulator
     * _before_ the terminal process has launched, when a string is specified, a trailing \n is
     * added at the end. This allows for example the terminal instance to display a styled message
     * as the first line of the terminal. Use \x1b over \033 or \e for the escape control character.
     */
    initialText?: string | {
        text: string;
        trailingNewLine: boolean;
    };
    /**
     * Custom PTY/pseudoterminal process to use.
     */
    customPtyImplementation?: (terminalId: number, cols: number, rows: number) => ITerminalChildProcess;
    /**
     * A UUID generated by the extension host process for terminals created on the extension host process.
     */
    extHostTerminalId?: string;
    /**
     * This is a terminal that attaches to an already running terminal.
     */
    attachPersistentProcess?: {
        id: number;
        findRevivedId?: boolean;
        pid: number;
        title: string;
        titleSource: TitleEventSource;
        cwd: string;
        icon?: TerminalIcon;
        color?: string;
        hasChildProcesses?: boolean;
        fixedDimensions?: IFixedTerminalDimensions;
        environmentVariableCollections?: ISerializableEnvironmentVariableCollections;
        reconnectionProperties?: IReconnectionProperties;
        type?: TerminalType;
        waitOnExit?: WaitOnExitValue;
        hideFromUser?: boolean;
        isFeatureTerminal?: boolean;
        shellIntegrationNonce: string;
    };
    /**
     * Whether the terminal process environment should be exactly as provided in
     * `TerminalOptions.env`. When this is false (default), the environment will be based on the
     * window's environment and also apply configured platform settings like
     * `terminal.integrated.env.windows` on top. When this is true, the complete environment must be
     * provided as nothing will be inherited from the process or any configuration.
     */
    strictEnv?: boolean;
    /**
     * Whether the terminal process environment will inherit VS Code's "shell environment" that may
     * get sourced from running a login shell depnding on how the application was launched.
     * Consumers that rely on development tools being present in the $PATH should set this to true.
     * This will overwrite the value of the inheritEnv setting.
     */
    useShellEnvironment?: boolean;
    /**
     * When enabled the terminal will run the process as normal but not be surfaced to the user
     * until `Terminal.show` is called. The typical usage for this is when you need to run
     * something that may need interactivity but only want to tell the user about it when
     * interaction is needed. Note that the terminals will still be exposed to all extensions
     * as normal.
     */
    hideFromUser?: boolean;
    /**
     * Whether this terminal is not a terminal that the user directly created and uses, but rather
     * a terminal used to drive some VS Code feature.
     */
    isFeatureTerminal?: boolean;
    /**
     * Whether this terminal was created by an extension.
     */
    isExtensionOwnedTerminal?: boolean;
    /**
     * The icon for the terminal, used primarily in the terminal tab.
     */
    icon?: TerminalIcon;
    /**
     * The color ID to use for this terminal. If not specified it will use the default fallback
     */
    color?: string;
    /**
     * When a parent terminal is provided via API, the group needs
     * to find the index in order to place the child
     * directly to the right of its parent.
     */
    parentTerminalId?: number;
    /**
     * The dimensions for the instance as set by the user
     * or via Size to Content Width
     */
    fixedDimensions?: IFixedTerminalDimensions;
    /**
     * Opt-out of the default terminal persistence on restart and reload
     */
    isTransient?: boolean;
    /**
     * Create a terminal without shell integration even when it's enabled
     */
    ignoreShellIntegration?: boolean;
}
type WaitOnExitValue = boolean | string | ((exitCode: number) => string);
interface ICreateContributedTerminalProfileOptions {
    icon?: URI | string | {
        light: URI;
        dark: URI;
    };
    color?: string;
    location?: TerminalLocation | {
        viewColumn: number;
        preserveState?: boolean;
    } | {
        splitActiveTerminal: boolean;
    };
}
declare enum TerminalLocation {
    Panel = 1,
    Editor = 2
}
type TerminalIcon = ThemeIcon | URI | {
    light: URI;
    dark: URI;
};
interface IShellLaunchConfigDto {
    name?: string;
    executable?: string;
    args?: string[] | string;
    cwd?: string | UriComponents;
    env?: ITerminalEnvironment;
    useShellEnvironment?: boolean;
    hideFromUser?: boolean;
    reconnectionProperties?: IReconnectionProperties;
    type?: 'Task' | 'Local';
    isFeatureTerminal?: boolean;
}
/**
 * A set of options for the terminal process. These differ from the shell launch config in that they
 * are set internally to the terminal component, not from the outside.
 */
interface ITerminalProcessOptions {
    shellIntegration: {
        enabled: boolean;
        suggestEnabled: boolean;
        nonce: string;
    };
    windowsEnableConpty: boolean;
    environmentVariableCollections: ISerializableEnvironmentVariableCollections | undefined;
    workspaceFolder: IWorkspaceFolder | undefined;
}
interface ITerminalEnvironment {
    [key: string]: string | null | undefined;
}
interface ITerminalLaunchError {
    message: string;
    code?: number;
}
interface IProcessReadyEvent {
    pid: number;
    cwd: string;
    windowsPty: IProcessReadyWindowsPty | undefined;
}
interface IProcessReadyWindowsPty {
    /**
     * What pty emulation backend is being used.
     */
    backend: 'conpty' | 'winpty';
    /**
     * The Windows build version (eg. 19045)
     */
    buildNumber: number;
}
/**
 * An interface representing a raw terminal child process, this contains a subset of the
 * child_process.ChildProcess node.js interface.
 */
interface ITerminalChildProcess {
    /**
     * A unique identifier for the terminal process. Note that the uniqueness only applies to a
     * given pty service connection, IDs will be duplicated for remote and local terminals for
     * example. The ID will be 0 if it does not support reconnection.
     */
    id: number;
    /**
     * Whether the process should be persisted across reloads.
     */
    shouldPersist: boolean;
    onProcessData: Event<IProcessDataEvent | string>;
    onProcessReady: Event<IProcessReadyEvent>;
    onProcessReplayComplete?: Event<void>;
    onDidChangeProperty: Event<IProcessProperty<any>>;
    onProcessExit: Event<number | undefined>;
    onRestoreCommands?: Event<ISerializedCommandDetectionCapability>;
    /**
     * Starts the process.
     *
     * @returns undefined when the process was successfully started, otherwise an object containing
     * information on what went wrong.
     */
    start(): Promise<ITerminalLaunchError | {
        injectedArgs: string[];
    } | undefined>;
    /**
     * Detach the process from the UI and await reconnect.
     * @param forcePersist Whether to force the process to persist if it supports persistence.
     */
    detach?(forcePersist?: boolean): Promise<void>;
    /**
     * Frees the port and kills the process
     */
    freePortKillProcess?(port: string): Promise<{
        port: string;
        processId: string;
    }>;
    /**
     * Shutdown the terminal process.
     *
     * @param immediate When true the process will be killed immediately, otherwise the process will
     * be given some time to make sure no additional data comes through.
     */
    shutdown(immediate: boolean): void;
    input(data: string): void;
    processBinary(data: string): Promise<void>;
    resize(cols: number, rows: number): void;
    clearBuffer(): void | Promise<void>;
    /**
     * Acknowledge a data event has been parsed by the terminal, this is used to implement flow
     * control to ensure remote processes to not get too far ahead of the client and flood the
     * connection.
     * @param charCount The number of characters being acknowledged.
     */
    acknowledgeDataEvent(charCount: number): void;
    /**
     * Sets the unicode version for the process, this drives the size of some characters in the
     * xterm-headless instance.
     */
    setUnicodeVersion(version: '6' | '11'): Promise<void>;
    getInitialCwd(): Promise<string>;
    getCwd(): Promise<string>;
    refreshProperty<T extends ProcessPropertyType>(property: T): Promise<IProcessPropertyMap[T]>;
    updateProperty<T extends ProcessPropertyType>(property: T, value: IProcessPropertyMap[T]): Promise<void>;
}
interface IProcessDataEvent {
    data: string;
    trackCommit: boolean;
    /**
     * When trackCommit is set, this will be set to a promise that resolves when the data is parsed.
     */
    writePromise?: Promise<void>;
}
interface ITerminalDimensions {
    /**
     * The columns of the terminal.
     */
    cols: number;
    /**
     * The rows of the terminal.
     */
    rows: number;
}
interface ITerminalProfile {
    profileName: string;
    path: string;
    isDefault: boolean;
    /**
     * Whether the terminal profile contains a potentially unsafe {@link path}. For example, the path
     * `C:\Cygwin` is the default install for Cygwin on Windows, but it could be created by any
     * user in a multi-user environment. As such, we don't want to blindly present it as a profile
     * without a warning.
     */
    isUnsafePath?: boolean;
    /**
     * An additional unsafe path that must exist, for example a script that appears in {@link args}.
     */
    requiresUnsafePath?: string;
    isAutoDetected?: boolean;
    /**
     * Whether the profile path was found on the `$PATH` environment variable, if so it will be
     * cleaner to display this profile in the UI using only `basename(path)`.
     */
    isFromPath?: boolean;
    args?: string | string[] | undefined;
    env?: ITerminalEnvironment;
    overrideName?: boolean;
    color?: string;
    icon?: ThemeIcon | URI | {
        light: URI;
        dark: URI;
    };
}
interface ITerminalDimensionsOverride extends Readonly<ITerminalDimensions> {
    /**
     * indicate that xterm must receive these exact dimensions, even if they overflow the ui!
     */
    forceExactSize?: boolean;
}
declare enum TerminalExitReason {
    Unknown = 0,
    Shutdown = 1,
    Process = 2,
    User = 3,
    Extension = 4
}
interface ITerminalBackend {
    readonly remoteAuthority: string | undefined;
    readonly isResponsive: boolean;
    /**
     * A promise that resolves when the backend is ready to be used, ie. after terminal persistence
     * has been actioned.
     */
    readonly whenReady: Promise<void>;
    /**
     * Signal to the backend that persistence has been actioned and is ready for use.
     */
    setReady(): void;
    /**
     * Fired when the ptyHost process becomes non-responsive, this should disable stdin for all
     * terminals using this pty host connection and mark them as disconnected.
     */
    onPtyHostUnresponsive: Event<void>;
    /**
     * Fired when the ptyHost process becomes responsive after being non-responsive. Allowing
     * previously disconnected terminals to reconnect.
     */
    onPtyHostResponsive: Event<void>;
    /**
     * Fired when the ptyHost has been restarted, this is used as a signal for listening terminals
     * that its pty has been lost and will remain disconnected.
     */
    onPtyHostRestart: Event<void>;
    onDidRequestDetach: Event<{
        requestId: number;
        workspaceId: string;
        instanceId: number;
    }>;
    attachToProcess(id: number): Promise<ITerminalChildProcess | undefined>;
    attachToRevivedProcess(id: number): Promise<ITerminalChildProcess | undefined>;
    listProcesses(): Promise<IProcessDetails[]>;
    getLatency(): Promise<IPtyHostLatencyMeasurement[]>;
    getDefaultSystemShell(osOverride?: OperatingSystem): Promise<string>;
    getProfiles(profiles: unknown, defaultProfile: unknown, includeDetectedProfiles?: boolean): Promise<ITerminalProfile[]>;
    getWslPath(original: string, direction: 'unix-to-win' | 'win-to-unix'): Promise<string>;
    getEnvironment(): Promise<IProcessEnvironment>;
    getShellEnvironment(): Promise<IProcessEnvironment | undefined>;
    setTerminalLayoutInfo(layoutInfo?: ITerminalsLayoutInfoById): Promise<void>;
    updateTitle(id: number, title: string, titleSource: TitleEventSource): Promise<void>;
    updateIcon(id: number, userInitiated: boolean, icon: TerminalIcon, color?: string): Promise<void>;
    getTerminalLayoutInfo(): Promise<ITerminalsLayoutInfo | undefined>;
    getPerformanceMarks(): Promise<PerformanceMark[]>;
    reduceConnectionGraceTime(): Promise<void>;
    requestDetachInstance(workspaceId: string, instanceId: number): Promise<IProcessDetails | undefined>;
    acceptDetachInstanceReply(requestId: number, persistentProcessId?: number): Promise<void>;
    persistTerminalState(): Promise<void>;
    createProcess(shellLaunchConfig: IShellLaunchConfig, cwd: string, cols: number, rows: number, unicodeVersion: '6' | '11', env: IProcessEnvironment, options: ITerminalProcessOptions, shouldPersist: boolean): Promise<ITerminalChildProcess>;
    restartPtyHost(): void;
}

export { ICreateContributedTerminalProfileOptions, IFixedTerminalDimensions, IProcessDataEvent, IProcessProperty, IProcessPropertyMap, IProcessReadyEvent, IProcessReadyWindowsPty, IPtyHostAttachTarget, IPtyHostLatencyMeasurement, IRawTerminalInstanceLayoutInfo, IRawTerminalTabLayoutInfo, IRawTerminalsLayoutInfo, IReconnectionProperties, IShellLaunchConfig, IShellLaunchConfigDto, ITerminalBackend, ITerminalChildProcess, ITerminalDimensions, ITerminalDimensionsOverride, ITerminalEnvironment, ITerminalLaunchError, ITerminalProcessOptions, ITerminalProfile, ITerminalsLayoutInfo, ITerminalsLayoutInfoById, PosixShellType, ProcessPropertyType, TerminalExitReason, TerminalIcon, TerminalLocation, TerminalShellType, TerminalType, TitleEventSource, WaitOnExitValue, WindowsShellType };
