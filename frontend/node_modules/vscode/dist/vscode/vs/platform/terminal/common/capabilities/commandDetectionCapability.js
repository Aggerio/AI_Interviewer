import { __decorate } from '../../../../../../node_modules/tslib/tslib.es6.js';
import { timeout } from 'monaco-editor/esm/vs/base/common/async.js';
import { debounce } from 'monaco-editor/esm/vs/base/common/decorators.js';
import { Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
class CommandDetectionCapability {
    get commands() { return this._commands; }
    get executingCommand() { return this._currentCommand.command; }
    get executingCommandObject() {
        if (this._currentCommand.commandStartMarker) {
            return { marker: this._currentCommand.commandStartMarker };
        }
        return undefined;
    }
    get cwd() { return this._cwd; }
    get _isInputting() {
        return !!(this._currentCommand.commandStartMarker && !this._currentCommand.commandExecutedMarker);
    }
    get hasInput() {
        if (!this._isInputting || !this._currentCommand?.commandStartMarker) {
            return undefined;
        }
        if (this._terminal.buffer.active.baseY + this._terminal.buffer.active.cursorY === this._currentCommand.commandStartMarker?.line) {
            const line = this._terminal.buffer.active.getLine(this._terminal.buffer.active.cursorY)?.translateToString(true, this._currentCommand.commandStartX);
            if (line === undefined) {
                return undefined;
            }
            return line.length > 0;
        }
        return true;
    }
    constructor(_terminal, _logService) {
        this._terminal = _terminal;
        this._logService = _logService;
        this.type = 2 ;
        this._commands = [];
        this._currentCommand = {};
        this._isWindowsPty = false;
        this._commandMarkers = [];
        this.__isCommandStorageDisabled = false;
        this._onCommandStarted = ( new Emitter());
        this.onCommandStarted = this._onCommandStarted.event;
        this._onBeforeCommandFinished = ( new Emitter());
        this.onBeforeCommandFinished = this._onBeforeCommandFinished.event;
        this._onCommandFinished = ( new Emitter());
        this.onCommandFinished = this._onCommandFinished.event;
        this._onCommandExecuted = ( new Emitter());
        this.onCommandExecuted = this._onCommandExecuted.event;
        this._onCommandInvalidated = ( new Emitter());
        this.onCommandInvalidated = this._onCommandInvalidated.event;
        this._onCurrentCommandInvalidated = ( new Emitter());
        this.onCurrentCommandInvalidated = this._onCurrentCommandInvalidated.event;
        this._dimensions = {
            cols: this._terminal.cols,
            rows: this._terminal.rows
        };
        this._terminal.onResize(e => this._handleResize(e));
        this._terminal.onCursorMove(() => this._handleCursorMove());
        this._setupClearListeners();
    }
    _handleResize(e) {
        if (this._isWindowsPty) {
            this._preHandleResizeWindows(e);
        }
        this._dimensions.cols = e.cols;
        this._dimensions.rows = e.rows;
    }
    _handleCursorMove() {
        if (this._terminal.buffer.active === this._terminal.buffer.normal && this._currentCommand.commandStartMarker) {
            if (this._terminal.buffer.active.baseY + this._terminal.buffer.active.cursorY < this._currentCommand.commandStartMarker.line) {
                this._clearCommandsInViewport();
                this._currentCommand.isInvalid = true;
                this._onCurrentCommandInvalidated.fire({ reason: "windows"  });
            }
        }
    }
    _setupClearListeners() {
        this.onBeforeCommandFinished(command => {
            if (this._isWindowsPty) {
                if (command.command.trim().toLowerCase() === 'clear' || command.command.trim().toLowerCase() === 'cls') {
                    this._clearCommandsInViewport();
                    this._currentCommand.isInvalid = true;
                    this._onCurrentCommandInvalidated.fire({ reason: "windows"  });
                }
            }
        });
        this._terminal.parser.registerCsiHandler({ final: 'J' }, params => {
            if (!this._isWindowsPty) {
                if (params.length >= 1 && (params[0] === 2 || params[0] === 3)) {
                    this._clearCommandsInViewport();
                }
            }
            return false;
        });
    }
    _preHandleResizeWindows(e) {
        const baseY = this._terminal.buffer.active.baseY;
        const rowsDifference = e.rows - this._dimensions.rows;
        if (rowsDifference > 0) {
            this._waitForCursorMove().then(() => {
                const potentialShiftedLineCount = Math.min(rowsDifference, baseY);
                for (let i = this.commands.length - 1; i >= 0; i--) {
                    const command = this.commands[i];
                    if (!command.marker || command.marker.line < baseY || command.commandStartLineContent === undefined) {
                        break;
                    }
                    const line = this._terminal.buffer.active.getLine(command.marker.line);
                    if (!line || line.translateToString(true) === command.commandStartLineContent) {
                        continue;
                    }
                    const shiftedY = command.marker.line - potentialShiftedLineCount;
                    const shiftedLine = this._terminal.buffer.active.getLine(shiftedY);
                    if (shiftedLine?.translateToString(true) !== command.commandStartLineContent) {
                        continue;
                    }
                    this._terminal._core._bufferService.buffer.lines.onDeleteEmitter.fire({
                        index: this._terminal.buffer.active.baseY,
                        amount: potentialShiftedLineCount
                    });
                }
            });
        }
    }
    _clearCommandsInViewport() {
        let count = 0;
        for (let i = this._commands.length - 1; i >= 0; i--) {
            const line = this._commands[i].marker?.line;
            if (line && line < this._terminal.buffer.active.baseY) {
                break;
            }
            count++;
        }
        if (count > 0) {
            this._onCommandInvalidated.fire(this._commands.splice(this._commands.length - count, count));
        }
    }
    _waitForCursorMove() {
        const cursorX = this._terminal.buffer.active.cursorX;
        const cursorY = this._terminal.buffer.active.cursorY;
        let totalDelay = 0;
        return ( new Promise((resolve, reject) => {
            const interval = setInterval(() => {
                if (cursorX !== this._terminal.buffer.active.cursorX || cursorY !== this._terminal.buffer.active.cursorY) {
                    resolve();
                    clearInterval(interval);
                    return;
                }
                totalDelay += 10;
                if (totalDelay > 1000) {
                    clearInterval(interval);
                    resolve();
                }
            }, 10);
        }));
    }
    setCwd(value) {
        this._cwd = value;
    }
    setIsWindowsPty(value) {
        this._isWindowsPty = value;
    }
    setIsCommandStorageDisabled() {
        this.__isCommandStorageDisabled = true;
    }
    getCwdForLine(line) {
        if (this._currentCommand.promptStartMarker && line >= this._currentCommand.promptStartMarker?.line) {
            return this._cwd;
        }
        const reversed = [...this._commands].reverse();
        return reversed.find(c => c.marker.line <= line - 1)?.cwd;
    }
    handlePromptStart(options) {
        this._currentCommand.promptStartMarker = options?.marker || this._terminal.registerMarker(0);
        this._logService.debug('CommandDetectionCapability#handlePromptStart', this._terminal.buffer.active.cursorX, this._currentCommand.promptStartMarker?.line);
    }
    handleContinuationStart() {
        this._currentCommand.currentContinuationMarker = this._terminal.registerMarker(0);
        this._logService.debug('CommandDetectionCapability#handleContinuationStart', this._currentCommand.currentContinuationMarker);
    }
    handleContinuationEnd() {
        if (!this._currentCommand.currentContinuationMarker) {
            this._logService.warn('CommandDetectionCapability#handleContinuationEnd Received continuation end without start');
            return;
        }
        if (!this._currentCommand.continuations) {
            this._currentCommand.continuations = [];
        }
        this._currentCommand.continuations.push({
            marker: this._currentCommand.currentContinuationMarker,
            end: this._terminal.buffer.active.cursorX
        });
        this._currentCommand.currentContinuationMarker = undefined;
        this._logService.debug('CommandDetectionCapability#handleContinuationEnd', this._currentCommand.continuations[this._currentCommand.continuations.length - 1]);
    }
    handleRightPromptStart() {
        this._currentCommand.commandRightPromptStartX = this._terminal.buffer.active.cursorX;
        this._logService.debug('CommandDetectionCapability#handleRightPromptStart', this._currentCommand.commandRightPromptStartX);
    }
    handleRightPromptEnd() {
        this._currentCommand.commandRightPromptEndX = this._terminal.buffer.active.cursorX;
        this._logService.debug('CommandDetectionCapability#handleRightPromptEnd', this._currentCommand.commandRightPromptEndX);
    }
    handleCommandStart(options) {
        this._handleCommandStartOptions = options;
        this._currentCommand.commandStartMarker = options?.marker || this._currentCommand.commandStartMarker;
        if (this._currentCommand.commandStartMarker?.line === this._terminal.buffer.active.cursorY) {
            this._currentCommand.commandStartX = this._terminal.buffer.active.cursorX;
            this._logService.debug('CommandDetectionCapability#handleCommandStart', this._currentCommand.commandStartX, this._currentCommand.commandStartMarker?.line);
            return;
        }
        if (this._isWindowsPty) {
            this._handleCommandStartWindows();
            return;
        }
        this._currentCommand.commandStartX = this._terminal.buffer.active.cursorX;
        this._currentCommand.commandStartMarker = options?.marker || this._terminal.registerMarker(0);
        this._currentCommand.commandExecutedMarker?.dispose();
        this._currentCommand.commandExecutedMarker = undefined;
        this._currentCommand.commandExecutedX = undefined;
        for (const m of this._commandMarkers) {
            m.dispose();
        }
        this._commandMarkers.length = 0;
        this._onCommandStarted.fire({ marker: options?.marker || this._currentCommand.commandStartMarker, markProperties: options?.markProperties });
        this._logService.debug('CommandDetectionCapability#handleCommandStart', this._currentCommand.commandStartX, this._currentCommand.commandStartMarker?.line);
    }
    _handleCommandStartWindows() {
        this._currentCommand.commandStartX = this._terminal.buffer.active.cursorX;
        this._commandMarkers.length = 0;
        timeout(0).then(() => {
            if (!this._currentCommand.commandExecutedMarker) {
                this._onCursorMoveListener = this._terminal.onCursorMove(() => {
                    if (this._commandMarkers.length === 0 || this._commandMarkers[this._commandMarkers.length - 1].line !== this._terminal.buffer.active.cursorY) {
                        const marker = this._terminal.registerMarker(0);
                        if (marker) {
                            this._commandMarkers.push(marker);
                        }
                    }
                });
            }
            this._currentCommand.commandStartMarker = this._terminal.registerMarker(0);
            if (this._currentCommand.commandStartMarker) {
                const line = this._terminal.buffer.active.getLine(this._currentCommand.commandStartMarker.line);
                if (line) {
                    this._currentCommand.commandStartLineContent = line.translateToString(true);
                }
            }
            this._onCommandStarted.fire({ marker: this._currentCommand.commandStartMarker });
            this._logService.debug('CommandDetectionCapability#_handleCommandStartWindows', this._currentCommand.commandStartX, this._currentCommand.commandStartMarker?.line);
        });
    }
    handleGenericCommand(options) {
        if (options?.markProperties?.disableCommandStorage) {
            this.setIsCommandStorageDisabled();
        }
        this.handlePromptStart(options);
        this.handleCommandStart(options);
        this.handleCommandExecuted(options);
        this.handleCommandFinished(undefined, options);
    }
    handleCommandExecuted(options) {
        if (this._isWindowsPty) {
            this._handleCommandExecutedWindows();
            return;
        }
        this._currentCommand.commandExecutedMarker = options?.marker || this._terminal.registerMarker(0);
        this._currentCommand.commandExecutedX = this._terminal.buffer.active.cursorX;
        this._logService.debug('CommandDetectionCapability#handleCommandExecuted', this._currentCommand.commandExecutedX, this._currentCommand.commandExecutedMarker?.line);
        if (!this._currentCommand.commandStartMarker || !this._currentCommand.commandExecutedMarker || this._currentCommand.commandStartX === undefined) {
            return;
        }
        this._currentCommand.command = this.__isCommandStorageDisabled ? '' : this._terminal.buffer.active.getLine(this._currentCommand.commandStartMarker.line)?.translateToString(true, this._currentCommand.commandStartX, this._currentCommand.commandRightPromptStartX).trim();
        let y = this._currentCommand.commandStartMarker.line + 1;
        const commandExecutedLine = this._currentCommand.commandExecutedMarker.line;
        for (; y < commandExecutedLine; y++) {
            const line = this._terminal.buffer.active.getLine(y);
            if (line) {
                const continuation = this._currentCommand.continuations?.find(e => e.marker.line === y);
                if (continuation) {
                    this._currentCommand.command += '\n';
                }
                const startColumn = continuation?.end ?? 0;
                this._currentCommand.command += line.translateToString(true, startColumn);
            }
        }
        if (y === commandExecutedLine) {
            this._currentCommand.command += this._terminal.buffer.active.getLine(commandExecutedLine)?.translateToString(true, undefined, this._currentCommand.commandExecutedX) || '';
        }
        this._onCommandExecuted.fire();
    }
    _handleCommandExecutedWindows() {
        this._onCursorMoveListener?.dispose();
        this._onCursorMoveListener = undefined;
        this._evaluateCommandMarkersWindows();
        this._currentCommand.commandExecutedX = this._terminal.buffer.active.cursorX;
        this._onCommandExecuted.fire();
        this._logService.debug('CommandDetectionCapability#handleCommandExecuted', this._currentCommand.commandExecutedX, this._currentCommand.commandExecutedMarker?.line);
    }
    invalidateCurrentCommand(request) {
        this._currentCommand.isInvalid = true;
        this._onCurrentCommandInvalidated.fire(request);
    }
    handleCommandFinished(exitCode, options) {
        if (this._isWindowsPty) {
            this._preHandleCommandFinishedWindows();
        }
        this._currentCommand.commandFinishedMarker = options?.marker || this._terminal.registerMarker(0);
        let command = this._currentCommand.command;
        this._logService.debug('CommandDetectionCapability#handleCommandFinished', this._terminal.buffer.active.cursorX, this._currentCommand.commandFinishedMarker?.line, this._currentCommand.command, this._currentCommand);
        this._exitCode = exitCode;
        if (this._exitCode === undefined) {
            const lastCommand = this.commands.length > 0 ? this.commands[this.commands.length - 1] : undefined;
            if (command && command.length > 0 && lastCommand?.command === command) {
                this._exitCode = lastCommand.exitCode;
            }
        }
        if (this._currentCommand.commandStartMarker === undefined || !this._terminal.buffer.active) {
            return;
        }
        if (this._exitCode === undefined && command === undefined) {
            command = '';
        }
        if ((command !== undefined && !command.startsWith('\\')) || this._handleCommandStartOptions?.ignoreCommandLine) {
            const buffer = this._terminal.buffer.active;
            const timestamp = Date.now();
            const executedMarker = this._currentCommand.commandExecutedMarker;
            const endMarker = this._currentCommand.commandFinishedMarker;
            const newCommand = {
                command: this._handleCommandStartOptions?.ignoreCommandLine ? '' : (command || ''),
                isTrusted: !!this._currentCommand.isTrusted,
                marker: this._currentCommand.commandStartMarker,
                endMarker,
                executedMarker,
                timestamp,
                cwd: this._cwd,
                exitCode: this._exitCode,
                commandStartLineContent: this._currentCommand.commandStartLineContent,
                hasOutput: () => !executedMarker?.isDisposed && !endMarker?.isDisposed && !!(executedMarker && endMarker && executedMarker?.line < endMarker.line),
                getOutput: () => getOutputForCommand(executedMarker, endMarker, buffer),
                getOutputMatch: (outputMatcher) => getOutputMatchForCommand(this._isWindowsPty && (executedMarker?.line === endMarker?.line) ? this._currentCommand.commandStartMarker : executedMarker, endMarker, buffer, this._terminal.cols, outputMatcher),
                markProperties: options?.markProperties
            };
            this._commands.push(newCommand);
            this._logService.debug('CommandDetectionCapability#onCommandFinished', newCommand);
            this._onBeforeCommandFinished.fire(newCommand);
            if (!this._currentCommand.isInvalid) {
                this._onCommandFinished.fire(newCommand);
            }
        }
        this._currentCommand.previousCommandMarker = this._currentCommand.commandStartMarker;
        this._currentCommand = {};
        this._handleCommandStartOptions = undefined;
    }
    _preHandleCommandFinishedWindows() {
        if (this._currentCommand.commandExecutedMarker) {
            return;
        }
        if (this._commandMarkers.length === 0) {
            if (!this._currentCommand.commandStartMarker) {
                this._currentCommand.commandStartMarker = this._terminal.registerMarker(0);
            }
            if (this._currentCommand.commandStartMarker) {
                this._commandMarkers.push(this._currentCommand.commandStartMarker);
            }
        }
        this._evaluateCommandMarkersWindows();
    }
    _evaluateCommandMarkersWindows() {
        if (this._commandMarkers.length === 0) {
            return;
        }
        this._commandMarkers = this._commandMarkers.sort((a, b) => a.line - b.line);
        this._currentCommand.commandStartMarker = this._commandMarkers[0];
        if (this._currentCommand.commandStartMarker) {
            const line = this._terminal.buffer.active.getLine(this._currentCommand.commandStartMarker.line);
            if (line) {
                this._currentCommand.commandStartLineContent = line.translateToString(true);
            }
        }
        this._currentCommand.commandExecutedMarker = this._commandMarkers[this._commandMarkers.length - 1];
    }
    setCommandLine(commandLine, isTrusted) {
        this._logService.debug('CommandDetectionCapability#setCommandLine', commandLine, isTrusted);
        this._currentCommand.command = commandLine;
        this._currentCommand.isTrusted = isTrusted;
    }
    serialize() {
        const commands = ( this.commands.map(e => {
            return {
                startLine: e.marker?.line,
                startX: undefined,
                endLine: e.endMarker?.line,
                executedLine: e.executedMarker?.line,
                command: this.__isCommandStorageDisabled ? '' : e.command,
                isTrusted: e.isTrusted,
                cwd: e.cwd,
                exitCode: e.exitCode,
                commandStartLineContent: e.commandStartLineContent,
                timestamp: e.timestamp,
                markProperties: e.markProperties,
                aliases: e.aliases
            };
        }));
        if (this._currentCommand.commandStartMarker) {
            commands.push({
                startLine: this._currentCommand.commandStartMarker.line,
                startX: this._currentCommand.commandStartX,
                endLine: undefined,
                executedLine: undefined,
                command: '',
                isTrusted: true,
                cwd: this._cwd,
                exitCode: undefined,
                commandStartLineContent: undefined,
                timestamp: 0,
                markProperties: undefined
            });
        }
        return {
            isWindowsPty: this._isWindowsPty,
            commands
        };
    }
    deserialize(serialized) {
        if (serialized.isWindowsPty) {
            this.setIsWindowsPty(serialized.isWindowsPty);
        }
        const buffer = this._terminal.buffer.normal;
        for (const e of serialized.commands) {
            const marker = e.startLine !== undefined ? this._terminal.registerMarker(e.startLine - (buffer.baseY + buffer.cursorY)) : undefined;
            if (!marker) {
                continue;
            }
            if (!e.endLine) {
                this._currentCommand.commandStartMarker = marker;
                this._currentCommand.commandStartX = e.startX;
                this._cwd = e.cwd;
                this._onCommandStarted.fire({ marker });
                continue;
            }
            const endMarker = e.endLine !== undefined ? this._terminal.registerMarker(e.endLine - (buffer.baseY + buffer.cursorY)) : undefined;
            const executedMarker = e.executedLine !== undefined ? this._terminal.registerMarker(e.executedLine - (buffer.baseY + buffer.cursorY)) : undefined;
            const newCommand = {
                command: this.__isCommandStorageDisabled ? '' : e.command,
                isTrusted: e.isTrusted,
                marker,
                endMarker,
                executedMarker,
                timestamp: e.timestamp,
                cwd: e.cwd,
                commandStartLineContent: e.commandStartLineContent,
                exitCode: e.exitCode,
                hasOutput: () => !executedMarker?.isDisposed && !endMarker?.isDisposed && !!(executedMarker && endMarker && executedMarker.line < endMarker.line),
                getOutput: () => getOutputForCommand(executedMarker, endMarker, buffer),
                getOutputMatch: (outputMatcher) => getOutputMatchForCommand(this._isWindowsPty && (executedMarker?.line === endMarker?.line) ? marker : executedMarker, endMarker, buffer, this._terminal.cols, outputMatcher),
                markProperties: e.markProperties,
                wasReplayed: true
            };
            this._commands.push(newCommand);
            this._logService.debug('CommandDetectionCapability#onCommandFinished', newCommand);
            this._onCommandFinished.fire(newCommand);
        }
    }
}
CommandDetectionCapability.__decorator = ( __decorate([
    debounce(500)
], CommandDetectionCapability.prototype, "_handleCursorMove", null));
function getOutputForCommand(executedMarker, endMarker, buffer) {
    if (!executedMarker || !endMarker) {
        return undefined;
    }
    const startLine = executedMarker.line;
    const endLine = endMarker.line;
    if (startLine === endLine) {
        return undefined;
    }
    let output = '';
    let line;
    for (let i = startLine; i < endLine; i++) {
        line = buffer.getLine(i);
        if (!line) {
            continue;
        }
        output += line.translateToString(!line.isWrapped) + (line.isWrapped ? '' : '\n');
    }
    return output === '' ? undefined : output;
}
function getOutputMatchForCommand(executedMarker, endMarker, buffer, cols, outputMatcher) {
    if (!executedMarker || !endMarker) {
        return undefined;
    }
    const endLine = endMarker.line;
    if (endLine === -1) {
        return undefined;
    }
    const startLine = Math.max(executedMarker.line, 0);
    const matcher = outputMatcher.lineMatcher;
    const linesToCheck = typeof matcher === 'string' ? 1 : outputMatcher.length || countNewLines(matcher);
    const lines = [];
    let match;
    if (outputMatcher.anchor === 'bottom') {
        for (let i = endLine - (outputMatcher.offset || 0); i >= startLine; i--) {
            let wrappedLineStart = i;
            const wrappedLineEnd = i;
            while (wrappedLineStart >= startLine && buffer.getLine(wrappedLineStart)?.isWrapped) {
                wrappedLineStart--;
            }
            i = wrappedLineStart;
            lines.unshift(getXtermLineContent(buffer, wrappedLineStart, wrappedLineEnd, cols));
            if (!match) {
                match = lines[0].match(matcher);
            }
            if (lines.length >= linesToCheck) {
                break;
            }
        }
    }
    else {
        for (let i = startLine + (outputMatcher.offset || 0); i < endLine; i++) {
            const wrappedLineStart = i;
            let wrappedLineEnd = i;
            while (wrappedLineEnd + 1 < endLine && buffer.getLine(wrappedLineEnd + 1)?.isWrapped) {
                wrappedLineEnd++;
            }
            i = wrappedLineEnd;
            lines.push(getXtermLineContent(buffer, wrappedLineStart, wrappedLineEnd, cols));
            if (!match) {
                match = lines[lines.length - 1].match(matcher);
            }
            if (lines.length >= linesToCheck) {
                break;
            }
        }
    }
    return match ? { regexMatch: match, outputLines: lines } : undefined;
}
function getXtermLineContent(buffer, lineStart, lineEnd, cols) {
    const maxLineLength = Math.max(2048 / cols * 2);
    lineEnd = Math.min(lineEnd, lineStart + maxLineLength);
    let content = '';
    for (let i = lineStart; i <= lineEnd; i++) {
        const line = buffer.getLine(i);
        if (line) {
            content += line.translateToString(true, 0, cols);
        }
    }
    return content;
}
function countNewLines(regex) {
    if (!regex.multiline) {
        return 1;
    }
    const source = regex.source;
    let count = 1;
    let i = source.indexOf('\\n');
    while (i !== -1) {
        count++;
        i = source.indexOf('\\n', i + 1);
    }
    return count;
}
export { CommandDetectionCapability };
