import { bufferToStream, VSBuffer } from 'monaco-editor/esm/vs/base/common/buffer.js';
import { canceled } from 'monaco-editor/esm/vs/base/common/errors.js';
import { OfflineError } from '../common/request.js';
function request(options, token) {
    if (options.proxyAuthorization) {
        options.headers = {
            ...(options.headers || {}),
            'Proxy-Authorization': options.proxyAuthorization
        };
    }
    const xhr = ( new XMLHttpRequest());
    return ( new Promise((resolve, reject) => {
        xhr.open(options.type || 'GET', options.url || '', true, options.user, options.password);
        setRequestHeaders(xhr, options);
        xhr.responseType = 'arraybuffer';
        xhr.onerror = e => reject(navigator.onLine ? ( new Error(xhr.statusText && ('XHR failed: ' + xhr.statusText) || 'XHR failed')) : ( new OfflineError()));
        xhr.onload = (e) => {
            resolve({
                res: {
                    statusCode: xhr.status,
                    headers: getResponseHeaders(xhr)
                },
                stream: bufferToStream(VSBuffer.wrap(( new Uint8Array(xhr.response))))
            });
        };
        xhr.ontimeout = e => reject(( new Error(`XHR timeout: ${options.timeout}ms`)));
        if (options.timeout) {
            xhr.timeout = options.timeout;
        }
        xhr.send(options.data);
        token.onCancellationRequested(() => {
            xhr.abort();
            reject(canceled());
        });
    }));
}
function setRequestHeaders(xhr, options) {
    if (options.headers) {
        outer: for (const k in options.headers) {
            switch (k) {
                case 'User-Agent':
                case 'Accept-Encoding':
                case 'Content-Length':
                    continue outer;
            }
            xhr.setRequestHeader(k, options.headers[k]);
        }
    }
}
function getResponseHeaders(xhr) {
    const headers = Object.create(null);
    for (const line of xhr.getAllResponseHeaders().split(/\r\n|\n|\r/g)) {
        if (line) {
            const idx = line.indexOf(':');
            headers[line.substr(0, idx).trim().toLowerCase()] = line.substr(idx + 1).trim();
        }
    }
    return headers;
}
export { request };
