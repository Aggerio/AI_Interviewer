import { Range } from './range.js';

/**
 * A range of lines (1-based).
 */
declare class LineRange {
    static fromRange(range: Range): LineRange;
    static subtract(a: LineRange, b: LineRange | undefined): LineRange[];
    /**
     * @param lineRanges An array of sorted line ranges.
     */
    static joinMany(lineRanges: readonly (readonly LineRange[])[]): readonly LineRange[];
    /**
     * @param lineRanges1 Must be sorted.
     * @param lineRanges2 Must be sorted.
     */
    static join(lineRanges1: readonly LineRange[], lineRanges2: readonly LineRange[]): readonly LineRange[];
    static ofLength(startLineNumber: number, length: number): LineRange;
    /**
     * @internal
     */
    static deserialize(lineRange: ISerializedLineRange): LineRange;
    /**
     * The start line number.
     */
    readonly startLineNumber: number;
    /**
     * The end line number (exclusive).
     */
    readonly endLineNumberExclusive: number;
    constructor(startLineNumber: number, endLineNumberExclusive: number);
    /**
     * Indicates if this line range contains the given line number.
     */
    contains(lineNumber: number): boolean;
    /**
     * Indicates if this line range is empty.
     */
    get isEmpty(): boolean;
    /**
     * Moves this line range by the given offset of line numbers.
     */
    delta(offset: number): LineRange;
    /**
     * The number of lines this line range spans.
     */
    get length(): number;
    /**
     * Creates a line range that combines this and the given line range.
     */
    join(other: LineRange): LineRange;
    toString(): string;
    /**
     * The resulting range is empty if the ranges do not intersect, but touch.
     * If the ranges don't even touch, the result is undefined.
     */
    intersect(other: LineRange): LineRange | undefined;
    intersectsStrict(other: LineRange): boolean;
    overlapOrTouch(other: LineRange): boolean;
    equals(b: LineRange): boolean;
    toInclusiveRange(): Range | null;
    toExclusiveRange(): Range;
    mapToLineArray<T>(f: (lineNumber: number) => T): T[];
    forEach(f: (lineNumber: number) => void): void;
    /**
     * @internal
     */
    serialize(): ISerializedLineRange;
    includes(lineNumber: number): boolean;
}
type ISerializedLineRange = [startLineNumber: number, endLineNumberExclusive: number];

export { ISerializedLineRange, LineRange };
