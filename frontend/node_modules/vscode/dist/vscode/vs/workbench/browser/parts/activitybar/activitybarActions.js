import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import './media/activityaction.css.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { append, $, clearNode, hide, show, addDisposableListener, EventType, EventHelper } from 'monaco-editor/esm/vs/base/browser/dom.js';
import { StandardKeyboardEvent } from 'monaco-editor/esm/vs/base/browser/keyboardEvent.js';
import { EventType as EventType$1 } from 'monaco-editor/esm/vs/base/browser/touch.js';
import { Action, Separator, toAction, SubmenuAction } from 'monaco-editor/esm/vs/base/common/actions.js';
import { DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { MenuId, registerAction2, Action2, IMenuService } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { IContextMenuService } from 'monaco-editor/esm/vs/platform/contextview/browser/contextView.js';
import { ITelemetryService } from 'monaco-editor/esm/vs/platform/telemetry/common/telemetry.js';
import { activeContrastBorder, focusBorder } from 'monaco-editor/esm/vs/platform/theme/common/colorRegistry.js';
import { registerThemingParticipant, IThemeService } from 'monaco-editor/esm/vs/platform/theme/common/themeService.js';
import { ActivityAction, ToggleCompositePinnedAction, ToggleCompositeBadgeAction, ActivityActionViewItem } from '../compositeBarActions.js';
import { Categories } from 'monaco-editor/esm/vs/platform/action/common/actionCommonCategories.js';
import { ACTIVITY_BAR_ACTIVE_BORDER, ACTIVITY_BAR_ACTIVE_FOCUS_BORDER, ACTIVITY_BAR_ACTIVE_BACKGROUND } from '../../../common/theme.js';
import { IWorkbenchLayoutService } from '../../../services/layout/browser/layoutService.js';
import { IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { createAndFillInActionBarActions } from 'monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.js';
import { getCurrentAuthenticationSessionInfo } from '../../../services/authentication/browser/authenticationService.js';
import { IAuthenticationService } from '../../../services/authentication/common/authentication.js';
import { IWorkbenchEnvironmentService } from '../../../services/environment/common/environmentService.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { IProductService } from 'monaco-editor/esm/vs/platform/product/common/productService.js';
import { IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
import { IHoverService } from '../../../services/hover/browser/hover.js';
import { IKeybindingService } from 'monaco-editor/esm/vs/platform/keybinding/common/keybinding.js';
import { IPaneCompositePartService } from '../../../services/panecomposite/browser/panecomposite.js';
import { ICredentialsService } from '../../../../platform/credentials/common/credentials.js';
import { IUserDataProfileService } from '../../../services/userDataProfile/common/userDataProfile.js';
import { StandardMouseEvent } from 'monaco-editor/esm/vs/base/browser/mouseEvent.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { ISecretStorageService } from '../../../../platform/secrets/common/secrets.js';
let ViewContainerActivityAction = class ViewContainerActivityAction extends ActivityAction {
    static { this.preventDoubleClickDelay = 300; }
    constructor(activity, paneCompositePart, layoutService, telemetryService, configurationService) {
        super(activity);
        this.paneCompositePart = paneCompositePart;
        this.layoutService = layoutService;
        this.telemetryService = telemetryService;
        this.configurationService = configurationService;
        this.lastRun = 0;
    }
    updateActivity(activity) {
        this.activity = activity;
    }
    async run(event) {
        if (event instanceof MouseEvent && event.button === 2) {
            return;
        }
        const now = Date.now();
        if (now > this.lastRun  && now - this.lastRun < ViewContainerActivityAction.preventDoubleClickDelay) {
            return;
        }
        this.lastRun = now;
        const sideBarVisible = this.layoutService.isVisible("workbench.parts.sidebar" );
        const activeViewlet = this.paneCompositePart.getActivePaneComposite();
        const focusBehavior = this.configurationService.getValue('workbench.activityBar.iconClickBehavior');
        const focus = (event && 'preserveFocus' in event) ? !event.preserveFocus : true;
        if (sideBarVisible && activeViewlet?.getId() === this.activity.id) {
            switch (focusBehavior) {
                case 'focus':
                    this.logAction('refocus');
                    this.paneCompositePart.openPaneComposite(this.activity.id, focus);
                    break;
                case 'toggle':
                default:
                    this.logAction('hide');
                    this.layoutService.setPartHidden(true, "workbench.parts.sidebar" );
                    break;
            }
            return;
        }
        this.logAction('show');
        await this.paneCompositePart.openPaneComposite(this.activity.id, focus);
        return this.activate();
    }
    logAction(action) {
        this.telemetryService.publicLog2('activityBarAction', { viewletId: this.activity.id, action });
    }
};
ViewContainerActivityAction = ( __decorate([
    ( __param(2, IWorkbenchLayoutService)),
    ( __param(3, ITelemetryService)),
    ( __param(4, IConfigurationService))
], ViewContainerActivityAction));
let AbstractGlobalActivityActionViewItem = class AbstractGlobalActivityActionViewItem extends ActivityActionViewItem {
    constructor(action, contextMenuActionsProvider, options, themeService, hoverService, menuService, contextMenuService, contextKeyService, configurationService, environmentService, keybindingService) {
        super(action, options, () => true, themeService, hoverService, configurationService, keybindingService);
        this.contextMenuActionsProvider = contextMenuActionsProvider;
        this.menuService = menuService;
        this.contextMenuService = contextMenuService;
        this.contextKeyService = contextKeyService;
        this.environmentService = environmentService;
    }
    render(container) {
        super.render(container);
        this._register(addDisposableListener(this.container, EventType.MOUSE_DOWN, async (e) => {
            EventHelper.stop(e, true);
            const isLeftClick = e?.button !== 2;
            if (isLeftClick) {
                this.run();
            }
        }));
        this._register(addDisposableListener(this.container, EventType.CONTEXT_MENU, async (e) => {
            const disposables = ( new DisposableStore());
            const actions = await this.resolveContextMenuActions(disposables);
            const event = ( new StandardMouseEvent(e));
            this.contextMenuService.showContextMenu({
                getAnchor: () => event,
                getActions: () => actions,
                onHide: () => disposables.dispose()
            });
        }));
        this._register(addDisposableListener(this.container, EventType.KEY_UP, (e) => {
            const event = ( new StandardKeyboardEvent(e));
            if (event.equals(3 ) || event.equals(10 )) {
                EventHelper.stop(e, true);
                this.run();
            }
        }));
        this._register(addDisposableListener(this.container, EventType$1.Tap, (e) => {
            EventHelper.stop(e, true);
            this.run();
        }));
    }
    async resolveContextMenuActions(disposables) {
        return this.contextMenuActionsProvider();
    }
};
AbstractGlobalActivityActionViewItem = ( __decorate([
    ( __param(3, IThemeService)),
    ( __param(4, IHoverService)),
    ( __param(5, IMenuService)),
    ( __param(6, IContextMenuService)),
    ( __param(7, IContextKeyService)),
    ( __param(8, IConfigurationService)),
    ( __param(9, IWorkbenchEnvironmentService)),
    ( __param(10, IKeybindingService))
], AbstractGlobalActivityActionViewItem));
let MenuActivityActionViewItem = class MenuActivityActionViewItem extends AbstractGlobalActivityActionViewItem {
    constructor(menuId, action, contextMenuActionsProvider, icon, colors, hoverOptions, themeService, hoverService, menuService, contextMenuService, contextKeyService, configurationService, environmentService, keybindingService) {
        super(action, contextMenuActionsProvider, { draggable: false, colors, icon, hasPopup: true, hoverOptions }, themeService, hoverService, menuService, contextMenuService, contextKeyService, configurationService, environmentService, keybindingService);
        this.menuId = menuId;
    }
    async run() {
        const disposables = ( new DisposableStore());
        const menu = disposables.add(this.menuService.createMenu(this.menuId, this.contextKeyService));
        const actions = await this.resolveMainMenuActions(menu, disposables);
        this.contextMenuService.showContextMenu({
            getAnchor: () => this.container,
            anchorAlignment: this.configurationService.getValue('workbench.sideBar.location') === 'left' ? 1  : 0 ,
            anchorAxisAlignment: 1 ,
            getActions: () => actions,
            onHide: () => disposables.dispose(),
            menuActionOptions: { renderShortTitle: true },
        });
    }
    async resolveMainMenuActions(menu, _disposable) {
        const actions = [];
        createAndFillInActionBarActions(menu, { renderShortTitle: true }, { primary: [], secondary: actions });
        return actions;
    }
};
MenuActivityActionViewItem = ( __decorate([
    ( __param(6, IThemeService)),
    ( __param(7, IHoverService)),
    ( __param(8, IMenuService)),
    ( __param(9, IContextMenuService)),
    ( __param(10, IContextKeyService)),
    ( __param(11, IConfigurationService)),
    ( __param(12, IWorkbenchEnvironmentService)),
    ( __param(13, IKeybindingService))
], MenuActivityActionViewItem));
let AccountsActivityActionViewItem = class AccountsActivityActionViewItem extends MenuActivityActionViewItem {
    static { this.ACCOUNTS_VISIBILITY_PREFERENCE_KEY = 'workbench.activity.showAccounts'; }
    constructor(action, contextMenuActionsProvider, colors, activityHoverOptions, themeService, hoverService, contextMenuService, menuService, contextKeyService, authenticationService, environmentService, productService, configurationService, storageService, keybindingService, secretStorageService, credentialsService, logService) {
        super(MenuId.AccountsContext, action, contextMenuActionsProvider, true, colors, activityHoverOptions, themeService, hoverService, menuService, contextMenuService, contextKeyService, configurationService, environmentService, keybindingService);
        this.authenticationService = authenticationService;
        this.productService = productService;
        this.storageService = storageService;
        this.secretStorageService = secretStorageService;
        this.credentialsService = credentialsService;
        this.logService = logService;
        this.groupedAccounts = ( new Map());
        this.problematicProviders = ( new Set());
        this.initialized = false;
        this.sessionFromEmbedder = getCurrentAuthenticationSessionInfo(this.credentialsService, this.secretStorageService, this.productService);
        this.registerListeners();
        this.initialize();
    }
    registerListeners() {
        this._register(this.authenticationService.onDidRegisterAuthenticationProvider(async (e) => {
            await this.addAccountsFromProvider(e.id);
        }));
        this._register(this.authenticationService.onDidUnregisterAuthenticationProvider((e) => {
            this.groupedAccounts.delete(e.id);
            this.problematicProviders.delete(e.id);
        }));
        this._register(this.authenticationService.onDidChangeSessions(async (e) => {
            for (const changed of [...e.event.changed, ...e.event.added]) {
                try {
                    await this.addOrUpdateAccount(e.providerId, changed.account);
                }
                catch (e) {
                    this.logService.error(e);
                }
            }
            for (const removed of e.event.removed) {
                this.removeAccount(e.providerId, removed.account);
            }
        }));
    }
    async initialize() {
        const providerIds = this.authenticationService.getProviderIds();
        const results = await Promise.allSettled(( providerIds.map(providerId => this.addAccountsFromProvider(providerId))));
        for (const result of results) {
            if (result.status === 'rejected') {
                this.logService.error(result.reason);
            }
        }
        this.initialized = true;
    }
    async resolveMainMenuActions(accountsMenu, disposables) {
        await super.resolveMainMenuActions(accountsMenu, disposables);
        const providers = this.authenticationService.getProviderIds();
        const otherCommands = accountsMenu.getActions();
        let menus = [];
        for (const providerId of providers) {
            if (!this.initialized) {
                const noAccountsAvailableAction = disposables.add(( new Action('noAccountsAvailable', ( localize('loading', "Loading...")), undefined, false)));
                menus.push(noAccountsAvailableAction);
                break;
            }
            const providerLabel = this.authenticationService.getLabel(providerId);
            const accounts = this.groupedAccounts.get(providerId);
            if (!accounts) {
                if (( this.problematicProviders.has(providerId))) {
                    const providerUnavailableAction = disposables.add(( new Action('providerUnavailable', ( localize('authProviderUnavailable', '{0} is currently unavailable', providerLabel)), undefined, false)));
                    menus.push(providerUnavailableAction);
                    try {
                        await this.addAccountsFromProvider(providerId);
                    }
                    catch (e) {
                        this.logService.error(e);
                    }
                }
                continue;
            }
            for (const account of accounts) {
                const manageExtensionsAction = disposables.add(( new Action(`configureSessions${account.label}`, ( localize('manageTrustedExtensions', "Manage Trusted Extensions")), undefined, true, () => {
                    return this.authenticationService.manageTrustedExtensionsForAccount(providerId, account.label);
                })));
                const providerSubMenuActions = [manageExtensionsAction];
                if (account.canSignOut) {
                    const signOutAction = disposables.add(( new Action('signOut', ( localize('signOut', "Sign Out")), undefined, true, async () => {
                        const allSessions = await this.authenticationService.getSessions(providerId);
                        const sessionsForAccount = allSessions.filter(s => s.account.id === account.id);
                        return await this.authenticationService.removeAccountSessions(providerId, account.label, sessionsForAccount);
                    })));
                    providerSubMenuActions.push(signOutAction);
                }
                const providerSubMenu = ( new SubmenuAction(
                    'activitybar.submenu',
                    `${account.label} (${providerLabel})`,
                    providerSubMenuActions
                ));
                menus.push(providerSubMenu);
            }
        }
        if (providers.length && !menus.length) {
            const noAccountsAvailableAction = disposables.add(( new Action('noAccountsAvailable', ( localize('noAccounts', "You are not signed in to any accounts")), undefined, false)));
            menus.push(noAccountsAvailableAction);
        }
        if (menus.length && otherCommands.length) {
            menus.push(( new Separator()));
        }
        otherCommands.forEach((group, i) => {
            const actions = group[1];
            menus = menus.concat(actions);
            if (i !== otherCommands.length - 1) {
                menus.push(( new Separator()));
            }
        });
        return menus;
    }
    async resolveContextMenuActions(disposables) {
        const actions = await super.resolveContextMenuActions(disposables);
        actions.unshift(...[
            toAction({ id: 'hideAccounts', label: ( localize('hideAccounts', "Hide Accounts")), run: () => this.storageService.store(AccountsActivityActionViewItem.ACCOUNTS_VISIBILITY_PREFERENCE_KEY, false, 0 , 0 ) }),
            ( new Separator())
        ]);
        return actions;
    }
    async addOrUpdateAccount(providerId, account) {
        let accounts = this.groupedAccounts.get(providerId);
        if (accounts) {
            const existingAccount = accounts.find(a => a.id === account.id);
            if (existingAccount) {
                if (existingAccount.label !== account.label) {
                    existingAccount.label = account.label;
                }
                return;
            }
        }
        else {
            accounts = [];
            this.groupedAccounts.set(providerId, accounts);
        }
        const sessionFromEmbedder = await this.sessionFromEmbedder;
        let canSignOut = !!sessionFromEmbedder?.canSignOut;
        if (!canSignOut) {
            if (sessionFromEmbedder?.id) {
                const sessions = (await this.authenticationService.getSessions(providerId)).filter(s => s.account.id === account.id);
                canSignOut = !( sessions.some(s => s.id === sessionFromEmbedder.id));
            }
            else {
                canSignOut = true;
            }
        }
        accounts.push({ ...account, canSignOut });
    }
    removeAccount(providerId, account) {
        const accounts = this.groupedAccounts.get(providerId);
        if (!accounts) {
            return;
        }
        const index = accounts.findIndex(a => a.id === account.id);
        if (index === -1) {
            return;
        }
        accounts.splice(index, 1);
        if (accounts.length === 0) {
            this.groupedAccounts.delete(providerId);
        }
    }
    async addAccountsFromProvider(providerId) {
        try {
            const sessions = await this.authenticationService.getSessions(providerId);
            this.problematicProviders.delete(providerId);
            for (const session of sessions) {
                try {
                    await this.addOrUpdateAccount(providerId, session.account);
                }
                catch (e) {
                    this.logService.error(e);
                }
            }
        }
        catch (e) {
            this.logService.error(e);
            this.problematicProviders.add(providerId);
        }
    }
};
AccountsActivityActionViewItem = ( __decorate([
    ( __param(4, IThemeService)),
    ( __param(5, IHoverService)),
    ( __param(6, IContextMenuService)),
    ( __param(7, IMenuService)),
    ( __param(8, IContextKeyService)),
    ( __param(9, IAuthenticationService)),
    ( __param(10, IWorkbenchEnvironmentService)),
    ( __param(11, IProductService)),
    ( __param(12, IConfigurationService)),
    ( __param(13, IStorageService)),
    ( __param(14, IKeybindingService)),
    ( __param(15, ISecretStorageService)),
    ( __param(16, ICredentialsService)),
    ( __param(17, ILogService))
], AccountsActivityActionViewItem));
let GlobalActivityActionViewItem = class GlobalActivityActionViewItem extends MenuActivityActionViewItem {
    constructor(action, contextMenuActionsProvider, colors, activityHoverOptions, userDataProfileService, themeService, hoverService, menuService, contextMenuService, contextKeyService, configurationService, environmentService, keybindingService) {
        super(MenuId.GlobalActivity, action, contextMenuActionsProvider, true, colors, activityHoverOptions, themeService, hoverService, menuService, contextMenuService, contextKeyService, configurationService, environmentService, keybindingService);
        this.userDataProfileService = userDataProfileService;
        this._register(this.userDataProfileService.onDidChangeCurrentProfile(() => this.updateProfileBadge()));
    }
    render(container) {
        super.render(container);
        this.profileBadge = append(container, $('.profile-badge'));
        this.profileBadgeContent = append(this.profileBadge, $('.profile-badge-content'));
        this.updateProfileBadge();
    }
    updateProfileBadge() {
        if (!this.profileBadge || !this.profileBadgeContent) {
            return;
        }
        clearNode(this.profileBadgeContent);
        hide(this.profileBadge);
        if (this.userDataProfileService.currentProfile.isDefault) {
            return;
        }
        if (this.action.getBadge()) {
            return;
        }
        this.profileBadgeContent.textContent = this.userDataProfileService.currentProfile.name.substring(0, 2).toUpperCase();
        show(this.profileBadge);
    }
    updateBadge() {
        super.updateBadge();
        this.updateProfileBadge();
    }
    computeTitle() {
        return this.userDataProfileService.currentProfile.isDefault ? super.computeTitle() : ( localize(
            'manage',
            "Manage {0} (Profile)",
            this.userDataProfileService.currentProfile.name
        ));
    }
};
GlobalActivityActionViewItem = ( __decorate([
    ( __param(4, IUserDataProfileService)),
    ( __param(5, IThemeService)),
    ( __param(6, IHoverService)),
    ( __param(7, IMenuService)),
    ( __param(8, IContextMenuService)),
    ( __param(9, IContextKeyService)),
    ( __param(10, IConfigurationService)),
    ( __param(11, IWorkbenchEnvironmentService)),
    ( __param(12, IKeybindingService))
], GlobalActivityActionViewItem));
class PlaceHolderViewContainerActivityAction extends ViewContainerActivityAction {
}
class PlaceHolderToggleCompositePinnedAction extends ToggleCompositePinnedAction {
    constructor(id, compositeBar) {
        super({ id, name: id, classNames: undefined }, compositeBar);
    }
    setActivity(activity) {
        this.label = activity.name;
    }
}
class PlaceHolderToggleCompositeBadgeAction extends ToggleCompositeBadgeAction {
    constructor(id, compositeBar) {
        super({ id, name: id, classNames: undefined }, compositeBar);
    }
    setActivity(activity) {
        this.label = activity.name;
    }
}
class SwitchSideBarViewAction extends Action2 {
    constructor(desc, offset) {
        super(desc);
        this.offset = offset;
    }
    async run(accessor) {
        const paneCompositeService = accessor.get(IPaneCompositePartService);
        const visibleViewletIds = paneCompositeService.getVisiblePaneCompositeIds(0 );
        const activeViewlet = paneCompositeService.getActivePaneComposite(0 );
        if (!activeViewlet) {
            return;
        }
        let targetViewletId;
        for (let i = 0; i < visibleViewletIds.length; i++) {
            if (visibleViewletIds[i] === activeViewlet.getId()) {
                targetViewletId = visibleViewletIds[(i + visibleViewletIds.length + this.offset) % visibleViewletIds.length];
                break;
            }
        }
        await paneCompositeService.openPaneComposite(targetViewletId, 0 , true);
    }
}
registerAction2(class PreviousSideBarViewAction extends SwitchSideBarViewAction {
    constructor() {
        super({
            id: 'workbench.action.previousSideBarView',
            title: { value: ( localize('previousSideBarView', "Previous Primary Side Bar View")), original: 'Previous Primary Side Bar View' },
            category: Categories.View,
            f1: true
        }, -1);
    }
});
registerAction2(class NextSideBarViewAction extends SwitchSideBarViewAction {
    constructor() {
        super({
            id: 'workbench.action.nextSideBarView',
            title: { value: ( localize('nextSideBarView', "Next Primary Side Bar View")), original: 'Next Primary Side Bar View' },
            category: Categories.View,
            f1: true
        }, 1);
    }
});
registerAction2(class FocusActivityBarAction extends Action2 {
    constructor() {
        super({
            id: 'workbench.action.focusActivityBar',
            title: { value: ( localize('focusActivityBar', "Focus Activity Bar")), original: 'Focus Activity Bar' },
            category: Categories.View,
            f1: true
        });
    }
    async run(accessor) {
        const layoutService = accessor.get(IWorkbenchLayoutService);
        layoutService.setPartHidden(false, "workbench.parts.activitybar" );
        layoutService.focusPart("workbench.parts.activitybar" );
    }
});
registerThemingParticipant((theme, collector) => {
    const activityBarActiveBorderColor = theme.getColor(ACTIVITY_BAR_ACTIVE_BORDER);
    if (activityBarActiveBorderColor) {
        collector.addRule(`
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked .active-item-indicator:before {
				border-left-color: ${activityBarActiveBorderColor};
			}
		`);
    }
    const activityBarActiveFocusBorderColor = theme.getColor(ACTIVITY_BAR_ACTIVE_FOCUS_BORDER);
    if (activityBarActiveFocusBorderColor) {
        collector.addRule(`
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked:focus::before {
				visibility: hidden;
			}

			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked:focus .active-item-indicator:before {
				visibility: visible;
				border-left-color: ${activityBarActiveFocusBorderColor};
			}
		`);
    }
    const activityBarActiveBackgroundColor = theme.getColor(ACTIVITY_BAR_ACTIVE_BACKGROUND);
    if (activityBarActiveBackgroundColor) {
        collector.addRule(`
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked .active-item-indicator {
				z-index: 0;
				background-color: ${activityBarActiveBackgroundColor};
			}
		`);
    }
    const outline = theme.getColor(activeContrastBorder);
    if (outline) {
        collector.addRule(`
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item:before {
				content: "";
				position: absolute;
				top: 8px;
				left: 8px;
				height: 32px;
				width: 32px;
				z-index: 1;
			}

			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.profile-activity-item:before {
				top: -6px;
			}

			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.active:before,
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.active:hover:before,
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked:before,
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked:hover:before {
				outline: 1px solid;
			}

			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item:hover:before {
				outline: 1px dashed;
			}

			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item:focus .active-item-indicator:before {
				border-left-color: ${outline};
			}

			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.active:before,
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.active:hover:before,
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked:before,
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked:hover:before,
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item:hover:before {
				outline-color: ${outline};
			}
		`);
    }
    else {
        const focusBorderColor = theme.getColor(focusBorder);
        if (focusBorderColor) {
            collector.addRule(`
				.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item:focus .active-item-indicator:before {
						border-left-color: ${focusBorderColor};
					}
				`);
        }
    }
});
export { AccountsActivityActionViewItem, GlobalActivityActionViewItem, PlaceHolderToggleCompositeBadgeAction, PlaceHolderToggleCompositePinnedAction, PlaceHolderViewContainerActivityAction, ViewContainerActivityAction };
