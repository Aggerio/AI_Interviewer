import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import { DataTransfers } from 'monaco-editor/esm/vs/base/browser/dnd.js';
import * as dom from 'monaco-editor/esm/vs/base/browser/dom.js';
import { renderMarkdownAsPlaintext } from 'monaco-editor/esm/vs/base/browser/markdownRenderer.js';
import { ActionBar } from 'monaco-editor/esm/vs/base/browser/ui/actionbar/actionbar.js';
import { ActionViewItem } from 'monaco-editor/esm/vs/base/browser/ui/actionbar/actionViewItems.js';
import { CollapseAllAction } from '../../../../base/browser/ui/tree/treeDefaults.js';
import { ActionRunner } from 'monaco-editor/esm/vs/base/common/actions.js';
import { timeout } from 'monaco-editor/esm/vs/base/common/async.js';
import { CancellationTokenSource, CancellationToken } from 'monaco-editor/esm/vs/base/common/cancellation.js';
import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { isCancellationError } from 'monaco-editor/esm/vs/base/common/errors.js';
import { Emitter, Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { createMatches } from 'monaco-editor/esm/vs/base/common/filters.js';
import { isMarkdownString } from 'monaco-editor/esm/vs/base/common/htmlContent.js';
import { Disposable, DisposableStore, toDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { Mimes } from 'monaco-editor/esm/vs/base/common/mime.js';
import { Schemas } from 'monaco-editor/esm/vs/base/common/network.js';
import { basename, dirname } from 'monaco-editor/esm/vs/base/common/resources.js';
import { isFalsyOrWhitespace } from 'monaco-editor/esm/vs/base/common/strings.js';
import { isString } from 'monaco-editor/esm/vs/base/common/types.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { generateUuid } from 'monaco-editor/esm/vs/base/common/uuid.js';
import './media/views.css.js';
import { VSDataTransfer } from 'monaco-editor/esm/vs/base/common/dataTransfer.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { createActionViewItem, createAndFillInContextMenuActions } from 'monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.js';
import { MenuRegistry, MenuId, registerAction2, Action2, IMenuService } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { CommandsRegistry, ICommandService } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { IContextKeyService, RawContextKey, ContextKeyExpr } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { IContextMenuService } from 'monaco-editor/esm/vs/platform/contextview/browser/contextView.js';
import { FileKind } from 'monaco-editor/esm/vs/platform/files/common/files.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IKeybindingService } from 'monaco-editor/esm/vs/platform/keybinding/common/keybinding.js';
import { ILabelService } from 'monaco-editor/esm/vs/platform/label/common/label.js';
import { WorkbenchAsyncDataTree } from 'monaco-editor/esm/vs/platform/list/browser/listService.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { INotificationService } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { IOpenerService } from 'monaco-editor/esm/vs/platform/opener/common/opener.js';
import { IProgressService } from 'monaco-editor/esm/vs/platform/progress/common/progress.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { ITelemetryService } from 'monaco-editor/esm/vs/platform/telemetry/common/telemetry.js';
import { ColorScheme } from 'monaco-editor/esm/vs/platform/theme/common/theme.js';
import { FolderThemeIcon, FileThemeIcon, IThemeService } from 'monaco-editor/esm/vs/platform/theme/common/themeService.js';
import { ThemeIcon } from 'monaco-editor/esm/vs/base/common/themables.js';
import { fillEditorsDragData } from '../../dnd.js';
import { ResourceLabels } from '../../labels.js';
import { API_OPEN_EDITOR_COMMAND_ID, API_OPEN_DIFF_EDITOR_COMMAND_ID } from '../editor/editorCommands.js';
import { ViewPane } from './viewPane.js';
import { PANEL_BACKGROUND, SIDE_BAR_BACKGROUND } from '../../../common/theme.js';
import { ResolvableTreeItem, TreeItemCollapsibleState, Extensions, IViewDescriptorService } from '../../../common/views.js';
import { IActivityService, NumberBadge } from '../../../services/activity/common/activity.js';
import { IExtensionService } from '../../../services/extensions/common/extensions.js';
import { IHoverService } from '../../../services/hover/browser/hover.js';
import { ITreeViewsService } from '../../../services/views/browser/treeViewsService.js';
import { LocalSelectionTransfer, CodeDataTransfers } from 'monaco-editor/esm/vs/platform/dnd/browser/dnd.js';
import { toExternalVSDataTransfer } from 'monaco-editor/esm/vs/editor/browser/dnd.js';
import { TreeItemCheckbox, CheckboxStateHandler } from './checkbox.js';
import { setTimeout0 } from 'monaco-editor/esm/vs/base/common/platform.js';
import { TelemetryTrustedValue } from '../../../../platform/telemetry/common/telemetryUtils.js';
import { ITreeViewsDnDService } from 'monaco-editor/esm/vs/editor/common/services/treeViewsDndService.js';
import { DraggedTreeItemsIdentifier } from 'monaco-editor/esm/vs/editor/common/services/treeViewsDnd.js';
import { MarkdownRenderer } from 'monaco-editor/esm/vs/editor/contrib/markdownRenderer/browser/markdownRenderer.js';
let TreeViewPane = class TreeViewPane extends ViewPane {
    constructor(options, keybindingService, contextMenuService, configurationService, contextKeyService, viewDescriptorService, instantiationService, openerService, themeService, telemetryService, notificationService) {
        super({ ...options, titleMenuId: MenuId.ViewTitle, donotForwardArgs: false }, keybindingService, contextMenuService, configurationService, contextKeyService, viewDescriptorService, instantiationService, openerService, themeService, telemetryService);
        const { treeView } = ( Registry.as(Extensions.ViewsRegistry)).getView(options.id);
        this.treeView = treeView;
        this._register(this.treeView.onDidChangeActions(() => this.updateActions(), this));
        this._register(this.treeView.onDidChangeTitle((newTitle) => this.updateTitle(newTitle)));
        this._register(this.treeView.onDidChangeDescription((newDescription) => this.updateTitleDescription(newDescription)));
        this._register(toDisposable(() => {
            if (this._container && this.treeView.container && (this._container === this.treeView.container)) {
                this.treeView.setVisibility(false);
            }
        }));
        this._register(this.onDidChangeBodyVisibility(() => this.updateTreeVisibility()));
        this._register(this.treeView.onDidChangeWelcomeState(() => this._onDidChangeViewWelcomeState.fire()));
        if (options.title !== this.treeView.title) {
            this.updateTitle(this.treeView.title);
        }
        if (options.titleDescription !== this.treeView.description) {
            this.updateTitleDescription(this.treeView.description);
        }
        this._actionRunner = ( new MultipleSelectionActionRunner(notificationService, () => this.treeView.getSelection()));
        this.updateTreeVisibility();
    }
    focus() {
        super.focus();
        this.treeView.focus();
    }
    renderBody(container) {
        this._container = container;
        super.renderBody(container);
        this.renderTreeView(container);
    }
    shouldShowWelcome() {
        return ((this.treeView.dataProvider === undefined) || !!this.treeView.dataProvider.isTreeEmpty) && (this.treeView.message === undefined);
    }
    layoutBody(height, width) {
        super.layoutBody(height, width);
        this.layoutTreeView(height, width);
    }
    getOptimalWidth() {
        return this.treeView.getOptimalWidth();
    }
    renderTreeView(container) {
        this.treeView.show(container);
    }
    layoutTreeView(height, width) {
        this.treeView.layout(height, width);
    }
    updateTreeVisibility() {
        this.treeView.setVisibility(this.isBodyVisible());
    }
    getActionRunner() {
        return this._actionRunner;
    }
    getActionsContext() {
        return { $treeViewId: this.id, $focusedTreeItem: true, $selectedTreeItems: true };
    }
};
TreeViewPane = ( __decorate([
    ( __param(1, IKeybindingService)),
    ( __param(2, IContextMenuService)),
    ( __param(3, IConfigurationService)),
    ( __param(4, IContextKeyService)),
    ( __param(5, IViewDescriptorService)),
    ( __param(6, IInstantiationService)),
    ( __param(7, IOpenerService)),
    ( __param(8, IThemeService)),
    ( __param(9, ITelemetryService)),
    ( __param(10, INotificationService))
], TreeViewPane));
class Root {
    constructor() {
        this.label = { label: 'root' };
        this.handle = '0';
        this.parentHandle = undefined;
        this.collapsibleState = TreeItemCollapsibleState.Expanded;
        this.children = undefined;
    }
}
function isTreeCommandEnabled(treeCommand, contextKeyService) {
    const command = CommandsRegistry.getCommand(treeCommand.originalId ? treeCommand.originalId : treeCommand.id);
    if (command) {
        const commandAction = MenuRegistry.getCommand(command.id);
        const precondition = commandAction && commandAction.precondition;
        if (precondition) {
            return contextKeyService.contextMatchesRules(precondition);
        }
    }
    return true;
}
function isRenderedMessageValue(messageValue) {
    return !!messageValue && typeof messageValue !== 'string' && 'element' in messageValue && 'dispose' in messageValue;
}
const noDataProviderMessage = ( localize(
    'no-dataprovider',
    "There is no data provider registered that can provide view data."
));
const RawCustomTreeViewContextKey = ( new RawContextKey('customTreeView', false));
class Tree extends WorkbenchAsyncDataTree {
}
let AbstractTreeView = class AbstractTreeView extends Disposable {
    constructor(id, _title, themeService, instantiationService, commandService, configurationService, progressService, contextMenuService, keybindingService, notificationService, viewDescriptorService, hoverService, contextKeyService, activityService, logService) {
        super();
        this.id = id;
        this._title = _title;
        this.themeService = themeService;
        this.instantiationService = instantiationService;
        this.commandService = commandService;
        this.configurationService = configurationService;
        this.progressService = progressService;
        this.contextMenuService = contextMenuService;
        this.keybindingService = keybindingService;
        this.notificationService = notificationService;
        this.viewDescriptorService = viewDescriptorService;
        this.hoverService = hoverService;
        this.contextKeyService = contextKeyService;
        this.activityService = activityService;
        this.logService = logService;
        this.isVisible = false;
        this._hasIconForParentNode = false;
        this._hasIconForLeafNode = false;
        this.focused = false;
        this._canSelectMany = false;
        this._manuallyManageCheckboxes = false;
        this.elementsToRefresh = [];
        this.lastSelection = [];
        this._onDidExpandItem = this._register(( new Emitter()));
        this.onDidExpandItem = this._onDidExpandItem.event;
        this._onDidCollapseItem = this._register(( new Emitter()));
        this.onDidCollapseItem = this._onDidCollapseItem.event;
        this._onDidChangeSelectionAndFocus = this._register(( new Emitter()));
        this.onDidChangeSelectionAndFocus = this._onDidChangeSelectionAndFocus.event;
        this._onDidChangeVisibility = this._register(( new Emitter()));
        this.onDidChangeVisibility = this._onDidChangeVisibility.event;
        this._onDidChangeActions = this._register(( new Emitter()));
        this.onDidChangeActions = this._onDidChangeActions.event;
        this._onDidChangeWelcomeState = this._register(( new Emitter()));
        this.onDidChangeWelcomeState = this._onDidChangeWelcomeState.event;
        this._onDidChangeTitle = this._register(( new Emitter()));
        this.onDidChangeTitle = this._onDidChangeTitle.event;
        this._onDidChangeDescription = this._register(( new Emitter()));
        this.onDidChangeDescription = this._onDidChangeDescription.event;
        this._onDidChangeCheckboxState = this._register(( new Emitter()));
        this.onDidChangeCheckboxState = this._onDidChangeCheckboxState.event;
        this._onDidCompleteRefresh = this._register(( new Emitter()));
        this._isInitialized = false;
        this._height = 0;
        this._width = 0;
        this.refreshing = false;
        this.root = ( new Root());
        this.lastActive = this.root;
    }
    initialize() {
        if (this._isInitialized) {
            return;
        }
        this._isInitialized = true;
        this.contextKeyService.bufferChangeEvents(() => {
            this.initializeShowCollapseAllAction();
            this.initializeCollapseAllToggle();
            this.initializeShowRefreshAction();
        });
        this.treeViewDnd = this.instantiationService.createInstance(CustomTreeViewDragAndDrop, this.id);
        if (this._dragAndDropController) {
            this.treeViewDnd.controller = this._dragAndDropController;
        }
        this._register(this.configurationService.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('explorer.decorations')) {
                this.doRefresh([this.root]);
            }
        }));
        this._register(this.viewDescriptorService.onDidChangeLocation(({ views, from, to }) => {
            if (( views.some(v => v.id === this.id))) {
                this.tree?.updateOptions({ overrideStyles: { listBackground: this.viewLocation === 1  ? PANEL_BACKGROUND : SIDE_BAR_BACKGROUND } });
            }
        }));
        this.registerActions();
        this.create();
    }
    get viewContainer() {
        return this.viewDescriptorService.getViewContainerByViewId(this.id);
    }
    get viewLocation() {
        return this.viewDescriptorService.getViewLocationById(this.id);
    }
    get dragAndDropController() {
        return this._dragAndDropController;
    }
    set dragAndDropController(dnd) {
        this._dragAndDropController = dnd;
        if (this.treeViewDnd) {
            this.treeViewDnd.controller = dnd;
        }
    }
    get dataProvider() {
        return this._dataProvider;
    }
    set dataProvider(dataProvider) {
        if (dataProvider) {
            const self = this;
            this._dataProvider = new (class {
                constructor() {
                    this._isEmpty = true;
                    this._onDidChangeEmpty = ( new Emitter());
                    this.onDidChangeEmpty = this._onDidChangeEmpty.event;
                }
                get isTreeEmpty() {
                    return this._isEmpty;
                }
                async getChildren(node) {
                    let children;
                    const checkboxesUpdated = [];
                    if (node && node.children) {
                        children = node.children;
                    }
                    else {
                        node = node ?? self.root;
                        node.children = await (node instanceof Root ? dataProvider.getChildren() : dataProvider.getChildren(node));
                        children = node.children ?? [];
                        children.forEach(child => {
                            child.parent = node;
                            if (!self.manuallyManageCheckboxes && (node?.checkbox?.isChecked === true) && (child.checkbox?.isChecked === false)) {
                                child.checkbox.isChecked = true;
                                checkboxesUpdated.push(child);
                            }
                        });
                    }
                    if (node instanceof Root) {
                        const oldEmpty = this._isEmpty;
                        this._isEmpty = children.length === 0;
                        if (oldEmpty !== this._isEmpty) {
                            this._onDidChangeEmpty.fire();
                        }
                    }
                    if (checkboxesUpdated.length > 0) {
                        self._onDidChangeCheckboxState.fire(checkboxesUpdated);
                    }
                    return children;
                }
            });
            if (this._dataProvider.onDidChangeEmpty) {
                this._register(this._dataProvider.onDidChangeEmpty(() => {
                    this.updateCollapseAllToggle();
                    this._onDidChangeWelcomeState.fire();
                }));
            }
            this.updateMessage();
            this.refresh();
        }
        else {
            this._dataProvider = undefined;
            this.updateMessage();
        }
        this._onDidChangeWelcomeState.fire();
    }
    get message() {
        return this._message;
    }
    set message(message) {
        this._message = message;
        this.updateMessage();
        this._onDidChangeWelcomeState.fire();
    }
    get title() {
        return this._title;
    }
    set title(name) {
        this._title = name;
        this._onDidChangeTitle.fire(this._title);
    }
    get description() {
        return this._description;
    }
    set description(description) {
        this._description = description;
        this._onDidChangeDescription.fire(this._description);
    }
    get badge() {
        return this._badge;
    }
    set badge(badge) {
        if (this._badge?.value === badge?.value &&
            this._badge?.tooltip === badge?.tooltip) {
            return;
        }
        if (this._badgeActivity) {
            this._badgeActivity.dispose();
            this._badgeActivity = undefined;
        }
        this._badge = badge;
        if (badge) {
            const activity = {
                badge: ( new NumberBadge(badge.value, () => badge.tooltip)),
                priority: 50
            };
            this._badgeActivity = this.activityService.showViewActivity(this.id, activity);
        }
    }
    get canSelectMany() {
        return this._canSelectMany;
    }
    set canSelectMany(canSelectMany) {
        const oldCanSelectMany = this._canSelectMany;
        this._canSelectMany = canSelectMany;
        if (this._canSelectMany !== oldCanSelectMany) {
            this.tree?.updateOptions({ multipleSelectionSupport: this.canSelectMany });
        }
    }
    get manuallyManageCheckboxes() {
        return this._manuallyManageCheckboxes;
    }
    set manuallyManageCheckboxes(manuallyManageCheckboxes) {
        this._manuallyManageCheckboxes = manuallyManageCheckboxes;
    }
    get hasIconForParentNode() {
        return this._hasIconForParentNode;
    }
    get hasIconForLeafNode() {
        return this._hasIconForLeafNode;
    }
    get visible() {
        return this.isVisible;
    }
    initializeShowCollapseAllAction(startingValue = false) {
        if (!this.collapseAllContext) {
            this.collapseAllContextKey = ( new RawContextKey(`treeView.${this.id}.enableCollapseAll`, startingValue, ( localize(
                'treeView.enableCollapseAll',
                "Whether the the tree view with id {0} enables collapse all.",
                this.id
            ))));
            this.collapseAllContext = this.collapseAllContextKey.bindTo(this.contextKeyService);
        }
        return true;
    }
    get showCollapseAllAction() {
        this.initializeShowCollapseAllAction();
        return !!this.collapseAllContext?.get();
    }
    set showCollapseAllAction(showCollapseAllAction) {
        this.initializeShowCollapseAllAction(showCollapseAllAction);
        this.collapseAllContext?.set(showCollapseAllAction);
    }
    initializeShowRefreshAction(startingValue = false) {
        if (!this.refreshContext) {
            this.refreshContextKey = ( new RawContextKey(`treeView.${this.id}.enableRefresh`, startingValue, ( localize(
                'treeView.enableRefresh',
                "Whether the tree view with id {0} enables refresh.",
                this.id
            ))));
            this.refreshContext = this.refreshContextKey.bindTo(this.contextKeyService);
        }
    }
    get showRefreshAction() {
        this.initializeShowRefreshAction();
        return !!this.refreshContext?.get();
    }
    set showRefreshAction(showRefreshAction) {
        this.initializeShowRefreshAction(showRefreshAction);
        this.refreshContext?.set(showRefreshAction);
    }
    registerActions() {
        const that = this;
        this._register(registerAction2(class extends Action2 {
            constructor() {
                super({
                    id: `workbench.actions.treeView.${that.id}.refresh`,
                    title: ( localize('refresh', "Refresh")),
                    menu: {
                        id: MenuId.ViewTitle,
                        when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('view', that.id)), that.refreshContextKey)),
                        group: 'navigation',
                        order: Number.MAX_SAFE_INTEGER - 1,
                    },
                    icon: Codicon.refresh
                });
            }
            async run() {
                return that.refresh();
            }
        }));
        this._register(registerAction2(class extends Action2 {
            constructor() {
                super({
                    id: `workbench.actions.treeView.${that.id}.collapseAll`,
                    title: ( localize('collapseAll', "Collapse All")),
                    menu: {
                        id: MenuId.ViewTitle,
                        when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('view', that.id)), that.collapseAllContextKey)),
                        group: 'navigation',
                        order: Number.MAX_SAFE_INTEGER,
                    },
                    precondition: that.collapseAllToggleContextKey,
                    icon: Codicon.collapseAll
                });
            }
            async run() {
                if (that.tree) {
                    return ( new CollapseAllAction(that.tree, true)).run();
                }
            }
        }));
    }
    setVisibility(isVisible) {
        this.initialize();
        isVisible = !!isVisible;
        if (this.isVisible === isVisible) {
            return;
        }
        this.isVisible = isVisible;
        if (this.tree) {
            if (this.isVisible) {
                dom.show(this.tree.getHTMLElement());
            }
            else {
                dom.hide(this.tree.getHTMLElement());
            }
            if (this.isVisible && this.elementsToRefresh.length && this.dataProvider) {
                this.doRefresh(this.elementsToRefresh);
                this.elementsToRefresh = [];
            }
        }
        setTimeout0(() => {
            if (this.dataProvider) {
                this._onDidChangeVisibility.fire(this.isVisible);
            }
        });
        if (this.visible) {
            this.activate();
        }
    }
    focus(reveal = true, revealItem) {
        if (this.tree && this.root.children && this.root.children.length > 0) {
            const element = revealItem ?? this.tree.getSelection()[0];
            if (element && reveal) {
                this.tree.reveal(element, 0.5);
            }
            this.tree.domFocus();
        }
        else if (this.tree) {
            this.tree.domFocus();
        }
        else {
            this.domNode.focus();
        }
    }
    show(container) {
        this._container = container;
        dom.append(container, this.domNode);
    }
    create() {
        this.domNode = dom.$('.tree-explorer-viewlet-tree-view');
        this.messageElement = dom.append(this.domNode, dom.$('.message'));
        this.updateMessage();
        this.treeContainer = dom.append(this.domNode, dom.$('.customview-tree'));
        this.treeContainer.classList.add('file-icon-themable-tree', 'show-file-icons');
        const focusTracker = this._register(dom.trackFocus(this.domNode));
        this._register(focusTracker.onDidFocus(() => this.focused = true));
        this._register(focusTracker.onDidBlur(() => this.focused = false));
    }
    createTree() {
        const actionViewItemProvider = createActionViewItem.bind(undefined, this.instantiationService);
        const treeMenus = this._register(this.instantiationService.createInstance(TreeMenus, this.id));
        this.treeLabels = this._register(this.instantiationService.createInstance(ResourceLabels, this));
        const dataSource = this.instantiationService.createInstance(TreeDataSource, this, (task) => this.progressService.withProgress({ location: this.id }, () => task));
        const aligner = ( new Aligner(this.themeService));
        const checkboxStateHandler = this._register(( new CheckboxStateHandler()));
        const renderer = this.instantiationService.createInstance(TreeRenderer, this.id, treeMenus, this.treeLabels, actionViewItemProvider, aligner, checkboxStateHandler, this.manuallyManageCheckboxes);
        this._register(renderer.onDidChangeCheckboxState(e => this._onDidChangeCheckboxState.fire(e)));
        const widgetAriaLabel = this._title;
        this.tree = this._register(this.instantiationService.createInstance(Tree, this.id, this.treeContainer, ( new TreeViewDelegate()), [renderer], dataSource, {
            identityProvider: ( new TreeViewIdentityProvider()),
            accessibilityProvider: {
                getAriaLabel(element) {
                    if (element.accessibilityInformation) {
                        return element.accessibilityInformation.label;
                    }
                    if (isString(element.tooltip)) {
                        return element.tooltip;
                    }
                    else {
                        if (element.resourceUri && !element.label) {
                            return null;
                        }
                        let buildAriaLabel = '';
                        if (element.label) {
                            buildAriaLabel += element.label.label + ' ';
                        }
                        if (element.description) {
                            buildAriaLabel += element.description;
                        }
                        return buildAriaLabel;
                    }
                },
                getRole(element) {
                    return element.accessibilityInformation?.role ?? 'treeitem';
                },
                getWidgetAriaLabel() {
                    return widgetAriaLabel;
                }
            },
            keyboardNavigationLabelProvider: {
                getKeyboardNavigationLabel: (item) => {
                    return item.label ? item.label.label : (item.resourceUri ? basename(URI.revive(item.resourceUri)) : undefined);
                }
            },
            expandOnlyOnTwistieClick: (e) => {
                return !!e.command || !!e.checkbox || this.configurationService.getValue('workbench.tree.expandMode') === 'doubleClick';
            },
            collapseByDefault: (e) => {
                return e.collapsibleState !== TreeItemCollapsibleState.Expanded;
            },
            multipleSelectionSupport: this.canSelectMany,
            dnd: this.treeViewDnd,
            overrideStyles: {
                listBackground: this.viewLocation === 1  ? PANEL_BACKGROUND : SIDE_BAR_BACKGROUND
            }
        }));
        treeMenus.setContextKeyService(this.tree.contextKeyService);
        aligner.tree = this.tree;
        const actionRunner = ( new MultipleSelectionActionRunner(this.notificationService, () => this.tree.getSelection()));
        renderer.actionRunner = actionRunner;
        this.tree.contextKeyService.createKey(this.id, true);
        const customTreeKey = RawCustomTreeViewContextKey.bindTo(this.tree.contextKeyService);
        customTreeKey.set(true);
        this._register(this.tree.onContextMenu(e => this.onContextMenu(treeMenus, e, actionRunner)));
        this._register(this.tree.onDidChangeSelection(e => {
            this.lastSelection = e.elements;
            this.lastActive = this.tree?.getFocus()[0] ?? this.lastActive;
            this._onDidChangeSelectionAndFocus.fire({ selection: this.lastSelection, focus: this.lastActive });
        }));
        this._register(this.tree.onDidChangeFocus(e => {
            if (e.elements.length && (e.elements[0] !== this.lastActive)) {
                this.lastActive = e.elements[0];
                this.lastSelection = this.tree?.getSelection() ?? this.lastSelection;
                this._onDidChangeSelectionAndFocus.fire({ selection: this.lastSelection, focus: this.lastActive });
            }
        }));
        this._register(this.tree.onDidChangeCollapseState(e => {
            if (!e.node.element) {
                return;
            }
            const element = Array.isArray(e.node.element.element) ? e.node.element.element[0] : e.node.element.element;
            if (e.node.collapsed) {
                this._onDidCollapseItem.fire(element);
            }
            else {
                this._onDidExpandItem.fire(element);
            }
        }));
        this.tree.setInput(this.root).then(() => this.updateContentAreas());
        this._register(this.tree.onDidOpen(async (e) => {
            if (!e.browserEvent) {
                return;
            }
            if (e.browserEvent.target && e.browserEvent.target.classList.contains(TreeItemCheckbox.checkboxClass)) {
                return;
            }
            const selection = this.tree.getSelection();
            const command = await this.resolveCommand(selection.length === 1 ? selection[0] : undefined);
            if (command && isTreeCommandEnabled(command, this.contextKeyService)) {
                let args = command.arguments || [];
                if (command.id === API_OPEN_EDITOR_COMMAND_ID || command.id === API_OPEN_DIFF_EDITOR_COMMAND_ID) {
                    args = [...args, e];
                }
                try {
                    await this.commandService.executeCommand(command.id, ...args);
                }
                catch (err) {
                    this.notificationService.error(err);
                }
            }
        }));
        this._register(treeMenus.onDidChange((changed) => {
            if (this.tree?.hasNode(changed)) {
                this.tree?.rerender(changed);
            }
        }));
    }
    async resolveCommand(element) {
        let command = element?.command;
        if (element && !command) {
            if ((element instanceof ResolvableTreeItem) && element.hasResolve) {
                await element.resolve(( new CancellationTokenSource()).token);
                command = element.command;
            }
        }
        return command;
    }
    onContextMenu(treeMenus, treeEvent, actionRunner) {
        this.hoverService.hideHover();
        const node = treeEvent.element;
        if (node === null) {
            return;
        }
        const event = treeEvent.browserEvent;
        event.preventDefault();
        event.stopPropagation();
        this.tree.setFocus([node]);
        const actions = treeMenus.getResourceContextActions(node);
        if (!actions.length) {
            return;
        }
        this.contextMenuService.showContextMenu({
            getAnchor: () => treeEvent.anchor,
            getActions: () => actions,
            getActionViewItem: (action) => {
                const keybinding = this.keybindingService.lookupKeybinding(action.id);
                if (keybinding) {
                    return ( new ActionViewItem(action, action, { label: true, keybinding: keybinding.getLabel() }));
                }
                return undefined;
            },
            onHide: (wasCancelled) => {
                if (wasCancelled) {
                    this.tree.domFocus();
                }
            },
            getActionsContext: () => ({ $treeViewId: this.id, $treeItemHandle: node.handle }),
            actionRunner
        });
    }
    updateMessage() {
        if (this._message) {
            this.showMessage(this._message);
        }
        else if (!this.dataProvider) {
            this.showMessage(noDataProviderMessage);
        }
        else {
            this.hideMessage();
        }
        this.updateContentAreas();
    }
    showMessage(message) {
        if (isRenderedMessageValue(this._messageValue)) {
            this._messageValue.dispose();
        }
        if (isMarkdownString(message) && !this.markdownRenderer) {
            this.markdownRenderer = this.instantiationService.createInstance(MarkdownRenderer, {});
        }
        this._messageValue = isMarkdownString(message) ? this.markdownRenderer.render(message) : message;
        if (!this.messageElement) {
            return;
        }
        this.messageElement.classList.remove('hide');
        this.resetMessageElement();
        if (typeof this._messageValue === 'string' && !isFalsyOrWhitespace(this._messageValue)) {
            this.messageElement.textContent = this._messageValue;
        }
        else if (isRenderedMessageValue(this._messageValue)) {
            this.messageElement.appendChild(this._messageValue.element);
        }
        this.layout(this._height, this._width);
    }
    hideMessage() {
        this.resetMessageElement();
        this.messageElement?.classList.add('hide');
        this.layout(this._height, this._width);
    }
    resetMessageElement() {
        if (this.messageElement) {
            dom.clearNode(this.messageElement);
        }
    }
    layout(height, width) {
        if (height && width && this.messageElement && this.treeContainer) {
            this._height = height;
            this._width = width;
            const treeHeight = height - dom.getTotalHeight(this.messageElement);
            this.treeContainer.style.height = treeHeight + 'px';
            this.tree?.layout(treeHeight, width);
        }
    }
    getOptimalWidth() {
        if (this.tree) {
            const parentNode = this.tree.getHTMLElement();
            const childNodes = [].slice.call(parentNode.querySelectorAll('.outline-item-label > a'));
            return dom.getLargestChildWidth(parentNode, childNodes);
        }
        return 0;
    }
    async refresh(elements) {
        if (this.dataProvider && this.tree) {
            if (this.refreshing) {
                await Event.toPromise(this._onDidCompleteRefresh.event);
            }
            if (!elements) {
                elements = [this.root];
                this.elementsToRefresh = [];
            }
            for (const element of elements) {
                element.children = undefined;
            }
            if (this.isVisible) {
                return this.doRefresh(elements);
            }
            else {
                if (this.elementsToRefresh.length) {
                    const seen = ( new Set());
                    this.elementsToRefresh.forEach(element => seen.add(element.handle));
                    for (const element of elements) {
                        if (!( seen.has(element.handle))) {
                            this.elementsToRefresh.push(element);
                        }
                    }
                }
                else {
                    this.elementsToRefresh.push(...elements);
                }
            }
        }
        return undefined;
    }
    async expand(itemOrItems) {
        const tree = this.tree;
        if (!tree) {
            return;
        }
        try {
            itemOrItems = Array.isArray(itemOrItems) ? itemOrItems : [itemOrItems];
            for (const element of itemOrItems) {
                await tree.expand(element, false);
            }
        }
        catch (e) {
        }
    }
    isCollapsed(item) {
        return !!this.tree?.isCollapsed(item);
    }
    setSelection(items) {
        this.tree?.setSelection(items);
    }
    getSelection() {
        return this.tree?.getSelection() ?? [];
    }
    setFocus(item) {
        if (this.tree) {
            if (item) {
                this.focus(true, item);
                this.tree.setFocus([item]);
            }
            else {
                this.tree.setFocus([]);
            }
        }
    }
    async reveal(item) {
        if (this.tree) {
            return this.tree.reveal(item);
        }
    }
    async doRefresh(elements) {
        const tree = this.tree;
        if (tree && this.visible) {
            this.refreshing = true;
            const oldSelection = tree.getSelection();
            try {
                await Promise.all(( elements.map(element => tree.updateChildren(element, true, true))));
            }
            catch (e) {
                this.logService.error(e);
            }
            const newSelection = tree.getSelection();
            if (oldSelection.length !== newSelection.length || ( oldSelection.some((value, index) => value.handle !== newSelection[index].handle))) {
                this.lastSelection = newSelection;
                this._onDidChangeSelectionAndFocus.fire({ selection: this.lastSelection, focus: this.lastActive });
            }
            this.refreshing = false;
            this._onDidCompleteRefresh.fire();
            this.updateContentAreas();
            if (this.focused) {
                this.focus(false);
            }
            this.updateCollapseAllToggle();
        }
    }
    initializeCollapseAllToggle() {
        if (!this.collapseAllToggleContext) {
            this.collapseAllToggleContextKey = ( new RawContextKey(`treeView.${this.id}.toggleCollapseAll`, false, ( localize(
                'treeView.toggleCollapseAll',
                "Whether collapse all is toggled for the tree view with id {0}.",
                this.id
            ))));
            this.collapseAllToggleContext = this.collapseAllToggleContextKey.bindTo(this.contextKeyService);
        }
    }
    updateCollapseAllToggle() {
        if (this.showCollapseAllAction) {
            this.initializeCollapseAllToggle();
            this.collapseAllToggleContext?.set(!!this.root.children && (this.root.children.length > 0) &&
                ( this.root.children.some(value => value.collapsibleState !== TreeItemCollapsibleState.None)));
        }
    }
    updateContentAreas() {
        const isTreeEmpty = !this.root.children || this.root.children.length === 0;
        if (this._messageValue && isTreeEmpty && !this.refreshing && this.treeContainer) {
            if (!this.dragAndDropController) {
                this.treeContainer.classList.add('hide');
            }
            this.domNode.setAttribute('tabindex', '0');
        }
        else if (this.treeContainer) {
            this.treeContainer.classList.remove('hide');
            this.domNode.removeAttribute('tabindex');
        }
    }
    get container() {
        return this._container;
    }
};
AbstractTreeView = ( __decorate([
    ( __param(2, IThemeService)),
    ( __param(3, IInstantiationService)),
    ( __param(4, ICommandService)),
    ( __param(5, IConfigurationService)),
    ( __param(6, IProgressService)),
    ( __param(7, IContextMenuService)),
    ( __param(8, IKeybindingService)),
    ( __param(9, INotificationService)),
    ( __param(10, IViewDescriptorService)),
    ( __param(11, IHoverService)),
    ( __param(12, IContextKeyService)),
    ( __param(13, IActivityService)),
    ( __param(14, ILogService))
], AbstractTreeView));
class TreeViewIdentityProvider {
    getId(element) {
        return element.handle;
    }
}
class TreeViewDelegate {
    getHeight(element) {
        return TreeRenderer.ITEM_HEIGHT;
    }
    getTemplateId(element) {
        return TreeRenderer.TREE_TEMPLATE_ID;
    }
}
class TreeDataSource {
    constructor(treeView, withProgress) {
        this.treeView = treeView;
        this.withProgress = withProgress;
    }
    hasChildren(element) {
        return !!this.treeView.dataProvider && (element.collapsibleState !== TreeItemCollapsibleState.None);
    }
    async getChildren(element) {
        let result = [];
        if (this.treeView.dataProvider) {
            try {
                result = (await this.withProgress(this.treeView.dataProvider.getChildren(element))) ?? [];
            }
            catch (e) {
                if (!e.message.startsWith('Bad progress location:')) {
                    throw e;
                }
            }
        }
        return result;
    }
}
let TreeRenderer = class TreeRenderer extends Disposable {
    static { this.ITEM_HEIGHT = 22; }
    static { this.TREE_TEMPLATE_ID = 'treeExplorer'; }
    constructor(treeViewId, menus, labels, actionViewItemProvider, aligner, checkboxStateHandler, manuallyManageCheckboxes, themeService, configurationService, labelService, hoverService, treeViewsService, contextKeyService) {
        super();
        this.treeViewId = treeViewId;
        this.menus = menus;
        this.labels = labels;
        this.actionViewItemProvider = actionViewItemProvider;
        this.aligner = aligner;
        this.checkboxStateHandler = checkboxStateHandler;
        this.manuallyManageCheckboxes = manuallyManageCheckboxes;
        this.themeService = themeService;
        this.configurationService = configurationService;
        this.labelService = labelService;
        this.hoverService = hoverService;
        this.treeViewsService = treeViewsService;
        this.contextKeyService = contextKeyService;
        this._onDidChangeCheckboxState = this._register(( new Emitter()));
        this.onDidChangeCheckboxState = this._onDidChangeCheckboxState.event;
        this._hasCheckbox = false;
        this._renderedElements = ( new Map());
        this._hoverDelegate = {
            showHover: (options) => this.hoverService.showHover(options),
            delay: this.configurationService.getValue('workbench.hover.delay')
        };
        this._register(this.themeService.onDidFileIconThemeChange(() => this.rerender()));
        this._register(this.themeService.onDidColorThemeChange(() => this.rerender()));
        this._register(checkboxStateHandler.onDidChangeCheckboxState(items => {
            this.updateCheckboxes(items);
        }));
    }
    get templateId() {
        return TreeRenderer.TREE_TEMPLATE_ID;
    }
    set actionRunner(actionRunner) {
        this._actionRunner = actionRunner;
    }
    renderTemplate(container) {
        container.classList.add('custom-view-tree-node-item');
        const checkboxContainer = dom.append(container, dom.$(''));
        const resourceLabel = this.labels.create(container, { supportHighlights: true, hoverDelegate: this._hoverDelegate });
        const icon = dom.prepend(resourceLabel.element, dom.$('.custom-view-tree-node-item-icon'));
        const actionsContainer = dom.append(resourceLabel.element, dom.$('.actions'));
        const actionBar = ( new ActionBar(actionsContainer, {
            actionViewItemProvider: this.actionViewItemProvider
        }));
        return { resourceLabel, icon, checkboxContainer, actionBar, container, elementDisposable: ( new DisposableStore()) };
    }
    getHover(label, resource, node) {
        if (!(node instanceof ResolvableTreeItem) || !node.hasResolve) {
            if (resource && !node.tooltip) {
                return undefined;
            }
            else if (node.tooltip === undefined) {
                return label;
            }
            else if (!isString(node.tooltip)) {
                return { markdown: node.tooltip, markdownNotSupportedFallback: resource ? undefined : renderMarkdownAsPlaintext(node.tooltip) };
            }
            else if (node.tooltip !== '') {
                return node.tooltip;
            }
            else {
                return undefined;
            }
        }
        return {
            markdown: typeof node.tooltip === 'string' ? node.tooltip :
                (token) => {
                    return ( new Promise((resolve) => {
                        node.resolve(token).then(() => resolve(node.tooltip));
                    }));
                },
            markdownNotSupportedFallback: resource ? undefined : (label ?? '')
        };
    }
    renderElement(element, index, templateData) {
        const node = element.element;
        const resource = node.resourceUri ? URI.revive(node.resourceUri) : null;
        const treeItemLabel = node.label ? node.label : (resource ? { label: basename(resource) } : undefined);
        const description = isString(node.description) ? node.description : resource && node.description === true ? this.labelService.getUriLabel(dirname(resource), { relative: true }) : undefined;
        const label = treeItemLabel ? treeItemLabel.label : undefined;
        const matches = (treeItemLabel && treeItemLabel.highlights && label) ? ( treeItemLabel.highlights.map(([start, end]) => {
            if (start < 0) {
                start = label.length + start;
            }
            if (end < 0) {
                end = label.length + end;
            }
            if ((start >= label.length) || (end > label.length)) {
                return ({ start: 0, end: 0 });
            }
            if (start > end) {
                const swap = start;
                start = end;
                end = swap;
            }
            return ({ start, end });
        })) : undefined;
        const icon = this.themeService.getColorTheme().type === ColorScheme.LIGHT ? node.icon : node.iconDark;
        const iconUrl = icon ? URI.revive(icon) : undefined;
        const title = this.getHover(label, resource, node);
        templateData.actionBar.clear();
        templateData.icon.style.color = '';
        let commandEnabled = true;
        if (node.command) {
            commandEnabled = isTreeCommandEnabled(node.command, this.contextKeyService);
        }
        this.renderCheckbox(node, templateData);
        if (resource) {
            const fileDecorations = this.configurationService.getValue('explorer.decorations');
            const labelResource = resource ? resource : ( URI.parse('missing:_icon_resource'));
            templateData.resourceLabel.setResource({ name: label, description, resource: labelResource }, {
                fileKind: this.getFileKind(node),
                title,
                hideIcon: this.shouldHideResourceLabelIcon(iconUrl, node.themeIcon),
                fileDecorations,
                extraClasses: ['custom-view-tree-node-item-resourceLabel'],
                matches: matches ? matches : createMatches(element.filterData),
                strikethrough: treeItemLabel?.strikethrough,
                disabledCommand: !commandEnabled,
                labelEscapeNewLines: true
            });
        }
        else {
            templateData.resourceLabel.setResource({ name: label, description }, {
                title,
                hideIcon: true,
                extraClasses: ['custom-view-tree-node-item-resourceLabel'],
                matches: matches ? matches : createMatches(element.filterData),
                strikethrough: treeItemLabel?.strikethrough,
                disabledCommand: !commandEnabled,
                labelEscapeNewLines: true
            });
        }
        if (iconUrl) {
            templateData.icon.className = 'custom-view-tree-node-item-icon';
            templateData.icon.style.backgroundImage = dom.asCSSUrl(iconUrl);
        }
        else {
            let iconClass;
            if (this.shouldShowThemeIcon(!!resource, node.themeIcon)) {
                iconClass = ThemeIcon.asClassName(node.themeIcon);
                if (node.themeIcon.color) {
                    templateData.icon.style.color = this.themeService.getColorTheme().getColor(node.themeIcon.color.id)?.toString() ?? '';
                }
            }
            templateData.icon.className = iconClass ? `custom-view-tree-node-item-icon ${iconClass}` : '';
            templateData.icon.style.backgroundImage = '';
        }
        if (!commandEnabled) {
            templateData.icon.className = templateData.icon.className + ' disabled';
            if (templateData.container.parentElement) {
                templateData.container.parentElement.className = templateData.container.parentElement.className + ' disabled';
            }
        }
        templateData.actionBar.context = { $treeViewId: this.treeViewId, $treeItemHandle: node.handle };
        const menuActions = this.menus.getResourceActions(node);
        if (menuActions.menu) {
            templateData.elementDisposable.add(menuActions.menu);
        }
        templateData.actionBar.push(menuActions.actions, { icon: true, label: false });
        if (this._actionRunner) {
            templateData.actionBar.actionRunner = this._actionRunner;
        }
        this.setAlignment(templateData.container, node);
        this.treeViewsService.addRenderedTreeItemElement(node, templateData.container);
        this._renderedElements.set(element.element.handle, { original: element, rendered: templateData });
    }
    rerender() {
        const keys = ( new Set(( this._renderedElements.keys())));
        for (const key of keys) {
            const value = this._renderedElements.get(key);
            if (value) {
                this.disposeElement(value.original, 0, value.rendered);
                this.renderElement(value.original, 0, value.rendered);
            }
        }
    }
    renderCheckbox(node, templateData) {
        if (node.checkbox) {
            if (!this._hasCheckbox) {
                this._hasCheckbox = true;
                this.rerender();
            }
            if (!templateData.checkbox) {
                const checkbox = ( new TreeItemCheckbox(
                    templateData.checkboxContainer,
                    this.checkboxStateHandler,
                    this._hoverDelegate
                ));
                templateData.checkbox = checkbox;
            }
            templateData.checkbox.render(node);
        }
        else if (templateData.checkbox) {
            templateData.checkbox.dispose();
            templateData.checkbox = undefined;
        }
    }
    setAlignment(container, treeItem) {
        container.parentElement.classList.toggle('align-icon-with-twisty', !this._hasCheckbox && this.aligner.alignIconWithTwisty(treeItem));
    }
    shouldHideResourceLabelIcon(iconUrl, icon) {
        return (!!iconUrl || (!!icon && !this.isFileKindThemeIcon(icon)));
    }
    shouldShowThemeIcon(hasResource, icon) {
        if (!icon) {
            return false;
        }
        return !(hasResource && this.isFileKindThemeIcon(icon));
    }
    isFolderThemeIcon(icon) {
        return icon?.id === FolderThemeIcon.id;
    }
    isFileKindThemeIcon(icon) {
        if (icon) {
            return icon.id === FileThemeIcon.id || this.isFolderThemeIcon(icon);
        }
        else {
            return false;
        }
    }
    getFileKind(node) {
        if (node.themeIcon) {
            switch (node.themeIcon.id) {
                case FileThemeIcon.id:
                    return FileKind.FILE;
                case FolderThemeIcon.id:
                    return FileKind.FOLDER;
            }
        }
        return node.collapsibleState === TreeItemCollapsibleState.Collapsed || node.collapsibleState === TreeItemCollapsibleState.Expanded ? FileKind.FOLDER : FileKind.FILE;
    }
    updateCheckboxes(items) {
        const additionalItems = [];
        if (!this.manuallyManageCheckboxes) {
            for (const item of items) {
                if (item.checkbox !== undefined) {
                    function checkChildren(currentItem) {
                        for (const child of (currentItem.children ?? [])) {
                            if ((child.checkbox !== undefined) && (currentItem.checkbox !== undefined) && (child.checkbox.isChecked !== currentItem.checkbox.isChecked)) {
                                child.checkbox.isChecked = currentItem.checkbox.isChecked;
                                additionalItems.push(child);
                                checkChildren(child);
                            }
                        }
                    }
                    checkChildren(item);
                    const visitedParents = ( new Set());
                    function checkParents(currentItem) {
                        if (currentItem.parent && (currentItem.parent.checkbox !== undefined) && currentItem.parent.children) {
                            if (( visitedParents.has(currentItem.parent))) {
                                return;
                            }
                            else {
                                visitedParents.add(currentItem.parent);
                            }
                            let someUnchecked = false;
                            let someChecked = false;
                            for (const child of currentItem.parent.children) {
                                if (someUnchecked && someChecked) {
                                    break;
                                }
                                if (child.checkbox !== undefined) {
                                    if (child.checkbox.isChecked) {
                                        someChecked = true;
                                    }
                                    else {
                                        someUnchecked = true;
                                    }
                                }
                            }
                            if (someChecked && !someUnchecked && (currentItem.parent.checkbox.isChecked !== true)) {
                                currentItem.parent.checkbox.isChecked = true;
                                additionalItems.push(currentItem.parent);
                                checkParents(currentItem.parent);
                            }
                            else if (someUnchecked && (currentItem.parent.checkbox.isChecked !== false)) {
                                currentItem.parent.checkbox.isChecked = false;
                                additionalItems.push(currentItem.parent);
                                checkParents(currentItem.parent);
                            }
                        }
                    }
                    checkParents(item);
                }
            }
        }
        items = items.concat(additionalItems);
        items.forEach(item => {
            const renderedItem = this._renderedElements.get(item.handle);
            if (renderedItem) {
                renderedItem.rendered.checkbox?.render(item);
            }
        });
        this._onDidChangeCheckboxState.fire(items);
    }
    disposeElement(resource, index, templateData) {
        templateData.elementDisposable.clear();
        this._renderedElements.delete(resource.element.handle);
        this.treeViewsService.removeRenderedTreeItemElement(resource.element);
        templateData.checkbox?.dispose();
        templateData.checkbox = undefined;
    }
    disposeTemplate(templateData) {
        templateData.resourceLabel.dispose();
        templateData.actionBar.dispose();
        templateData.elementDisposable.dispose();
    }
};
TreeRenderer = ( __decorate([
    ( __param(7, IThemeService)),
    ( __param(8, IConfigurationService)),
    ( __param(9, ILabelService)),
    ( __param(10, IHoverService)),
    ( __param(11, ITreeViewsService)),
    ( __param(12, IContextKeyService))
], TreeRenderer));
class Aligner extends Disposable {
    constructor(themeService) {
        super();
        this.themeService = themeService;
    }
    set tree(tree) {
        this._tree = tree;
    }
    alignIconWithTwisty(treeItem) {
        if (treeItem.collapsibleState !== TreeItemCollapsibleState.None) {
            return false;
        }
        if (!this.hasIcon(treeItem)) {
            return false;
        }
        if (this._tree) {
            const parent = this._tree.getParentElement(treeItem) || this._tree.getInput();
            if (this.hasIcon(parent)) {
                return !!parent.children && ( parent.children.some(
                    c => c.collapsibleState !== TreeItemCollapsibleState.None && !this.hasIcon(c)
                ));
            }
            return !!parent.children && parent.children.every(c => c.collapsibleState === TreeItemCollapsibleState.None || !this.hasIcon(c));
        }
        else {
            return false;
        }
    }
    hasIcon(node) {
        const icon = this.themeService.getColorTheme().type === ColorScheme.LIGHT ? node.icon : node.iconDark;
        if (icon) {
            return true;
        }
        if (node.resourceUri || node.themeIcon) {
            const fileIconTheme = this.themeService.getFileIconTheme();
            const isFolder = node.themeIcon ? node.themeIcon.id === FolderThemeIcon.id : node.collapsibleState !== TreeItemCollapsibleState.None;
            if (isFolder) {
                return fileIconTheme.hasFileIcons && fileIconTheme.hasFolderIcons;
            }
            return fileIconTheme.hasFileIcons;
        }
        return false;
    }
}
class MultipleSelectionActionRunner extends ActionRunner {
    constructor(notificationService, getSelectedResources) {
        super();
        this.getSelectedResources = getSelectedResources;
        this._register(this.onDidRun(e => {
            if (e.error && !isCancellationError(e.error)) {
                notificationService.error(( localize(
                    'command-error',
                    'Error running command {1}: {0}. This is likely caused by the extension that contributes {1}.',
                    e.error.message,
                    e.action.id
                )));
            }
        }));
    }
    async runAction(action, context) {
        const selection = this.getSelectedResources();
        let selectionHandleArgs = undefined;
        let actionInSelected = false;
        if (selection.length > 1) {
            selectionHandleArgs = ( selection.map(selected => {
                if ((selected.handle === context.$treeItemHandle) || context.$selectedTreeItems) {
                    actionInSelected = true;
                }
                return { $treeViewId: context.$treeViewId, $treeItemHandle: selected.handle };
            }));
        }
        if (!actionInSelected) {
            selectionHandleArgs = undefined;
        }
        await action.run(context, selectionHandleArgs);
    }
}
let TreeMenus = class TreeMenus extends Disposable {
    constructor(id, menuService) {
        super();
        this.id = id;
        this.menuService = menuService;
        this._onDidChange = ( new Emitter());
        this.onDidChange = this._onDidChange.event;
    }
    getResourceActions(element) {
        const actions = this.getActions(MenuId.ViewItemContext, element, true);
        return { menu: actions.menu, actions: actions.primary };
    }
    getResourceContextActions(element) {
        return this.getActions(MenuId.ViewItemContext, element).secondary;
    }
    setContextKeyService(service) {
        this.contextKeyService = service;
    }
    getActions(menuId, element, listen = false) {
        if (!this.contextKeyService) {
            return { primary: [], secondary: [] };
        }
        const contextKeyService = this.contextKeyService.createOverlay([
            ['view', this.id],
            ['viewItem', element.contextValue]
        ]);
        const menu = this.menuService.createMenu(menuId, contextKeyService);
        const primary = [];
        const secondary = [];
        const result = { primary, secondary, menu };
        createAndFillInContextMenuActions(menu, { shouldForwardArgs: true }, result, 'inline');
        if (listen) {
            this._register(menu.onDidChange(() => this._onDidChange.fire(element)));
        }
        else {
            menu.dispose();
        }
        return result;
    }
    dispose() {
        this.contextKeyService = undefined;
        super.dispose();
    }
};
TreeMenus = ( __decorate([
    ( __param(1, IMenuService))
], TreeMenus));
let CustomTreeView = class CustomTreeView extends AbstractTreeView {
    constructor(id, title, extensionId, themeService, instantiationService, commandService, configurationService, progressService, contextMenuService, keybindingService, notificationService, viewDescriptorService, contextKeyService, hoverService, extensionService, activityService, telemetryService, logService) {
        super(id, title, themeService, instantiationService, commandService, configurationService, progressService, contextMenuService, keybindingService, notificationService, viewDescriptorService, hoverService, contextKeyService, activityService, logService);
        this.extensionId = extensionId;
        this.extensionService = extensionService;
        this.telemetryService = telemetryService;
        this.activated = false;
    }
    activate() {
        if (!this.activated) {
            this.telemetryService.publicLog2('Extension:ViewActivate', {
                extensionId: ( new TelemetryTrustedValue(this.extensionId)),
                id: this.id,
            });
            this.createTree();
            this.progressService.withProgress({ location: this.id }, () => this.extensionService.activateByEvent(`onView:${this.id}`))
                .then(() => timeout(2000))
                .then(() => {
                this.updateMessage();
            });
            this.activated = true;
        }
    }
};
CustomTreeView = ( __decorate([
    ( __param(3, IThemeService)),
    ( __param(4, IInstantiationService)),
    ( __param(5, ICommandService)),
    ( __param(6, IConfigurationService)),
    ( __param(7, IProgressService)),
    ( __param(8, IContextMenuService)),
    ( __param(9, IKeybindingService)),
    ( __param(10, INotificationService)),
    ( __param(11, IViewDescriptorService)),
    ( __param(12, IContextKeyService)),
    ( __param(13, IHoverService)),
    ( __param(14, IExtensionService)),
    ( __param(15, IActivityService)),
    ( __param(16, ITelemetryService)),
    ( __param(17, ILogService))
], CustomTreeView));
let CustomTreeViewDragAndDrop = class CustomTreeViewDragAndDrop {
    constructor(treeId, labelService, instantiationService, treeViewsDragAndDropService, logService) {
        this.treeId = treeId;
        this.labelService = labelService;
        this.instantiationService = instantiationService;
        this.treeViewsDragAndDropService = treeViewsDragAndDropService;
        this.logService = logService;
        this.treeItemsTransfer = LocalSelectionTransfer.getInstance();
        this.treeMimeType = `application/vnd.code.tree.${treeId.toLowerCase()}`;
    }
    set controller(controller) {
        this.dndController = controller;
    }
    handleDragAndLog(dndController, itemHandles, uuid, dragCancellationToken) {
        return dndController.handleDrag(itemHandles, uuid, dragCancellationToken).then(additionalDataTransfer => {
            if (additionalDataTransfer) {
                const unlistedTypes = [];
                for (const item of additionalDataTransfer) {
                    if ((item[0] !== this.treeMimeType) && (dndController.dragMimeTypes.findIndex(value => value === item[0]) < 0)) {
                        unlistedTypes.push(item[0]);
                    }
                }
                if (unlistedTypes.length) {
                    this.logService.warn(`Drag and drop controller for tree ${this.treeId} adds the following data transfer types but does not declare them in dragMimeTypes: ${unlistedTypes.join(', ')}`);
                }
            }
            return additionalDataTransfer;
        });
    }
    addExtensionProvidedTransferTypes(originalEvent, itemHandles) {
        if (!originalEvent.dataTransfer || !this.dndController) {
            return;
        }
        const uuid = generateUuid();
        this.dragCancellationToken = ( new CancellationTokenSource());
        this.treeViewsDragAndDropService.addDragOperationTransfer(uuid, this.handleDragAndLog(this.dndController, itemHandles, uuid, this.dragCancellationToken.token));
        this.treeItemsTransfer.setData([( new DraggedTreeItemsIdentifier(uuid))], DraggedTreeItemsIdentifier.prototype);
        originalEvent.dataTransfer.clearData(Mimes.text);
        if (this.dndController.dragMimeTypes.find((element) => element === Mimes.uriList)) {
            originalEvent.dataTransfer?.setData(DataTransfers.RESOURCES, '');
        }
        this.dndController.dragMimeTypes.forEach(supportedType => {
            originalEvent.dataTransfer?.setData(supportedType, '');
        });
    }
    addResourceInfoToTransfer(originalEvent, resources) {
        if (resources.length && originalEvent.dataTransfer) {
            this.instantiationService.invokeFunction(accessor => fillEditorsDragData(accessor, resources, originalEvent));
            const fileResources = ( resources.filter(s => s.scheme === Schemas.file).map(r => r.fsPath));
            if (fileResources.length) {
                originalEvent.dataTransfer.setData(CodeDataTransfers.FILES, JSON.stringify(fileResources));
            }
        }
    }
    onDragStart(data, originalEvent) {
        if (originalEvent.dataTransfer) {
            const treeItemsData = data.getData();
            const resources = [];
            const sourceInfo = {
                id: this.treeId,
                itemHandles: []
            };
            treeItemsData.forEach(item => {
                sourceInfo.itemHandles.push(item.handle);
                if (item.resourceUri) {
                    resources.push(URI.revive(item.resourceUri));
                }
            });
            this.addResourceInfoToTransfer(originalEvent, resources);
            this.addExtensionProvidedTransferTypes(originalEvent, sourceInfo.itemHandles);
            originalEvent.dataTransfer.setData(this.treeMimeType, JSON.stringify(sourceInfo));
        }
    }
    debugLog(types) {
        if (types.size) {
            this.logService.debug(`TreeView dragged mime types: ${Array.from(types).join(', ')}`);
        }
        else {
            this.logService.debug(`TreeView dragged with no supported mime types.`);
        }
    }
    onDragOver(data, targetElement, targetIndex, originalEvent) {
        const dataTransfer = toExternalVSDataTransfer(originalEvent.dataTransfer);
        const types = ( new Set(Array.from(dataTransfer, x => x[0])));
        if (originalEvent.dataTransfer) {
            for (const item of originalEvent.dataTransfer.items) {
                if (item.kind === 'file' || item.type === DataTransfers.RESOURCES.toLowerCase()) {
                    types.add(Mimes.uriList);
                    break;
                }
            }
        }
        this.debugLog(types);
        const dndController = this.dndController;
        if (!dndController || !originalEvent.dataTransfer || (dndController.dropMimeTypes.length === 0)) {
            return false;
        }
        const dragContainersSupportedType = ( Array.from(types).some((value, index) => {
            if (value === this.treeMimeType) {
                return true;
            }
            else {
                return dndController.dropMimeTypes.indexOf(value) >= 0;
            }
        }));
        if (dragContainersSupportedType) {
            return { accept: true, bubble: 0 , autoExpand: true };
        }
        return false;
    }
    getDragURI(element) {
        if (!this.dndController) {
            return null;
        }
        return element.resourceUri ? ( URI.revive(element.resourceUri).toString()) : element.handle;
    }
    getDragLabel(elements) {
        if (!this.dndController) {
            return undefined;
        }
        if (elements.length > 1) {
            return String(elements.length);
        }
        const element = elements[0];
        return element.label ? element.label.label : (element.resourceUri ? this.labelService.getUriLabel(URI.revive(element.resourceUri)) : undefined);
    }
    async drop(data, targetNode, targetIndex, originalEvent) {
        const dndController = this.dndController;
        if (!originalEvent.dataTransfer || !dndController) {
            return;
        }
        let treeSourceInfo;
        let willDropUuid;
        if (this.treeItemsTransfer.hasData(DraggedTreeItemsIdentifier.prototype)) {
            willDropUuid = this.treeItemsTransfer.getData(DraggedTreeItemsIdentifier.prototype)[0].identifier;
        }
        const originalDataTransfer = toExternalVSDataTransfer(originalEvent.dataTransfer, true);
        const outDataTransfer = ( new VSDataTransfer());
        for (const [type, item] of originalDataTransfer) {
            if (type === this.treeMimeType || dndController.dropMimeTypes.includes(type) || (item.asFile() && dndController.dropMimeTypes.includes(DataTransfers.FILES.toLowerCase()))) {
                outDataTransfer.append(type, item);
                if (type === this.treeMimeType) {
                    try {
                        treeSourceInfo = JSON.parse(await item.asString());
                    }
                    catch {
                    }
                }
            }
        }
        const additionalDataTransfer = await this.treeViewsDragAndDropService.removeDragOperationTransfer(willDropUuid);
        if (additionalDataTransfer) {
            for (const [type, item] of additionalDataTransfer) {
                outDataTransfer.append(type, item);
            }
        }
        return dndController.handleDrop(outDataTransfer, targetNode, CancellationToken.None, willDropUuid, treeSourceInfo?.id, treeSourceInfo?.itemHandles);
    }
    onDragEnd(originalEvent) {
        if (originalEvent.dataTransfer?.dropEffect === 'none') {
            this.dragCancellationToken?.cancel();
        }
    }
};
CustomTreeViewDragAndDrop = ( __decorate([
    ( __param(1, ILabelService)),
    ( __param(2, IInstantiationService)),
    ( __param(3, ITreeViewsDnDService)),
    ( __param(4, ILogService))
], CustomTreeViewDragAndDrop));
export { CustomTreeView, CustomTreeViewDragAndDrop, RawCustomTreeViewContextKey, TreeViewPane };
