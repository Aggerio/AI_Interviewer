import { localize } from 'monaco-editor/esm/vs/nls.js';
import { EditorExtensions } from '../common/editor.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { toDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { Iterable } from 'monaco-editor/esm/vs/base/common/iterator.js';
class EditorPaneDescriptor {
    static create(ctor, typeId, name) {
        return ( new EditorPaneDescriptor(ctor, typeId, name));
    }
    constructor(ctor, typeId, name) {
        this.ctor = ctor;
        this.typeId = typeId;
        this.name = name;
    }
    instantiate(instantiationService) {
        return instantiationService.createInstance(this.ctor);
    }
    describes(editorPane) {
        return editorPane.getId() === this.typeId;
    }
}
class EditorPaneRegistry {
    constructor() {
        this.mapEditorPanesToEditors = ( new Map());
    }
    registerEditorPane(editorPaneDescriptor, editorDescriptors) {
        this.mapEditorPanesToEditors.set(editorPaneDescriptor, editorDescriptors);
        return toDisposable(() => {
            this.mapEditorPanesToEditors.delete(editorPaneDescriptor);
        });
    }
    getEditorPane(editor) {
        const descriptors = this.findEditorPaneDescriptors(editor);
        if (descriptors.length === 0) {
            return undefined;
        }
        if (descriptors.length === 1) {
            return descriptors[0];
        }
        return editor.prefersEditorPane(descriptors);
    }
    findEditorPaneDescriptors(editor, byInstanceOf) {
        const matchingEditorPaneDescriptors = [];
        for (const editorPane of ( this.mapEditorPanesToEditors.keys())) {
            const editorDescriptors = this.mapEditorPanesToEditors.get(editorPane) || [];
            for (const editorDescriptor of editorDescriptors) {
                const editorClass = editorDescriptor.ctor;
                if (!byInstanceOf && editor.constructor === editorClass) {
                    matchingEditorPaneDescriptors.push(editorPane);
                    break;
                }
                else if (byInstanceOf && editor instanceof editorClass) {
                    matchingEditorPaneDescriptors.push(editorPane);
                    break;
                }
            }
        }
        if (!byInstanceOf && matchingEditorPaneDescriptors.length === 0) {
            return this.findEditorPaneDescriptors(editor, true);
        }
        return matchingEditorPaneDescriptors;
    }
    getEditorPaneByType(typeId) {
        return Iterable.find(( this.mapEditorPanesToEditors.keys()), editor => editor.typeId === typeId);
    }
    getEditorPanes() {
        return Array.from(( this.mapEditorPanesToEditors.keys()));
    }
    getEditors() {
        const editorClasses = [];
        for (const editorPane of ( this.mapEditorPanesToEditors.keys())) {
            const editorDescriptors = this.mapEditorPanesToEditors.get(editorPane);
            if (editorDescriptors) {
                editorClasses.push(...( editorDescriptors.map(editorDescriptor => editorDescriptor.ctor)));
            }
        }
        return editorClasses;
    }
}
Registry.add(EditorExtensions.EditorPane, ( new EditorPaneRegistry()));
function computeEditorAriaLabel(input, index, group, groupCount) {
    let ariaLabel = input.getAriaLabel();
    if (group && !group.isPinned(input)) {
        ariaLabel = ( localize('preview', "{0}, preview", ariaLabel));
    }
    if (group?.isSticky(index ?? input)) {
        ariaLabel = ( localize('pinned', "{0}, pinned", ariaLabel));
    }
    if (group && typeof groupCount === 'number' && groupCount > 1) {
        ariaLabel = `${ariaLabel}, ${group.ariaLabel}`;
    }
    return ariaLabel;
}
export { EditorPaneDescriptor, EditorPaneRegistry, computeEditorAriaLabel };
