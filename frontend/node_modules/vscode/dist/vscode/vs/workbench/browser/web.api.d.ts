import { UriComponents, URI } from '../../base/common/uri.js';
import { IWebSocketFactory } from '../../platform/remote/browser/browserSocketFactory.js';
import { IURLCallbackProvider } from '../services/url/browser/urlService.js';
import { LogLevel } from '../../platform/log/common/log.js';
import { IUpdateProvider } from '../services/update/browser/updateService.js';
import { Event } from '../../base/common/event.js';
import { IWorkspaceProvider } from '../services/host/browser/browserHostService.js';
import { IProductConfiguration } from '../../base/common/product.js';
import { ICredentialsProvider } from '../../platform/credentials/common/credentials.js';
import { ISecretStorageProvider } from '../../platform/secrets/common/secrets.js';
import { TunnelProviderFeatures } from '../../platform/tunnel/common/tunnel.js';
import { ITextEditorOptions } from '../../platform/editor/common/editor.js';
import { EditorGroupLayout } from '../services/editor/common/editorGroupsService.js';

interface IWorkbenchConstructionOptions {
    /**
     * The remote authority is the IP:PORT from where the workbench is served
     * from. It is for example being used for the websocket connections as address.
     */
    readonly remoteAuthority?: string;
    /**
     * The connection token to send to the server.
     */
    readonly connectionToken?: string | Promise<string>;
    /**
     * An endpoint to serve iframe content ("webview") from. This is required
     * to provide full security isolation from the workbench host.
     */
    readonly webviewEndpoint?: string;
    /**
     * A factory for web sockets.
     */
    readonly webSocketFactory?: IWebSocketFactory;
    /**
     * A provider for resource URIs.
     *
     * *Note*: This will only be invoked after the `connectionToken` is resolved.
     */
    readonly resourceUriProvider?: IResourceUriProvider;
    /**
     * Resolves an external uri before it is opened.
     */
    readonly resolveExternalUri?: IExternalUriResolver;
    /**
     * A provider for supplying tunneling functionality,
     * such as creating tunnels and showing candidate ports to forward.
     */
    readonly tunnelProvider?: ITunnelProvider;
    /**
     * Endpoints to be used for proxying authentication code exchange calls in the browser.
     */
    readonly codeExchangeProxyEndpoints?: {
        [providerId: string]: string;
    };
    /**
     * The identifier of an edit session associated with the current workspace.
     */
    readonly editSessionId?: string;
    /**
     * Resource delegation handler that allows for loading of resources when
     * using remote resolvers.
     *
     * This is exclusive with {@link resourceUriProvider}. `resourceUriProvider`
     * should be used if a {@link webSocketFactory} is used, and will be preferred.
     */
    readonly remoteResourceProvider?: IRemoteResourceProvider;
    /**
     * A handler for opening workspaces and providing the initial workspace.
     */
    readonly workspaceProvider?: IWorkspaceProvider;
    /**
     * Settings sync options
     */
    readonly settingsSyncOptions?: ISettingsSyncOptions;
    /**
     * The credentials provider to store and retrieve secrets.
     * TODO: Remove this in favor of the secret storage provider.
     */
    readonly credentialsProvider?: ICredentialsProvider;
    /**
     * The secret storage provider to store and retrieve secrets.
     */
    readonly secretStorageProvider?: ISecretStorageProvider;
    /**
     * Additional builtin extensions those cannot be uninstalled but only be disabled.
     * It can be one of the following:
     * 	- an extension in the Marketplace
     * 	- location of the extension where it is hosted.
     */
    readonly additionalBuiltinExtensions?: readonly (MarketplaceExtension | UriComponents)[];
    /**
     * List of extensions to be enabled if they are installed.
     * Note: This will not install extensions if not installed.
     */
    readonly enabledExtensions?: readonly ExtensionId[];
    /**
     * Additional domains allowed to open from the workbench without the
     * link protection popup.
     */
    readonly additionalTrustedDomains?: string[];
    /**
     * Enable workspace trust feature for the current window
     */
    readonly enableWorkspaceTrust?: boolean;
    /**
     * Urls that will be opened externally that are allowed access
     * to the opener window. This is primarily used to allow
     * `window.close()` to be called from the newly opened window.
     */
    readonly openerAllowedExternalUrlPrefixes?: string[];
    /**
     * Support for URL callbacks.
     */
    readonly urlCallbackProvider?: IURLCallbackProvider;
    /**
     * Support adding additional properties to telemetry.
     */
    readonly resolveCommonTelemetryProperties?: ICommonTelemetryPropertiesResolver;
    /**
     * A set of optional commands that should be registered with the commands
     * registry.
     *
     * Note: commands can be called from extensions if the identifier is known!
     */
    readonly commands?: readonly ICommand[];
    /**
     * Optional default layout to apply on first time the workspace is opened
     * (unless `force` is specified). This includes visibility of views and
     * editors including editor grid layout.
     */
    readonly defaultLayout?: IDefaultLayout;
    /**
     * Optional configuration default overrides contributed to the workbench.
     */
    readonly configurationDefaults?: Record<string, any>;
    /**
     * Profile to use for the workbench.
     */
    readonly profile?: {
        readonly name: string;
        readonly contents?: string | UriComponents;
    };
    /**
     * URI of the profile to preview.
     */
    readonly profileToPreview?: UriComponents;
    /**
     * Support for update reporting
     */
    readonly updateProvider?: IUpdateProvider;
    /**
     * Support for product quality switching
     */
    readonly productQualityChangeHandler?: IProductQualityChangeHandler;
    /**
     * Optional home indicator to appear above the hamburger menu in the activity bar.
     */
    readonly homeIndicator?: IHomeIndicator;
    /**
     * Optional welcome banner to appear above the workbench. Can be dismissed by the
     * user.
     */
    readonly welcomeBanner?: IWelcomeBanner;
    /**
     * Optional override for the product configuration properties.
     */
    readonly productConfiguration?: Partial<IProductConfiguration>;
    /**
     * Optional override for properties of the window indicator in the status bar.
     */
    readonly windowIndicator?: IWindowIndicator;
    /**
     * Specifies the default theme type (LIGHT, DARK..) and allows to provide initial colors that are shown
     * until the color theme that is specified in the settings (`editor.colorTheme`) is loaded and applied.
     * Once there are persisted colors from a last run these will be used.
     *
     * The idea is that the colors match the main colors from the theme defined in the `configurationDefaults`.
     */
    readonly initialColorTheme?: IInitialColorTheme;
    /**
     *  Welcome dialog. Can be dismissed by the user.
     */
    readonly welcomeDialog?: IWelcomeDialog;
    readonly messagePorts?: ReadonlyMap<ExtensionId, MessagePort>;
    readonly developmentOptions?: IDevelopmentOptions;
}
interface IResourceUriProvider {
    (uri: URI): URI;
}
/**
 * The identifier of an extension in the format: `PUBLISHER.NAME`. For example: `vscode.csharp`
 */
type ExtensionId = string;
type MarketplaceExtension = ExtensionId | {
    readonly id: ExtensionId;
    preRelease?: boolean;
    migrateStorageFrom?: ExtensionId;
};
interface ICommonTelemetryPropertiesResolver {
    (): {
        [key: string]: any;
    };
}
interface IExternalUriResolver {
    (uri: URI): Promise<URI>;
}
interface ITunnelProvider {
    /**
     * Support for creating tunnels.
     */
    tunnelFactory?: ITunnelFactory;
    /**
     * Support for filtering candidate ports.
     */
    showPortCandidate?: IShowPortCandidate;
    /**
     * The features that the tunnel provider supports.
     */
    features?: TunnelProviderFeatures;
}
interface ITunnelFactory {
    (tunnelOptions: ITunnelOptions, tunnelCreationOptions: TunnelCreationOptions): Promise<ITunnel> | undefined;
}
interface ITunnelOptions {
    remoteAddress: {
        port: number;
        host: string;
    };
    /**
     * The desired local port. If this port can't be used, then another will be chosen.
     */
    localAddressPort?: number;
    label?: string;
    privacy?: string;
    protocol?: string;
}
interface TunnelCreationOptions {
    /**
     * True when the local operating system will require elevation to use the requested local port.
     */
    elevationRequired?: boolean;
}
interface ITunnel {
    remoteAddress: {
        port: number;
        host: string;
    };
    /**
     * The complete local address(ex. localhost:1234)
     */
    localAddress: string;
    privacy?: string;
    /**
     * If protocol is not provided, it is assumed to be http, regardless of the localAddress
     */
    protocol?: string;
    /**
     * Implementers of Tunnel should fire onDidDispose when dispose is called.
     */
    onDidDispose: Event<void>;
    dispose(): Promise<void> | void;
}
interface IShowPortCandidate {
    (host: string, port: number, detail: string): Promise<boolean>;
}
declare enum Menu {
    CommandPalette = 0,
    StatusBarWindowIndicatorMenu = 1
}
interface ICommand {
    /**
     * An identifier for the command. Commands can be executed from extensions
     * using the `vscode.commands.executeCommand` API using that command ID.
     */
    id: string;
    /**
     * The optional label of the command. If provided, the command will appear
     * in the command palette.
     */
    label?: string;
    /**
     * The optional menus to append this command to. Only valid if `label` is
     * provided as well.
     * @default Menu.CommandPalette
     */
    menu?: Menu | Menu[];
    /**
     * A function that is being executed with any arguments passed over. The
     * return type will be send back to the caller.
     *
     * Note: arguments and return type should be serializable so that they can
     * be exchanged across processes boundaries.
     */
    handler: (...args: any[]) => unknown;
}
interface IHomeIndicator {
    /**
     * The link to open when clicking the home indicator.
     */
    href: string;
    /**
     * The icon name for the home indicator. This needs to be one of the existing
     * icons from our Codicon icon set. For example `code`.
     */
    icon: string;
    /**
     * A tooltip that will appear while hovering over the home indicator.
     */
    title: string;
}
interface IWelcomeBanner {
    /**
     * Welcome banner message to appear as text.
     */
    message: string;
    /**
     * Optional icon for the banner. This is either the URL to an icon to use
     * or the name of one of the existing icons from our Codicon icon set.
     *
     * If not provided a default icon will be used.
     */
    icon?: string | UriComponents;
    /**
     * Optional actions to appear as links after the welcome banner message.
     */
    actions?: IWelcomeLinkAction[];
}
interface IWelcomeLinkAction {
    /**
     * The link to open when clicking. Supports command invocation when
     * using the `command:<commandId>` value.
     */
    href: string;
    /**
     * The label to show for the action link.
     */
    label: string;
    /**
     * A tooltip that will appear while hovering over the action link.
     */
    title?: string;
}
interface IWindowIndicator {
    /**
     * Triggering this event will cause the window indicator to update.
     */
    readonly onDidChange?: Event<void>;
    /**
     * Label of the window indicator may include octicons
     * e.g. `$(remote) label`
     */
    label: string;
    /**
     * Tooltip of the window indicator should not include
     * octicons and be descriptive.
     */
    tooltip: string;
    /**
     * If provided, overrides the default command that
     * is executed when clicking on the window indicator.
     */
    command?: string;
}
declare enum ColorScheme {
    DARK = "dark",
    LIGHT = "light",
    HIGH_CONTRAST_LIGHT = "hcLight",
    HIGH_CONTRAST_DARK = "hcDark"
}
interface IInitialColorTheme {
    /**
     * Initial color theme type.
     */
    readonly themeType: ColorScheme;
    /**
     * A list of workbench colors to apply initially.
     */
    readonly colors?: {
        [colorId: string]: string;
    };
}
interface IWelcomeDialog {
    /**
     * Unique identifier of the welcome dialog. The identifier will be used to determine
     * if the dialog has been previously displayed.
     */
    id: string;
    /**
     * Title of the welcome dialog.
     */
    title: string;
    /**
     * Button text of the welcome dialog.
     */
    buttonText: string;
    /**
     * Button command to execute from the welcome dialog.
     */
    buttonCommand: string;
    /**
     * Message text for the welcome dialog.
     */
    message: string;
    /**
     * Media to include in the welcome dialog.
     */
    media: {
        altText: string;
        path: string;
    };
}
interface IDefaultView {
    /**
     * The identifier of the view to show by default.
     */
    readonly id: string;
}
interface IDefaultEditor {
    /**
     * The location of the editor in the editor grid layout.
     * Editors are layed out in editor groups and the view
     * column is counted from top left to bottom right in
     * the order of appearance beginning with `1`.
     *
     * If not provided, the editor will open in the active
     * group.
     */
    readonly viewColumn?: number;
    /**
     * The resource of the editor to open.
     */
    readonly uri: UriComponents;
    /**
     * Optional extra options like which editor
     * to use or which text to select.
     */
    readonly options?: ITextEditorOptions;
    /**
     * Will not open an untitled editor in case
     * the resource does not exist.
     */
    readonly openOnlyIfExists?: boolean;
}
interface IDefaultLayout {
    /**
     * A list of views to show by default.
     */
    readonly views?: IDefaultView[];
    /**
     * A list of editors to show by default.
     */
    readonly editors?: IDefaultEditor[];
    /**
     * The layout to use for the workbench.
     */
    readonly layout?: {
        /**
         * The layout of the editor area.
         */
        readonly editors?: EditorGroupLayout;
    };
    /**
     * Forces this layout to be applied even if this isn't
     * the first time the workspace has been opened
     */
    readonly force?: boolean;
}
interface IProductQualityChangeHandler {
    /**
     * Handler is being called when the user wants to switch between
     * `insider` or `stable` product qualities.
     */
    (newQuality: 'insider' | 'stable'): void;
}
/**
 * Settings sync options
 */
interface ISettingsSyncOptions {
    /**
     * Is settings sync enabled
     */
    readonly enabled: boolean;
    /**
     * Version of extensions sync state.
     * Extensions sync state will be reset if version is provided and different from previous version.
     */
    readonly extensionsSyncStateVersion?: string;
    /**
     * Handler is being called when the user changes Settings Sync enablement.
     */
    enablementHandler?(enablement: boolean, authenticationProvider: string): void;
    /**
     * Authentication provider
     */
    readonly authenticationProvider?: {
        /**
         * Unique identifier of the authentication provider.
         */
        readonly id: string;
        /**
         * Called when the user wants to signin to Settings Sync using the given authentication provider.
         * The returned promise should resolve to the authentication session id.
         */
        signIn(): Promise<string>;
    };
}
interface IDevelopmentOptions {
    /**
     * Current logging level. Default is `LogLevel.Info`.
     */
    readonly logLevel?: LogLevel;
    /**
     * Extension log level.
     */
    readonly extensionLogLevel?: [string, LogLevel][];
    /**
     * Location of a module containing extension tests to run once the workbench is open.
     */
    readonly extensionTestsPath?: UriComponents;
    /**
     * Add extensions under development.
     */
    readonly extensions?: readonly UriComponents[];
    /**
     * Whether to enable the smoke test driver.
     */
    readonly enableSmokeTestDriver?: boolean;
}
/**
 * Utility provided in the {@link WorkbenchOptions} which allows loading resources
 * when remote resolvers are used in the web.
 */
interface IRemoteResourceProvider {
    /**
     * Path the workbench should delegate requests to. The embedder should
     * install a service worker on this path and emit {@link onDidReceiveRequest}
     * events when requests come in for that path.
     */
    readonly path: string;
    /**
     * Event that should fire when requests are made on the {@link pathPrefix}.
     */
    readonly onDidReceiveRequest: Event<IRemoteResourceRequest>;
}
/**
 * todo@connor4312: this may eventually gain more properties like method and
 * headers, but for now we only deal with GET requests.
 */
interface IRemoteResourceRequest {
    /**
     * Request URI. Generally will begin with the current
     * origin and {@link IRemoteResourceProvider.pathPrefix}.
     */
    uri: URI;
    /**
     * A method called by the editor to issue a response to the request.
     */
    respondWith(statusCode: number, body: Uint8Array, headers: Record<string, string>): void;
}

export { ColorScheme, ExtensionId, ICommand, ICommonTelemetryPropertiesResolver, IDefaultEditor, IDefaultLayout, IDefaultView, IDevelopmentOptions, IExternalUriResolver, IHomeIndicator, IInitialColorTheme, IProductQualityChangeHandler, IRemoteResourceProvider, IRemoteResourceRequest, IResourceUriProvider, ISettingsSyncOptions, IShowPortCandidate, ITunnel, ITunnelFactory, ITunnelOptions, ITunnelProvider, IWelcomeBanner, IWelcomeDialog, IWelcomeLinkAction, IWindowIndicator, IWorkbenchConstructionOptions, MarketplaceExtension, Menu, TunnelCreationOptions };
