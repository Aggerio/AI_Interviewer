import { __decorate, __param } from '../../../../../node_modules/tslib/tslib.es6.js';
import { ContextKeyExpr, RawContextKey, IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { KeybindingsRegistry } from 'monaco-editor/esm/vs/platform/keybinding/common/keybindingsRegistry.js';
import { WorkbenchListFocusContextKey, WorkbenchListScrollAtTopContextKey, WorkbenchListScrollAtBottomContextKey } from 'monaco-editor/esm/vs/platform/list/browser/listService.js';
import { Disposable, combinedDisposable, toDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { Extensions } from '../../common/contributions.js';
function handleFocusEventsGroup(group, handler) {
    const focusedIndices = ( new Set());
    return combinedDisposable(...( group.map((events, index) => combinedDisposable(events.onDidFocus(() => {
        if (!focusedIndices.size) {
            handler(true);
        }
        focusedIndices.add(index);
    }), events.onDidBlur(() => {
        focusedIndices.delete(index);
        if (!focusedIndices.size) {
            handler(false);
        }
    })))));
}
const NavigableContainerFocusedContextKey = ( new RawContextKey('navigableContainerFocused', false));
let NavigableContainerManager = class NavigableContainerManager {
    constructor(contextKeyService) {
        this.containers = ( new Set());
        this.focused = NavigableContainerFocusedContextKey.bindTo(contextKeyService);
        NavigableContainerManager.INSTANCE = this;
    }
    dispose() {
        this.containers.clear();
        this.focused.reset();
        NavigableContainerManager.INSTANCE = undefined;
    }
    static register(container) {
        const instance = this.INSTANCE;
        if (!instance) {
            return Disposable.None;
        }
        instance.containers.add(container);
        return combinedDisposable(handleFocusEventsGroup(container.focusNotifiers, (isFocus) => {
            if (isFocus) {
                instance.focused.set(true);
                instance.lastContainer = container;
            }
            else if (instance.lastContainer === container) {
                instance.focused.set(false);
                instance.lastContainer = undefined;
            }
        }), toDisposable(() => {
            instance.containers.delete(container);
            if (instance.lastContainer === container) {
                instance.focused.set(false);
                instance.lastContainer = undefined;
            }
        }));
    }
    static getActive() {
        return this.INSTANCE?.lastContainer;
    }
};
NavigableContainerManager = ( __decorate([
    ( __param(0, IContextKeyService))
], NavigableContainerManager));
function registerNavigableContainer(container) {
    return NavigableContainerManager.register(container);
}
( Registry.as(Extensions.Workbench))
    .registerWorkbenchContribution(NavigableContainerManager, 1 );
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: 'widgetNavigation.focusPrevious',
    weight: 200 ,
    when: ( ContextKeyExpr.and(NavigableContainerFocusedContextKey, ( ContextKeyExpr.or(WorkbenchListFocusContextKey?.negate(), WorkbenchListScrollAtTopContextKey)))),
    primary: 2048  | 16 ,
    handler: () => {
        const activeContainer = NavigableContainerManager.getActive();
        activeContainer?.focusPreviousWidget();
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: 'widgetNavigation.focusNext',
    weight: 200 ,
    when: ( ContextKeyExpr.and(NavigableContainerFocusedContextKey, ( ContextKeyExpr.or(
        WorkbenchListFocusContextKey?.negate(),
        WorkbenchListScrollAtBottomContextKey
    )))),
    primary: 2048  | 18 ,
    handler: () => {
        const activeContainer = NavigableContainerManager.getActive();
        activeContainer?.focusNextWidget();
    }
});
export { registerNavigableContainer };
