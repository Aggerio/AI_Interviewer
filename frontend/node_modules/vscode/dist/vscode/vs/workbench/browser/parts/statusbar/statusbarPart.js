import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import './media/statusbarpart.css.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { MutableDisposable, dispose, DisposableStore, disposeIfDisposable, toDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { Part } from '../../part.js';
import { Gesture, EventType as EventType$1 } from 'monaco-editor/esm/vs/base/browser/touch.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { isStatusbarEntryPriority, isStatusbarEntryLocation } from '../../../services/statusbar/browser/statusbar.js';
import { IContextMenuService } from 'monaco-editor/esm/vs/platform/contextview/browser/contextView.js';
import { toAction, Separator } from 'monaco-editor/esm/vs/base/common/actions.js';
import { IThemeService } from 'monaco-editor/esm/vs/platform/theme/common/themeService.js';
import { STATUS_BAR_ITEM_HOVER_BACKGROUND, STATUS_BAR_ITEM_COMPACT_HOVER_BACKGROUND, STATUS_BAR_BACKGROUND, STATUS_BAR_NO_FOLDER_BACKGROUND, STATUS_BAR_FOREGROUND, STATUS_BAR_NO_FOLDER_FOREGROUND, STATUS_BAR_ITEM_FOCUS_BORDER, STATUS_BAR_BORDER, STATUS_BAR_NO_FOLDER_BORDER, STATUS_BAR_FOCUS_BORDER } from '../../../common/theme.js';
import { IWorkspaceContextService } from 'monaco-editor/esm/vs/platform/workspace/common/workspace.js';
import { contrastBorder, activeContrastBorder } from 'monaco-editor/esm/vs/platform/theme/common/colorRegistry.js';
import { addDisposableListener, EventType, clearNode, EventHelper, createStyleSheet } from 'monaco-editor/esm/vs/base/browser/dom.js';
import { IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
import { IWorkbenchLayoutService } from '../../../services/layout/browser/layoutService.js';
import { coalesce, equals } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { StandardMouseEvent } from 'monaco-editor/esm/vs/base/browser/mouseEvent.js';
import { ToggleStatusbarVisibilityAction } from '../../actions/layoutActions.js';
import { assertIsDefined } from 'monaco-editor/esm/vs/base/common/types.js';
import { IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { isHighContrast } from 'monaco-editor/esm/vs/platform/theme/common/theme.js';
import { hash } from 'monaco-editor/esm/vs/base/common/hash.js';
import { IHoverService } from '../../../services/hover/browser/hover.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { ToggleStatusbarEntryVisibilityAction, HideStatusbarEntryAction } from './statusbarActions.js';
import { StatusbarViewModel } from './statusbarModel.js';
import { StatusbarEntryItem } from './statusbarItem.js';
import { StatusBarFocused } from '../../../common/contextkeys.js';
let StatusbarPart = class StatusbarPart extends Part {
    constructor(instantiationService, themeService, contextService, storageService, layoutService, contextMenuService, contextKeyService, hoverService, configurationService) {
        super("workbench.parts.statusbar" , { hasTitle: false }, themeService, storageService, layoutService);
        this.instantiationService = instantiationService;
        this.contextService = contextService;
        this.storageService = storageService;
        this.contextMenuService = contextMenuService;
        this.contextKeyService = contextKeyService;
        this.hoverService = hoverService;
        this.configurationService = configurationService;
        this.minimumWidth = 0;
        this.maximumWidth = Number.POSITIVE_INFINITY;
        this.minimumHeight = 22;
        this.maximumHeight = 22;
        this.pendingEntries = [];
        this.viewModel = this._register(( new StatusbarViewModel(this.storageService)));
        this.onDidChangeEntryVisibility = this.viewModel.onDidChangeEntryVisibility;
        this.hoverDelegate = new (class {
            get delay() {
                if (Date.now() - this.lastHoverHideTime < 200) {
                    return 0;
                }
                return this.configurationService.getValue('workbench.hover.delay');
            }
            constructor(configurationService, hoverService) {
                this.configurationService = configurationService;
                this.hoverService = hoverService;
                this.lastHoverHideTime = 0;
                this.placement = 'element';
            }
            showHover(options, focus) {
                return this.hoverService.showHover({
                    ...options,
                    hideOnKeyDown: true
                }, focus);
            }
            onDidHideHover() {
                this.lastHoverHideTime = Date.now();
            }
        })(this.configurationService, this.hoverService);
        this.compactEntriesDisposable = this._register(( new MutableDisposable()));
        this.styleOverrides = ( new Set());
        this.registerListeners();
    }
    registerListeners() {
        this._register(this.onDidChangeEntryVisibility(() => this.updateCompactEntries()));
        this._register(this.contextService.onDidChangeWorkbenchState(() => this.updateStyles()));
    }
    addEntry(entry, id, alignment, priorityOrLocation = 0) {
        let priority;
        if (isStatusbarEntryPriority(priorityOrLocation)) {
            priority = priorityOrLocation;
        }
        else {
            priority = {
                primary: priorityOrLocation,
                secondary: hash(id)
            };
        }
        if (!this.element) {
            return this.doAddPendingEntry(entry, id, alignment, priority);
        }
        return this.doAddEntry(entry, id, alignment, priority);
    }
    doAddPendingEntry(entry, id, alignment, priority) {
        const pendingEntry = { entry, id, alignment, priority };
        this.pendingEntries.push(pendingEntry);
        const accessor = {
            update: (entry) => {
                if (pendingEntry.accessor) {
                    pendingEntry.accessor.update(entry);
                }
                else {
                    pendingEntry.entry = entry;
                }
            },
            dispose: () => {
                if (pendingEntry.accessor) {
                    pendingEntry.accessor.dispose();
                }
                else {
                    this.pendingEntries = this.pendingEntries.filter(entry => entry !== pendingEntry);
                }
            }
        };
        return accessor;
    }
    doAddEntry(entry, id, alignment, priority) {
        const itemContainer = this.doCreateStatusItem(id, alignment, ...coalesce([entry.showBeak ? 'has-beak' : undefined]));
        const item = this.instantiationService.createInstance(StatusbarEntryItem, itemContainer, entry, this.hoverDelegate);
        const viewModelEntry = new class {
            constructor() {
                this.id = id;
                this.alignment = alignment;
                this.priority = priority;
                this.container = itemContainer;
                this.labelContainer = item.labelContainer;
            }
            get name() { return item.name; }
            get hasCommand() { return item.hasCommand; }
        };
        const { needsFullRefresh } = this.doAddOrRemoveModelEntry(viewModelEntry, true);
        if (needsFullRefresh) {
            this.appendStatusbarEntries();
        }
        else {
            this.appendStatusbarEntry(viewModelEntry);
        }
        return {
            update: entry => {
                item.update(entry);
            },
            dispose: () => {
                const { needsFullRefresh } = this.doAddOrRemoveModelEntry(viewModelEntry, false);
                if (needsFullRefresh) {
                    this.appendStatusbarEntries();
                }
                else {
                    itemContainer.remove();
                }
                dispose(item);
            }
        };
    }
    doCreateStatusItem(id, alignment, ...extraClasses) {
        const itemContainer = document.createElement('div');
        itemContainer.id = id;
        itemContainer.classList.add('statusbar-item');
        if (extraClasses) {
            itemContainer.classList.add(...extraClasses);
        }
        if (alignment === 1 ) {
            itemContainer.classList.add('right');
        }
        else {
            itemContainer.classList.add('left');
        }
        return itemContainer;
    }
    doAddOrRemoveModelEntry(entry, add) {
        const entriesBefore = this.viewModel.entries;
        if (add) {
            this.viewModel.add(entry);
        }
        else {
            this.viewModel.remove(entry);
        }
        const entriesAfter = this.viewModel.entries;
        if (add) {
            entriesBefore.splice(entriesAfter.indexOf(entry), 0, entry);
        }
        else {
            entriesBefore.splice(entriesBefore.indexOf(entry), 1);
        }
        const needsFullRefresh = !equals(entriesBefore, entriesAfter);
        return { needsFullRefresh };
    }
    isEntryVisible(id) {
        return !this.viewModel.isHidden(id);
    }
    updateEntryVisibility(id, visible) {
        if (visible) {
            this.viewModel.show(id);
        }
        else {
            this.viewModel.hide(id);
        }
    }
    focusNextEntry() {
        this.viewModel.focusNextEntry();
    }
    focusPreviousEntry() {
        this.viewModel.focusPreviousEntry();
    }
    isEntryFocused() {
        return this.viewModel.isEntryFocused();
    }
    focus(preserveEntryFocus = true) {
        this.getContainer()?.focus();
        const lastFocusedEntry = this.viewModel.lastFocusedEntry;
        if (preserveEntryFocus && lastFocusedEntry) {
            setTimeout(() => lastFocusedEntry.labelContainer.focus(), 0);
        }
    }
    createContentArea(parent) {
        this.element = parent;
        const scopedContextKeyService = this.contextKeyService.createScoped(this.element);
        StatusBarFocused.bindTo(scopedContextKeyService).set(true);
        this.leftItemsContainer = document.createElement('div');
        this.leftItemsContainer.classList.add('left-items', 'items-container');
        this.element.appendChild(this.leftItemsContainer);
        this.element.tabIndex = 0;
        this.rightItemsContainer = document.createElement('div');
        this.rightItemsContainer.classList.add('right-items', 'items-container');
        this.element.appendChild(this.rightItemsContainer);
        this._register(addDisposableListener(parent, EventType.CONTEXT_MENU, e => this.showContextMenu(e)));
        this._register(Gesture.addTarget(parent));
        this._register(addDisposableListener(parent, EventType$1.Contextmenu, e => this.showContextMenu(e)));
        this.createInitialStatusbarEntries();
        return this.element;
    }
    createInitialStatusbarEntries() {
        this.appendStatusbarEntries();
        while (this.pendingEntries.length) {
            const pending = this.pendingEntries.shift();
            if (pending) {
                pending.accessor = this.addEntry(pending.entry, pending.id, pending.alignment, pending.priority.primary);
            }
        }
    }
    appendStatusbarEntries() {
        const leftItemsContainer = assertIsDefined(this.leftItemsContainer);
        const rightItemsContainer = assertIsDefined(this.rightItemsContainer);
        clearNode(leftItemsContainer);
        clearNode(rightItemsContainer);
        for (const entry of [
            ...this.viewModel.getEntries(0 ),
            ...this.viewModel.getEntries(1 ).reverse()
        ]) {
            const target = entry.alignment === 0  ? leftItemsContainer : rightItemsContainer;
            target.appendChild(entry.container);
        }
        this.updateCompactEntries();
    }
    appendStatusbarEntry(entry) {
        const entries = this.viewModel.getEntries(entry.alignment);
        if (entry.alignment === 1 ) {
            entries.reverse();
        }
        const target = assertIsDefined(entry.alignment === 0  ? this.leftItemsContainer : this.rightItemsContainer);
        const index = entries.indexOf(entry);
        if (index + 1 === entries.length) {
            target.appendChild(entry.container);
        }
        else {
            target.insertBefore(entry.container, entries[index + 1].container);
        }
        this.updateCompactEntries();
    }
    updateCompactEntries() {
        const entries = this.viewModel.entries;
        const mapIdToVisibleEntry = ( new Map());
        for (const entry of entries) {
            if (!this.viewModel.isHidden(entry.id)) {
                mapIdToVisibleEntry.set(entry.id, entry);
            }
            entry.container.classList.remove('compact-left', 'compact-right');
        }
        const compactEntryGroups = ( new Map());
        for (const entry of ( mapIdToVisibleEntry.values())) {
            if (isStatusbarEntryLocation(entry.priority.primary) &&
                entry.priority.primary.compact
            ) {
                const locationId = entry.priority.primary.id;
                const location = mapIdToVisibleEntry.get(locationId);
                if (!location) {
                    continue;
                }
                let compactEntryGroup = compactEntryGroups.get(locationId);
                if (!compactEntryGroup) {
                    compactEntryGroup = ( new Set([entry, location]));
                    compactEntryGroups.set(locationId, compactEntryGroup);
                }
                else {
                    compactEntryGroup.add(entry);
                }
                if (entry.priority.primary.alignment === 0 ) {
                    location.container.classList.add('compact-left');
                    entry.container.classList.add('compact-right');
                }
                else {
                    location.container.classList.add('compact-right');
                    entry.container.classList.add('compact-left');
                }
            }
        }
        const statusBarItemHoverBackground = this.getColor(STATUS_BAR_ITEM_HOVER_BACKGROUND);
        const statusBarItemCompactHoverBackground = this.getColor(STATUS_BAR_ITEM_COMPACT_HOVER_BACKGROUND);
        this.compactEntriesDisposable.value = ( new DisposableStore());
        if (statusBarItemHoverBackground && statusBarItemCompactHoverBackground && !isHighContrast(this.theme.type)) {
            for (const [, compactEntryGroup] of compactEntryGroups) {
                for (const compactEntry of compactEntryGroup) {
                    if (!compactEntry.hasCommand) {
                        continue;
                    }
                    this.compactEntriesDisposable.value.add(addDisposableListener(compactEntry.labelContainer, EventType.MOUSE_OVER, () => {
                        compactEntryGroup.forEach(compactEntry => compactEntry.labelContainer.style.backgroundColor = statusBarItemHoverBackground);
                        compactEntry.labelContainer.style.backgroundColor = statusBarItemCompactHoverBackground;
                    }));
                    this.compactEntriesDisposable.value.add(addDisposableListener(compactEntry.labelContainer, EventType.MOUSE_OUT, () => {
                        compactEntryGroup.forEach(compactEntry => compactEntry.labelContainer.style.backgroundColor = '');
                    }));
                }
            }
        }
    }
    showContextMenu(e) {
        EventHelper.stop(e, true);
        const event = ( new StandardMouseEvent(e));
        let actions = undefined;
        this.contextMenuService.showContextMenu({
            getAnchor: () => event,
            getActions: () => {
                actions = this.getContextMenuActions(event);
                return actions;
            },
            onHide: () => {
                if (actions) {
                    disposeIfDisposable(actions);
                }
            }
        });
    }
    getContextMenuActions(event) {
        const actions = [];
        actions.push(toAction({ id: ToggleStatusbarVisibilityAction.ID, label: ( localize('hideStatusBar', "Hide Status Bar")), run: () => this.instantiationService.invokeFunction(accessor => ( new ToggleStatusbarVisibilityAction()).run(accessor)) }));
        actions.push(( new Separator()));
        const handledEntries = ( new Set());
        for (const entry of this.viewModel.entries) {
            if (!( handledEntries.has(entry.id))) {
                actions.push(( new ToggleStatusbarEntryVisibilityAction(entry.id, entry.name, this.viewModel)));
                handledEntries.add(entry.id);
            }
        }
        let statusEntryUnderMouse = undefined;
        for (let element = event.target; element; element = element.parentElement) {
            const entry = this.viewModel.findEntry(element);
            if (entry) {
                statusEntryUnderMouse = entry;
                break;
            }
        }
        if (statusEntryUnderMouse) {
            actions.push(( new Separator()));
            actions.push(( new HideStatusbarEntryAction(statusEntryUnderMouse.id, statusEntryUnderMouse.name, this.viewModel)));
        }
        return actions;
    }
    updateStyles() {
        super.updateStyles();
        const container = assertIsDefined(this.getContainer());
        const styleOverride = [...this.styleOverrides].sort((a, b) => a.priority - b.priority)[0];
        const backgroundColor = this.getColor(styleOverride?.background ?? (this.contextService.getWorkbenchState() !== 1  ? STATUS_BAR_BACKGROUND : STATUS_BAR_NO_FOLDER_BACKGROUND)) || '';
        container.style.backgroundColor = backgroundColor;
        const foregroundColor = this.getColor(styleOverride?.foreground ?? (this.contextService.getWorkbenchState() !== 1  ? STATUS_BAR_FOREGROUND : STATUS_BAR_NO_FOLDER_FOREGROUND)) || '';
        container.style.color = foregroundColor;
        const itemBorderColor = this.getColor(STATUS_BAR_ITEM_FOCUS_BORDER);
        const borderColor = this.getColor(styleOverride?.border ?? (this.contextService.getWorkbenchState() !== 1  ? STATUS_BAR_BORDER : STATUS_BAR_NO_FOLDER_BORDER)) || this.getColor(contrastBorder);
        if (borderColor) {
            container.classList.add('status-border-top');
            container.style.setProperty('--status-border-top-color', borderColor);
        }
        else {
            container.classList.remove('status-border-top');
            container.style.removeProperty('--status-border-top-color');
        }
        const statusBarFocusColor = this.getColor(STATUS_BAR_FOCUS_BORDER);
        if (!this.styleElement) {
            this.styleElement = createStyleSheet(container);
        }
        this.styleElement.textContent = `

				/* Status bar focus outline */
				.monaco-workbench .part.statusbar:focus {
					outline-color: ${statusBarFocusColor};
				}

				/* Status bar item focus outline */
				.monaco-workbench .part.statusbar > .items-container > .statusbar-item a:focus-visible:not(.disabled) {
					outline: 1px solid ${this.getColor(activeContrastBorder) ?? itemBorderColor};
					outline-offset: ${borderColor ? '-2px' : '-1px'};
				}

				/* Notification Beak */
				.monaco-workbench .part.statusbar > .items-container > .statusbar-item.has-beak > .status-bar-item-beak-container:before {
					border-bottom-color: ${backgroundColor};
				}
			`;
    }
    layout(width, height, top, left) {
        super.layout(width, height, top, left);
        super.layoutContents(width, height);
    }
    overrideStyle(style) {
        this.styleOverrides.add(style);
        this.updateStyles();
        return toDisposable(() => {
            this.styleOverrides.delete(style);
            this.updateStyles();
        });
    }
    toJSON() {
        return {
            type: "workbench.parts.statusbar"
        };
    }
};
StatusbarPart = ( __decorate([
    ( __param(0, IInstantiationService)),
    ( __param(1, IThemeService)),
    ( __param(2, IWorkspaceContextService)),
    ( __param(3, IStorageService)),
    ( __param(4, IWorkbenchLayoutService)),
    ( __param(5, IContextMenuService)),
    ( __param(6, IContextKeyService)),
    ( __param(7, IHoverService)),
    ( __param(8, IConfigurationService))
], StatusbarPart));
export { StatusbarPart };
