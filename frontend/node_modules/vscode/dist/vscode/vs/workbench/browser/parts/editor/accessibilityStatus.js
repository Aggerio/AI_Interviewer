import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import { Disposable, MutableDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { Event } from 'monaco-editor/esm/vs/base/common/event.js';
import Severity from 'monaco-editor/esm/vs/base/common/severity.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { IAccessibilityService } from 'monaco-editor/esm/vs/platform/accessibility/common/accessibility.js';
import { CommandsRegistry } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { NotificationPriority, INotificationService } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { IStatusbarService } from '../../../services/statusbar/browser/statusbar.js';
import { themeColorFromId } from 'monaco-editor/esm/vs/platform/theme/common/themeService.js';
import { STATUS_BAR_PROMINENT_ITEM_BACKGROUND, STATUS_BAR_PROMINENT_ITEM_FOREGROUND } from '../../../common/theme.js';
let AccessibilityStatus = class AccessibilityStatus extends Disposable {
    constructor(configurationService, notificationService, _accessibilityService, statusbarService) {
        super();
        this.configurationService = configurationService;
        this.notificationService = notificationService;
        this._accessibilityService = _accessibilityService;
        this.statusbarService = statusbarService;
        this.screenReaderNotification = null;
        this.promptedScreenReader = false;
        this.screenReaderModeElement = this._register(( new MutableDisposable()));
        this._register(this._accessibilityService.onDidChangeScreenReaderOptimized(() => this.onScreenReaderModeChange()));
        this._register(configurationService.onDidChangeConfiguration(c => {
            if (c.affectsConfiguration('editor.accessibilitySupport')) {
                this.onScreenReaderModeChange();
            }
        }));
        CommandsRegistry.registerCommand({ id: 'showEditorScreenReaderNotification', handler: () => this.showScreenReaderNotification() });
        this.updateScreenReaderModeElement(this._accessibilityService.isScreenReaderOptimized());
    }
    showScreenReaderNotification() {
        if (!this.screenReaderNotification) {
            this.screenReaderNotification = this.notificationService.prompt(Severity.Info, ( localize(
                'screenReaderDetectedExplanation.question',
                "Are you using a screen reader to operate VS Code?"
            )), [{
                    label: ( localize('screenReaderDetectedExplanation.answerYes', "Yes")),
                    run: () => {
                        this.configurationService.updateValue('editor.accessibilitySupport', 'on', 2 );
                    }
                }, {
                    label: ( localize('screenReaderDetectedExplanation.answerNo', "No")),
                    run: () => {
                        this.configurationService.updateValue('editor.accessibilitySupport', 'off', 2 );
                    }
                }], {
                sticky: true,
                priority: NotificationPriority.URGENT
            });
            Event.once(this.screenReaderNotification.onDidClose)(() => this.screenReaderNotification = null);
        }
    }
    updateScreenReaderModeElement(visible) {
        if (visible) {
            if (!this.screenReaderModeElement.value) {
                const text = ( localize('screenReaderDetected', "Screen Reader Optimized"));
                this.screenReaderModeElement.value = this.statusbarService.addEntry({
                    name: ( localize('status.editor.screenReaderMode', "Screen Reader Mode")),
                    text,
                    ariaLabel: text,
                    command: 'showEditorScreenReaderNotification',
                    backgroundColor: themeColorFromId(STATUS_BAR_PROMINENT_ITEM_BACKGROUND),
                    color: themeColorFromId(STATUS_BAR_PROMINENT_ITEM_FOREGROUND)
                }, 'status.editor.screenReaderMode', 1 , 100.6);
            }
        }
        else {
            this.screenReaderModeElement.clear();
        }
    }
    onScreenReaderModeChange() {
        const screenReaderDetected = this._accessibilityService.isScreenReaderOptimized();
        if (screenReaderDetected) {
            const screenReaderConfiguration = this.configurationService.getValue('editor.accessibilitySupport');
            if (screenReaderConfiguration === 'auto') {
                if (!this.promptedScreenReader) {
                    this.promptedScreenReader = true;
                    setTimeout(() => this.showScreenReaderNotification(), 100);
                }
            }
        }
        if (this.screenReaderNotification) {
            this.screenReaderNotification.close();
        }
        this.updateScreenReaderModeElement(this._accessibilityService.isScreenReaderOptimized());
    }
};
AccessibilityStatus = ( __decorate([
    ( __param(0, IConfigurationService)),
    ( __param(1, INotificationService)),
    ( __param(2, IAccessibilityService)),
    ( __param(3, IStatusbarService))
], AccessibilityStatus));
export { AccessibilityStatus };
