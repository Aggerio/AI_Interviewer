import './media/compositepart.css.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { defaultGenerator } from 'monaco-editor/esm/vs/base/common/idGenerator.js';
import { MutableDisposable, dispose, DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { isCancellationError } from 'monaco-editor/esm/vs/base/common/errors.js';
import { prepareActions } from 'monaco-editor/esm/vs/base/browser/ui/actionbar/actionbar.js';
import { ProgressBar } from 'monaco-editor/esm/vs/base/browser/ui/progressbar/progressbar.js';
import { Part } from '../part.js';
import { ServiceCollection } from 'monaco-editor/esm/vs/platform/instantiation/common/serviceCollection.js';
import { IEditorProgressService } from 'monaco-editor/esm/vs/platform/progress/common/progress.js';
import { $, show, hide, append, Dimension } from 'monaco-editor/esm/vs/base/browser/dom.js';
import { assertIsDefined, withNullAsUndefined } from 'monaco-editor/esm/vs/base/common/types.js';
import { createActionViewItem } from 'monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.js';
import { ScopedProgressIndicator, AbstractProgressScope } from '../../services/progress/browser/progressIndicator.js';
import { WorkbenchToolBar } from 'monaco-editor/esm/vs/platform/actions/browser/toolbar.js';
import { defaultProgressBarStyles } from 'monaco-editor/esm/vs/platform/theme/browser/defaultStyles.js';
class CompositePart extends Part {
    constructor(notificationService, storageService, contextMenuService, layoutService, keybindingService, instantiationService, themeService, registry, activeCompositeSettingsKey, defaultCompositeId, nameForTelemetry, compositeCSSClass, titleForegroundColor, id, options) {
        super(id, options, themeService, storageService, layoutService);
        this.notificationService = notificationService;
        this.storageService = storageService;
        this.contextMenuService = contextMenuService;
        this.keybindingService = keybindingService;
        this.instantiationService = instantiationService;
        this.registry = registry;
        this.activeCompositeSettingsKey = activeCompositeSettingsKey;
        this.defaultCompositeId = defaultCompositeId;
        this.nameForTelemetry = nameForTelemetry;
        this.compositeCSSClass = compositeCSSClass;
        this.titleForegroundColor = titleForegroundColor;
        this.onDidCompositeOpen = this._register(( new Emitter()));
        this.onDidCompositeClose = this._register(( new Emitter()));
        this.mapCompositeToCompositeContainer = ( new Map());
        this.mapActionsBindingToComposite = ( new Map());
        this.instantiatedCompositeItems = ( new Map());
        this.actionsListener = this._register(( new MutableDisposable()));
        this.lastActiveCompositeId = storageService.get(activeCompositeSettingsKey, 1 , this.defaultCompositeId);
    }
    openComposite(id, focus) {
        if (this.activeComposite?.getId() === id) {
            if (focus) {
                this.activeComposite.focus();
            }
            return this.activeComposite;
        }
        if (!this.element) {
            return;
        }
        return this.doOpenComposite(id, focus);
    }
    doOpenComposite(id, focus = false) {
        const currentCompositeOpenToken = defaultGenerator.nextId();
        this.currentCompositeOpenToken = currentCompositeOpenToken;
        if (this.activeComposite) {
            this.hideActiveComposite();
        }
        this.updateTitle(id);
        const composite = this.createComposite(id, true);
        if ((this.currentCompositeOpenToken !== currentCompositeOpenToken) || (this.activeComposite && this.activeComposite.getId() !== composite.getId())) {
            return undefined;
        }
        if (this.activeComposite?.getId() === composite.getId()) {
            if (focus) {
                composite.focus();
            }
            this.onDidCompositeOpen.fire({ composite, focus });
            return composite;
        }
        this.showComposite(composite);
        if (focus) {
            composite.focus();
        }
        if (composite) {
            this.onDidCompositeOpen.fire({ composite, focus });
        }
        return composite;
    }
    createComposite(id, isActive) {
        const compositeItem = this.instantiatedCompositeItems.get(id);
        if (compositeItem) {
            return compositeItem.composite;
        }
        const compositeDescriptor = this.registry.getComposite(id);
        if (compositeDescriptor) {
            const that = this;
            const compositeProgressIndicator = ( new ScopedProgressIndicator(
                assertIsDefined(this.progressBar),
                new (class extends AbstractProgressScope {
                    constructor() {
                        super(compositeDescriptor.id, !!isActive);
                        this._register(that.onDidCompositeOpen.event(e => this.onScopeOpened(e.composite.getId())));
                        this._register(that.onDidCompositeClose.event(e => this.onScopeClosed(e.getId())));
                    }
                })()
            ));
            const compositeInstantiationService = this.instantiationService.createChild(( new ServiceCollection(
                [IEditorProgressService, compositeProgressIndicator]
            )));
            const composite = compositeDescriptor.instantiate(compositeInstantiationService);
            const disposable = ( new DisposableStore());
            this.instantiatedCompositeItems.set(id, { composite, disposable, progress: compositeProgressIndicator });
            disposable.add(composite.onTitleAreaUpdate(() => this.onTitleAreaUpdate(composite.getId()), this));
            return composite;
        }
        throw new Error(`Unable to find composite with id ${id}`);
    }
    showComposite(composite) {
        this.activeComposite = composite;
        const id = this.activeComposite.getId();
        if (id !== this.defaultCompositeId) {
            this.storageService.store(this.activeCompositeSettingsKey, id, 1 , 1 );
        }
        else {
            this.storageService.remove(this.activeCompositeSettingsKey, 1 );
        }
        this.lastActiveCompositeId = this.activeComposite.getId();
        let compositeContainer = this.mapCompositeToCompositeContainer.get(composite.getId());
        if (!compositeContainer) {
            compositeContainer = $('.composite');
            compositeContainer.classList.add(...this.compositeCSSClass.split(' '));
            compositeContainer.id = composite.getId();
            composite.create(compositeContainer);
            composite.updateStyles();
            this.mapCompositeToCompositeContainer.set(composite.getId(), compositeContainer);
        }
        if (!this.activeComposite || composite.getId() !== this.activeComposite.getId()) {
            return undefined;
        }
        const contentArea = this.getContentArea();
        contentArea?.appendChild(compositeContainer);
        show(compositeContainer);
        const toolBar = assertIsDefined(this.toolBar);
        toolBar.actionRunner = composite.getActionRunner();
        const descriptor = this.registry.getComposite(composite.getId());
        if (descriptor && descriptor.name !== composite.getTitle()) {
            this.updateTitle(composite.getId(), composite.getTitle());
        }
        let actionsBinding = this.mapActionsBindingToComposite.get(composite.getId());
        if (!actionsBinding) {
            actionsBinding = this.collectCompositeActions(composite);
            this.mapActionsBindingToComposite.set(composite.getId(), actionsBinding);
        }
        actionsBinding();
        this.actionsListener.value = toolBar.actionRunner.onDidRun(e => {
            if (e.error && !isCancellationError(e.error)) {
                this.notificationService.error(e.error);
            }
        });
        composite.setVisible(true);
        if (!this.activeComposite || composite.getId() !== this.activeComposite.getId()) {
            return;
        }
        if (this.contentAreaSize) {
            composite.layout(this.contentAreaSize);
        }
        if (this.boundarySashes) {
            composite.setBoundarySashes(this.boundarySashes);
        }
    }
    onTitleAreaUpdate(compositeId) {
        const composite = this.instantiatedCompositeItems.get(compositeId);
        if (composite) {
            this.updateTitle(compositeId, composite.composite.getTitle());
        }
        if (this.activeComposite?.getId() === compositeId) {
            const actionsBinding = this.collectCompositeActions(this.activeComposite);
            this.mapActionsBindingToComposite.set(this.activeComposite.getId(), actionsBinding);
            actionsBinding();
        }
        else {
            this.mapActionsBindingToComposite.delete(compositeId);
        }
    }
    updateTitle(compositeId, compositeTitle) {
        const compositeDescriptor = this.registry.getComposite(compositeId);
        if (!compositeDescriptor || !this.titleLabel) {
            return;
        }
        if (!compositeTitle) {
            compositeTitle = compositeDescriptor.name;
        }
        const keybinding = this.keybindingService.lookupKeybinding(compositeId);
        this.titleLabel.updateTitle(compositeId, compositeTitle, withNullAsUndefined(keybinding?.getLabel()));
        const toolBar = assertIsDefined(this.toolBar);
        toolBar.setAriaLabel(( localize('ariaCompositeToolbarLabel', "{0} actions", compositeTitle)));
    }
    collectCompositeActions(composite) {
        const menuIds = composite?.getMenuIds();
        const primaryActions = composite?.getActions().slice(0) || [];
        const secondaryActions = composite?.getSecondaryActions().slice(0) || [];
        const toolBar = assertIsDefined(this.toolBar);
        toolBar.context = this.actionsContextProvider();
        return () => toolBar.setActions(prepareActions(primaryActions), prepareActions(secondaryActions), menuIds);
    }
    getActiveComposite() {
        return this.activeComposite;
    }
    getLastActiveCompositeId() {
        return this.lastActiveCompositeId;
    }
    hideActiveComposite() {
        if (!this.activeComposite) {
            return undefined;
        }
        const composite = this.activeComposite;
        this.activeComposite = undefined;
        const compositeContainer = this.mapCompositeToCompositeContainer.get(composite.getId());
        composite.setVisible(false);
        if (compositeContainer) {
            compositeContainer.remove();
            hide(compositeContainer);
        }
        this.progressBar?.stop().hide();
        if (this.toolBar) {
            this.collectCompositeActions()();
        }
        this.onDidCompositeClose.fire(composite);
        return composite;
    }
    createTitleArea(parent) {
        const titleArea = append(parent, $('.composite'));
        titleArea.classList.add('title');
        this.titleLabel = this.createTitleLabel(titleArea);
        const titleActionsContainer = append(titleArea, $('.title-actions'));
        this.toolBar = this._register(this.instantiationService.createInstance(WorkbenchToolBar, titleActionsContainer, {
            actionViewItemProvider: action => this.actionViewItemProvider(action),
            orientation: 0 ,
            getKeyBinding: action => this.keybindingService.lookupKeybinding(action.id),
            anchorAlignmentProvider: () => this.getTitleAreaDropDownAnchorAlignment(),
            toggleMenuTitle: ( localize('viewsAndMoreActions', "Views and More Actions...")),
            telemetrySource: this.nameForTelemetry
        }));
        this.collectCompositeActions()();
        return titleArea;
    }
    createTitleLabel(parent) {
        const titleContainer = append(parent, $('.title-label'));
        const titleLabel = append(titleContainer, $('h2'));
        this.titleLabelElement = titleLabel;
        const $this = this;
        return {
            updateTitle: (id, title, keybinding) => {
                if (!this.activeComposite || this.activeComposite.getId() === id) {
                    titleLabel.innerText = title;
                    titleLabel.title = keybinding ? ( localize('titleTooltip', "{0} ({1})", title, keybinding)) : title;
                }
            },
            updateStyles: () => {
                titleLabel.style.color = $this.titleForegroundColor ? $this.getColor($this.titleForegroundColor) || '' : '';
            }
        };
    }
    updateStyles() {
        super.updateStyles();
        const titleLabel = assertIsDefined(this.titleLabel);
        titleLabel.updateStyles();
    }
    actionViewItemProvider(action) {
        if (this.activeComposite) {
            return this.activeComposite.getActionViewItem(action);
        }
        return createActionViewItem(this.instantiationService, action);
    }
    actionsContextProvider() {
        if (this.activeComposite) {
            return this.activeComposite.getActionsContext();
        }
        return null;
    }
    createContentArea(parent) {
        const contentContainer = append(parent, $('.content'));
        this.progressBar = this._register(( new ProgressBar(contentContainer, defaultProgressBarStyles)));
        this.progressBar.hide();
        return contentContainer;
    }
    getProgressIndicator(id) {
        const compositeItem = this.instantiatedCompositeItems.get(id);
        return compositeItem ? compositeItem.progress : undefined;
    }
    getTitleAreaDropDownAnchorAlignment() {
        return 1 ;
    }
    layout(width, height, top, left) {
        super.layout(width, height, top, left);
        this.contentAreaSize = Dimension.lift(super.layoutContents(width, height).contentSize);
        this.activeComposite?.layout(this.contentAreaSize);
    }
    setBoundarySashes(sashes) {
        this.boundarySashes = sashes;
        this.activeComposite?.setBoundarySashes(sashes);
    }
    removeComposite(compositeId) {
        if (this.activeComposite?.getId() === compositeId) {
            return false;
        }
        this.mapCompositeToCompositeContainer.delete(compositeId);
        this.mapActionsBindingToComposite.delete(compositeId);
        const compositeItem = this.instantiatedCompositeItems.get(compositeId);
        if (compositeItem) {
            compositeItem.composite.dispose();
            dispose(compositeItem.disposable);
            this.instantiatedCompositeItems.delete(compositeId);
        }
        return true;
    }
    dispose() {
        this.mapCompositeToCompositeContainer.clear();
        this.mapActionsBindingToComposite.clear();
        this.instantiatedCompositeItems.forEach(compositeItem => {
            compositeItem.composite.dispose();
            dispose(compositeItem.disposable);
        });
        this.instantiatedCompositeItems.clear();
        super.dispose();
    }
}
export { CompositePart };
