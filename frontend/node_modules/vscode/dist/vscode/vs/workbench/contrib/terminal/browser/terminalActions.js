import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import { BrowserFeatures } from 'monaco-editor/esm/vs/base/browser/canIUse.js';
import { Action } from 'monaco-editor/esm/vs/base/common/actions.js';
import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { KeyChord } from 'monaco-editor/esm/vs/base/common/keyCodes.js';
import { Schemas } from 'monaco-editor/esm/vs/base/common/network.js';
import { isLinux, isWindows } from 'monaco-editor/esm/vs/base/common/platform.js';
import { isObject, isString, withNullAsUndefined } from 'monaco-editor/esm/vs/base/common/types.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { ICodeEditorService } from 'monaco-editor/esm/vs/editor/browser/services/codeEditorService.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { CONTEXT_ACCESSIBILITY_MODE_ENABLED } from 'monaco-editor/esm/vs/platform/accessibility/common/accessibility.js';
import { registerAction2, Action2 } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { ICommandService } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { ContextKeyExpr } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { ILabelService } from 'monaco-editor/esm/vs/platform/label/common/label.js';
import { IListService } from 'monaco-editor/esm/vs/platform/list/browser/listService.js';
import { INotificationService, Severity } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { IOpenerService } from 'monaco-editor/esm/vs/platform/opener/common/opener.js';
import { IQuickInputService } from 'monaco-editor/esm/vs/platform/quickinput/common/quickInput.js';
import { TerminalLocation, TerminalExitReason } from '../../../../platform/terminal/common/terminal.js';
import { IWorkspaceContextService } from 'monaco-editor/esm/vs/platform/workspace/common/workspace.js';
import { PICK_WORKSPACE_FOLDER_COMMAND_ID } from '../../../browser/actions/workspaceCommands.js';
import { CLOSE_EDITOR_COMMAND_ID } from '../../../browser/parts/editor/editorCommands.js';
import { ResourceContextKey } from '../../../common/contextkeys.js';
import { ITerminalService, ITerminalGroupService, ITerminalInstanceService, ITerminalEditorService } from './terminal.js';
import { TerminalQuickAccessProvider } from './terminalQuickAccess.js';
import { ITerminalProfileService, ITerminalProfileResolverService } from '../common/terminal.js';
import { TerminalContextKeys } from '../common/terminalContextKey.js';
import { createProfileSchemaEnums } from '../../../../platform/terminal/common/terminalProfiles.js';
import { terminalStrings } from '../common/terminalStrings.js';
import { IConfigurationResolverService } from '../../../services/configurationResolver/common/configurationResolver.js';
import { IWorkbenchEnvironmentService } from '../../../services/environment/common/environmentService.js';
import { IHistoryService } from '../../../services/history/common/history.js';
import { IPreferencesService } from '../../../services/preferences/common/preferences.js';
import { IRemoteAgentService } from '../../../services/remote/common/remoteAgentService.js';
import { SIDE_GROUP } from '../../../services/editor/common/editorService.js';
import { isAbsolute } from 'monaco-editor/esm/vs/base/common/path.js';
import { AbstractVariableResolverService } from '../../../services/configurationResolver/common/variableResolver.js';
import { IThemeService } from 'monaco-editor/esm/vs/platform/theme/common/themeService.js';
import { getIconId, getColorClass, getUriClasses } from './terminalIcon.js';
import { getCommandHistory, clearShellFileHistory } from '../common/history.js';
import { IModelService } from 'monaco-editor/esm/vs/editor/common/services/model.js';
import { ILanguageService } from 'monaco-editor/esm/vs/editor/common/languages/language.js';
import { CancellationToken } from 'monaco-editor/esm/vs/base/common/cancellation.js';
import { dirname } from 'monaco-editor/esm/vs/base/common/resources.js';
import { getIconClasses } from 'monaco-editor/esm/vs/editor/common/services/getIconClasses.js';
import { FileKind } from 'monaco-editor/esm/vs/platform/files/common/files.js';
import { IClipboardService } from 'monaco-editor/esm/vs/platform/clipboard/common/clipboardService.js';
import { newTerminalIcon, killTerminalIcon } from './terminalIcons.js';
import { IEditorGroupsService } from '../../../services/editor/common/editorGroupsService.js';
import { Iterable } from 'monaco-editor/esm/vs/base/common/iterator.js';
const switchTerminalActionViewItemSeparator = '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500';
const switchTerminalShowTabsTitle = ( localize('showTerminalTabs', "Show Tabs"));
const category = terminalStrings.actionCategory;
async function getCwdForSplit(configHelper, instance, folders, commandService) {
    switch (configHelper.config.splitCwd) {
        case 'workspaceRoot':
            if (folders !== undefined && commandService !== undefined) {
                if (folders.length === 1) {
                    return folders[0].uri;
                }
                else if (folders.length > 1) {
                    const options = {
                        placeHolder: ( localize(
                            'workbench.action.terminal.newWorkspacePlaceholder',
                            "Select current working directory for new terminal"
                        ))
                    };
                    const workspace = await commandService.executeCommand(PICK_WORKSPACE_FOLDER_COMMAND_ID, [options]);
                    if (!workspace) {
                        return undefined;
                    }
                    return Promise.resolve(workspace.uri);
                }
            }
            return '';
        case 'initial':
            return instance.getInitialCwd();
        case 'inherited':
            return instance.getCwd();
    }
}
const terminalSendSequenceCommand = async (accessor, args) => {
    const instance = accessor.get(ITerminalService).activeInstance;
    if (instance) {
        const text = isObject(args) && 'text' in args ? toOptionalString(args.text) : undefined;
        if (!text) {
            return;
        }
        const configurationResolverService = accessor.get(IConfigurationResolverService);
        const workspaceContextService = accessor.get(IWorkspaceContextService);
        const historyService = accessor.get(IHistoryService);
        const activeWorkspaceRootUri = historyService.getLastActiveWorkspaceRoot(instance.isRemote ? Schemas.vscodeRemote : Schemas.file);
        const lastActiveWorkspaceRoot = activeWorkspaceRootUri ? withNullAsUndefined(workspaceContextService.getWorkspaceFolder(activeWorkspaceRootUri)) : undefined;
        const resolvedText = await configurationResolverService.resolveAsync(lastActiveWorkspaceRoot, text);
        instance.sendText(resolvedText, false);
    }
};
let TerminalLaunchHelpAction = class TerminalLaunchHelpAction extends Action {
    constructor(_openerService) {
        super('workbench.action.terminal.launchHelp', ( localize('terminalLaunchHelp', "Open Help")));
        this._openerService = _openerService;
    }
    async run() {
        this._openerService.open('https://aka.ms/vscode-troubleshoot-terminal-launch');
    }
};
TerminalLaunchHelpAction = ( __decorate([
    ( __param(0, IOpenerService))
], TerminalLaunchHelpAction));
function registerTerminalAction(options) {
    options.f1 = options.f1 ?? true;
    options.category = options.category ?? category;
    options.precondition = options.precondition ?? TerminalContextKeys.processSupported;
    const runFunc = options.run;
    const strictOptions = options;
    delete strictOptions['run'];
    return registerAction2(class extends Action2 {
        constructor() {
            super(strictOptions);
        }
        run(accessor, args) {
            return runFunc(getTerminalServices(accessor), accessor, args);
        }
    });
}
function registerActiveInstanceAction(options) {
    const originalRun = options.run;
    return registerTerminalAction({
        ...options,
        run: (c, accessor, args) => {
            const activeInstance = c.service.activeInstance;
            if (activeInstance) {
                return originalRun(activeInstance, c, accessor, args);
            }
        }
    });
}
function registerActiveXtermAction(options) {
    const originalRun = options.run;
    return registerTerminalAction({
        ...options,
        run: (c, accessor, args) => {
            const activeDetached = Iterable.find(c.service.detachedXterms, d => d.isFocused);
            if (activeDetached) {
                return originalRun(activeDetached, accessor, undefined, args);
            }
            const activeInstance = c.service.activeInstance;
            if (activeInstance?.xterm) {
                return originalRun(activeInstance.xterm, accessor, activeInstance, args);
            }
        }
    });
}
function getTerminalServices(accessor) {
    return {
        service: accessor.get(ITerminalService),
        groupService: accessor.get(ITerminalGroupService),
        instanceService: accessor.get(ITerminalInstanceService),
        editorService: accessor.get(ITerminalEditorService),
        profileService: accessor.get(ITerminalProfileService),
        profileResolverService: accessor.get(ITerminalProfileResolverService)
    };
}
function registerTerminalActions() {
    registerTerminalAction({
        id: "workbench.action.terminal.newInActiveWorkspace" ,
        title: { value: ( localize(
            'workbench.action.terminal.newInActiveWorkspace',
            "Create New Terminal (In Active Workspace)"
        )), original: 'Create New Terminal (In Active Workspace)' },
        run: async (c) => {
            if (c.service.isProcessSupportRegistered) {
                const instance = await c.service.createTerminal({ location: c.service.defaultLocation });
                if (!instance) {
                    return;
                }
                c.service.setActiveInstance(instance);
            }
            await c.groupService.showPanel(true);
        }
    });
    refreshTerminalActions([]);
    registerTerminalAction({
        id: "workbench.action.createTerminalEditor" ,
        title: { value: ( localize(
            'workbench.action.terminal.createTerminalEditor',
            "Create New Terminal in Editor Area"
        )), original: 'Create New Terminal in Editor Area' },
        run: async (c, _, args) => {
            const options = (isObject(args) && 'location' in args) ? args : { location: TerminalLocation.Editor };
            const instance = await c.service.createTerminal(options);
            instance.focusWhenReady();
        }
    });
    registerTerminalAction({
        id: "workbench.action.createTerminalEditorSameGroup" ,
        title: { value: ( localize(
            'workbench.action.terminal.createTerminalEditor',
            "Create New Terminal in Editor Area"
        )), original: 'Create New Terminal in Editor Area' },
        f1: false,
        run: async (c, accessor, args) => {
            const editorGroupsService = accessor.get(IEditorGroupsService);
            const instance = await c.service.createTerminal({
                location: { viewColumn: editorGroupsService.activeGroup.index }
            });
            instance.focusWhenReady();
        }
    });
    registerTerminalAction({
        id: "workbench.action.createTerminalEditorSide" ,
        title: { value: ( localize(
            'workbench.action.terminal.createTerminalEditorSide',
            "Create New Terminal in Editor Area to the Side"
        )), original: 'Create New Terminal in Editor Area to the Side' },
        run: async (c) => {
            const instance = await c.service.createTerminal({
                location: { viewColumn: SIDE_GROUP }
            });
            instance.focusWhenReady();
        }
    });
    registerActiveInstanceAction({
        id: "workbench.action.terminal.moveToEditor" ,
        title: terminalStrings.moveToEditor,
        precondition: ( ContextKeyExpr.and(( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )), ( TerminalContextKeys.terminalEditorActive.toNegated()), TerminalContextKeys.viewShowing)),
        run: (activeInstance, c) => c.service.moveToEditor(activeInstance)
    });
    registerTerminalAction({
        id: "workbench.action.terminal.moveToEditorInstance" ,
        title: terminalStrings.moveToEditor,
        f1: false,
        precondition: ( ContextKeyExpr.and(( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )), TerminalContextKeys.isOpen)),
        run: async (c, accessor) => {
            const selectedInstances = getSelectedInstances(accessor);
            if (!selectedInstances || selectedInstances.length === 0) {
                return;
            }
            for (const instance of selectedInstances) {
                c.service.moveToEditor(instance);
            }
            selectedInstances[selectedInstances.length - 1].focus();
        }
    });
    registerTerminalAction({
        id: "workbench.action.terminal.moveToTerminalPanel" ,
        title: terminalStrings.moveToTerminalPanel,
        precondition: ( ContextKeyExpr.and(( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )), TerminalContextKeys.terminalEditorActive)),
        run: (c, _, args) => {
            const source = toOptionalUri(args) ?? c.editorService.activeInstance;
            if (source) {
                c.service.moveToTerminalView(source);
            }
        }
    });
    registerTerminalAction({
        id: "workbench.action.terminal.showTabs" ,
        title: { value: ( localize('workbench.action.terminal.showTabs', "Show Tabs")), original: 'Show Tabs' },
        f1: false,
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (c) => c.groupService.showTabs()
    });
    registerTerminalAction({
        id: "workbench.action.terminal.focusPreviousPane" ,
        title: { value: ( localize(
            'workbench.action.terminal.focusPreviousPane',
            "Focus Previous Terminal in Terminal Group"
        )), original: 'Focus Previous Terminal in Terminal Group' },
        keybinding: {
            primary: 512  | 15 ,
            secondary: [512  | 16 ],
            mac: {
                primary: 512  | 2048  | 15 ,
                secondary: [512  | 2048  | 16 ]
            },
            when: TerminalContextKeys.focus,
            weight: 200
        },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: async (c) => {
            c.groupService.activeGroup?.focusPreviousPane();
            await c.groupService.showPanel(true);
        }
    });
    registerTerminalAction({
        id: "workbench.action.terminal.focusNextPane" ,
        title: { value: ( localize(
            'workbench.action.terminal.focusNextPane',
            "Focus Next Terminal in Terminal Group"
        )), original: 'Focus Next Terminal in Terminal Group' },
        keybinding: {
            primary: 512  | 17 ,
            secondary: [512  | 18 ],
            mac: {
                primary: 512  | 2048  | 17 ,
                secondary: [512  | 2048  | 18 ]
            },
            when: TerminalContextKeys.focus,
            weight: 200
        },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: async (c) => {
            c.groupService.activeGroup?.focusNextPane();
            await c.groupService.showPanel(true);
        }
    });
    registerActiveInstanceAction({
        id: "workbench.action.terminal.runRecentCommand" ,
        title: { value: ( localize('workbench.action.terminal.runRecentCommand', "Run Recent Command...")), original: 'Run Recent Command...' },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        keybinding: [
            {
                primary: 2048  | 48 ,
                mac: { primary: 256  | 48  },
                when: ( ContextKeyExpr.and(TerminalContextKeys.focus, CONTEXT_ACCESSIBILITY_MODE_ENABLED)),
                weight: 200
            },
            {
                primary: 2048  | 512  | 48 ,
                mac: { primary: 256  | 512  | 48  },
                when: ( ContextKeyExpr.and(TerminalContextKeys.focus, ( CONTEXT_ACCESSIBILITY_MODE_ENABLED.negate()))),
                weight: 200
            }
        ],
        run: async (activeInstance, c) => {
            await activeInstance.runRecent('command');
            if (activeInstance?.target === TerminalLocation.Editor) {
                await c.editorService.revealActiveEditor();
            }
            else {
                await c.groupService.showPanel(false);
            }
        }
    });
    registerActiveInstanceAction({
        id: "workbench.action.terminal.copyLastCommandOutput" ,
        title: { value: ( localize('workbench.action.terminal.copyLastCommand', 'Copy Last Command Output')), original: 'Copy Last Command Output' },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: async (instance, c, accessor) => {
            const clipboardService = accessor.get(IClipboardService);
            const commands = instance.capabilities.get(2 )?.commands;
            if (!commands || commands.length === 0) {
                return;
            }
            const command = commands[commands.length - 1];
            if (!command?.hasOutput()) {
                return;
            }
            const output = command.getOutput();
            if (isString(output)) {
                await clipboardService.writeText(output);
            }
        }
    });
    registerActiveInstanceAction({
        id: "workbench.action.terminal.goToRecentDirectory" ,
        title: { value: ( localize(
            'workbench.action.terminal.goToRecentDirectory',
            "Go to Recent Directory..."
        )), original: 'Go to Recent Directory...' },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        keybinding: {
            primary: 2048  | 37 ,
            when: TerminalContextKeys.focus,
            weight: 200
        },
        run: async (activeInstance, c) => {
            await activeInstance.runRecent('cwd');
            if (activeInstance?.target === TerminalLocation.Editor) {
                await c.editorService.revealActiveEditor();
            }
            else {
                await c.groupService.showPanel(false);
            }
        }
    });
    registerTerminalAction({
        id: "workbench.action.terminal.resizePaneLeft" ,
        title: { value: ( localize('workbench.action.terminal.resizePaneLeft', "Resize Terminal Left")), original: 'Resize Terminal Left' },
        keybinding: {
            linux: { primary: 2048  | 1024  | 15  },
            mac: { primary: 2048  | 256  | 15  },
            when: TerminalContextKeys.focus,
            weight: 200
        },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (c) => c.groupService.activeGroup?.resizePane(0 )
    });
    registerTerminalAction({
        id: "workbench.action.terminal.resizePaneRight" ,
        title: { value: ( localize('workbench.action.terminal.resizePaneRight', "Resize Terminal Right")), original: 'Resize Terminal Right' },
        keybinding: {
            linux: { primary: 2048  | 1024  | 17  },
            mac: { primary: 2048  | 256  | 17  },
            when: TerminalContextKeys.focus,
            weight: 200
        },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (c) => c.groupService.activeGroup?.resizePane(1 )
    });
    registerTerminalAction({
        id: "workbench.action.terminal.resizePaneUp" ,
        title: { value: ( localize('workbench.action.terminal.resizePaneUp', "Resize Terminal Up")), original: 'Resize Terminal Up' },
        keybinding: {
            mac: { primary: 2048  | 256  | 16  },
            when: TerminalContextKeys.focus,
            weight: 200
        },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (c) => c.groupService.activeGroup?.resizePane(2 )
    });
    registerTerminalAction({
        id: "workbench.action.terminal.resizePaneDown" ,
        title: { value: ( localize('workbench.action.terminal.resizePaneDown', "Resize Terminal Down")), original: 'Resize Terminal Down' },
        keybinding: {
            mac: { primary: 2048  | 256  | 18  },
            when: TerminalContextKeys.focus,
            weight: 200
        },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (c) => c.groupService.activeGroup?.resizePane(3 )
    });
    registerTerminalAction({
        id: "workbench.action.terminal.focus" ,
        title: terminalStrings.focus,
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: async (c) => {
            const instance = c.service.activeInstance || (await c.service.createTerminal({ location: TerminalLocation.Panel }));
            if (!instance) {
                return;
            }
            c.service.setActiveInstance(instance);
            return c.groupService.showPanel(true);
        }
    });
    registerTerminalAction({
        id: "workbench.action.terminal.focusTabs" ,
        title: { value: ( localize('workbench.action.terminal.focus.tabsView', "Focus Terminal Tabs View")), original: 'Focus Terminal Tabs View' },
        keybinding: {
            primary: 2048  | 1024  | 93 ,
            weight: 200 ,
            when: ( ContextKeyExpr.or(TerminalContextKeys.tabsFocus, TerminalContextKeys.focus)),
        },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (c) => c.groupService.focusTabs()
    });
    registerTerminalAction({
        id: "workbench.action.terminal.focusNext" ,
        title: { value: ( localize('workbench.action.terminal.focusNext', "Focus Next Terminal Group")), original: 'Focus Next Terminal Group' },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        keybinding: {
            primary: 2048  | 12 ,
            mac: {
                primary: 2048  | 1024  | 94
            },
            when: ( ContextKeyExpr.and(TerminalContextKeys.focus, ( TerminalContextKeys.editorFocus.negate()))),
            weight: 200
        },
        run: async (c) => {
            c.groupService.setActiveGroupToNext();
            await c.groupService.showPanel(true);
        }
    });
    registerTerminalAction({
        id: "workbench.action.terminal.focusPrevious" ,
        title: { value: ( localize('workbench.action.terminal.focusPrevious', "Focus Previous Terminal Group")), original: 'Focus Previous Terminal Group' },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        keybinding: {
            primary: 2048  | 11 ,
            mac: {
                primary: 2048  | 1024  | 92
            },
            when: ( ContextKeyExpr.and(TerminalContextKeys.focus, ( TerminalContextKeys.editorFocus.negate()))),
            weight: 200
        },
        run: async (c) => {
            c.groupService.setActiveGroupToPrevious();
            await c.groupService.showPanel(true);
        }
    });
    registerTerminalAction({
        id: "workbench.action.terminal.runSelectedText" ,
        title: { value: ( localize(
            'workbench.action.terminal.runSelectedText',
            "Run Selected Text In Active Terminal"
        )), original: 'Run Selected Text In Active Terminal' },
        run: async (c, accessor) => {
            const codeEditorService = accessor.get(ICodeEditorService);
            const editor = codeEditorService.getActiveCodeEditor();
            if (!editor || !editor.hasModel()) {
                return;
            }
            const instance = await c.service.getActiveOrCreateInstance({ acceptsInput: true });
            const selection = editor.getSelection();
            let text;
            if (selection.isEmpty()) {
                text = editor.getModel().getLineContent(selection.selectionStartLineNumber).trim();
            }
            else {
                const endOfLinePreference = isWindows ? 1  : 2 ;
                text = editor.getModel().getValueInRange(selection, endOfLinePreference);
            }
            instance.sendText(text, true, true);
            await c.service.revealActiveTerminal();
        }
    });
    registerTerminalAction({
        id: "workbench.action.terminal.runActiveFile" ,
        title: { value: ( localize(
            'workbench.action.terminal.runActiveFile',
            "Run Active File In Active Terminal"
        )), original: 'Run Active File In Active Terminal' },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: async (c, accessor) => {
            const codeEditorService = accessor.get(ICodeEditorService);
            const notificationService = accessor.get(INotificationService);
            const workbenchEnvironmentService = accessor.get(IWorkbenchEnvironmentService);
            const editor = codeEditorService.getActiveCodeEditor();
            if (!editor || !editor.hasModel()) {
                return;
            }
            const instance = await c.service.getActiveOrCreateInstance({ acceptsInput: true });
            const isRemote = instance ? instance.isRemote : (workbenchEnvironmentService.remoteAuthority ? true : false);
            const uri = editor.getModel().uri;
            if ((!isRemote && uri.scheme !== Schemas.file && uri.scheme !== Schemas.vscodeUserData) || (isRemote && uri.scheme !== Schemas.vscodeRemote)) {
                notificationService.warn(( localize(
                    'workbench.action.terminal.runActiveFile.noFile',
                    'Only files on disk can be run in the terminal'
                )));
                return;
            }
            await instance.sendPath(uri, true);
            return c.groupService.showPanel();
        }
    });
    registerActiveXtermAction({
        id: "workbench.action.terminal.scrollDown" ,
        title: { value: ( localize('workbench.action.terminal.scrollDown', "Scroll Down (Line)")), original: 'Scroll Down (Line)' },
        keybinding: {
            primary: 2048  | 512  | 12 ,
            linux: { primary: 2048  | 1024  | 18  },
            when: ( ContextKeyExpr.and(TerminalContextKeys.focusInAny, ( TerminalContextKeys.altBufferActive.negate()))),
            weight: 200
        },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (xterm) => xterm.scrollDownLine()
    });
    registerActiveXtermAction({
        id: "workbench.action.terminal.scrollDownPage" ,
        title: { value: ( localize('workbench.action.terminal.scrollDownPage', "Scroll Down (Page)")), original: 'Scroll Down (Page)' },
        keybinding: {
            primary: 1024  | 12 ,
            mac: { primary: 12  },
            when: ( ContextKeyExpr.and(TerminalContextKeys.focusInAny, ( TerminalContextKeys.altBufferActive.negate()))),
            weight: 200
        },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (xterm) => xterm.scrollDownPage()
    });
    registerActiveXtermAction({
        id: "workbench.action.terminal.scrollToBottom" ,
        title: { value: ( localize('workbench.action.terminal.scrollToBottom', "Scroll to Bottom")), original: 'Scroll to Bottom' },
        keybinding: {
            primary: 2048  | 13 ,
            linux: { primary: 1024  | 13  },
            when: ( ContextKeyExpr.and(TerminalContextKeys.focusInAny, ( TerminalContextKeys.altBufferActive.negate()))),
            weight: 200
        },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (xterm) => xterm.scrollToBottom()
    });
    registerActiveXtermAction({
        id: "workbench.action.terminal.scrollUp" ,
        title: { value: ( localize('workbench.action.terminal.scrollUp', "Scroll Up (Line)")), original: 'Scroll Up (Line)' },
        keybinding: {
            primary: 2048  | 512  | 11 ,
            linux: { primary: 2048  | 1024  | 16  },
            when: ( ContextKeyExpr.and(TerminalContextKeys.focusInAny, ( TerminalContextKeys.altBufferActive.negate()))),
            weight: 200
        },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (xterm) => xterm.scrollUpLine()
    });
    registerActiveXtermAction({
        id: "workbench.action.terminal.scrollUpPage" ,
        title: { value: ( localize('workbench.action.terminal.scrollUpPage', "Scroll Up (Page)")), original: 'Scroll Up (Page)' },
        f1: true,
        category,
        keybinding: {
            primary: 1024  | 11 ,
            mac: { primary: 11  },
            when: ( ContextKeyExpr.and(TerminalContextKeys.focusInAny, ( TerminalContextKeys.altBufferActive.negate()))),
            weight: 200
        },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (xterm) => xterm.scrollUpPage()
    });
    registerActiveXtermAction({
        id: "workbench.action.terminal.scrollToTop" ,
        title: { value: ( localize('workbench.action.terminal.scrollToTop', "Scroll to Top")), original: 'Scroll to Top' },
        keybinding: {
            primary: 2048  | 14 ,
            linux: { primary: 1024  | 14  },
            when: ( ContextKeyExpr.and(TerminalContextKeys.focusInAny, ( TerminalContextKeys.altBufferActive.negate()))),
            weight: 200
        },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (xterm) => xterm.scrollToTop()
    });
    registerActiveXtermAction({
        id: "workbench.action.terminal.clearSelection" ,
        title: { value: ( localize('workbench.action.terminal.clearSelection', "Clear Selection")), original: 'Clear Selection' },
        keybinding: {
            primary: 9 ,
            when: ( ContextKeyExpr.and(
                TerminalContextKeys.focusInAny,
                TerminalContextKeys.textSelected,
                TerminalContextKeys.notFindVisible
            )),
            weight: 200
        },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (xterm) => {
            if (xterm.hasSelection()) {
                xterm.clearSelection();
            }
        }
    });
    registerTerminalAction({
        id: "workbench.action.terminal.changeIcon" ,
        title: terminalStrings.changeIcon,
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (c, _, args) => getResourceOrActiveInstance(c, args)?.changeIcon()
    });
    registerTerminalAction({
        id: "workbench.action.terminal.changeIconPanel" ,
        title: terminalStrings.changeIcon,
        f1: false,
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (c) => c.groupService.activeInstance?.changeIcon()
    });
    registerTerminalAction({
        id: "workbench.action.terminal.changeIconInstance" ,
        title: terminalStrings.changeIcon,
        f1: false,
        precondition: ( ContextKeyExpr.and(( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )), TerminalContextKeys.tabsSingularSelection)),
        run: (c, accessor) => getSelectedInstances(accessor)?.[0].changeIcon()
    });
    registerTerminalAction({
        id: "workbench.action.terminal.changeColor" ,
        title: terminalStrings.changeColor,
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (c, _, args) => getResourceOrActiveInstance(c, args)?.changeColor()
    });
    registerTerminalAction({
        id: "workbench.action.terminal.changeColorPanel" ,
        title: terminalStrings.changeColor,
        f1: false,
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (c) => c.groupService.activeInstance?.changeColor()
    });
    registerTerminalAction({
        id: "workbench.action.terminal.changeColorInstance" ,
        title: terminalStrings.changeColor,
        f1: false,
        precondition: ( ContextKeyExpr.and(( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )), TerminalContextKeys.tabsSingularSelection)),
        run: (c, accessor) => getSelectedInstances(accessor)?.[0].changeColor()
    });
    registerTerminalAction({
        id: "workbench.action.terminal.rename" ,
        title: terminalStrings.rename,
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (c, accessor, args) => renameWithQuickPick(c, accessor, args)
    });
    registerTerminalAction({
        id: "workbench.action.terminal.renamePanel" ,
        title: terminalStrings.rename,
        f1: false,
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (c, accessor) => renameWithQuickPick(c, accessor)
    });
    registerTerminalAction({
        id: "workbench.action.terminal.renameInstance" ,
        title: terminalStrings.rename,
        f1: false,
        keybinding: {
            primary: 60 ,
            mac: {
                primary: 3
            },
            when: ( ContextKeyExpr.and(TerminalContextKeys.tabsFocus)),
            weight: 200
        },
        precondition: ( ContextKeyExpr.and(( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )), TerminalContextKeys.tabsSingularSelection)),
        run: async (c, accessor) => {
            const notificationService = accessor.get(INotificationService);
            const instance = getSelectedInstances(accessor)?.[0];
            if (!instance) {
                return;
            }
            c.service.setEditingTerminal(instance);
            c.service.setEditable(instance, {
                validationMessage: value => validateTerminalName(value),
                onFinish: async (value, success) => {
                    c.service.setEditable(instance, null);
                    c.service.setEditingTerminal(undefined);
                    if (success) {
                        try {
                            await instance.rename(value);
                        }
                        catch (e) {
                            notificationService.error(e);
                        }
                    }
                }
            });
        }
    });
    registerActiveInstanceAction({
        id: "workbench.action.terminal.detachSession" ,
        title: { value: ( localize('workbench.action.terminal.detachSession', "Detach Session")), original: 'Detach Session' },
        run: (activeInstance) => activeInstance.detachProcessAndDispose(TerminalExitReason.User)
    });
    registerTerminalAction({
        id: "workbench.action.terminal.attachToSession" ,
        title: { value: ( localize('workbench.action.terminal.attachToSession', "Attach to Session")), original: 'Attach to Session' },
        run: async (c, accessor) => {
            const quickInputService = accessor.get(IQuickInputService);
            const labelService = accessor.get(ILabelService);
            const remoteAgentService = accessor.get(IRemoteAgentService);
            const notificationService = accessor.get(INotificationService);
            const remoteAuthority = remoteAgentService.getConnection()?.remoteAuthority ?? undefined;
            const backend = await accessor.get(ITerminalInstanceService).getBackend(remoteAuthority);
            if (!backend) {
                throw new Error(`No backend registered for remote authority '${remoteAuthority}'`);
            }
            const terms = await backend.listProcesses();
            backend.reduceConnectionGraceTime();
            const unattachedTerms = terms.filter(term => !c.service.isAttachedToTerminal(term));
            const items = ( unattachedTerms.map(term => {
                const cwdLabel = labelService.getUriLabel(URI.file(term.cwd));
                return {
                    label: term.title,
                    detail: term.workspaceName ? `${term.workspaceName} \u2E31 ${cwdLabel}` : cwdLabel,
                    description: term.pid ? String(term.pid) : '',
                    term
                };
            }));
            if (items.length === 0) {
                notificationService.info(( localize('noUnattachedTerminals', 'There are no unattached terminals to attach to')));
                return;
            }
            const selected = await quickInputService.pick(items, { canPickMany: false });
            if (selected) {
                const instance = await c.service.createTerminal({
                    config: { attachPersistentProcess: selected.term }
                });
                c.service.setActiveInstance(instance);
                await focusActiveTerminal(instance, c);
            }
        }
    });
    registerTerminalAction({
        id: "workbench.action.quickOpenTerm" ,
        title: { value: ( localize('quickAccessTerminal', "Switch Active Terminal")), original: 'Switch Active Terminal' },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (c, accessor) => accessor.get(IQuickInputService).quickAccess.show(TerminalQuickAccessProvider.PREFIX)
    });
    registerActiveInstanceAction({
        id: "workbench.action.terminal.scrollToPreviousCommand" ,
        title: { value: ( localize(
            'workbench.action.terminal.scrollToPreviousCommand',
            "Scroll To Previous Command"
        )), original: 'Scroll To Previous Command' },
        keybinding: {
            primary: 2048  | 16 ,
            when: ( ContextKeyExpr.and(TerminalContextKeys.focus, ( CONTEXT_ACCESSIBILITY_MODE_ENABLED.negate()))),
            weight: 200
        },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (activeInstance) => activeInstance.xterm?.markTracker.scrollToPreviousMark(undefined, undefined, ( activeInstance.capabilities.has(2 )))
    });
    registerActiveInstanceAction({
        id: "workbench.action.terminal.scrollToNextCommand" ,
        title: { value: ( localize('workbench.action.terminal.scrollToNextCommand', "Scroll To Next Command")), original: 'Scroll To Next Command' },
        keybinding: {
            primary: 2048  | 18 ,
            when: ( ContextKeyExpr.and(TerminalContextKeys.focus, ( CONTEXT_ACCESSIBILITY_MODE_ENABLED.negate()))),
            weight: 200
        },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (activeInstance) => {
            activeInstance.xterm?.markTracker.scrollToNextMark();
            activeInstance.focus();
        }
    });
    registerActiveInstanceAction({
        id: "workbench.action.terminal.selectToPreviousCommand" ,
        title: { value: ( localize(
            'workbench.action.terminal.selectToPreviousCommand',
            "Select To Previous Command"
        )), original: 'Select To Previous Command' },
        keybinding: {
            primary: 2048  | 1024  | 16 ,
            when: TerminalContextKeys.focus,
            weight: 200
        },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (activeInstance) => {
            activeInstance.xterm?.markTracker.selectToPreviousMark();
            activeInstance.focus();
        }
    });
    registerActiveInstanceAction({
        id: "workbench.action.terminal.selectToNextCommand" ,
        title: { value: ( localize('workbench.action.terminal.selectToNextCommand', "Select To Next Command")), original: 'Select To Next Command' },
        keybinding: {
            primary: 2048  | 1024  | 18 ,
            when: TerminalContextKeys.focus,
            weight: 200
        },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (activeInstance) => {
            activeInstance.xterm?.markTracker.selectToNextMark();
            activeInstance.focus();
        }
    });
    registerActiveXtermAction({
        id: "workbench.action.terminal.selectToPreviousLine" ,
        title: { value: ( localize(
            'workbench.action.terminal.selectToPreviousLine',
            "Select To Previous Line"
        )), original: 'Select To Previous Line' },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: async (xterm, _, instance) => {
            xterm.markTracker.selectToPreviousLine();
            (instance || xterm).focus();
        }
    });
    registerActiveXtermAction({
        id: "workbench.action.terminal.selectToNextLine" ,
        title: { value: ( localize('workbench.action.terminal.selectToNextLine', "Select To Next Line")), original: 'Select To Next Line' },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: async (xterm, _, instance) => {
            xterm.markTracker.selectToNextLine();
            (instance || xterm).focus();
        }
    });
    registerTerminalAction({
        id: "workbench.action.terminal.sendSequence" ,
        title: terminalStrings.sendSequence,
        f1: false,
        description: {
            description: terminalStrings.sendSequence.value,
            args: [{
                    name: 'args',
                    schema: {
                        type: 'object',
                        required: ['text'],
                        properties: {
                            text: {
                                description: ( localize('sendSequence', "The sequence of text to send to the terminal")),
                                type: 'string'
                            }
                        },
                    }
                }]
        },
        run: (c, accessor, args) => terminalSendSequenceCommand(accessor, args)
    });
    registerTerminalAction({
        id: "workbench.action.terminal.newWithCwd" ,
        title: terminalStrings.newWithCwd,
        description: {
            description: terminalStrings.newWithCwd.value,
            args: [{
                    name: 'args',
                    schema: {
                        type: 'object',
                        required: ['cwd'],
                        properties: {
                            cwd: {
                                description: ( localize(
                                    'workbench.action.terminal.newWithCwd.cwd',
                                    "The directory to start the terminal at"
                                )),
                                type: 'string'
                            }
                        },
                    }
                }]
        },
        run: async (c, _, args) => {
            const cwd = isObject(args) && 'cwd' in args ? toOptionalString(args.cwd) : undefined;
            const instance = await c.service.createTerminal({ cwd });
            if (!instance) {
                return;
            }
            c.service.setActiveInstance(instance);
            await focusActiveTerminal(instance, c);
        }
    });
    registerActiveInstanceAction({
        id: "workbench.action.terminal.renameWithArg" ,
        title: terminalStrings.renameWithArgs,
        description: {
            description: terminalStrings.renameWithArgs.value,
            args: [{
                    name: 'args',
                    schema: {
                        type: 'object',
                        required: ['name'],
                        properties: {
                            name: {
                                description: ( localize(
                                    'workbench.action.terminal.renameWithArg.name',
                                    "The new name for the terminal"
                                )),
                                type: 'string',
                                minLength: 1
                            }
                        }
                    }
                }]
        },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: async (activeInstance, c, accessor, args) => {
            const notificationService = accessor.get(INotificationService);
            const name = isObject(args) && 'name' in args ? toOptionalString(args.name) : undefined;
            if (!name) {
                notificationService.warn(( localize(
                    'workbench.action.terminal.renameWithArg.noName',
                    "No name argument provided"
                )));
                return;
            }
            activeInstance.rename(name);
        }
    });
    registerActiveInstanceAction({
        id: "workbench.action.terminal.relaunch" ,
        title: { value: ( localize('workbench.action.terminal.relaunch', "Relaunch Active Terminal")), original: 'Relaunch Active Terminal' },
        run: (activeInstance) => activeInstance.relaunch()
    });
    registerTerminalAction({
        id: "workbench.action.terminal.split" ,
        title: terminalStrings.split,
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.webExtensionContributedProfile
        )),
        keybinding: {
            primary: 2048  | 1024  | 26 ,
            weight: 200 ,
            mac: {
                primary: 2048  | 93 ,
                secondary: [256  | 1024  | 26 ]
            },
            when: TerminalContextKeys.focus
        },
        icon: Codicon.splitHorizontal,
        run: async (c, accessor, args) => {
            const optionsOrProfile = isObject(args) ? args : undefined;
            const commandService = accessor.get(ICommandService);
            const workspaceContextService = accessor.get(IWorkspaceContextService);
            const options = convertOptionsOrProfileToOptions(optionsOrProfile);
            const activeInstance = (await c.service.getInstanceHost(options?.location)).activeInstance;
            if (!activeInstance) {
                return;
            }
            const cwd = await getCwdForSplit(c.service.configHelper, activeInstance, workspaceContextService.getWorkspace().folders, commandService);
            if (cwd === undefined) {
                return;
            }
            const instance = await c.service.createTerminal({ location: { parentTerminal: activeInstance }, config: options?.config, cwd });
            await focusActiveTerminal(instance, c);
        }
    });
    registerTerminalAction({
        id: "workbench.action.terminal.splitInstance" ,
        title: terminalStrings.split,
        f1: false,
        keybinding: {
            primary: 2048  | 1024  | 26 ,
            mac: {
                primary: 2048  | 93 ,
                secondary: [256  | 1024  | 26 ]
            },
            weight: 200 ,
            when: TerminalContextKeys.tabsFocus
        },
        run: async (c, accessor) => {
            const instances = getSelectedInstances(accessor);
            if (instances) {
                const promises = [];
                for (const t of instances) {
                    promises.push((async () => {
                        await c.service.createTerminal({ location: { parentTerminal: t } });
                        await c.groupService.showPanel(true);
                    })());
                }
                await Promise.all(promises);
            }
        }
    });
    registerActiveInstanceAction({
        id: "workbench.action.terminal.unsplit" ,
        title: terminalStrings.unsplit,
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (activeInstance, c) => c.groupService.unsplitInstance(activeInstance)
    });
    registerTerminalAction({
        id: "workbench.action.terminal.unsplitInstance" ,
        title: terminalStrings.unsplit,
        f1: false,
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: async (c, accessor) => {
            const instances = getSelectedInstances(accessor);
            if (instances?.length === 1) {
                const group = c.groupService.getGroupForInstance(instances[0]);
                if (group && group?.terminalInstances.length > 1) {
                    c.groupService.unsplitInstance(instances[0]);
                }
            }
        }
    });
    registerTerminalAction({
        id: "workbench.action.terminal.joinInstance" ,
        title: { value: ( localize('workbench.action.terminal.joinInstance', "Join Terminals")), original: 'Join Terminals' },
        precondition: ( ContextKeyExpr.and(( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )), ( TerminalContextKeys.tabsSingularSelection.toNegated()))),
        run: async (c, accessor) => {
            const instances = getSelectedInstances(accessor);
            if (instances && instances.length > 1) {
                c.groupService.joinInstances(instances);
            }
        }
    });
    registerTerminalAction({
        id: "workbench.action.terminal.join" ,
        title: { value: ( localize('workbench.action.terminal.join', "Join Terminals")), original: 'Join Terminals' },
        precondition: ( ContextKeyExpr.and(( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )))),
        run: async (c, accessor) => {
            const themeService = accessor.get(IThemeService);
            const notificationService = accessor.get(INotificationService);
            const quickInputService = accessor.get(IQuickInputService);
            const picks = [];
            if (c.groupService.instances.length <= 1) {
                notificationService.warn(( localize(
                    'workbench.action.terminal.join.insufficientTerminals',
                    'Insufficient terminals for the join action'
                )));
                return;
            }
            const otherInstances = c.groupService.instances.filter(i => i.instanceId !== c.groupService.activeInstance?.instanceId);
            for (const terminal of otherInstances) {
                const group = c.groupService.getGroupForInstance(terminal);
                if (group?.terminalInstances.length === 1) {
                    const iconId = getIconId(accessor, terminal);
                    const label = `$(${iconId}): ${terminal.title}`;
                    const iconClasses = [];
                    const colorClass = getColorClass(terminal);
                    if (colorClass) {
                        iconClasses.push(colorClass);
                    }
                    const uriClasses = getUriClasses(terminal, themeService.getColorTheme().type);
                    if (uriClasses) {
                        iconClasses.push(...uriClasses);
                    }
                    picks.push({
                        terminal,
                        label,
                        iconClasses
                    });
                }
            }
            if (picks.length === 0) {
                notificationService.warn(( localize(
                    'workbench.action.terminal.join.onlySplits',
                    'All terminals are joined already'
                )));
                return;
            }
            const result = await quickInputService.pick(picks, {});
            if (result) {
                c.groupService.joinInstances([result.terminal, c.groupService.activeInstance]);
            }
        }
    });
    registerActiveInstanceAction({
        id: "workbench.action.terminal.splitInActiveWorkspace" ,
        title: { value: ( localize(
            'workbench.action.terminal.splitInActiveWorkspace',
            "Split Terminal (In Active Workspace)"
        )), original: 'Split Terminal (In Active Workspace)' },
        run: async (instance, c) => {
            const newInstance = await c.service.createTerminal({ location: { parentTerminal: instance } });
            if (newInstance?.target !== TerminalLocation.Editor) {
                await c.groupService.showPanel(true);
            }
        }
    });
    registerActiveXtermAction({
        id: "workbench.action.terminal.selectAll" ,
        title: { value: ( localize('workbench.action.terminal.selectAll', "Select All")), original: 'Select All' },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        keybinding: [{
                primary: 0,
                mac: { primary: 2048  | 31  },
                weight: 200 ,
                when: TerminalContextKeys.focusInAny
            }],
        run: (xterm) => xterm.selectAll()
    });
    registerTerminalAction({
        id: "workbench.action.terminal.new" ,
        title: { value: ( localize('workbench.action.terminal.new', "Create New Terminal")), original: 'Create New Terminal' },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.webExtensionContributedProfile
        )),
        icon: newTerminalIcon,
        keybinding: {
            primary: 2048  | 1024  | 91 ,
            mac: { primary: 256  | 1024  | 91  },
            weight: 200
        },
        run: async (c, accessor, args) => {
            let eventOrOptions = isObject(args) ? args : undefined;
            const workspaceContextService = accessor.get(IWorkspaceContextService);
            const commandService = accessor.get(ICommandService);
            const folders = workspaceContextService.getWorkspace().folders;
            if (eventOrOptions && eventOrOptions instanceof MouseEvent && (eventOrOptions.altKey || eventOrOptions.ctrlKey)) {
                await c.service.createTerminal({ location: { splitActiveTerminal: true } });
                return;
            }
            if (c.service.isProcessSupportRegistered) {
                eventOrOptions = !eventOrOptions || eventOrOptions instanceof MouseEvent ? {} : eventOrOptions;
                let instance;
                if (folders.length <= 1) {
                    instance = await c.service.createTerminal(eventOrOptions);
                }
                else {
                    const cwd = (await pickTerminalCwd(accessor))?.cwd;
                    if (!cwd) {
                        return;
                    }
                    eventOrOptions.cwd = cwd;
                    instance = await c.service.createTerminal(eventOrOptions);
                }
                c.service.setActiveInstance(instance);
                await focusActiveTerminal(instance, c);
            }
            else {
                if (c.profileService.contributedProfiles.length > 0) {
                    commandService.executeCommand("workbench.action.terminal.newWithProfile" );
                }
                else {
                    commandService.executeCommand("workbench.action.terminal.toggleTerminal" );
                }
            }
        }
    });
    registerTerminalAction({
        id: "workbench.action.terminal.kill" ,
        title: { value: ( localize('workbench.action.terminal.kill', "Kill the Active Terminal Instance")), original: 'Kill the Active Terminal Instance' },
        precondition: ( ContextKeyExpr.or(( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )), TerminalContextKeys.isOpen)),
        icon: killTerminalIcon,
        run: async (c) => {
            const instance = c.groupService.activeInstance;
            if (!instance) {
                return;
            }
            await c.service.safeDisposeTerminal(instance);
            if (c.groupService.instances.length > 0) {
                await c.groupService.showPanel(true);
            }
        }
    });
    registerTerminalAction({
        id: "workbench.action.terminal.killAll" ,
        title: { value: ( localize('workbench.action.terminal.killAll', "Kill All Terminals")), original: 'Kill All Terminals' },
        precondition: ( ContextKeyExpr.or(( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )), TerminalContextKeys.isOpen)),
        icon: Codicon.trash,
        run: async (c) => {
            const disposePromises = [];
            for (const instance of c.service.instances) {
                disposePromises.push(c.service.safeDisposeTerminal(instance));
            }
            await Promise.all(disposePromises);
        }
    });
    registerTerminalAction({
        id: "workbench.action.terminal.killEditor" ,
        title: { value: ( localize(
            'workbench.action.terminal.killEditor',
            "Kill the Active Terminal in Editor Area"
        )), original: 'Kill the Active Terminal in Editor Area' },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        keybinding: {
            primary: 2048  | 53 ,
            win: { primary: 2048  | 62 , secondary: [2048  | 53 ] },
            weight: 200 ,
            when: ( ContextKeyExpr.and(TerminalContextKeys.focus, ( ResourceContextKey.Scheme.isEqualTo(Schemas.vscodeTerminal)), TerminalContextKeys.editorFocus))
        },
        run: (c, accessor) => accessor.get(ICommandService).executeCommand(CLOSE_EDITOR_COMMAND_ID)
    });
    registerTerminalAction({
        id: "workbench.action.terminal.killInstance" ,
        title: terminalStrings.kill,
        f1: false,
        precondition: ( ContextKeyExpr.or(( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )), TerminalContextKeys.isOpen)),
        keybinding: {
            primary: 20 ,
            mac: {
                primary: 2048  | 1 ,
                secondary: [20 ]
            },
            weight: 200 ,
            when: TerminalContextKeys.tabsFocus
        },
        run: async (c, accessor) => {
            const selectedInstances = getSelectedInstances(accessor);
            if (!selectedInstances) {
                return;
            }
            const listService = accessor.get(IListService);
            const disposePromises = [];
            for (const instance of selectedInstances) {
                disposePromises.push(c.service.safeDisposeTerminal(instance));
            }
            await Promise.all(disposePromises);
            if (c.service.instances.length > 0) {
                c.groupService.focusTabs();
                listService.lastFocusedList?.focusNext();
            }
        }
    });
    registerTerminalAction({
        id: "workbench.action.terminal.focusHover" ,
        title: terminalStrings.focusHover,
        precondition: ( ContextKeyExpr.or(( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )), TerminalContextKeys.isOpen)),
        keybinding: {
            primary: KeyChord(2048  | 41 , 2048  | 39 ),
            weight: 200 ,
            when: ( ContextKeyExpr.or(TerminalContextKeys.tabsFocus, TerminalContextKeys.focus))
        },
        run: (c) => c.groupService.focusHover()
    });
    registerActiveInstanceAction({
        id: "workbench.action.terminal.clear" ,
        title: { value: ( localize('workbench.action.terminal.clear', "Clear")), original: 'Clear' },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        keybinding: [{
                primary: 0,
                mac: { primary: 2048  | 41  },
                weight: 200  + 1,
                when: ( ContextKeyExpr.and(TerminalContextKeys.focus, ( CONTEXT_ACCESSIBILITY_MODE_ENABLED.negate()))),
            }],
        run: (activeInstance) => activeInstance.clearBuffer()
    });
    registerTerminalAction({
        id: "workbench.action.terminal.selectDefaultShell" ,
        title: { value: ( localize('workbench.action.terminal.selectDefaultShell', "Select Default Profile")), original: 'Select Default Profile' },
        run: (c) => c.service.showProfileQuickPick('setDefault')
    });
    registerTerminalAction({
        id: "workbench.action.terminal.openSettings" ,
        title: { value: ( localize('workbench.action.terminal.openSettings', "Configure Terminal Settings")), original: 'Configure Terminal Settings' },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: (c, accessor) => accessor.get(IPreferencesService).openSettings({ jsonEditor: false, query: '@feature:terminal' })
    });
    registerActiveInstanceAction({
        id: "workbench.action.terminal.setDimensions" ,
        title: { value: ( localize('workbench.action.terminal.setFixedDimensions', "Set Fixed Dimensions")), original: 'Set Fixed Dimensions' },
        precondition: ( ContextKeyExpr.and(( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )), TerminalContextKeys.isOpen)),
        run: (activeInstance) => activeInstance.setFixedDimensions()
    });
    registerActiveInstanceAction({
        id: "workbench.action.terminal.sizeToContentWidth" ,
        title: { value: ( localize(
            'workbench.action.terminal.sizeToContentWidth',
            "Toggle Size to Content Width"
        )), original: 'Toggle Size to Content Width' },
        precondition: ( ContextKeyExpr.and(( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )), TerminalContextKeys.isOpen)),
        keybinding: {
            primary: 512  | 56 ,
            weight: 200 ,
            when: TerminalContextKeys.focus
        },
        run: (instancactiveInstance) => instancactiveInstance.toggleSizeToContentWidth()
    });
    registerTerminalAction({
        id: "workbench.action.terminal.sizeToContentWidthInstance" ,
        title: terminalStrings.toggleSizeToContentWidth,
        f1: false,
        precondition: ( ContextKeyExpr.and(( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )), TerminalContextKeys.focus)),
        run: (c, accessor) => getSelectedInstances(accessor)?.[0].toggleSizeToContentWidth()
    });
    registerTerminalAction({
        id: "workbench.action.terminal.clearPreviousSessionHistory" ,
        title: { value: ( localize(
            'workbench.action.terminal.clearPreviousSessionHistory',
            "Clear Previous Session History"
        )), original: 'Clear Previous Session History' },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: async (c, accessor) => {
            getCommandHistory(accessor).clear();
            clearShellFileHistory();
        }
    });
    registerActiveInstanceAction({
        id: "workbench.action.terminal.selectPrevSuggestion" ,
        title: { value: ( localize(
            'workbench.action.terminal.selectPrevSuggestion',
            "Select the Previous Suggestion"
        )), original: 'Select the Previous Suggestion' },
        f1: false,
        precondition: ( ContextKeyExpr.and(( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )), TerminalContextKeys.focus, TerminalContextKeys.isOpen, TerminalContextKeys.suggestWidgetVisible)),
        keybinding: {
            primary: 16 ,
            weight: 200  + 1
        },
        run: (activeInstance) => activeInstance.selectPreviousSuggestion()
    });
    registerActiveInstanceAction({
        id: "workbench.action.terminal.selectPrevPageSuggestion" ,
        title: { value: ( localize(
            'workbench.action.terminal.selectPrevPageSuggestion',
            "Select the Previous Page Suggestion"
        )), original: 'Select the Previous Page Suggestion' },
        f1: false,
        precondition: ( ContextKeyExpr.and(( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )), TerminalContextKeys.focus, TerminalContextKeys.isOpen, TerminalContextKeys.suggestWidgetVisible)),
        keybinding: {
            primary: 11 ,
            weight: 200  + 1
        },
        run: (activeInstance) => activeInstance.selectPreviousPageSuggestion()
    });
    registerActiveInstanceAction({
        id: "workbench.action.terminal.selectNextSuggestion" ,
        title: { value: ( localize(
            'workbench.action.terminal.selectNextSuggestion',
            "Select the Next Suggestion"
        )), original: 'Select the Next Suggestion' },
        f1: false,
        precondition: ( ContextKeyExpr.and(( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )), TerminalContextKeys.focus, TerminalContextKeys.isOpen, TerminalContextKeys.suggestWidgetVisible)),
        keybinding: {
            primary: 18 ,
            weight: 200  + 1
        },
        run: (insactiveInstanceance) => insactiveInstanceance.selectNextSuggestion()
    });
    registerActiveInstanceAction({
        id: "workbench.action.terminal.selectNextPageSuggestion" ,
        title: { value: ( localize(
            'workbench.action.terminal.selectNextPageSuggestion',
            "Select the Next Page Suggestion"
        )), original: 'Select the Next Page Suggestion' },
        f1: false,
        precondition: ( ContextKeyExpr.and(( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )), TerminalContextKeys.focus, TerminalContextKeys.isOpen, TerminalContextKeys.suggestWidgetVisible)),
        keybinding: {
            primary: 12 ,
            weight: 200  + 1
        },
        run: (activeInstance) => activeInstance.selectNextPageSuggestion()
    });
    registerActiveInstanceAction({
        id: "workbench.action.terminal.acceptSelectedSuggestion" ,
        title: { value: ( localize(
            'workbench.action.terminal.acceptSelectedSuggestion',
            "Accept Selected Suggestion"
        )), original: 'Accept Selected Suggestion' },
        f1: false,
        precondition: ( ContextKeyExpr.and(( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )), TerminalContextKeys.focus, TerminalContextKeys.isOpen, TerminalContextKeys.suggestWidgetVisible)),
        keybinding: {
            primary: 3 ,
            secondary: [2 ],
            weight: 200  + 1
        },
        run: (activeInstance) => activeInstance.acceptSelectedSuggestion()
    });
    registerActiveInstanceAction({
        id: "workbench.action.terminal.hideSuggestWidget" ,
        title: { value: ( localize('workbench.action.terminal.hideSuggestWidget', "Hide Suggest Widget")), original: 'Hide Suggest Widget' },
        f1: false,
        precondition: ( ContextKeyExpr.and(( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )), TerminalContextKeys.focus, TerminalContextKeys.isOpen, TerminalContextKeys.suggestWidgetVisible)),
        keybinding: {
            primary: 9 ,
            weight: 200  + 1
        },
        run: (activeInstance) => activeInstance.hideSuggestWidget()
    });
    if (BrowserFeatures.clipboard.writeText) {
        registerActiveXtermAction({
            id: "workbench.action.terminal.copySelection" ,
            title: { value: ( localize('workbench.action.terminal.copySelection', "Copy Selection")), original: 'Copy Selection' },
            precondition: ( ContextKeyExpr.or(TerminalContextKeys.textSelectedInFocused, ( ContextKeyExpr.and(( ContextKeyExpr.or(
                TerminalContextKeys.processSupported,
                TerminalContextKeys.terminalHasBeenCreated
            )), TerminalContextKeys.textSelected)))),
            keybinding: [{
                    primary: 2048  | 1024  | 33 ,
                    mac: { primary: 2048  | 33  },
                    weight: 200 ,
                    when: ( ContextKeyExpr.or(( ContextKeyExpr.and(TerminalContextKeys.textSelected, TerminalContextKeys.focus)), TerminalContextKeys.textSelectedInFocused))
                }],
            run: (activeInstance) => activeInstance.copySelection()
        });
        registerActiveXtermAction({
            id: "workbench.action.terminal.copyAndClearSelection" ,
            title: { value: ( localize(
                'workbench.action.terminal.copyAndClearSelection',
                "Copy and Clear Selection"
            )), original: 'Copy and Clear Selection' },
            precondition: ( ContextKeyExpr.or(TerminalContextKeys.textSelectedInFocused, ( ContextKeyExpr.and(( ContextKeyExpr.or(
                TerminalContextKeys.processSupported,
                TerminalContextKeys.terminalHasBeenCreated
            )), TerminalContextKeys.textSelected)))),
            keybinding: [{
                    win: { primary: 2048  | 33  },
                    weight: 200 ,
                    when: ( ContextKeyExpr.or(( ContextKeyExpr.and(TerminalContextKeys.textSelected, TerminalContextKeys.focus)), TerminalContextKeys.textSelectedInFocused))
                }],
            run: async (xterm) => {
                await xterm.copySelection();
                xterm.clearSelection();
            }
        });
        registerActiveXtermAction({
            id: "workbench.action.terminal.copySelectionAsHtml" ,
            title: { value: ( localize('workbench.action.terminal.copySelectionAsHtml', "Copy Selection as HTML")), original: 'Copy Selection as HTML' },
            f1: true,
            category,
            precondition: ( ContextKeyExpr.or(TerminalContextKeys.textSelectedInFocused, ( ContextKeyExpr.and(( ContextKeyExpr.or(
                TerminalContextKeys.processSupported,
                TerminalContextKeys.terminalHasBeenCreated
            )), TerminalContextKeys.textSelected)))),
            run: (xterm) => xterm.copySelection(true)
        });
    }
    if (BrowserFeatures.clipboard.readText) {
        registerActiveInstanceAction({
            id: "workbench.action.terminal.paste" ,
            title: { value: ( localize('workbench.action.terminal.paste', "Paste into Active Terminal")), original: 'Paste into Active Terminal' },
            precondition: ( ContextKeyExpr.or(
                TerminalContextKeys.processSupported,
                TerminalContextKeys.terminalHasBeenCreated
            )),
            keybinding: [{
                    primary: 2048  | 52 ,
                    win: { primary: 2048  | 52 , secondary: [2048  | 1024  | 52 ] },
                    linux: { primary: 2048  | 1024  | 52  },
                    weight: 200 ,
                    when: TerminalContextKeys.focus
                }],
            run: (activeInstance) => activeInstance.paste()
        });
    }
    if (BrowserFeatures.clipboard.readText && isLinux) {
        registerActiveInstanceAction({
            id: "workbench.action.terminal.pasteSelection" ,
            title: { value: ( localize(
                'workbench.action.terminal.pasteSelection',
                "Paste Selection into Active Terminal"
            )), original: 'Paste Selection into Active Terminal' },
            precondition: ( ContextKeyExpr.or(
                TerminalContextKeys.processSupported,
                TerminalContextKeys.terminalHasBeenCreated
            )),
            keybinding: [{
                    linux: { primary: 1024  | 19  },
                    weight: 200 ,
                    when: TerminalContextKeys.focus
                }],
            run: (activeInstance) => activeInstance.pasteSelection()
        });
    }
    registerTerminalAction({
        id: "workbench.action.terminal.switchTerminal" ,
        title: { value: ( localize('workbench.action.terminal.switchTerminal', "Switch Terminal")), original: 'Switch Terminal' },
        precondition: ( ContextKeyExpr.or(
            TerminalContextKeys.processSupported,
            TerminalContextKeys.terminalHasBeenCreated
        )),
        run: async (c, accessor, args) => {
            const item = toOptionalString(args);
            if (!item) {
                return;
            }
            if (item === switchTerminalActionViewItemSeparator) {
                c.service.refreshActiveGroup();
                return;
            }
            if (item === switchTerminalShowTabsTitle) {
                accessor.get(IConfigurationService).updateValue("terminal.integrated.tabs.enabled" , true);
                return;
            }
            const terminalIndexRe = /^([0-9]+): /;
            const indexMatches = terminalIndexRe.exec(item);
            if (indexMatches) {
                c.groupService.setActiveGroupByIndex(Number(indexMatches[1]) - 1);
                return c.groupService.showPanel(true);
            }
            const quickSelectProfiles = c.profileService.availableProfiles;
            const profileSelection = item.substring(4);
            if (quickSelectProfiles) {
                const profile = quickSelectProfiles.find(profile => profile.profileName === profileSelection);
                if (profile) {
                    const instance = await c.service.createTerminal({
                        config: profile
                    });
                    c.service.setActiveInstance(instance);
                }
                else {
                    console.warn(`No profile with name "${profileSelection}"`);
                }
            }
            else {
                console.warn(`Unmatched terminal item: "${item}"`);
            }
        }
    });
}
function getSelectedInstances(accessor) {
    const listService = accessor.get(IListService);
    const terminalService = accessor.get(ITerminalService);
    if (!listService.lastFocusedList?.getSelection()) {
        return undefined;
    }
    const selections = listService.lastFocusedList.getSelection();
    const focused = listService.lastFocusedList.getFocus();
    const instances = [];
    if (focused.length === 1 && !selections.includes(focused[0])) {
        instances.push(terminalService.getInstanceFromIndex(focused[0]));
        return instances;
    }
    for (const selection of selections) {
        instances.push(terminalService.getInstanceFromIndex(selection));
    }
    return instances;
}
function validateTerminalName(name) {
    if (!name || name.trim().length === 0) {
        return {
            content: ( localize(
                'emptyTerminalNameInfo',
                "Providing no name will reset it to the default value"
            )),
            severity: Severity.Info
        };
    }
    return null;
}
function convertOptionsOrProfileToOptions(optionsOrProfile) {
    if (isObject(optionsOrProfile) && 'profileName' in optionsOrProfile) {
        return { config: optionsOrProfile, location: optionsOrProfile.location };
    }
    return optionsOrProfile;
}
let newWithProfileAction;
function refreshTerminalActions(detectedProfiles) {
    const profileEnum = createProfileSchemaEnums(detectedProfiles);
    newWithProfileAction?.dispose();
    newWithProfileAction = registerAction2(class extends Action2 {
        constructor() {
            super({
                id: "workbench.action.terminal.newWithProfile" ,
                title: { value: ( localize(
                    'workbench.action.terminal.newWithProfile',
                    "Create New Terminal (With Profile)"
                )), original: 'Create New Terminal (With Profile)' },
                f1: true,
                category,
                precondition: ( ContextKeyExpr.or(
                    TerminalContextKeys.processSupported,
                    TerminalContextKeys.webExtensionContributedProfile
                )),
                description: {
                    description: "workbench.action.terminal.newWithProfile" ,
                    args: [{
                            name: 'args',
                            schema: {
                                type: 'object',
                                required: ['profileName'],
                                properties: {
                                    profileName: {
                                        description: ( localize(
                                            'workbench.action.terminal.newWithProfile.profileName',
                                            "The name of the profile to create"
                                        )),
                                        type: 'string',
                                        enum: profileEnum.values,
                                        markdownEnumDescriptions: profileEnum.markdownDescriptions
                                    }
                                }
                            }
                        }]
                },
            });
        }
        async run(accessor, eventOrOptionsOrProfile, profile) {
            const c = getTerminalServices(accessor);
            const workspaceContextService = accessor.get(IWorkspaceContextService);
            const commandService = accessor.get(ICommandService);
            let event;
            let options;
            let instance;
            let cwd;
            if (isObject(eventOrOptionsOrProfile) && eventOrOptionsOrProfile && 'profileName' in eventOrOptionsOrProfile) {
                const config = c.profileService.availableProfiles.find(profile => profile.profileName === eventOrOptionsOrProfile.profileName);
                if (!config) {
                    throw new Error(`Could not find terminal profile "${eventOrOptionsOrProfile.profileName}"`);
                }
                options = { config };
            }
            else if (eventOrOptionsOrProfile instanceof MouseEvent || eventOrOptionsOrProfile instanceof PointerEvent || eventOrOptionsOrProfile instanceof KeyboardEvent) {
                event = eventOrOptionsOrProfile;
                options = profile ? { config: profile } : undefined;
            }
            else {
                options = convertOptionsOrProfileToOptions(eventOrOptionsOrProfile);
            }
            if (event && (event.altKey || event.ctrlKey)) {
                const parentTerminal = c.service.activeInstance;
                if (parentTerminal) {
                    await c.service.createTerminal({ location: { parentTerminal }, config: options?.config });
                    return;
                }
            }
            const folders = workspaceContextService.getWorkspace().folders;
            if (folders.length > 1) {
                const options = {
                    placeHolder: ( localize(
                        'workbench.action.terminal.newWorkspacePlaceholder',
                        "Select current working directory for new terminal"
                    ))
                };
                const workspace = await commandService.executeCommand(PICK_WORKSPACE_FOLDER_COMMAND_ID, [options]);
                if (!workspace) {
                    return;
                }
                cwd = workspace.uri;
            }
            if (options) {
                options.cwd = cwd;
                instance = await c.service.createTerminal(options);
            }
            else {
                instance = await c.service.showProfileQuickPick('createInstance', cwd);
            }
            if (instance) {
                c.service.setActiveInstance(instance);
                await focusActiveTerminal(instance, c);
            }
        }
    });
}
function getResourceOrActiveInstance(c, resource) {
    return c.service.getInstanceFromResource(toOptionalUri(resource)) || c.service.activeInstance;
}
async function pickTerminalCwd(accessor, cancel) {
    const quickInputService = accessor.get(IQuickInputService);
    const labelService = accessor.get(ILabelService);
    const contextService = accessor.get(IWorkspaceContextService);
    const modelService = accessor.get(IModelService);
    const languageService = accessor.get(ILanguageService);
    const configurationService = accessor.get(IConfigurationService);
    const configurationResolverService = accessor.get(IConfigurationResolverService);
    const folders = contextService.getWorkspace().folders;
    if (!folders.length) {
        return;
    }
    const folderCwdPairs = await Promise.all(( folders.map(
        x => resolveWorkspaceFolderCwd(x, configurationService, configurationResolverService)
    )));
    const shrinkedPairs = shrinkWorkspaceFolderCwdPairs(folderCwdPairs);
    if (shrinkedPairs.length === 1) {
        return shrinkedPairs[0];
    }
    const folderPicks = ( shrinkedPairs.map(pair => {
        const label = pair.folder.name;
        const description = pair.isOverridden
            ? ( localize(
            'workbench.action.terminal.overriddenCwdDescription',
            "(Overriden) {0}",
            labelService.getUriLabel(pair.cwd, { relative: !pair.isAbsolute })
        ))
            : labelService.getUriLabel(dirname(pair.cwd), { relative: true });
        return {
            label,
            description: description !== label ? description : undefined,
            pair: pair,
            iconClasses: getIconClasses(modelService, languageService, pair.cwd, FileKind.ROOT_FOLDER)
        };
    }));
    const options = {
        placeHolder: ( localize(
            'workbench.action.terminal.newWorkspacePlaceholder',
            "Select current working directory for new terminal"
        )),
        matchOnDescription: true,
        canPickMany: false,
    };
    const token = cancel || CancellationToken.None;
    const pick = await quickInputService.pick(folderPicks, options, token);
    return pick?.pair;
}
async function resolveWorkspaceFolderCwd(folder, configurationService, configurationResolverService) {
    const cwdConfig = configurationService.getValue("terminal.integrated.cwd" , { resource: folder.uri });
    if (!isString(cwdConfig) || cwdConfig.length === 0) {
        return { folder, cwd: folder.uri, isAbsolute: false, isOverridden: false };
    }
    const resolvedCwdConfig = await configurationResolverService.resolveAsync(folder, cwdConfig);
    return isAbsolute(resolvedCwdConfig) || resolvedCwdConfig.startsWith(AbstractVariableResolverService.VARIABLE_LHS)
        ? { folder, isAbsolute: true, isOverridden: true, cwd: ( URI.from({ scheme: folder.uri.scheme, path: resolvedCwdConfig })) }
        : { folder, isAbsolute: false, isOverridden: true, cwd: URI.joinPath(folder.uri, resolvedCwdConfig) };
}
function shrinkWorkspaceFolderCwdPairs(pairs) {
    const map = ( new Map());
    for (const pair of pairs) {
        const key = ( pair.cwd.toString());
        const value = map.get(key);
        if (!value || key === ( pair.folder.uri.toString())) {
            map.set(key, pair);
        }
    }
    const selectedPairs = ( new Set(( map.values())));
    const selectedPairsInOrder = pairs.filter(x => ( selectedPairs.has(x)));
    return selectedPairsInOrder;
}
async function focusActiveTerminal(instance, c) {
    if (instance.target === TerminalLocation.Editor) {
        await c.editorService.revealActiveEditor();
        await instance.focusWhenReady(true);
    }
    else {
        await c.groupService.showPanel(true);
    }
}
async function renameWithQuickPick(c, accessor, resource) {
    const instance = getResourceOrActiveInstance(c, resource);
    if (instance) {
        const title = await accessor.get(IQuickInputService).input({
            value: instance.title,
            prompt: ( localize('workbench.action.terminal.rename.prompt', "Enter terminal name")),
        });
        instance.rename(title);
    }
}
function toOptionalUri(obj) {
    return URI.isUri(obj) ? obj : undefined;
}
function toOptionalString(obj) {
    return isString(obj) ? obj : undefined;
}
export { TerminalLaunchHelpAction, getCwdForSplit, refreshTerminalActions, registerActiveInstanceAction, registerActiveXtermAction, registerTerminalAction, registerTerminalActions, shrinkWorkspaceFolderCwdPairs, switchTerminalActionViewItemSeparator, switchTerminalShowTabsTitle, terminalSendSequenceCommand, validateTerminalName };
