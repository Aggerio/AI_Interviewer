import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import { SettingMatchType } from '../../../services/preferences/common/preferences.js';
import { distinct } from 'monaco-editor/esm/vs/base/common/arrays.js';
import * as strings from 'monaco-editor/esm/vs/base/common/strings.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { Extensions } from 'monaco-editor/esm/vs/platform/configuration/common/configurationRegistry.js';
import { matchesWords, or, matchesCamelCase, matchesContiguousSubString, matchesPrefix } from 'monaco-editor/esm/vs/base/common/filters.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { IExtensionManagementService } from '../../../../platform/extensionManagement/common/extensionManagement.js';
import { IWorkbenchExtensionEnablementService } from '../../../services/extensionManagement/common/extensionManagement.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { IProductService } from 'monaco-editor/esm/vs/platform/product/common/productService.js';
let PreferencesSearchService = class PreferencesSearchService extends Disposable {
    constructor(instantiationService, configurationService, productService, extensionManagementService, extensionEnablementService) {
        super();
        this.instantiationService = instantiationService;
        this.configurationService = configurationService;
        this.productService = productService;
        this.extensionManagementService = extensionManagementService;
        this.extensionEnablementService = extensionEnablementService;
        this._installedExtensions = this.extensionManagementService.getInstalled(1 ).then(exts => {
            return exts
                .filter(ext => this.extensionEnablementService.isEnabled(ext))
                .filter(ext => ext.manifest && ext.manifest.contributes && ext.manifest.contributes.configuration)
                .filter(ext => !!ext.identifier.uuid);
        });
    }
    get remoteSearchAllowed() {
        const workbenchSettings = this.configurationService.getValue().workbench.settings;
        if (!workbenchSettings.enableNaturalLanguageSearch) {
            return false;
        }
        return !!this._endpoint.urlBase;
    }
    get _endpoint() {
        const workbenchSettings = this.configurationService.getValue().workbench.settings;
        if (workbenchSettings.naturalLanguageSearchEndpoint) {
            return {
                urlBase: workbenchSettings.naturalLanguageSearchEndpoint,
                key: workbenchSettings.naturalLanguageSearchKey
            };
        }
        else {
            return {
                urlBase: this.productService.settingsSearchUrl
            };
        }
    }
    getRemoteSearchProvider(filter, newExtensionsOnly = false) {
        return undefined;
    }
    getLocalSearchProvider(filter) {
        return this.instantiationService.createInstance(LocalSearchProvider, filter);
    }
};
PreferencesSearchService = ( __decorate([
    ( __param(0, IInstantiationService)),
    ( __param(1, IConfigurationService)),
    ( __param(2, IProductService)),
    ( __param(3, IExtensionManagementService)),
    ( __param(4, IWorkbenchExtensionEnablementService))
], PreferencesSearchService));
let LocalSearchProvider = class LocalSearchProvider {
    static { this.EXACT_MATCH_SCORE = 10000; }
    static { this.START_SCORE = 1000; }
    constructor(_filter, configurationService) {
        this._filter = _filter;
        this.configurationService = configurationService;
        this._filter = this._filter
            .replace(/[":]/g, ' ')
            .replace(/  /g, ' ')
            .trim();
    }
    searchModel(preferencesModel, token) {
        if (!this._filter) {
            return Promise.resolve(null);
        }
        let orderedScore = LocalSearchProvider.START_SCORE;
        const settingMatcher = (setting) => {
            const { matches, matchType } = ( new SettingMatches(
                this._filter,
                setting,
                true,
                true,
                (filter, setting) => preferencesModel.findValueMatches(filter, setting),
                this.configurationService
            ));
            const score = this._filter === setting.key ?
                LocalSearchProvider.EXACT_MATCH_SCORE :
                orderedScore--;
            return matches && matches.length ?
                {
                    matches,
                    matchType,
                    score
                } :
                null;
        };
        const filterMatches = preferencesModel.filterSettings(this._filter, this.getGroupFilter(this._filter), settingMatcher);
        if (filterMatches[0] && filterMatches[0].score === LocalSearchProvider.EXACT_MATCH_SCORE) {
            return Promise.resolve({
                filterMatches: filterMatches.slice(0, 1),
                exactMatch: true
            });
        }
        else {
            return Promise.resolve({
                filterMatches
            });
        }
    }
    getGroupFilter(filter) {
        const regex = strings.createRegExp(filter, false, { global: true });
        return (group) => {
            return regex.test(group.title);
        };
    }
};
LocalSearchProvider = ( __decorate([
    ( __param(1, IConfigurationService))
], LocalSearchProvider));
let SettingMatches = class SettingMatches {
    constructor(searchString, setting, requireFullQueryMatch, searchDescription, valuesMatcher, configurationService) {
        this.requireFullQueryMatch = requireFullQueryMatch;
        this.searchDescription = searchDescription;
        this.valuesMatcher = valuesMatcher;
        this.configurationService = configurationService;
        this.descriptionMatchingWords = ( new Map());
        this.keyMatchingWords = ( new Map());
        this.valueMatchingWords = ( new Map());
        this.matchType = SettingMatchType.None;
        this.matches = distinct(this._findMatchesInSetting(searchString, setting), (match) => `${match.startLineNumber}_${match.startColumn}_${match.endLineNumber}_${match.endColumn}_`);
    }
    _findMatchesInSetting(searchString, setting) {
        const result = this._doFindMatchesInSetting(searchString, setting);
        if (setting.overrides && setting.overrides.length) {
            for (const subSetting of setting.overrides) {
                const subSettingMatches = ( new SettingMatches(
                    searchString,
                    subSetting,
                    this.requireFullQueryMatch,
                    this.searchDescription,
                    this.valuesMatcher,
                    this.configurationService
                ));
                const words = searchString.split(' ');
                const descriptionRanges = this.getRangesForWords(words, this.descriptionMatchingWords, [subSettingMatches.descriptionMatchingWords, subSettingMatches.keyMatchingWords, subSettingMatches.valueMatchingWords]);
                const keyRanges = this.getRangesForWords(words, this.keyMatchingWords, [subSettingMatches.descriptionMatchingWords, subSettingMatches.keyMatchingWords, subSettingMatches.valueMatchingWords]);
                const subSettingKeyRanges = this.getRangesForWords(words, subSettingMatches.keyMatchingWords, [this.descriptionMatchingWords, this.keyMatchingWords, subSettingMatches.valueMatchingWords]);
                const subSettingValueRanges = this.getRangesForWords(words, subSettingMatches.valueMatchingWords, [this.descriptionMatchingWords, this.keyMatchingWords, subSettingMatches.keyMatchingWords]);
                result.push(...descriptionRanges, ...keyRanges, ...subSettingKeyRanges, ...subSettingValueRanges);
                result.push(...subSettingMatches.matches);
                this.refreshMatchType(keyRanges.length + subSettingKeyRanges.length);
                this.matchType |= subSettingMatches.matchType;
            }
        }
        return result;
    }
    _doFindMatchesInSetting(searchString, setting) {
        const registry = ( Registry.as(Extensions.Configuration)).getConfigurationProperties();
        const schema = registry[setting.key];
        const words = searchString.split(' ');
        const settingKeyAsWords = setting.key.split('.').join(' ');
        const settingValue = this.configurationService.getValue(setting.key);
        for (const word of words) {
            if (this.searchDescription) {
                for (let lineIndex = 0; lineIndex < setting.description.length; lineIndex++) {
                    const descriptionMatches = matchesWords(word, setting.description[lineIndex], true);
                    if (descriptionMatches) {
                        this.descriptionMatchingWords.set(word, ( descriptionMatches.map(match => this.toDescriptionRange(setting, match, lineIndex))));
                    }
                    this.checkForWholeWordMatchType(word, setting.description[lineIndex]);
                }
            }
            const keyMatches = or(matchesWords, matchesCamelCase)(word, settingKeyAsWords);
            if (keyMatches) {
                this.keyMatchingWords.set(word, ( keyMatches.map(match => this.toKeyRange(setting, match))));
            }
            this.checkForWholeWordMatchType(word, settingKeyAsWords);
            const valueMatches = typeof settingValue === 'string' ? matchesContiguousSubString(word, settingValue) : null;
            if (valueMatches) {
                this.valueMatchingWords.set(word, ( valueMatches.map(match => this.toValueRange(setting, match))));
            }
            else if (schema && schema.enum && ( schema.enum.some(
                enumValue => typeof enumValue === 'string' && !!matchesContiguousSubString(word, enumValue)
            ))) {
                this.valueMatchingWords.set(word, []);
            }
            if (typeof settingValue === 'string') {
                this.checkForWholeWordMatchType(word, settingValue);
            }
        }
        const descriptionRanges = [];
        if (this.searchDescription) {
            for (let lineIndex = 0; lineIndex < setting.description.length; lineIndex++) {
                const matches = or(matchesContiguousSubString)(searchString, setting.description[lineIndex] || '') || [];
                descriptionRanges.push(...( matches.map(match => this.toDescriptionRange(setting, match, lineIndex))));
            }
            if (descriptionRanges.length === 0) {
                descriptionRanges.push(...this.getRangesForWords(words, this.descriptionMatchingWords, [this.keyMatchingWords, this.valueMatchingWords]));
            }
        }
        const keyMatches = or(matchesPrefix, matchesContiguousSubString)(searchString, setting.key);
        const keyRanges = keyMatches ? ( keyMatches.map(match => this.toKeyRange(setting, match))) : this.getRangesForWords(words, this.keyMatchingWords, [this.descriptionMatchingWords, this.valueMatchingWords]);
        let valueRanges = [];
        if (typeof settingValue === 'string' && settingValue) {
            const valueMatches = or(matchesPrefix, matchesContiguousSubString)(searchString, settingValue);
            valueRanges = valueMatches ? ( valueMatches.map(match => this.toValueRange(setting, match))) : this.getRangesForWords(words, this.valueMatchingWords, [this.keyMatchingWords, this.descriptionMatchingWords]);
        }
        else {
            valueRanges = this.valuesMatcher(searchString, setting);
        }
        this.refreshMatchType(keyRanges.length);
        return [...descriptionRanges, ...keyRanges, ...valueRanges];
    }
    checkForWholeWordMatchType(singleWordQuery, lineToSearch) {
        singleWordQuery = singleWordQuery.toLowerCase().replace(/[\s-\._]+$/, '');
        lineToSearch = lineToSearch.toLowerCase();
        const singleWordRegex = ( new RegExp(`\\b${strings.escapeRegExpCharacters(singleWordQuery)}\\b`));
        if (singleWordRegex.test(lineToSearch)) {
            this.matchType |= SettingMatchType.WholeWordMatch;
        }
    }
    refreshMatchType(keyRangesLength) {
        if (keyRangesLength) {
            this.matchType |= SettingMatchType.KeyMatch;
        }
    }
    getRangesForWords(words, from, others) {
        const result = [];
        for (const word of words) {
            const ranges = from.get(word);
            if (ranges) {
                result.push(...ranges);
            }
            else if (this.requireFullQueryMatch && others.every(o => !( o.has(word)))) {
                return [];
            }
        }
        return result;
    }
    toKeyRange(setting, match) {
        return {
            startLineNumber: setting.keyRange.startLineNumber,
            startColumn: setting.keyRange.startColumn + match.start,
            endLineNumber: setting.keyRange.startLineNumber,
            endColumn: setting.keyRange.startColumn + match.end
        };
    }
    toDescriptionRange(setting, match, lineIndex) {
        return {
            startLineNumber: setting.descriptionRanges[lineIndex].startLineNumber,
            startColumn: setting.descriptionRanges[lineIndex].startColumn + match.start,
            endLineNumber: setting.descriptionRanges[lineIndex].endLineNumber,
            endColumn: setting.descriptionRanges[lineIndex].startColumn + match.end
        };
    }
    toValueRange(setting, match) {
        return {
            startLineNumber: setting.valueRange.startLineNumber,
            startColumn: setting.valueRange.startColumn + match.start + 1,
            endLineNumber: setting.valueRange.startLineNumber,
            endColumn: setting.valueRange.startColumn + match.end + 1
        };
    }
};
SettingMatches = ( __decorate([
    ( __param(5, IConfigurationService))
], SettingMatches));
export { LocalSearchProvider, PreferencesSearchService, SettingMatches };
