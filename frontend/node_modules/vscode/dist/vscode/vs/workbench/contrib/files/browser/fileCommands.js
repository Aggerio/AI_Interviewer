import * as nls from 'monaco-editor/esm/vs/nls.js';
import { EditorResourceAccessor, SideBySideEditor } from '../../../common/editor.js';
import { SideBySideEditorInput } from '../../../common/editor/sideBySideEditorInput.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IWorkspaceContextService } from 'monaco-editor/esm/vs/platform/workspace/common/workspace.js';
import { ExplorerFocusCondition, FilesExplorerFocusCondition, ExplorerFolderContext, TextFileContentProvider, VIEW_ID, ExplorerCompressedFocusContext, ExplorerCompressedFirstFocusContext, VIEWLET_ID, ExplorerCompressedLastFocusContext } from '../common/files.js';
import { IClipboardService } from 'monaco-editor/esm/vs/platform/clipboard/common/clipboardService.js';
import { toErrorMessage } from 'monaco-editor/esm/vs/base/common/errorMessage.js';
import { IListService } from 'monaco-editor/esm/vs/platform/list/browser/listService.js';
import { CommandsRegistry, ICommandService } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { ContextKeyExpr, IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { IFileService } from 'monaco-editor/esm/vs/platform/files/common/files.js';
import { KeybindingsRegistry } from 'monaco-editor/esm/vs/platform/keybinding/common/keybindingsRegistry.js';
import { KeyChord } from 'monaco-editor/esm/vs/base/common/keyCodes.js';
import { isWeb, isWindows } from 'monaco-editor/esm/vs/base/common/platform.js';
import { ITextModelService } from 'monaco-editor/esm/vs/editor/common/services/resolverService.js';
import { IExplorerService, getMultiSelectedResources, getResourceForCommand, getOpenEditorsViewMultiSelection } from './files.js';
import { IWorkspaceEditingService } from '../../../services/workspaces/common/workspaceEditing.js';
import { getMultiSelectedEditorContexts } from '../../../browser/parts/editor/editorCommands.js';
import { Schemas } from 'monaco-editor/esm/vs/base/common/network.js';
import { INotificationService, Severity } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { EditorContextKeys } from 'monaco-editor/esm/vs/editor/common/editorContextKeys.js';
import { IEditorService, SIDE_GROUP } from '../../../services/editor/common/editorService.js';
import { IEditorGroupsService } from '../../../services/editor/common/editorGroupsService.js';
import { ILabelService } from 'monaco-editor/esm/vs/platform/label/common/label.js';
import { basename, joinPath, isEqual } from 'monaco-editor/esm/vs/base/common/resources.js';
import { dispose } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { coalesce } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { ICodeEditorService } from 'monaco-editor/esm/vs/editor/browser/services/codeEditorService.js';
import { EmbeddedCodeEditorWidget } from 'monaco-editor/esm/vs/editor/browser/widget/embeddedCodeEditorWidget.js';
import { ITextFileService } from '../../../services/textfile/common/textfiles.js';
import { IUriIdentityService } from 'monaco-editor/esm/vs/platform/uriIdentity/common/uriIdentity.js';
import { isCancellationError } from 'monaco-editor/esm/vs/base/common/errors.js';
import { toAction } from 'monaco-editor/esm/vs/base/common/actions.js';
import { EditorResolution, EditorOpenSource } from 'monaco-editor/esm/vs/platform/editor/common/editor.js';
import { hash } from 'monaco-editor/esm/vs/base/common/hash.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { IPaneCompositePartService } from '../../../services/panecomposite/browser/panecomposite.js';
import { IViewsService } from '../../../common/views.js';
import { OPEN_TO_SIDE_COMMAND_ID, COMPARE_WITH_SAVED_COMMAND_ID, SELECT_FOR_COMPARE_COMMAND_ID, ResourceSelectedForCompareContext, COMPARE_SELECTED_COMMAND_ID, COMPARE_RESOURCE_COMMAND_ID, COPY_PATH_COMMAND_ID, COPY_RELATIVE_PATH_COMMAND_ID, REVEAL_IN_EXPLORER_COMMAND_ID, OPEN_WITH_EXPLORER_COMMAND_ID, SAVE_FILE_COMMAND_ID, SAVE_FILE_WITHOUT_FORMATTING_COMMAND_ID, SAVE_FILE_AS_COMMAND_ID, SAVE_ALL_COMMAND_ID, SAVE_ALL_IN_GROUP_COMMAND_ID, SAVE_FILES_COMMAND_ID, REVERT_FILE_COMMAND_ID, REMOVE_ROOT_FOLDER_COMMAND_ID, PREVIOUS_COMPRESSED_FOLDER, NEXT_COMPRESSED_FOLDER, FIRST_COMPRESSED_FOLDER, LAST_COMPRESSED_FOLDER, NEW_UNTITLED_FILE_COMMAND_ID, NEW_UNTITLED_FILE_LABEL, NEW_FILE_COMMAND_ID } from './fileConstants.js';
import '../../../../../../override/vs/platform/dialogs/common/dialogs.js';
import { RemoveRootFolderAction } from '../../../browser/actions/workspaceActions.js';
import { OpenEditorsView } from './views/openEditorsView.js';
import { IFileDialogService } from '../../../../platform/dialogs/common/dialogs.js';
KeybindingsRegistry.registerCommandAndKeybindingRule({
    weight: 200 ,
    when: ExplorerFocusCondition,
    primary: 2048  | 3 ,
    mac: {
        primary: 256  | 3
    },
    id: OPEN_TO_SIDE_COMMAND_ID, handler: async (accessor, resource) => {
        const editorService = accessor.get(IEditorService);
        const listService = accessor.get(IListService);
        const fileService = accessor.get(IFileService);
        const explorerService = accessor.get(IExplorerService);
        const resources = getMultiSelectedResources(resource, listService, editorService, explorerService);
        if (resources.length) {
            const untitledResources = resources.filter(resource => resource.scheme === Schemas.untitled);
            const fileResources = resources.filter(resource => resource.scheme !== Schemas.untitled);
            const items = await Promise.all(( fileResources.map(async (resource) => {
                const item = explorerService.findClosest(resource);
                if (item) {
                    return item;
                }
                return await fileService.stat(resource);
            })));
            const files = items.filter(i => !i.isDirectory);
            const editors = ( files.map(f => ({
                resource: f.resource,
                options: { pinned: true }
            }))).concat(...( untitledResources.map(
                untitledResource => ({ resource: untitledResource, options: { pinned: true } })
            )));
            await editorService.openEditors(editors, SIDE_GROUP);
        }
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    weight: 200  + 10,
    when: ( ContextKeyExpr.and(FilesExplorerFocusCondition, ( ExplorerFolderContext.toNegated()))),
    primary: 3 ,
    mac: {
        primary: 2048  | 18
    },
    id: 'explorer.openAndPassFocus', handler: async (accessor, _resource) => {
        const editorService = accessor.get(IEditorService);
        const explorerService = accessor.get(IExplorerService);
        const resources = explorerService.getContext(true);
        if (resources.length) {
            await editorService.openEditors(( resources.map(
                r => ({ resource: r.resource, options: { preserveFocus: false, pinned: true } })
            )));
        }
    }
});
const COMPARE_WITH_SAVED_SCHEMA = 'showModifications';
let providerDisposables = [];
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: COMPARE_WITH_SAVED_COMMAND_ID,
    when: undefined,
    weight: 200 ,
    primary: KeyChord(2048  | 41 , 34 ),
    handler: async (accessor, resource) => {
        const instantiationService = accessor.get(IInstantiationService);
        const textModelService = accessor.get(ITextModelService);
        const editorService = accessor.get(IEditorService);
        const fileService = accessor.get(IFileService);
        let registerEditorListener = false;
        if (providerDisposables.length === 0) {
            registerEditorListener = true;
            const provider = instantiationService.createInstance(TextFileContentProvider);
            providerDisposables.push(provider);
            providerDisposables.push(textModelService.registerTextModelContentProvider(COMPARE_WITH_SAVED_SCHEMA, provider));
        }
        const uri = getResourceForCommand(resource, accessor.get(IListService), editorService);
        if (uri && fileService.hasProvider(uri)) {
            const name = basename(uri);
            const editorLabel = ( nls.localize('modifiedLabel', "{0} (in file) â†” {1}", name, name));
            try {
                await TextFileContentProvider.open(uri, COMPARE_WITH_SAVED_SCHEMA, editorLabel, editorService, { pinned: true });
                if (registerEditorListener) {
                    providerDisposables.push(editorService.onDidVisibleEditorsChange(() => {
                        if (!( editorService.editors.some(
                            editor => !!EditorResourceAccessor.getCanonicalUri(editor, { supportSideBySide: SideBySideEditor.SECONDARY, filterByScheme: COMPARE_WITH_SAVED_SCHEMA })
                        ))) {
                            providerDisposables = dispose(providerDisposables);
                        }
                    }));
                }
            }
            catch {
                providerDisposables = dispose(providerDisposables);
            }
        }
    }
});
let globalResourceToCompare;
let resourceSelectedForCompareContext;
CommandsRegistry.registerCommand({
    id: SELECT_FOR_COMPARE_COMMAND_ID,
    handler: (accessor, resource) => {
        const listService = accessor.get(IListService);
        globalResourceToCompare = getResourceForCommand(resource, listService, accessor.get(IEditorService));
        if (!resourceSelectedForCompareContext) {
            resourceSelectedForCompareContext = ResourceSelectedForCompareContext.bindTo(accessor.get(IContextKeyService));
        }
        resourceSelectedForCompareContext.set(true);
    }
});
CommandsRegistry.registerCommand({
    id: COMPARE_SELECTED_COMMAND_ID,
    handler: async (accessor, resource) => {
        const editorService = accessor.get(IEditorService);
        const explorerService = accessor.get(IExplorerService);
        const resources = getMultiSelectedResources(resource, accessor.get(IListService), editorService, explorerService);
        if (resources.length === 2) {
            return editorService.openEditor({
                original: { resource: resources[0] },
                modified: { resource: resources[1] },
                options: { pinned: true }
            });
        }
        return true;
    }
});
CommandsRegistry.registerCommand({
    id: COMPARE_RESOURCE_COMMAND_ID,
    handler: (accessor, resource) => {
        const editorService = accessor.get(IEditorService);
        const listService = accessor.get(IListService);
        const rightResource = getResourceForCommand(resource, listService, editorService);
        if (globalResourceToCompare && rightResource) {
            editorService.openEditor({
                original: { resource: globalResourceToCompare },
                modified: { resource: rightResource },
                options: { pinned: true }
            });
        }
    }
});
async function resourcesToClipboard(resources, relative, clipboardService, labelService, configurationService) {
    if (resources.length) {
        const lineDelimiter = isWindows ? '\r\n' : '\n';
        let separator = undefined;
        if (relative) {
            const relativeSeparator = configurationService.getValue('explorer.copyRelativePathSeparator');
            if (relativeSeparator === '/' || relativeSeparator === '\\') {
                separator = relativeSeparator;
            }
        }
        const text = ( resources.map(
            resource => labelService.getUriLabel(resource, { relative, noPrefix: true, separator })
        )).join(lineDelimiter);
        await clipboardService.writeText(text);
    }
}
const copyPathCommandHandler = async (accessor, resource) => {
    const resources = getMultiSelectedResources(resource, accessor.get(IListService), accessor.get(IEditorService), accessor.get(IExplorerService));
    await resourcesToClipboard(resources, false, accessor.get(IClipboardService), accessor.get(ILabelService), accessor.get(IConfigurationService));
};
KeybindingsRegistry.registerCommandAndKeybindingRule({
    weight: 200 ,
    when: ( EditorContextKeys.focus.toNegated()),
    primary: 2048  | 512  | 33 ,
    win: {
        primary: 1024  | 512  | 33
    },
    id: COPY_PATH_COMMAND_ID,
    handler: copyPathCommandHandler
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    weight: 200 ,
    when: EditorContextKeys.focus,
    primary: KeyChord(2048  | 41 , 2048  | 512  | 33 ),
    win: {
        primary: 1024  | 512  | 33
    },
    id: COPY_PATH_COMMAND_ID,
    handler: copyPathCommandHandler
});
const copyRelativePathCommandHandler = async (accessor, resource) => {
    const resources = getMultiSelectedResources(resource, accessor.get(IListService), accessor.get(IEditorService), accessor.get(IExplorerService));
    await resourcesToClipboard(resources, true, accessor.get(IClipboardService), accessor.get(ILabelService), accessor.get(IConfigurationService));
};
KeybindingsRegistry.registerCommandAndKeybindingRule({
    weight: 200 ,
    when: ( EditorContextKeys.focus.toNegated()),
    primary: 2048  | 1024  | 512  | 33 ,
    win: {
        primary: KeyChord(2048  | 41 , 2048  | 1024  | 33 )
    },
    id: COPY_RELATIVE_PATH_COMMAND_ID,
    handler: copyRelativePathCommandHandler
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    weight: 200 ,
    when: EditorContextKeys.focus,
    primary: KeyChord(2048  | 41 , 2048  | 1024  | 512  | 33 ),
    win: {
        primary: KeyChord(2048  | 41 , 2048  | 1024  | 33 )
    },
    id: COPY_RELATIVE_PATH_COMMAND_ID,
    handler: copyRelativePathCommandHandler
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    weight: 200 ,
    when: undefined,
    primary: KeyChord(2048  | 41 , 46 ),
    id: 'workbench.action.files.copyPathOfActiveFile',
    handler: async (accessor) => {
        const editorService = accessor.get(IEditorService);
        const activeInput = editorService.activeEditor;
        const resource = EditorResourceAccessor.getOriginalUri(activeInput, { supportSideBySide: SideBySideEditor.PRIMARY });
        const resources = resource ? [resource] : [];
        await resourcesToClipboard(resources, false, accessor.get(IClipboardService), accessor.get(ILabelService), accessor.get(IConfigurationService));
    }
});
CommandsRegistry.registerCommand({
    id: REVEAL_IN_EXPLORER_COMMAND_ID,
    handler: async (accessor, resource) => {
        const viewService = accessor.get(IViewsService);
        const contextService = accessor.get(IWorkspaceContextService);
        const explorerService = accessor.get(IExplorerService);
        const uri = getResourceForCommand(resource, accessor.get(IListService), accessor.get(IEditorService));
        if (uri && contextService.isInsideWorkspace(uri)) {
            const explorerView = await viewService.openView(VIEW_ID, false);
            if (explorerView) {
                explorerView.setExpanded(true);
                await explorerService.select(uri, 'force');
                explorerView.focus();
            }
        }
        else {
            const openEditorsView = await viewService.openView(OpenEditorsView.ID, false);
            if (openEditorsView) {
                openEditorsView.setExpanded(true);
                openEditorsView.focus();
            }
        }
    }
});
CommandsRegistry.registerCommand({
    id: OPEN_WITH_EXPLORER_COMMAND_ID,
    handler: async (accessor, resource) => {
        const editorService = accessor.get(IEditorService);
        const uri = getResourceForCommand(resource, accessor.get(IListService), accessor.get(IEditorService));
        if (uri) {
            return editorService.openEditor({ resource: uri, options: { override: EditorResolution.PICK, source: EditorOpenSource.USER } });
        }
        return undefined;
    }
});
async function saveSelectedEditors(accessor, options) {
    const listService = accessor.get(IListService);
    const editorGroupService = accessor.get(IEditorGroupsService);
    const codeEditorService = accessor.get(ICodeEditorService);
    const textFileService = accessor.get(ITextFileService);
    let editors = getOpenEditorsViewMultiSelection(listService);
    if (!editors) {
        const activeGroup = editorGroupService.activeGroup;
        if (activeGroup.activeEditor) {
            editors = [];
            if (activeGroup.activeEditor instanceof SideBySideEditorInput &&
                !options?.saveAs && !(activeGroup.activeEditor.primary.hasCapability(4 ) || activeGroup.activeEditor.secondary.hasCapability(4 ))) {
                editors.push({ groupId: activeGroup.id, editor: activeGroup.activeEditor.primary });
                editors.push({ groupId: activeGroup.id, editor: activeGroup.activeEditor.secondary });
            }
            else {
                editors.push({ groupId: activeGroup.id, editor: activeGroup.activeEditor });
            }
        }
    }
    if (!editors || editors.length === 0) {
        return;
    }
    await doSaveEditors(accessor, editors, options);
    const focusedCodeEditor = codeEditorService.getFocusedCodeEditor();
    if (focusedCodeEditor instanceof EmbeddedCodeEditorWidget) {
        const resource = focusedCodeEditor.getModel()?.uri;
        if (resource && !( editors.some(
            ({ editor }) => isEqual(EditorResourceAccessor.getCanonicalUri(editor, { supportSideBySide: SideBySideEditor.PRIMARY }), resource)
        ))) {
            const model = textFileService.files.get(resource);
            if (!model?.isReadonly()) {
                await textFileService.save(resource, options);
            }
        }
    }
}
function saveDirtyEditorsOfGroups(accessor, groups, options) {
    const dirtyEditors = [];
    for (const group of groups) {
        for (const editor of group.getEditors(0 )) {
            if (editor.isDirty()) {
                dirtyEditors.push({ groupId: group.id, editor });
            }
        }
    }
    return doSaveEditors(accessor, dirtyEditors, options);
}
async function doSaveEditors(accessor, editors, options) {
    const editorService = accessor.get(IEditorService);
    const notificationService = accessor.get(INotificationService);
    const instantiationService = accessor.get(IInstantiationService);
    try {
        await editorService.save(editors, options);
    }
    catch (error) {
        if (!isCancellationError(error)) {
            notificationService.notify({
                id: ( editors.map(({ editor }) => hash(editor.resource?.toString()))).join(),
                severity: Severity.Error,
                message: ( nls.localize(
                    { key: 'genericSaveError', comment: ['{0} is the resource that failed to save and {1} the error message'] },
                    "Failed to save '{0}': {1}",
                    ( editors.map(({ editor }) => editor.getName())).join(', '),
                    toErrorMessage(error, false)
                )),
                actions: {
                    primary: [
                        toAction({ id: 'workbench.action.files.saveEditors', label: ( nls.localize('retry', "Retry")), run: () => instantiationService.invokeFunction(accessor => doSaveEditors(accessor, editors, options)) }),
                        toAction({ id: 'workbench.action.files.revertEditors', label: ( nls.localize('discard', "Discard")), run: () => editorService.revert(editors) })
                    ]
                }
            });
        }
    }
}
KeybindingsRegistry.registerCommandAndKeybindingRule({
    when: undefined,
    weight: 200 ,
    primary: 2048  | 49 ,
    id: SAVE_FILE_COMMAND_ID,
    handler: accessor => {
        return saveSelectedEditors(accessor, { reason: 1 , force: true  });
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    when: undefined,
    weight: 200 ,
    primary: KeyChord(2048  | 41 , 49 ),
    win: { primary: KeyChord(2048  | 41 , 2048  | 1024  | 49 ) },
    id: SAVE_FILE_WITHOUT_FORMATTING_COMMAND_ID,
    handler: accessor => {
        return saveSelectedEditors(accessor, { reason: 1 , force: true , skipSaveParticipants: true });
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: SAVE_FILE_AS_COMMAND_ID,
    weight: 200 ,
    when: undefined,
    primary: 2048  | 1024  | 49 ,
    handler: accessor => {
        return saveSelectedEditors(accessor, { reason: 1 , saveAs: true });
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    when: undefined,
    weight: 200 ,
    primary: undefined,
    mac: { primary: 2048  | 512  | 49  },
    win: { primary: KeyChord(2048  | 41 , 49 ) },
    id: SAVE_ALL_COMMAND_ID,
    handler: accessor => {
        return saveDirtyEditorsOfGroups(accessor, accessor.get(IEditorGroupsService).getGroups(1 ), { reason: 1  });
    }
});
CommandsRegistry.registerCommand({
    id: SAVE_ALL_IN_GROUP_COMMAND_ID,
    handler: (accessor, _, editorContext) => {
        const editorGroupService = accessor.get(IEditorGroupsService);
        const contexts = getMultiSelectedEditorContexts(editorContext, accessor.get(IListService), accessor.get(IEditorGroupsService));
        let groups = undefined;
        if (!contexts.length) {
            groups = editorGroupService.getGroups(1 );
        }
        else {
            groups = coalesce(( contexts.map(context => editorGroupService.getGroup(context.groupId))));
        }
        return saveDirtyEditorsOfGroups(accessor, groups, { reason: 1  });
    }
});
CommandsRegistry.registerCommand({
    id: SAVE_FILES_COMMAND_ID,
    handler: async (accessor) => {
        const editorService = accessor.get(IEditorService);
        const res = await editorService.saveAll({ includeUntitled: false, reason: 1  });
        return res.success;
    }
});
CommandsRegistry.registerCommand({
    id: REVERT_FILE_COMMAND_ID,
    handler: async (accessor) => {
        const notificationService = accessor.get(INotificationService);
        const listService = accessor.get(IListService);
        const editorGroupService = accessor.get(IEditorGroupsService);
        const editorService = accessor.get(IEditorService);
        let editors = getOpenEditorsViewMultiSelection(listService);
        if (!editors) {
            const activeGroup = editorGroupService.activeGroup;
            if (activeGroup.activeEditor) {
                editors = [{ groupId: activeGroup.id, editor: activeGroup.activeEditor }];
            }
        }
        if (!editors || editors.length === 0) {
            return;
        }
        try {
            await editorService.revert(editors.filter(({ editor }) => !editor.hasCapability(4 ) ), { force: true });
        }
        catch (error) {
            notificationService.error(( nls.localize('genericRevertError', "Failed to revert '{0}': {1}", ( editors.map(({ editor }) => editor.getName())).join(', '), toErrorMessage(error, false))));
        }
    }
});
CommandsRegistry.registerCommand({
    id: REMOVE_ROOT_FOLDER_COMMAND_ID,
    handler: (accessor, resource) => {
        const workspaceEditingService = accessor.get(IWorkspaceEditingService);
        const contextService = accessor.get(IWorkspaceContextService);
        const uriIdentityService = accessor.get(IUriIdentityService);
        const workspace = contextService.getWorkspace();
        const resources = getMultiSelectedResources(resource, accessor.get(IListService), accessor.get(IEditorService), accessor.get(IExplorerService)).filter(resource => ( workspace.folders.some(folder => uriIdentityService.extUri.isEqual(folder.uri, resource)))
        );
        if (resources.length === 0) {
            const commandService = accessor.get(ICommandService);
            return commandService.executeCommand(RemoveRootFolderAction.ID);
        }
        return workspaceEditingService.removeFolders(resources);
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    weight: 200  + 10,
    when: ( ContextKeyExpr.and(
        FilesExplorerFocusCondition,
        ExplorerCompressedFocusContext,
        ( ExplorerCompressedFirstFocusContext.negate())
    )),
    primary: 15 ,
    id: PREVIOUS_COMPRESSED_FOLDER,
    handler: accessor => {
        const paneCompositeService = accessor.get(IPaneCompositePartService);
        const viewlet = paneCompositeService.getActivePaneComposite(0 );
        if (viewlet?.getId() !== VIEWLET_ID) {
            return;
        }
        const explorer = viewlet.getViewPaneContainer();
        const view = explorer.getExplorerView();
        view.previousCompressedStat();
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    weight: 200  + 10,
    when: ( ContextKeyExpr.and(
        FilesExplorerFocusCondition,
        ExplorerCompressedFocusContext,
        ( ExplorerCompressedLastFocusContext.negate())
    )),
    primary: 17 ,
    id: NEXT_COMPRESSED_FOLDER,
    handler: accessor => {
        const paneCompositeService = accessor.get(IPaneCompositePartService);
        const viewlet = paneCompositeService.getActivePaneComposite(0 );
        if (viewlet?.getId() !== VIEWLET_ID) {
            return;
        }
        const explorer = viewlet.getViewPaneContainer();
        const view = explorer.getExplorerView();
        view.nextCompressedStat();
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    weight: 200  + 10,
    when: ( ContextKeyExpr.and(
        FilesExplorerFocusCondition,
        ExplorerCompressedFocusContext,
        ( ExplorerCompressedFirstFocusContext.negate())
    )),
    primary: 14 ,
    id: FIRST_COMPRESSED_FOLDER,
    handler: accessor => {
        const paneCompositeService = accessor.get(IPaneCompositePartService);
        const viewlet = paneCompositeService.getActivePaneComposite(0 );
        if (viewlet?.getId() !== VIEWLET_ID) {
            return;
        }
        const explorer = viewlet.getViewPaneContainer();
        const view = explorer.getExplorerView();
        view.firstCompressedStat();
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    weight: 200  + 10,
    when: ( ContextKeyExpr.and(
        FilesExplorerFocusCondition,
        ExplorerCompressedFocusContext,
        ( ExplorerCompressedLastFocusContext.negate())
    )),
    primary: 13 ,
    id: LAST_COMPRESSED_FOLDER,
    handler: accessor => {
        const paneCompositeService = accessor.get(IPaneCompositePartService);
        const viewlet = paneCompositeService.getActivePaneComposite(0 );
        if (viewlet?.getId() !== VIEWLET_ID) {
            return;
        }
        const explorer = viewlet.getViewPaneContainer();
        const view = explorer.getExplorerView();
        view.lastCompressedStat();
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    weight: 200 ,
    when: null,
    primary: isWeb ? ((isWindows ? KeyChord(2048  | 41 , 44 ) : 2048  | 512  | 44) ) : 2048  | 44 ,
    secondary: isWeb ? [2048  | 44 ] : undefined,
    id: NEW_UNTITLED_FILE_COMMAND_ID,
    description: {
        description: NEW_UNTITLED_FILE_LABEL,
        args: [
            {
                isOptional: true,
                name: 'New Untitled Text File arguments',
                description: 'The editor view type or language ID if known',
                schema: {
                    'type': 'object',
                    'properties': {
                        'viewType': {
                            'type': 'string'
                        },
                        'languageId': {
                            'type': 'string'
                        }
                    }
                }
            }
        ]
    },
    handler: async (accessor, args) => {
        const editorService = accessor.get(IEditorService);
        await editorService.openEditor({
            resource: undefined,
            options: {
                override: args?.viewType,
                pinned: true
            },
            languageId: args?.languageId,
        });
    }
});
CommandsRegistry.registerCommand({
    id: NEW_FILE_COMMAND_ID,
    handler: async (accessor, args) => {
        const editorService = accessor.get(IEditorService);
        const dialogService = accessor.get(IFileDialogService);
        const fileService = accessor.get(IFileService);
        const createFileLocalized = ( nls.localize('newFileCommand.saveLabel', "Create File"));
        const defaultFileUri = joinPath(await dialogService.defaultFilePath(), args?.fileName ?? 'Untitled.txt');
        const saveUri = await dialogService.showSaveDialog({ saveLabel: createFileLocalized, title: createFileLocalized, defaultUri: defaultFileUri });
        if (!saveUri) {
            return;
        }
        await fileService.createFile(saveUri, undefined, { overwrite: true });
        await editorService.openEditor({
            resource: saveUri,
            options: {
                override: args?.viewType,
                pinned: true
            },
            languageId: args?.languageId,
        });
    }
});
