import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import { Emitter, Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { Disposable, dispose } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { ACTIVE_OUTPUT_CHANNEL_CONTEXT, CONTEXT_ACTIVE_LOG_OUTPUT, OUTPUT_SCHEME, OUTPUT_VIEW_ID, Extensions, LOG_MIME, OUTPUT_MIME, LOG_SCHEME, IOutputService } from '../../../services/output/common/output.js';
import { OutputLinkProvider } from './outputLinkProvider.js';
import { ITextModelService } from 'monaco-editor/esm/vs/editor/common/services/resolverService.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { ILifecycleService } from '../../../services/lifecycle/common/lifecycle.js';
import { IViewsService } from '../../../common/views.js';
import { IOutputChannelModelService } from '../common/outputChannelModelService.js';
import { ILanguageService } from 'monaco-editor/esm/vs/editor/common/languages/language.js';
import { IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
const OUTPUT_ACTIVE_CHANNEL_KEY = 'output.activechannel';
let OutputChannel = class OutputChannel extends Disposable {
    constructor(outputChannelDescriptor, outputChannelModelService, languageService) {
        super();
        this.outputChannelDescriptor = outputChannelDescriptor;
        this.scrollLock = false;
        this.id = outputChannelDescriptor.id;
        this.label = outputChannelDescriptor.label;
        this.uri = ( URI.from({ scheme: OUTPUT_SCHEME, path: this.id }));
        this.model = this._register(outputChannelModelService.createOutputChannelModel(this.id, this.uri, outputChannelDescriptor.languageId ? languageService.createById(outputChannelDescriptor.languageId) : languageService.createByMimeType(outputChannelDescriptor.log ? LOG_MIME : OUTPUT_MIME), outputChannelDescriptor.file));
    }
    append(output) {
        this.model.append(output);
    }
    update(mode, till) {
        this.model.update(mode, till, true);
    }
    clear() {
        this.model.clear();
    }
    replace(value) {
        this.model.replace(value);
    }
};
OutputChannel = ( __decorate([
    ( __param(1, IOutputChannelModelService)),
    ( __param(2, ILanguageService))
], OutputChannel));
let OutputService = class OutputService extends Disposable {
    constructor(storageService, instantiationService, textModelResolverService, logService, lifecycleService, viewsService, contextKeyService) {
        super();
        this.storageService = storageService;
        this.instantiationService = instantiationService;
        this.logService = logService;
        this.lifecycleService = lifecycleService;
        this.viewsService = viewsService;
        this.channels = ( new Map());
        this._onActiveOutputChannel = this._register(( new Emitter()));
        this.onActiveOutputChannel = this._onActiveOutputChannel.event;
        this.activeChannelIdInStorage = this.storageService.get(OUTPUT_ACTIVE_CHANNEL_KEY, 1 , '');
        this.activeOutputChannelContext = ACTIVE_OUTPUT_CHANNEL_CONTEXT.bindTo(contextKeyService);
        this.activeOutputChannelContext.set(this.activeChannelIdInStorage);
        this._register(this.onActiveOutputChannel(channel => this.activeOutputChannelContext.set(channel)));
        this.activeLogOutputChannelContext = CONTEXT_ACTIVE_LOG_OUTPUT.bindTo(contextKeyService);
        textModelResolverService.registerTextModelContentProvider(OUTPUT_SCHEME, this);
        instantiationService.createInstance(OutputLinkProvider);
        const registry = ( Registry.as(Extensions.OutputChannels));
        for (const channelIdentifier of registry.getChannels()) {
            this.onDidRegisterChannel(channelIdentifier.id);
        }
        this._register(registry.onDidRegisterChannel(this.onDidRegisterChannel, this));
        if (!this.activeChannel) {
            const channels = this.getChannelDescriptors();
            this.setActiveChannel(channels && channels.length > 0 ? this.getChannel(channels[0].id) : undefined);
        }
        this._register(Event.filter(this.viewsService.onDidChangeViewVisibility, e => e.id === OUTPUT_VIEW_ID && e.visible)(() => {
            if (this.activeChannel) {
                this.viewsService.getActiveViewWithId(OUTPUT_VIEW_ID)?.showChannel(this.activeChannel, true);
            }
        }));
        this._register(this.lifecycleService.onDidShutdown(() => this.dispose()));
    }
    provideTextContent(resource) {
        const channel = this.getChannel(resource.path);
        if (channel) {
            return channel.model.loadModel();
        }
        return null;
    }
    async showChannel(id, preserveFocus) {
        const channel = this.getChannel(id);
        if (this.activeChannel?.id !== channel?.id) {
            this.setActiveChannel(channel);
            this._onActiveOutputChannel.fire(id);
        }
        const outputView = await this.viewsService.openView(OUTPUT_VIEW_ID, !preserveFocus);
        if (outputView && channel) {
            outputView.showChannel(channel, !!preserveFocus);
        }
    }
    getChannel(id) {
        return this.channels.get(id);
    }
    getChannelDescriptor(id) {
        return ( Registry.as(Extensions.OutputChannels)).getChannel(id);
    }
    getChannelDescriptors() {
        return ( Registry.as(Extensions.OutputChannels)).getChannels();
    }
    getActiveChannel() {
        return this.activeChannel;
    }
    async onDidRegisterChannel(channelId) {
        const channel = this.createChannel(channelId);
        this.channels.set(channelId, channel);
        if (!this.activeChannel || this.activeChannelIdInStorage === channelId) {
            this.setActiveChannel(channel);
            this._onActiveOutputChannel.fire(channelId);
            const outputView = this.viewsService.getActiveViewWithId(OUTPUT_VIEW_ID);
            outputView?.showChannel(channel, true);
        }
    }
    createChannel(id) {
        const channelDisposables = [];
        const channel = this.instantiateChannel(id);
        channel.model.onDispose(() => {
            if (this.activeChannel === channel) {
                const channels = this.getChannelDescriptors();
                const channel = channels.length ? this.getChannel(channels[0].id) : undefined;
                if (channel && this.viewsService.isViewVisible(OUTPUT_VIEW_ID)) {
                    this.showChannel(channel.id);
                }
                else {
                    this.setActiveChannel(undefined);
                }
            }
            ( Registry.as(Extensions.OutputChannels)).removeChannel(id);
            dispose(channelDisposables);
        }, channelDisposables);
        return channel;
    }
    instantiateChannel(id) {
        const channelData = ( Registry.as(Extensions.OutputChannels)).getChannel(id);
        if (!channelData) {
            this.logService.error(`Channel '${id}' is not registered yet`);
            throw new Error(`Channel '${id}' is not registered yet`);
        }
        return this.instantiationService.createInstance(OutputChannel, channelData);
    }
    setActiveChannel(channel) {
        this.activeChannel = channel;
        this.activeLogOutputChannelContext.set(!!channel?.outputChannelDescriptor?.file && channel?.outputChannelDescriptor?.log);
        if (this.activeChannel) {
            this.storageService.store(OUTPUT_ACTIVE_CHANNEL_KEY, this.activeChannel.id, 1 , 1 );
        }
        else {
            this.storageService.remove(OUTPUT_ACTIVE_CHANNEL_KEY, 1 );
        }
    }
};
OutputService = ( __decorate([
    ( __param(0, IStorageService)),
    ( __param(1, IInstantiationService)),
    ( __param(2, ITextModelService)),
    ( __param(3, ILogService)),
    ( __param(4, ILifecycleService)),
    ( __param(5, IViewsService)),
    ( __param(6, IContextKeyService))
], OutputService));
let LogContentProvider = class LogContentProvider {
    constructor(outputService, outputChannelModelService, languageService) {
        this.outputService = outputService;
        this.outputChannelModelService = outputChannelModelService;
        this.languageService = languageService;
        this.channelModels = ( new Map());
    }
    provideTextContent(resource) {
        if (resource.scheme === LOG_SCHEME) {
            const channelModel = this.getChannelModel(resource);
            if (channelModel) {
                return channelModel.loadModel();
            }
        }
        return null;
    }
    getChannelModel(resource) {
        const channelId = resource.path;
        let channelModel = this.channelModels.get(channelId);
        if (!channelModel) {
            const channelDisposables = [];
            const outputChannelDescriptor = this.outputService.getChannelDescriptors().filter(({ id }) => id === channelId)[0];
            if (outputChannelDescriptor && outputChannelDescriptor.file) {
                channelModel = this.outputChannelModelService.createOutputChannelModel(channelId, resource, outputChannelDescriptor.languageId ? this.languageService.createById(outputChannelDescriptor.languageId) : this.languageService.createByMimeType(outputChannelDescriptor.log ? LOG_MIME : OUTPUT_MIME), outputChannelDescriptor.file);
                channelModel.onDispose(() => dispose(channelDisposables), channelDisposables);
                this.channelModels.set(channelId, channelModel);
            }
        }
        return channelModel;
    }
};
LogContentProvider = ( __decorate([
    ( __param(0, IOutputService)),
    ( __param(1, IOutputChannelModelService)),
    ( __param(2, ILanguageService))
], LogContentProvider));
export { LogContentProvider, OutputService };
