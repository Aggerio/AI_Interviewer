import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { PickerQuickAccessProvider, TriggerAction } from 'monaco-editor/esm/vs/platform/quickinput/browser/pickerQuickAccess.js';
import { matchesFuzzy } from 'monaco-editor/esm/vs/base/common/filters.js';
import { ITerminalEditorService, ITerminalGroupService } from './terminal.js';
import { ICommandService } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { IThemeService } from 'monaco-editor/esm/vs/platform/theme/common/themeService.js';
import { ThemeIcon } from 'monaco-editor/esm/vs/base/common/themables.js';
import { renameTerminalIcon, killTerminalIcon } from './terminalIcons.js';
import { getIconId, getColorClass, getUriClasses } from './terminalIcon.js';
import { terminalStrings } from '../common/terminalStrings.js';
import { TerminalLocation } from '../../../../platform/terminal/common/terminal.js';
import { IEditorService } from '../../../services/editor/common/editorService.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
let terminalPicks = [];
let TerminalQuickAccessProvider = class TerminalQuickAccessProvider extends PickerQuickAccessProvider {
    static { this.PREFIX = 'term '; }
    constructor(_editorService, _terminalService, _terminalEditorService, _terminalGroupService, _commandService, _themeService, _instantiationService) {
        super(TerminalQuickAccessProvider.PREFIX, { canAcceptInBackground: true });
        this._editorService = _editorService;
        this._terminalService = _terminalService;
        this._terminalEditorService = _terminalEditorService;
        this._terminalGroupService = _terminalGroupService;
        this._commandService = _commandService;
        this._themeService = _themeService;
        this._instantiationService = _instantiationService;
    }
    _getPicks(filter) {
        terminalPicks = [];
        terminalPicks.push({ type: 'separator', label: 'panel' });
        const terminalGroups = this._terminalGroupService.groups;
        for (let groupIndex = 0; groupIndex < terminalGroups.length; groupIndex++) {
            const terminalGroup = terminalGroups[groupIndex];
            for (let terminalIndex = 0; terminalIndex < terminalGroup.terminalInstances.length; terminalIndex++) {
                const terminal = terminalGroup.terminalInstances[terminalIndex];
                const pick = this._createPick(terminal, terminalIndex, filter, { groupIndex, groupSize: terminalGroup.terminalInstances.length });
                if (pick) {
                    terminalPicks.push(pick);
                }
            }
        }
        if (terminalPicks.length > 0) {
            terminalPicks.push({ type: 'separator', label: 'editor' });
        }
        const terminalEditors = this._terminalEditorService.instances;
        for (let editorIndex = 0; editorIndex < terminalEditors.length; editorIndex++) {
            const term = terminalEditors[editorIndex];
            term.target = TerminalLocation.Editor;
            const pick = this._createPick(term, editorIndex, filter);
            if (pick) {
                terminalPicks.push(pick);
            }
        }
        if (terminalPicks.length > 0) {
            terminalPicks.push({ type: 'separator' });
        }
        const createTerminalLabel = ( localize("workbench.action.terminal.newplus", "Create New Terminal"));
        terminalPicks.push({
            label: `$(plus) ${createTerminalLabel}`,
            ariaLabel: createTerminalLabel,
            accept: () => this._commandService.executeCommand("workbench.action.terminal.new" )
        });
        const createWithProfileLabel = ( localize(
            "workbench.action.terminal.newWithProfilePlus",
            "Create New Terminal With Profile"
        ));
        terminalPicks.push({
            label: `$(plus) ${createWithProfileLabel}`,
            ariaLabel: createWithProfileLabel,
            accept: () => this._commandService.executeCommand("workbench.action.terminal.newWithProfile" )
        });
        return terminalPicks;
    }
    _createPick(terminal, terminalIndex, filter, groupInfo) {
        const iconId = this._instantiationService.invokeFunction(getIconId, terminal);
        const index = groupInfo
            ? (groupInfo.groupSize > 1
                ? `${groupInfo.groupIndex + 1}.${terminalIndex + 1}`
                : `${groupInfo.groupIndex + 1}`)
            : `${terminalIndex + 1}`;
        const label = `$(${iconId}) ${index}: ${terminal.title}`;
        const iconClasses = [];
        const colorClass = getColorClass(terminal);
        if (colorClass) {
            iconClasses.push(colorClass);
        }
        const uriClasses = getUriClasses(terminal, this._themeService.getColorTheme().type);
        if (uriClasses) {
            iconClasses.push(...uriClasses);
        }
        const highlights = matchesFuzzy(filter, label, true);
        if (highlights) {
            return {
                label,
                description: terminal.description,
                highlights: { label: highlights },
                buttons: [
                    {
                        iconClass: ThemeIcon.asClassName(renameTerminalIcon),
                        tooltip: ( localize('renameTerminal', "Rename Terminal"))
                    },
                    {
                        iconClass: ThemeIcon.asClassName(killTerminalIcon),
                        tooltip: terminalStrings.kill.value
                    }
                ],
                iconClasses,
                trigger: buttonIndex => {
                    switch (buttonIndex) {
                        case 0:
                            this._commandService.executeCommand("workbench.action.terminal.rename" , terminal);
                            return TriggerAction.NO_ACTION;
                        case 1:
                            this._terminalService.safeDisposeTerminal(terminal);
                            return TriggerAction.REMOVE_ITEM;
                    }
                    return TriggerAction.NO_ACTION;
                },
                accept: (keyMod, event) => {
                    if (terminal.target === TerminalLocation.Editor) {
                        const existingEditors = this._editorService.findEditors(terminal.resource);
                        this._terminalEditorService.openEditor(terminal, { viewColumn: existingEditors?.[0].groupId });
                        this._terminalEditorService.setActiveInstance(terminal);
                    }
                    else {
                        this._terminalGroupService.showPanel(!event.inBackground);
                        this._terminalGroupService.setActiveInstance(terminal);
                    }
                }
            };
        }
        return undefined;
    }
};
TerminalQuickAccessProvider = ( __decorate([
    ( __param(0, IEditorService)),
    ( __param(1, ITerminalEditorService)),
    ( __param(2, ITerminalEditorService)),
    ( __param(3, ITerminalGroupService)),
    ( __param(4, ICommandService)),
    ( __param(5, IThemeService)),
    ( __param(6, IInstantiationService))
], TerminalQuickAccessProvider));
export { TerminalQuickAccessProvider };
