import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import { DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { getCodeEditor } from 'monaco-editor/esm/vs/editor/browser/editorBrowser.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { Extensions } from '../../../common/contributions.js';
import { IEditorService } from '../../../services/editor/common/editorService.js';
import { IStatusbarService } from '../../../services/statusbar/browser/statusbar.js';
import { ILanguageDetectionService, LanguageDetectionLanguageEventSource } from '../../../services/languageDetection/common/languageDetectionWorkerService.js';
import { ThrottledDelayer } from 'monaco-editor/esm/vs/base/common/async.js';
import { ILanguageService } from 'monaco-editor/esm/vs/editor/common/languages/language.js';
import { IKeybindingService } from 'monaco-editor/esm/vs/platform/keybinding/common/keybinding.js';
import { registerAction2, Action2 } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { INotificationService } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { ContextKeyExpr } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { NOTEBOOK_EDITOR_EDITABLE } from '../../notebook/common/notebookContextKeys.js';
import { EditorContextKeys } from 'monaco-editor/esm/vs/editor/common/editorContextKeys.js';
import { Schemas } from 'monaco-editor/esm/vs/base/common/network.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
const detectLanguageCommandId = 'editor.detectLanguage';
let LanguageDetectionStatusContribution = class LanguageDetectionStatusContribution {
    static { this._id = 'status.languageDetectionStatus'; }
    constructor(_languageDetectionService, _statusBarService, _configurationService, _editorService, _languageService, _keybindingService) {
        this._languageDetectionService = _languageDetectionService;
        this._statusBarService = _statusBarService;
        this._configurationService = _configurationService;
        this._editorService = _editorService;
        this._languageService = _languageService;
        this._keybindingService = _keybindingService;
        this._disposables = ( new DisposableStore());
        this._delayer = ( new ThrottledDelayer(1000));
        this._renderDisposables = ( new DisposableStore());
        _editorService.onDidActiveEditorChange(() => this._update(true), this, this._disposables);
        this._update(false);
    }
    dispose() {
        this._disposables.dispose();
        this._delayer.dispose();
        this._combinedEntry?.dispose();
        this._renderDisposables.dispose();
    }
    _update(clear) {
        if (clear) {
            this._combinedEntry?.dispose();
            this._combinedEntry = undefined;
        }
        this._delayer.trigger(() => this._doUpdate());
    }
    async _doUpdate() {
        const editor = getCodeEditor(this._editorService.activeTextEditorControl);
        this._renderDisposables.clear();
        editor?.onDidChangeModelLanguage(() => this._update(true), this, this._renderDisposables);
        editor?.onDidChangeModelContent(() => this._update(false), this, this._renderDisposables);
        const editorModel = editor?.getModel();
        const editorUri = editorModel?.uri;
        const existingId = editorModel?.getLanguageId();
        const enablementConfig = this._configurationService.getValue('workbench.editor.languageDetectionHints');
        const enabled = typeof enablementConfig === 'object' && enablementConfig?.untitledEditors;
        const disableLightbulb = !enabled || editorUri?.scheme !== Schemas.untitled || !existingId;
        if (disableLightbulb || !editorUri) {
            this._combinedEntry?.dispose();
            this._combinedEntry = undefined;
        }
        else {
            const lang = await this._languageDetectionService.detectLanguage(editorUri);
            const skip = { 'jsonc': 'json' };
            const existing = editorModel.getLanguageId();
            if (lang && lang !== existing && skip[existing] !== lang) {
                const detectedName = this._languageService.getLanguageName(lang) || lang;
                let tooltip = ( localize('status.autoDetectLanguage', "Accept Detected Language: {0}", detectedName));
                const keybinding = this._keybindingService.lookupKeybinding(detectLanguageCommandId);
                const label = keybinding?.getLabel();
                if (label) {
                    tooltip += ` (${label})`;
                }
                const props = {
                    name: ( localize('langDetection.name', "Language Detection")),
                    ariaLabel: ( localize('langDetection.aria', "Change to Detected Language: {0}", lang)),
                    tooltip,
                    command: detectLanguageCommandId,
                    text: '$(lightbulb-autofix)',
                };
                if (!this._combinedEntry) {
                    this._combinedEntry = this._statusBarService.addEntry(props, LanguageDetectionStatusContribution._id, 1 , { id: 'status.editor.mode', alignment: 1 , compact: true });
                }
                else {
                    this._combinedEntry.update(props);
                }
            }
            else {
                this._combinedEntry?.dispose();
                this._combinedEntry = undefined;
            }
        }
    }
};
LanguageDetectionStatusContribution = ( __decorate([
    ( __param(0, ILanguageDetectionService)),
    ( __param(1, IStatusbarService)),
    ( __param(2, IConfigurationService)),
    ( __param(3, IEditorService)),
    ( __param(4, ILanguageService)),
    ( __param(5, IKeybindingService))
], LanguageDetectionStatusContribution));
( Registry.as(Extensions.Workbench)).registerWorkbenchContribution(LanguageDetectionStatusContribution, 3 );
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: detectLanguageCommandId,
            title: { value: ( localize('detectlang', 'Detect Language from Content')), original: 'Detect Language from Content' },
            f1: true,
            precondition: ( ContextKeyExpr.and(( NOTEBOOK_EDITOR_EDITABLE.toNegated()), EditorContextKeys.editorTextFocus)),
            keybinding: { primary: 34  | 512  | 1024 , weight: 200  }
        });
    }
    async run(accessor) {
        const editorService = accessor.get(IEditorService);
        const languageDetectionService = accessor.get(ILanguageDetectionService);
        const editor = getCodeEditor(editorService.activeTextEditorControl);
        const notificationService = accessor.get(INotificationService);
        const editorUri = editor?.getModel()?.uri;
        if (editorUri) {
            const lang = await languageDetectionService.detectLanguage(editorUri);
            if (lang) {
                editor.getModel()?.setLanguage(lang, LanguageDetectionLanguageEventSource);
            }
            else {
                notificationService.warn(( localize('noDetection', "Unable to detect editor language")));
            }
        }
    }
});
