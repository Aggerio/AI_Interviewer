import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import * as dom from 'monaco-editor/esm/vs/base/browser/dom.js';
import { Gesture } from 'monaco-editor/esm/vs/base/browser/touch.js';
import { ActionBar } from 'monaco-editor/esm/vs/base/browser/ui/actionbar/actionbar.js';
import { IconLabel } from 'monaco-editor/esm/vs/base/browser/ui/iconLabel/iconLabel.js';
import { InputBox } from 'monaco-editor/esm/vs/base/browser/ui/inputbox/inputBox.js';
import { Action } from 'monaco-editor/esm/vs/base/common/actions.js';
import { equals } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { RunOnceScheduler } from 'monaco-editor/esm/vs/base/common/async.js';
import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { MarkdownString } from 'monaco-editor/esm/vs/base/common/htmlContent.js';
import { dispose } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import * as resources from 'monaco-editor/esm/vs/base/common/resources.js';
import { isCodeEditor } from 'monaco-editor/esm/vs/editor/browser/editorBrowser.js';
import { ILanguageService } from 'monaco-editor/esm/vs/editor/common/languages/language.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { createAndFillInActionBarActions, createAndFillInContextMenuActions } from 'monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.js';
import { registerAction2, Action2, MenuId, IMenuService } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { ContextKeyExpr, IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { IContextMenuService, IContextViewService } from 'monaco-editor/esm/vs/platform/contextview/browser/contextView.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IKeybindingService } from 'monaco-editor/esm/vs/platform/keybinding/common/keybinding.js';
import { ILabelService } from 'monaco-editor/esm/vs/platform/label/common/label.js';
import { WorkbenchList } from 'monaco-editor/esm/vs/platform/list/browser/listService.js';
import { IOpenerService } from 'monaco-editor/esm/vs/platform/opener/common/opener.js';
import { ITelemetryService } from 'monaco-editor/esm/vs/platform/telemetry/common/telemetry.js';
import { defaultInputBoxStyles } from 'monaco-editor/esm/vs/platform/theme/browser/defaultStyles.js';
import { IThemeService } from 'monaco-editor/esm/vs/platform/theme/common/themeService.js';
import { ThemeIcon } from 'monaco-editor/esm/vs/base/common/themables.js';
import { ViewAction, ViewPane } from '../../../browser/parts/views/viewPane.js';
import { IViewDescriptorService } from '../../../common/views.js';
import { debugBreakpointUnsupported, logBreakpoint, conditionalBreakpoint, watchExpressionsAddFuncBreakpoint, breakpointsActivate, breakpointsRemoveAll, dataBreakpoint, functionBreakpoint, breakpoint } from './debugIcons.js';
import { BREAKPOINTS_VIEW_ID, CONTEXT_DEBUGGERS_AVAILABLE, IDebugService, CONTEXT_BREAKPOINT_ITEM_TYPE, CONTEXT_BREAKPOINTS_EXIST, CONTEXT_IN_DEBUG_MODE, CONTEXT_BREAKPOINT_SUPPORTS_CONDITION, BREAKPOINT_EDITOR_CONTRIBUTION_ID, CONTEXT_BREAKPOINT_INPUT_FOCUSED, CONTEXT_BREAKPOINTS_FOCUSED, DEBUG_SCHEME, DebuggerString } from '../common/debug.js';
import { DataBreakpoint, FunctionBreakpoint, InstructionBreakpoint, Breakpoint, ExceptionBreakpoint } from '../common/debugModel.js';
import { DisassemblyViewInput } from '../common/disassemblyViewInput.js';
import { IEditorService, SIDE_GROUP, ACTIVE_GROUP } from '../../../services/editor/common/editorService.js';
import { IHoverService } from '../../../services/hover/browser/hover.js';
const $ = dom.$;
function createCheckbox(disposables) {
    const checkbox = $('input');
    checkbox.type = 'checkbox';
    checkbox.tabIndex = -1;
    disposables.push(Gesture.ignoreTarget(checkbox));
    return checkbox;
}
const MAX_VISIBLE_BREAKPOINTS = 9;
function getExpandedBodySize(model, sessionId, countLimit) {
    const length = model.getBreakpoints().length + model.getExceptionBreakpointsForSession(sessionId).length + model.getFunctionBreakpoints().length + model.getDataBreakpoints().length + model.getInstructionBreakpoints().length;
    return Math.min(countLimit, length) * 22;
}
let BreakpointsView = class BreakpointsView extends ViewPane {
    constructor(options, contextMenuService, debugService, keybindingService, instantiationService, themeService, editorService, contextViewService, configurationService, viewDescriptorService, contextKeyService, openerService, telemetryService, labelService, menuService, hoverService, languageService) {
        super(options, keybindingService, contextMenuService, configurationService, contextKeyService, viewDescriptorService, instantiationService, openerService, themeService, telemetryService);
        this.debugService = debugService;
        this.editorService = editorService;
        this.contextViewService = contextViewService;
        this.labelService = labelService;
        this.hoverService = hoverService;
        this.languageService = languageService;
        this.needsRefresh = false;
        this.needsStateChange = false;
        this.ignoreLayout = false;
        this.autoFocusedIndex = -1;
        this.menu = menuService.createMenu(MenuId.DebugBreakpointsContext, contextKeyService);
        this._register(this.menu);
        this.breakpointItemType = CONTEXT_BREAKPOINT_ITEM_TYPE.bindTo(contextKeyService);
        this.breakpointSupportsCondition = CONTEXT_BREAKPOINT_SUPPORTS_CONDITION.bindTo(contextKeyService);
        this.breakpointInputFocused = CONTEXT_BREAKPOINT_INPUT_FOCUSED.bindTo(contextKeyService);
        this._register(this.debugService.getModel().onDidChangeBreakpoints(() => this.onBreakpointsChange()));
        this._register(this.debugService.getViewModel().onDidFocusSession(() => this.onBreakpointsChange()));
        this._register(this.debugService.onDidChangeState(() => this.onStateChange()));
        this.hintDelayer = this._register(( new RunOnceScheduler(() => this.updateBreakpointsHint(true), 4000)));
    }
    renderBody(container) {
        super.renderBody(container);
        this.element.classList.add('debug-pane');
        container.classList.add('debug-breakpoints');
        const delegate = ( new BreakpointsDelegate(this));
        this.list = this.instantiationService.createInstance(WorkbenchList, 'Breakpoints', container, delegate, [
            this.instantiationService.createInstance(BreakpointsRenderer, this.menu, this.breakpointSupportsCondition, this.breakpointItemType),
            ( new ExceptionBreakpointsRenderer(
                this.menu,
                this.breakpointSupportsCondition,
                this.breakpointItemType,
                this.debugService
            )),
            ( new ExceptionBreakpointInputRenderer(this, this.debugService, this.contextViewService)),
            this.instantiationService.createInstance(FunctionBreakpointsRenderer, this.menu, this.breakpointSupportsCondition, this.breakpointItemType),
            this.instantiationService.createInstance(DataBreakpointsRenderer),
            ( new FunctionBreakpointInputRenderer(this, this.debugService, this.contextViewService, this.labelService)),
            this.instantiationService.createInstance(InstructionBreakpointsRenderer),
        ], {
            identityProvider: { getId: (element) => element.getId() },
            multipleSelectionSupport: false,
            keyboardNavigationLabelProvider: { getKeyboardNavigationLabel: (e) => e },
            accessibilityProvider: ( new BreakpointsAccessibilityProvider(this.debugService, this.labelService)),
            overrideStyles: {
                listBackground: this.getBackgroundColor()
            }
        });
        CONTEXT_BREAKPOINTS_FOCUSED.bindTo(this.list.contextKeyService);
        this._register(this.list.onContextMenu(this.onListContextMenu, this));
        this.list.onMouseMiddleClick(async ({ element }) => {
            if (element instanceof Breakpoint) {
                await this.debugService.removeBreakpoints(element.getId());
            }
            else if (element instanceof FunctionBreakpoint) {
                await this.debugService.removeFunctionBreakpoints(element.getId());
            }
            else if (element instanceof DataBreakpoint) {
                await this.debugService.removeDataBreakpoints(element.getId());
            }
            else if (element instanceof InstructionBreakpoint) {
                await this.debugService.removeInstructionBreakpoints(element.instructionReference);
            }
        });
        this._register(this.list.onDidOpen(async (e) => {
            if (!e.element) {
                return;
            }
            if (e.browserEvent instanceof MouseEvent && e.browserEvent.button === 1) {
                return;
            }
            if (e.element instanceof Breakpoint) {
                openBreakpointSource(e.element, e.sideBySide, e.editorOptions.preserveFocus || false, e.editorOptions.pinned || !e.editorOptions.preserveFocus, this.debugService, this.editorService);
            }
            if (e.element instanceof InstructionBreakpoint) {
                const disassemblyView = await this.editorService.openEditor(DisassemblyViewInput.instance);
                disassemblyView.goToAddress(e.element.instructionReference, e.browserEvent instanceof MouseEvent && e.browserEvent.detail === 2);
            }
            if (e.browserEvent instanceof MouseEvent && e.browserEvent.detail === 2 && e.element instanceof FunctionBreakpoint && e.element !== this.inputBoxData?.breakpoint) {
                this.renderInputBox({ breakpoint: e.element, type: 'name' });
            }
        }));
        this.list.splice(0, this.list.length, this.elements);
        this._register(this.onDidChangeBodyVisibility(visible => {
            if (visible) {
                if (this.needsRefresh) {
                    this.onBreakpointsChange();
                }
                if (this.needsStateChange) {
                    this.onStateChange();
                }
            }
        }));
        const containerModel = this.viewDescriptorService.getViewContainerModel(this.viewDescriptorService.getViewContainerByViewId(this.id));
        this._register(containerModel.onDidChangeAllViewDescriptors(() => {
            this.updateSize();
        }));
    }
    renderHeaderTitle(container, title) {
        super.renderHeaderTitle(container, title);
        const iconLabelContainer = dom.append(container, $('span.breakpoint-warning'));
        this.hintContainer = this._register(( new IconLabel(iconLabelContainer, {
            supportIcons: true, hoverDelegate: {
                showHover: (options, focus) => this.hoverService.showHover({ content: options.content, target: this.hintContainer.element }, focus),
                delay: this.configurationService.getValue('workbench.hover.delay')
            }
        })));
        dom.hide(this.hintContainer.element);
    }
    focus() {
        super.focus();
        this.list?.domFocus();
    }
    renderInputBox(data) {
        this._inputBoxData = data;
        this.onBreakpointsChange();
        this._inputBoxData = undefined;
    }
    get inputBoxData() {
        return this._inputBoxData;
    }
    layoutBody(height, width) {
        if (this.ignoreLayout) {
            return;
        }
        super.layoutBody(height, width);
        this.list?.layout(height, width);
        try {
            this.ignoreLayout = true;
            this.updateSize();
        }
        finally {
            this.ignoreLayout = false;
        }
    }
    onListContextMenu(e) {
        const element = e.element;
        const type = element instanceof Breakpoint ? 'breakpoint' : element instanceof ExceptionBreakpoint ? 'exceptionBreakpoint' :
            element instanceof FunctionBreakpoint ? 'functionBreakpoint' : element instanceof DataBreakpoint ? 'dataBreakpoint' :
                element instanceof InstructionBreakpoint ? 'instructionBreakpoint' : undefined;
        this.breakpointItemType.set(type);
        const session = this.debugService.getViewModel().focusedSession;
        const conditionSupported = element instanceof ExceptionBreakpoint ? element.supportsCondition : (!session || !!session.capabilities.supportsConditionalBreakpoints);
        this.breakpointSupportsCondition.set(conditionSupported);
        const secondary = [];
        createAndFillInContextMenuActions(this.menu, { arg: e.element, shouldForwardArgs: false }, { primary: [], secondary }, 'inline');
        this.contextMenuService.showContextMenu({
            getAnchor: () => e.anchor,
            getActions: () => secondary,
            getActionsContext: () => element
        });
    }
    updateSize() {
        const containerModel = this.viewDescriptorService.getViewContainerModel(this.viewDescriptorService.getViewContainerByViewId(this.id));
        const sessionId = this.debugService.getViewModel().focusedSession?.getId();
        this.minimumBodySize = this.orientation === 0  ? getExpandedBodySize(this.debugService.getModel(), sessionId, MAX_VISIBLE_BREAKPOINTS) : 170;
        this.maximumBodySize = this.orientation === 0  && containerModel.visibleViewDescriptors.length > 1 ? getExpandedBodySize(this.debugService.getModel(), sessionId, Number.POSITIVE_INFINITY) : Number.POSITIVE_INFINITY;
    }
    updateBreakpointsHint(delayed = false) {
        if (!this.hintContainer) {
            return;
        }
        const currentType = this.debugService.getViewModel().focusedSession?.configuration.type;
        const dbg = currentType ? this.debugService.getAdapterManager().getDebugger(currentType) : undefined;
        const message = dbg?.strings?.[DebuggerString.UnverifiedBreakpoints];
        const debuggerHasUnverifiedBps = message && this.debugService.getModel().getBreakpoints().filter(bp => {
            if (bp.verified || !bp.enabled) {
                return false;
            }
            const langId = this.languageService.guessLanguageIdByFilepathOrFirstLine(bp.uri);
            return langId && dbg.interestedInLanguage(langId);
        });
        if (message && debuggerHasUnverifiedBps?.length && this.debugService.getModel().areBreakpointsActivated()) {
            if (delayed) {
                const mdown = ( new MarkdownString(undefined, { isTrusted: true })).appendMarkdown(message);
                this.hintContainer.setLabel('$(warning)', undefined, { title: { markdown: mdown, markdownNotSupportedFallback: message } });
                dom.show(this.hintContainer.element);
            }
            else {
                this.hintDelayer.schedule();
            }
        }
        else {
            dom.hide(this.hintContainer.element);
        }
    }
    onBreakpointsChange() {
        if (this.isBodyVisible()) {
            this.updateSize();
            if (this.list) {
                const lastFocusIndex = this.list.getFocus()[0];
                const needsRefocus = lastFocusIndex && !this.elements.includes(this.list.element(lastFocusIndex));
                this.list.splice(0, this.list.length, this.elements);
                this.needsRefresh = false;
                if (needsRefocus) {
                    this.list.focusNth(Math.min(lastFocusIndex, this.list.length - 1));
                }
            }
            this.updateBreakpointsHint();
        }
        else {
            this.needsRefresh = true;
        }
    }
    onStateChange() {
        if (this.isBodyVisible()) {
            this.needsStateChange = false;
            const thread = this.debugService.getViewModel().focusedThread;
            let found = false;
            if (thread && thread.stoppedDetails && thread.stoppedDetails.hitBreakpointIds && thread.stoppedDetails.hitBreakpointIds.length > 0) {
                const hitBreakpointIds = thread.stoppedDetails.hitBreakpointIds;
                const elements = this.elements;
                const index = elements.findIndex(e => {
                    const id = e.getIdFromAdapter(thread.session.getId());
                    return typeof id === 'number' && hitBreakpointIds.indexOf(id) !== -1;
                });
                if (index >= 0) {
                    this.list.setFocus([index]);
                    this.list.setSelection([index]);
                    found = true;
                    this.autoFocusedIndex = index;
                }
            }
            if (!found) {
                const focus = this.list.getFocus();
                const selection = this.list.getSelection();
                if (this.autoFocusedIndex >= 0 && equals(focus, selection) && focus.indexOf(this.autoFocusedIndex) >= 0) {
                    this.list.setFocus([]);
                    this.list.setSelection([]);
                }
                this.autoFocusedIndex = -1;
            }
            this.updateBreakpointsHint();
        }
        else {
            this.needsStateChange = true;
        }
    }
    get elements() {
        const model = this.debugService.getModel();
        const sessionId = this.debugService.getViewModel().focusedSession?.getId();
        const elements = model.getExceptionBreakpointsForSession(sessionId).concat(model.getFunctionBreakpoints()).concat(model.getDataBreakpoints()).concat(model.getBreakpoints()).concat(model.getInstructionBreakpoints());
        return elements;
    }
};
BreakpointsView = ( __decorate([
    ( __param(1, IContextMenuService)),
    ( __param(2, IDebugService)),
    ( __param(3, IKeybindingService)),
    ( __param(4, IInstantiationService)),
    ( __param(5, IThemeService)),
    ( __param(6, IEditorService)),
    ( __param(7, IContextViewService)),
    ( __param(8, IConfigurationService)),
    ( __param(9, IViewDescriptorService)),
    ( __param(10, IContextKeyService)),
    ( __param(11, IOpenerService)),
    ( __param(12, ITelemetryService)),
    ( __param(13, ILabelService)),
    ( __param(14, IMenuService)),
    ( __param(15, IHoverService)),
    ( __param(16, ILanguageService))
], BreakpointsView));
class BreakpointsDelegate {
    constructor(view) {
        this.view = view;
    }
    getHeight(_element) {
        return 22;
    }
    getTemplateId(element) {
        if (element instanceof Breakpoint) {
            return BreakpointsRenderer.ID;
        }
        if (element instanceof FunctionBreakpoint) {
            const inputBoxBreakpoint = this.view.inputBoxData?.breakpoint;
            if (!element.name || (inputBoxBreakpoint && inputBoxBreakpoint.getId() === element.getId())) {
                return FunctionBreakpointInputRenderer.ID;
            }
            return FunctionBreakpointsRenderer.ID;
        }
        if (element instanceof ExceptionBreakpoint) {
            const inputBoxBreakpoint = this.view.inputBoxData?.breakpoint;
            if (inputBoxBreakpoint && inputBoxBreakpoint.getId() === element.getId()) {
                return ExceptionBreakpointInputRenderer.ID;
            }
            return ExceptionBreakpointsRenderer.ID;
        }
        if (element instanceof DataBreakpoint) {
            return DataBreakpointsRenderer.ID;
        }
        if (element instanceof InstructionBreakpoint) {
            return InstructionBreakpointsRenderer.ID;
        }
        return '';
    }
}
const breakpointIdToActionBarDomeNode = ( new Map());
let BreakpointsRenderer = class BreakpointsRenderer {
    constructor(menu, breakpointSupportsCondition, breakpointItemType, debugService, labelService) {
        this.menu = menu;
        this.breakpointSupportsCondition = breakpointSupportsCondition;
        this.breakpointItemType = breakpointItemType;
        this.debugService = debugService;
        this.labelService = labelService;
    }
    static { this.ID = 'breakpoints'; }
    get templateId() {
        return BreakpointsRenderer.ID;
    }
    renderTemplate(container) {
        const data = Object.create(null);
        data.toDispose = [];
        data.breakpoint = dom.append(container, $('.breakpoint'));
        data.icon = $('.icon');
        data.checkbox = createCheckbox(data.toDispose);
        data.toDispose.push(dom.addStandardDisposableListener(data.checkbox, 'change', (e) => {
            this.debugService.enableOrDisableBreakpoints(!data.context.enabled, data.context);
        }));
        dom.append(data.breakpoint, data.icon);
        dom.append(data.breakpoint, data.checkbox);
        data.name = dom.append(data.breakpoint, $('span.name'));
        data.filePath = dom.append(data.breakpoint, $('span.file-path'));
        data.actionBar = ( new ActionBar(data.breakpoint));
        data.toDispose.push(data.actionBar);
        const lineNumberContainer = dom.append(data.breakpoint, $('.line-number-container'));
        data.lineNumber = dom.append(lineNumberContainer, $('span.line-number.monaco-count-badge'));
        return data;
    }
    renderElement(breakpoint, index, data) {
        data.context = breakpoint;
        data.breakpoint.classList.toggle('disabled', !this.debugService.getModel().areBreakpointsActivated());
        data.name.textContent = resources.basenameOrAuthority(breakpoint.uri);
        data.lineNumber.textContent = ( breakpoint.lineNumber.toString());
        if (breakpoint.column) {
            data.lineNumber.textContent += `:${breakpoint.column}`;
        }
        data.filePath.textContent = this.labelService.getUriLabel(resources.dirname(breakpoint.uri), { relative: true });
        data.checkbox.checked = breakpoint.enabled;
        const { message, icon } = getBreakpointMessageAndIcon(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), breakpoint, this.labelService);
        data.icon.className = ThemeIcon.asClassName(icon);
        data.breakpoint.title = breakpoint.message || message || '';
        const debugActive = this.debugService.state === 3  || this.debugService.state === 2 ;
        if (debugActive && !breakpoint.verified) {
            data.breakpoint.classList.add('disabled');
        }
        const primary = [];
        const session = this.debugService.getViewModel().focusedSession;
        this.breakpointSupportsCondition.set(!session || !!session.capabilities.supportsConditionalBreakpoints);
        this.breakpointItemType.set('breakpoint');
        createAndFillInActionBarActions(this.menu, { arg: breakpoint, shouldForwardArgs: true }, { primary, secondary: [] }, 'inline');
        data.actionBar.clear();
        data.actionBar.push(primary, { icon: true, label: false });
        breakpointIdToActionBarDomeNode.set(breakpoint.getId(), data.actionBar.domNode);
    }
    disposeTemplate(templateData) {
        dispose(templateData.toDispose);
    }
};
BreakpointsRenderer = ( __decorate([
    ( __param(3, IDebugService)),
    ( __param(4, ILabelService))
], BreakpointsRenderer));
class ExceptionBreakpointsRenderer {
    constructor(menu, breakpointSupportsCondition, breakpointItemType, debugService) {
        this.menu = menu;
        this.breakpointSupportsCondition = breakpointSupportsCondition;
        this.breakpointItemType = breakpointItemType;
        this.debugService = debugService;
    }
    static { this.ID = 'exceptionbreakpoints'; }
    get templateId() {
        return ExceptionBreakpointsRenderer.ID;
    }
    renderTemplate(container) {
        const data = Object.create(null);
        data.toDispose = [];
        data.breakpoint = dom.append(container, $('.breakpoint'));
        data.checkbox = createCheckbox(data.toDispose);
        data.toDispose.push(dom.addStandardDisposableListener(data.checkbox, 'change', (e) => {
            this.debugService.enableOrDisableBreakpoints(!data.context.enabled, data.context);
        }));
        dom.append(data.breakpoint, data.checkbox);
        data.name = dom.append(data.breakpoint, $('span.name'));
        data.condition = dom.append(data.breakpoint, $('span.condition'));
        data.breakpoint.classList.add('exception');
        data.actionBar = ( new ActionBar(data.breakpoint));
        data.toDispose.push(data.actionBar);
        return data;
    }
    renderElement(exceptionBreakpoint, index, data) {
        data.context = exceptionBreakpoint;
        data.name.textContent = exceptionBreakpoint.label || `${exceptionBreakpoint.filter} exceptions`;
        data.breakpoint.title = exceptionBreakpoint.verified ? (exceptionBreakpoint.description || data.name.textContent) : exceptionBreakpoint.message || ( localize('unverifiedExceptionBreakpoint', "Unverified Exception Breakpoint"));
        data.breakpoint.classList.toggle('disabled', !exceptionBreakpoint.verified);
        data.checkbox.checked = exceptionBreakpoint.enabled;
        data.condition.textContent = exceptionBreakpoint.condition || '';
        data.condition.title = ( localize(
            'expressionCondition',
            "Expression condition: {0}",
            exceptionBreakpoint.condition
        ));
        const primary = [];
        this.breakpointSupportsCondition.set(exceptionBreakpoint.supportsCondition);
        this.breakpointItemType.set('exceptionBreakpoint');
        createAndFillInActionBarActions(this.menu, { arg: exceptionBreakpoint, shouldForwardArgs: true }, { primary, secondary: [] }, 'inline');
        data.actionBar.clear();
        data.actionBar.push(primary, { icon: true, label: false });
        breakpointIdToActionBarDomeNode.set(exceptionBreakpoint.getId(), data.actionBar.domNode);
    }
    disposeTemplate(templateData) {
        dispose(templateData.toDispose);
    }
}
let FunctionBreakpointsRenderer = class FunctionBreakpointsRenderer {
    constructor(menu, breakpointSupportsCondition, breakpointItemType, debugService, labelService) {
        this.menu = menu;
        this.breakpointSupportsCondition = breakpointSupportsCondition;
        this.breakpointItemType = breakpointItemType;
        this.debugService = debugService;
        this.labelService = labelService;
    }
    static { this.ID = 'functionbreakpoints'; }
    get templateId() {
        return FunctionBreakpointsRenderer.ID;
    }
    renderTemplate(container) {
        const data = Object.create(null);
        data.toDispose = [];
        data.breakpoint = dom.append(container, $('.breakpoint'));
        data.icon = $('.icon');
        data.checkbox = createCheckbox(data.toDispose);
        data.toDispose.push(dom.addStandardDisposableListener(data.checkbox, 'change', (e) => {
            this.debugService.enableOrDisableBreakpoints(!data.context.enabled, data.context);
        }));
        dom.append(data.breakpoint, data.icon);
        dom.append(data.breakpoint, data.checkbox);
        data.name = dom.append(data.breakpoint, $('span.name'));
        data.condition = dom.append(data.breakpoint, $('span.condition'));
        data.actionBar = ( new ActionBar(data.breakpoint));
        data.toDispose.push(data.actionBar);
        return data;
    }
    renderElement(functionBreakpoint, _index, data) {
        data.context = functionBreakpoint;
        data.name.textContent = functionBreakpoint.name;
        const { icon, message } = getBreakpointMessageAndIcon(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), functionBreakpoint, this.labelService);
        data.icon.className = ThemeIcon.asClassName(icon);
        data.icon.title = message ? message : '';
        data.checkbox.checked = functionBreakpoint.enabled;
        data.breakpoint.title = message ? message : '';
        if (functionBreakpoint.condition && functionBreakpoint.hitCondition) {
            data.condition.textContent = ( localize(
                'expressionAndHitCount',
                "Expression: {0} | Hit Count: {1}",
                functionBreakpoint.condition,
                functionBreakpoint.hitCondition
            ));
        }
        else {
            data.condition.textContent = functionBreakpoint.condition || functionBreakpoint.hitCondition || '';
        }
        const session = this.debugService.getViewModel().focusedSession;
        data.breakpoint.classList.toggle('disabled', (session && !session.capabilities.supportsFunctionBreakpoints) || !this.debugService.getModel().areBreakpointsActivated());
        if (session && !session.capabilities.supportsFunctionBreakpoints) {
            data.breakpoint.title = ( localize(
                'functionBreakpointsNotSupported',
                "Function breakpoints are not supported by this debug type"
            ));
        }
        const primary = [];
        this.breakpointSupportsCondition.set(!session || !!session.capabilities.supportsConditionalBreakpoints);
        this.breakpointItemType.set('functionBreakpoint');
        createAndFillInActionBarActions(this.menu, { arg: functionBreakpoint, shouldForwardArgs: true }, { primary, secondary: [] }, 'inline');
        data.actionBar.clear();
        data.actionBar.push(primary, { icon: true, label: false });
        breakpointIdToActionBarDomeNode.set(functionBreakpoint.getId(), data.actionBar.domNode);
    }
    disposeTemplate(templateData) {
        dispose(templateData.toDispose);
    }
};
FunctionBreakpointsRenderer = ( __decorate([
    ( __param(3, IDebugService)),
    ( __param(4, ILabelService))
], FunctionBreakpointsRenderer));
let DataBreakpointsRenderer = class DataBreakpointsRenderer {
    constructor(debugService, labelService) {
        this.debugService = debugService;
        this.labelService = labelService;
    }
    static { this.ID = 'databreakpoints'; }
    get templateId() {
        return DataBreakpointsRenderer.ID;
    }
    renderTemplate(container) {
        const data = Object.create(null);
        data.breakpoint = dom.append(container, $('.breakpoint'));
        data.toDispose = [];
        data.icon = $('.icon');
        data.checkbox = createCheckbox(data.toDispose);
        data.toDispose.push(dom.addStandardDisposableListener(data.checkbox, 'change', (e) => {
            this.debugService.enableOrDisableBreakpoints(!data.context.enabled, data.context);
        }));
        dom.append(data.breakpoint, data.icon);
        dom.append(data.breakpoint, data.checkbox);
        data.name = dom.append(data.breakpoint, $('span.name'));
        data.accessType = dom.append(data.breakpoint, $('span.access-type'));
        return data;
    }
    renderElement(dataBreakpoint, _index, data) {
        data.context = dataBreakpoint;
        data.name.textContent = dataBreakpoint.description;
        const { icon, message } = getBreakpointMessageAndIcon(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), dataBreakpoint, this.labelService);
        data.icon.className = ThemeIcon.asClassName(icon);
        data.icon.title = message ? message : '';
        data.checkbox.checked = dataBreakpoint.enabled;
        data.breakpoint.title = message ? message : '';
        const session = this.debugService.getViewModel().focusedSession;
        data.breakpoint.classList.toggle('disabled', (session && !session.capabilities.supportsDataBreakpoints) || !this.debugService.getModel().areBreakpointsActivated());
        if (session && !session.capabilities.supportsDataBreakpoints) {
            data.breakpoint.title = ( localize(
                'dataBreakpointsNotSupported',
                "Data breakpoints are not supported by this debug type"
            ));
        }
        if (dataBreakpoint.accessType) {
            const accessType = dataBreakpoint.accessType === 'read' ? ( localize('read', "Read")) : dataBreakpoint.accessType === 'write' ? ( localize('write', "Write")) : ( localize('access', "Access"));
            data.accessType.textContent = accessType;
        }
        else {
            data.accessType.textContent = '';
        }
    }
    disposeTemplate(templateData) {
        dispose(templateData.toDispose);
    }
};
DataBreakpointsRenderer = ( __decorate([
    ( __param(0, IDebugService)),
    ( __param(1, ILabelService))
], DataBreakpointsRenderer));
let InstructionBreakpointsRenderer = class InstructionBreakpointsRenderer {
    constructor(debugService, labelService) {
        this.debugService = debugService;
        this.labelService = labelService;
    }
    static { this.ID = 'instructionBreakpoints'; }
    get templateId() {
        return InstructionBreakpointsRenderer.ID;
    }
    renderTemplate(container) {
        const data = Object.create(null);
        data.toDispose = [];
        data.breakpoint = dom.append(container, $('.breakpoint'));
        data.icon = $('.icon');
        data.checkbox = createCheckbox(data.toDispose);
        data.toDispose.push(dom.addStandardDisposableListener(data.checkbox, 'change', (e) => {
            this.debugService.enableOrDisableBreakpoints(!data.context.enabled, data.context);
        }));
        dom.append(data.breakpoint, data.icon);
        dom.append(data.breakpoint, data.checkbox);
        data.name = dom.append(data.breakpoint, $('span.name'));
        data.address = dom.append(data.breakpoint, $('span.file-path'));
        data.actionBar = ( new ActionBar(data.breakpoint));
        data.toDispose.push(data.actionBar);
        return data;
    }
    renderElement(breakpoint, index, data) {
        data.context = breakpoint;
        data.breakpoint.classList.toggle('disabled', !this.debugService.getModel().areBreakpointsActivated());
        data.name.textContent = breakpoint.instructionReference;
        data.checkbox.checked = breakpoint.enabled;
        const { message, icon } = getBreakpointMessageAndIcon(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), breakpoint, this.labelService);
        data.icon.className = ThemeIcon.asClassName(icon);
        data.breakpoint.title = breakpoint.message || message || '';
        const debugActive = this.debugService.state === 3  || this.debugService.state === 2 ;
        if (debugActive && !breakpoint.verified) {
            data.breakpoint.classList.add('disabled');
        }
    }
    disposeTemplate(templateData) {
        dispose(templateData.toDispose);
    }
};
InstructionBreakpointsRenderer = ( __decorate([
    ( __param(0, IDebugService)),
    ( __param(1, ILabelService))
], InstructionBreakpointsRenderer));
class FunctionBreakpointInputRenderer {
    constructor(view, debugService, contextViewService, labelService) {
        this.view = view;
        this.debugService = debugService;
        this.contextViewService = contextViewService;
        this.labelService = labelService;
    }
    static { this.ID = 'functionbreakpointinput'; }
    get templateId() {
        return FunctionBreakpointInputRenderer.ID;
    }
    renderTemplate(container) {
        const template = Object.create(null);
        const toDispose = [];
        const breakpoint = dom.append(container, $('.breakpoint'));
        template.icon = $('.icon');
        template.checkbox = createCheckbox(toDispose);
        dom.append(breakpoint, template.icon);
        dom.append(breakpoint, template.checkbox);
        this.view.breakpointInputFocused.set(true);
        const inputBoxContainer = dom.append(breakpoint, $('.inputBoxContainer'));
        const inputBox = ( new InputBox(
            inputBoxContainer,
            this.contextViewService,
            { inputBoxStyles: defaultInputBoxStyles }
        ));
        const wrapUp = (success) => {
            template.updating = true;
            try {
                this.view.breakpointInputFocused.set(false);
                const id = template.breakpoint.getId();
                if (success) {
                    if (template.type === 'name') {
                        this.debugService.updateFunctionBreakpoint(id, { name: inputBox.value });
                    }
                    if (template.type === 'condition') {
                        this.debugService.updateFunctionBreakpoint(id, { condition: inputBox.value });
                    }
                    if (template.type === 'hitCount') {
                        this.debugService.updateFunctionBreakpoint(id, { hitCondition: inputBox.value });
                    }
                }
                else {
                    if (template.type === 'name' && !template.breakpoint.name) {
                        this.debugService.removeFunctionBreakpoints(id);
                    }
                    else {
                        this.view.renderInputBox(undefined);
                    }
                }
            }
            finally {
                template.updating = false;
            }
        };
        toDispose.push(dom.addStandardDisposableListener(inputBox.inputElement, 'keydown', (e) => {
            const isEscape = e.equals(9 );
            const isEnter = e.equals(3 );
            if (isEscape || isEnter) {
                e.preventDefault();
                e.stopPropagation();
                wrapUp(isEnter);
            }
        }));
        toDispose.push(dom.addDisposableListener(inputBox.inputElement, 'blur', () => {
            if (!template.updating) {
                wrapUp(!!inputBox.value);
            }
        }));
        template.inputBox = inputBox;
        template.toDispose = toDispose;
        return template;
    }
    renderElement(functionBreakpoint, _index, data) {
        data.breakpoint = functionBreakpoint;
        data.type = this.view.inputBoxData?.type || 'name';
        const { icon, message } = getBreakpointMessageAndIcon(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), functionBreakpoint, this.labelService);
        data.icon.className = ThemeIcon.asClassName(icon);
        data.icon.title = message ? message : '';
        data.checkbox.checked = functionBreakpoint.enabled;
        data.checkbox.disabled = true;
        data.inputBox.value = functionBreakpoint.name || '';
        let placeholder = ( localize('functionBreakpointPlaceholder', "Function to break on"));
        let ariaLabel = ( localize('functionBreakPointInputAriaLabel', "Type function breakpoint."));
        if (data.type === 'condition') {
            data.inputBox.value = functionBreakpoint.condition || '';
            placeholder = ( localize(
                'functionBreakpointExpressionPlaceholder',
                "Break when expression evaluates to true"
            ));
            ariaLabel = ( localize(
                'functionBreakPointExpresionAriaLabel',
                "Type expression. Function breakpoint will break when expression evaluates to true"
            ));
        }
        else if (data.type === 'hitCount') {
            data.inputBox.value = functionBreakpoint.hitCondition || '';
            placeholder = ( localize('functionBreakpointHitCountPlaceholder', "Break when hit count is met"));
            ariaLabel = ( localize(
                'functionBreakPointHitCountAriaLabel',
                "Type hit count. Function breakpoint will break when hit count is met."
            ));
        }
        data.inputBox.setAriaLabel(ariaLabel);
        data.inputBox.setPlaceHolder(placeholder);
        setTimeout(() => {
            data.inputBox.focus();
            data.inputBox.select();
        }, 0);
    }
    disposeTemplate(templateData) {
        dispose(templateData.toDispose);
    }
}
class ExceptionBreakpointInputRenderer {
    constructor(view, debugService, contextViewService) {
        this.view = view;
        this.debugService = debugService;
        this.contextViewService = contextViewService;
    }
    static { this.ID = 'exceptionbreakpointinput'; }
    get templateId() {
        return ExceptionBreakpointInputRenderer.ID;
    }
    renderTemplate(container) {
        const template = Object.create(null);
        const toDispose = [];
        const breakpoint = dom.append(container, $('.breakpoint'));
        breakpoint.classList.add('exception');
        template.checkbox = createCheckbox(toDispose);
        dom.append(breakpoint, template.checkbox);
        this.view.breakpointInputFocused.set(true);
        const inputBoxContainer = dom.append(breakpoint, $('.inputBoxContainer'));
        const inputBox = ( new InputBox(inputBoxContainer, this.contextViewService, {
            ariaLabel: ( localize('exceptionBreakpointAriaLabel', "Type exception breakpoint condition")),
            inputBoxStyles: defaultInputBoxStyles
        }));
        const wrapUp = (success) => {
            this.view.breakpointInputFocused.set(false);
            let newCondition = template.breakpoint.condition;
            if (success) {
                newCondition = inputBox.value !== '' ? inputBox.value : undefined;
            }
            this.debugService.setExceptionBreakpointCondition(template.breakpoint, newCondition);
        };
        toDispose.push(dom.addStandardDisposableListener(inputBox.inputElement, 'keydown', (e) => {
            const isEscape = e.equals(9 );
            const isEnter = e.equals(3 );
            if (isEscape || isEnter) {
                e.preventDefault();
                e.stopPropagation();
                wrapUp(isEnter);
            }
        }));
        toDispose.push(dom.addDisposableListener(inputBox.inputElement, 'blur', () => {
            setTimeout(() => {
                wrapUp(true);
            });
        }));
        template.inputBox = inputBox;
        template.toDispose = toDispose;
        return template;
    }
    renderElement(exceptionBreakpoint, _index, data) {
        const placeHolder = exceptionBreakpoint.conditionDescription || ( localize(
            'exceptionBreakpointPlaceholder',
            "Break when expression evaluates to true"
        ));
        data.inputBox.setPlaceHolder(placeHolder);
        data.breakpoint = exceptionBreakpoint;
        data.checkbox.checked = exceptionBreakpoint.enabled;
        data.checkbox.disabled = true;
        data.inputBox.value = exceptionBreakpoint.condition || '';
        setTimeout(() => {
            data.inputBox.focus();
            data.inputBox.select();
        }, 0);
    }
    disposeTemplate(templateData) {
        dispose(templateData.toDispose);
    }
}
class BreakpointsAccessibilityProvider {
    constructor(debugService, labelService) {
        this.debugService = debugService;
        this.labelService = labelService;
    }
    getWidgetAriaLabel() {
        return ( localize('breakpoints', "Breakpoints"));
    }
    getRole() {
        return 'checkbox';
    }
    isChecked(breakpoint) {
        return breakpoint.enabled;
    }
    getAriaLabel(element) {
        if (element instanceof ExceptionBreakpoint) {
            return ( element.toString());
        }
        const { message } = getBreakpointMessageAndIcon(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), element, this.labelService);
        const toString = ( element.toString());
        return message ? `${toString}, ${message}` : toString;
    }
}
function openBreakpointSource(breakpoint, sideBySide, preserveFocus, pinned, debugService, editorService) {
    if (breakpoint.uri.scheme === DEBUG_SCHEME && debugService.state === 0 ) {
        return Promise.resolve(undefined);
    }
    const selection = breakpoint.endLineNumber ? {
        startLineNumber: breakpoint.lineNumber,
        endLineNumber: breakpoint.endLineNumber,
        startColumn: breakpoint.column || 1,
        endColumn: breakpoint.endColumn || 1073741824
    } : {
        startLineNumber: breakpoint.lineNumber,
        startColumn: breakpoint.column || 1,
        endLineNumber: breakpoint.lineNumber,
        endColumn: breakpoint.column || 1073741824
    };
    return editorService.openEditor({
        resource: breakpoint.uri,
        options: {
            preserveFocus,
            selection,
            revealIfOpened: true,
            selectionRevealType: 1 ,
            pinned
        }
    }, sideBySide ? SIDE_GROUP : ACTIVE_GROUP);
}
function getBreakpointMessageAndIcon(state, breakpointsActivated, breakpoint$1, labelService) {
    const debugActive = state === 3  || state === 2 ;
    const breakpointIcon = breakpoint$1 instanceof DataBreakpoint ? dataBreakpoint : breakpoint$1 instanceof FunctionBreakpoint ? functionBreakpoint : breakpoint$1.logMessage ? logBreakpoint : breakpoint;
    if (!breakpoint$1.enabled || !breakpointsActivated) {
        return {
            icon: breakpointIcon.disabled,
            message: breakpoint$1.logMessage ? ( localize('disabledLogpoint', "Disabled Logpoint")) : ( localize('disabledBreakpoint', "Disabled Breakpoint")),
        };
    }
    const appendMessage = (text) => {
        return ('message' in breakpoint$1 && breakpoint$1.message) ? text.concat(', ' + breakpoint$1.message) : text;
    };
    if (debugActive && !breakpoint$1.verified) {
        return {
            icon: breakpointIcon.unverified,
            message: ('message' in breakpoint$1 && breakpoint$1.message) ? breakpoint$1.message : (breakpoint$1.logMessage ? ( localize('unverifiedLogpoint', "Unverified Logpoint")) : ( localize('unverifiedBreakpoint', "Unverified Breakpoint"))),
            showAdapterUnverifiedMessage: true
        };
    }
    if (breakpoint$1 instanceof DataBreakpoint) {
        if (!breakpoint$1.supported) {
            return {
                icon: breakpointIcon.unverified,
                message: ( localize(
                    'dataBreakpointUnsupported',
                    "Data breakpoints not supported by this debug type"
                )),
            };
        }
        return {
            icon: breakpointIcon.regular,
            message: breakpoint$1.message || ( localize('dataBreakpoint', "Data Breakpoint"))
        };
    }
    if (breakpoint$1 instanceof FunctionBreakpoint) {
        if (!breakpoint$1.supported) {
            return {
                icon: breakpointIcon.unverified,
                message: ( localize(
                    'functionBreakpointUnsupported',
                    "Function breakpoints not supported by this debug type"
                )),
            };
        }
        const messages = [];
        messages.push(breakpoint$1.message || ( localize('functionBreakpoint', "Function Breakpoint")));
        if (breakpoint$1.condition) {
            messages.push(( localize('expression', "Expression condition: {0}", breakpoint$1.condition)));
        }
        if (breakpoint$1.hitCondition) {
            messages.push(( localize('hitCount', "Hit Count: {0}", breakpoint$1.hitCondition)));
        }
        return {
            icon: breakpointIcon.regular,
            message: appendMessage(messages.join('\n'))
        };
    }
    if (breakpoint$1 instanceof InstructionBreakpoint) {
        if (!breakpoint$1.supported) {
            return {
                icon: breakpointIcon.unverified,
                message: ( localize(
                    'instructionBreakpointUnsupported',
                    "Instruction breakpoints not supported by this debug type"
                )),
            };
        }
        const messages = [];
        if (breakpoint$1.message) {
            messages.push(breakpoint$1.message);
        }
        else if (breakpoint$1.instructionReference) {
            messages.push(( localize(
                'instructionBreakpointAtAddress',
                "Instruction breakpoint at address {0}",
                breakpoint$1.instructionReference
            )));
        }
        else {
            messages.push(( localize('instructionBreakpoint', "Instruction breakpoint")));
        }
        if (breakpoint$1.hitCondition) {
            messages.push(( localize('hitCount', "Hit Count: {0}", breakpoint$1.hitCondition)));
        }
        return {
            icon: breakpointIcon.regular,
            message: appendMessage(messages.join('\n'))
        };
    }
    if (breakpoint$1.logMessage || breakpoint$1.condition || breakpoint$1.hitCondition) {
        const messages = [];
        if (!breakpoint$1.supported) {
            return {
                icon: debugBreakpointUnsupported,
                message: ( localize(
                    'breakpointUnsupported',
                    "Breakpoints of this type are not supported by the debugger"
                )),
            };
        }
        if (breakpoint$1.logMessage) {
            messages.push(( localize('logMessage', "Log Message: {0}", breakpoint$1.logMessage)));
        }
        if (breakpoint$1.condition) {
            messages.push(( localize('expression', "Expression condition: {0}", breakpoint$1.condition)));
        }
        if (breakpoint$1.hitCondition) {
            messages.push(( localize('hitCount', "Hit Count: {0}", breakpoint$1.hitCondition)));
        }
        return {
            icon: breakpoint$1.logMessage ? logBreakpoint.regular : conditionalBreakpoint.regular,
            message: appendMessage(messages.join('\n'))
        };
    }
    const message = ('message' in breakpoint$1 && breakpoint$1.message) ? breakpoint$1.message : breakpoint$1 instanceof Breakpoint && labelService ? labelService.getUriLabel(breakpoint$1.uri) : ( localize('breakpoint', "Breakpoint"));
    return {
        icon: breakpointIcon.regular,
        message
    };
}
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'workbench.debug.viewlet.action.addFunctionBreakpointAction',
            title: {
                value: ( localize('addFunctionBreakpoint', "Add Function Breakpoint")),
                original: 'Add Function Breakpoint',
                mnemonicTitle: ( localize(
                    { key: 'miFunctionBreakpoint', comment: ['&& denotes a mnemonic'] },
                    "&&Function Breakpoint..."
                ))
            },
            f1: true,
            icon: watchExpressionsAddFuncBreakpoint,
            menu: [{
                    id: MenuId.ViewTitle,
                    group: 'navigation',
                    order: 10,
                    when: ( ContextKeyExpr.equals('view', BREAKPOINTS_VIEW_ID))
                }, {
                    id: MenuId.MenubarNewBreakpointMenu,
                    group: '1_breakpoints',
                    order: 3,
                    when: CONTEXT_DEBUGGERS_AVAILABLE
                }]
        });
    }
    run(accessor) {
        const debugService = accessor.get(IDebugService);
        debugService.addFunctionBreakpoint();
    }
});
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'workbench.debug.viewlet.action.toggleBreakpointsActivatedAction',
            title: { value: ( localize('activateBreakpoints', "Toggle Activate Breakpoints")), original: 'Toggle Activate Breakpoints' },
            f1: true,
            icon: breakpointsActivate,
            menu: {
                id: MenuId.ViewTitle,
                group: 'navigation',
                order: 20,
                when: ( ContextKeyExpr.equals('view', BREAKPOINTS_VIEW_ID))
            }
        });
    }
    run(accessor) {
        const debugService = accessor.get(IDebugService);
        debugService.setBreakpointsActivated(!debugService.getModel().areBreakpointsActivated());
    }
});
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'workbench.debug.viewlet.action.removeBreakpoint',
            title: ( localize('removeBreakpoint', "Remove Breakpoint")),
            icon: Codicon.removeClose,
            menu: [{
                    id: MenuId.DebugBreakpointsContext,
                    group: '3_modification',
                    order: 10,
                    when: ( CONTEXT_BREAKPOINT_ITEM_TYPE.notEqualsTo('exceptionBreakpoint'))
                }, {
                    id: MenuId.DebugBreakpointsContext,
                    group: 'inline',
                    order: 20,
                    when: ( CONTEXT_BREAKPOINT_ITEM_TYPE.notEqualsTo('exceptionBreakpoint'))
                }]
        });
    }
    async run(accessor, breakpoint) {
        const debugService = accessor.get(IDebugService);
        if (breakpoint instanceof Breakpoint) {
            await debugService.removeBreakpoints(breakpoint.getId());
        }
        else if (breakpoint instanceof FunctionBreakpoint) {
            await debugService.removeFunctionBreakpoints(breakpoint.getId());
        }
        else if (breakpoint instanceof DataBreakpoint) {
            await debugService.removeDataBreakpoints(breakpoint.getId());
        }
        else if (breakpoint instanceof InstructionBreakpoint) {
            await debugService.removeInstructionBreakpoints(breakpoint.instructionReference);
        }
    }
});
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'workbench.debug.viewlet.action.removeAllBreakpoints',
            title: {
                original: 'Remove All Breakpoints',
                value: ( localize('removeAllBreakpoints', "Remove All Breakpoints")),
                mnemonicTitle: ( localize(
                    { key: 'miRemoveAllBreakpoints', comment: ['&& denotes a mnemonic'] },
                    "Remove &&All Breakpoints"
                ))
            },
            f1: true,
            icon: breakpointsRemoveAll,
            menu: [{
                    id: MenuId.ViewTitle,
                    group: 'navigation',
                    order: 30,
                    when: ( ContextKeyExpr.equals('view', BREAKPOINTS_VIEW_ID))
                }, {
                    id: MenuId.DebugBreakpointsContext,
                    group: '3_modification',
                    order: 20,
                    when: ( ContextKeyExpr.and(CONTEXT_BREAKPOINTS_EXIST, ( CONTEXT_BREAKPOINT_ITEM_TYPE.notEqualsTo('exceptionBreakpoint'))))
                }, {
                    id: MenuId.MenubarDebugMenu,
                    group: '5_breakpoints',
                    order: 3,
                    when: CONTEXT_DEBUGGERS_AVAILABLE
                }]
        });
    }
    run(accessor) {
        const debugService = accessor.get(IDebugService);
        debugService.removeBreakpoints();
        debugService.removeFunctionBreakpoints();
        debugService.removeDataBreakpoints();
        debugService.removeInstructionBreakpoints();
    }
});
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'workbench.debug.viewlet.action.enableAllBreakpoints',
            title: {
                original: 'Enable All Breakpoints',
                value: ( localize('enableAllBreakpoints', "Enable All Breakpoints")),
                mnemonicTitle: ( localize(
                    { key: 'miEnableAllBreakpoints', comment: ['&& denotes a mnemonic'] },
                    "&&Enable All Breakpoints"
                )),
            },
            f1: true,
            precondition: CONTEXT_DEBUGGERS_AVAILABLE,
            menu: [{
                    id: MenuId.DebugBreakpointsContext,
                    group: 'z_commands',
                    order: 10,
                    when: ( ContextKeyExpr.and(CONTEXT_BREAKPOINTS_EXIST, ( CONTEXT_BREAKPOINT_ITEM_TYPE.notEqualsTo('exceptionBreakpoint'))))
                }, {
                    id: MenuId.MenubarDebugMenu,
                    group: '5_breakpoints',
                    order: 1,
                    when: CONTEXT_DEBUGGERS_AVAILABLE
                }]
        });
    }
    async run(accessor) {
        const debugService = accessor.get(IDebugService);
        await debugService.enableOrDisableBreakpoints(true);
    }
});
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'workbench.debug.viewlet.action.disableAllBreakpoints',
            title: {
                original: 'Disable All Breakpoints',
                value: ( localize('disableAllBreakpoints', "Disable All Breakpoints")),
                mnemonicTitle: ( localize(
                    { key: 'miDisableAllBreakpoints', comment: ['&& denotes a mnemonic'] },
                    "Disable A&&ll Breakpoints"
                ))
            },
            f1: true,
            precondition: CONTEXT_DEBUGGERS_AVAILABLE,
            menu: [{
                    id: MenuId.DebugBreakpointsContext,
                    group: 'z_commands',
                    order: 20,
                    when: ( ContextKeyExpr.and(CONTEXT_BREAKPOINTS_EXIST, ( CONTEXT_BREAKPOINT_ITEM_TYPE.notEqualsTo('exceptionBreakpoint'))))
                }, {
                    id: MenuId.MenubarDebugMenu,
                    group: '5_breakpoints',
                    order: 2,
                    when: CONTEXT_DEBUGGERS_AVAILABLE
                }]
        });
    }
    async run(accessor) {
        const debugService = accessor.get(IDebugService);
        await debugService.enableOrDisableBreakpoints(false);
    }
});
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'workbench.debug.viewlet.action.reapplyBreakpointsAction',
            title: { value: ( localize('reapplyAllBreakpoints', "Reapply All Breakpoints")), original: 'Reapply All Breakpoints' },
            f1: true,
            precondition: CONTEXT_IN_DEBUG_MODE,
            menu: [{
                    id: MenuId.DebugBreakpointsContext,
                    group: 'z_commands',
                    order: 30,
                    when: ( ContextKeyExpr.and(CONTEXT_BREAKPOINTS_EXIST, ( CONTEXT_BREAKPOINT_ITEM_TYPE.notEqualsTo('exceptionBreakpoint'))))
                }]
        });
    }
    async run(accessor) {
        const debugService = accessor.get(IDebugService);
        await debugService.setBreakpointsActivated(true);
    }
});
registerAction2(class extends ViewAction {
    constructor() {
        super({
            id: 'debug.editBreakpoint',
            viewId: BREAKPOINTS_VIEW_ID,
            title: ( localize('editCondition', "Edit Condition...")),
            icon: Codicon.edit,
            precondition: CONTEXT_BREAKPOINT_SUPPORTS_CONDITION,
            menu: [{
                    id: MenuId.DebugBreakpointsContext,
                    group: 'navigation',
                    order: 10
                }, {
                    id: MenuId.DebugBreakpointsContext,
                    group: 'inline',
                    order: 10
                }]
        });
    }
    async runInView(accessor, view, breakpoint) {
        const debugService = accessor.get(IDebugService);
        const editorService = accessor.get(IEditorService);
        if (breakpoint instanceof Breakpoint) {
            const editor = await openBreakpointSource(breakpoint, false, false, true, debugService, editorService);
            if (editor) {
                const codeEditor = editor.getControl();
                if (isCodeEditor(codeEditor)) {
                    codeEditor.getContribution(BREAKPOINT_EDITOR_CONTRIBUTION_ID)?.showBreakpointWidget(breakpoint.lineNumber, breakpoint.column);
                }
            }
        }
        else if (breakpoint instanceof FunctionBreakpoint) {
            const contextMenuService = accessor.get(IContextMenuService);
            const actions = [( new Action('breakpoint.editCondition', ( localize('editCondition', "Edit Condition...")), undefined, true, async () => view.renderInputBox({ breakpoint, type: 'condition' }))),
                ( new Action('breakpoint.editCondition', ( localize('editHitCount', "Edit Hit Count...")), undefined, true, async () => view.renderInputBox({ breakpoint, type: 'hitCount' })))];
            const domNode = breakpointIdToActionBarDomeNode.get(breakpoint.getId());
            if (domNode) {
                contextMenuService.showContextMenu({
                    getActions: () => actions,
                    getAnchor: () => domNode,
                    onHide: () => dispose(actions)
                });
            }
        }
        else {
            view.renderInputBox({ breakpoint, type: 'condition' });
        }
    }
});
registerAction2(class extends ViewAction {
    constructor() {
        super({
            id: 'debug.editFunctionBreakpoint',
            viewId: BREAKPOINTS_VIEW_ID,
            title: ( localize('editBreakpoint', "Edit Function Breakpoint...")),
            menu: [{
                    id: MenuId.DebugBreakpointsContext,
                    group: '1_breakpoints',
                    order: 10,
                    when: ( CONTEXT_BREAKPOINT_ITEM_TYPE.isEqualTo('functionBreakpoint'))
                }]
        });
    }
    runInView(_accessor, view, breakpoint) {
        view.renderInputBox({ breakpoint, type: 'name' });
    }
});
registerAction2(class extends ViewAction {
    constructor() {
        super({
            id: 'debug.editFunctionBreakpointHitCount',
            viewId: BREAKPOINTS_VIEW_ID,
            title: ( localize('editHitCount', "Edit Hit Count...")),
            precondition: CONTEXT_BREAKPOINT_SUPPORTS_CONDITION,
            menu: [{
                    id: MenuId.DebugBreakpointsContext,
                    group: 'navigation',
                    order: 20,
                    when: ( CONTEXT_BREAKPOINT_ITEM_TYPE.isEqualTo('functionBreakpoint'))
                }]
        });
    }
    runInView(_accessor, view, breakpoint) {
        view.renderInputBox({ breakpoint, type: 'hitCount' });
    }
});
export { BreakpointsView, getBreakpointMessageAndIcon, getExpandedBodySize, openBreakpointSource };
