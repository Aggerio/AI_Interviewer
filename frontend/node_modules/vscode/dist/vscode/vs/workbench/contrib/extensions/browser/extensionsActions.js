import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import './media/extensionActions.css.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { Action, Separator, SubmenuAction } from 'monaco-editor/esm/vs/base/common/actions.js';
import { Throttler, Delayer } from 'monaco-editor/esm/vs/base/common/async.js';
import * as dom from 'monaco-editor/esm/vs/base/browser/dom.js';
import { Event, Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import * as json from 'monaco-editor/esm/vs/base/common/json.js';
import { IContextMenuService } from 'monaco-editor/esm/vs/platform/contextview/browser/contextView.js';
import { disposeIfDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { INSTALL_ACTIONS_GROUP, THEME_ACTIONS_GROUP, VIEWLET_ID, IExtensionsWorkbenchService, SELECT_INSTALL_VSIX_EXTENSION_COMMAND_ID, TOGGLE_IGNORE_EXTENSION_ACTION_ID } from '../common/extensions.js';
import { ExtensionsConfigurationInitialContent } from '../common/extensionsFileTemplate.js';
import { TargetPlatformToString, ExtensionManagementErrorCode, IExtensionGalleryService } from '../../../../platform/extensionManagement/common/extensionManagement.js';
import { IExtensionManagementServerService, IWorkbenchExtensionEnablementService } from '../../../services/extensionManagement/common/extensionManagement.js';
import { IExtensionRecommendationsService, IExtensionIgnoredRecommendationsService } from '../../../services/extensionRecommendations/common/extensionRecommendations.js';
import { areSameExtensions, getExtensionId } from '../../../../platform/extensionManagement/common/extensionManagementUtil.js';
import { isLanguagePackExtension, ExtensionIdentifier, getWorkspaceSupportTypeMessage, isApplicationScopedExtension } from 'monaco-editor/esm/vs/platform/extensions/common/extensions.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IFileService } from 'monaco-editor/esm/vs/platform/files/common/files.js';
import { IWorkspaceContextService } from 'monaco-editor/esm/vs/platform/workspace/common/workspace.js';
import { toExtensionDescription, toExtension, IExtensionService } from '../../../services/extensions/common/extensions.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { CommandsRegistry, ICommandService } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { registerThemingParticipant } from 'monaco-editor/esm/vs/platform/theme/common/themeService.js';
import { ThemeIcon } from 'monaco-editor/esm/vs/base/common/themables.js';
import { registerColor, buttonBackground, buttonForeground, buttonHoverBackground, buttonSeparator, editorErrorForeground, editorWarningForeground, editorInfoForeground } from 'monaco-editor/esm/vs/platform/theme/common/colorRegistry.js';
import { IJSONEditingService } from '../../../services/configuration/common/jsonEditing.js';
import { ITextModelService } from 'monaco-editor/esm/vs/editor/common/services/resolverService.js';
import { IMenuService, MenuId } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { PICK_WORKSPACE_FOLDER_COMMAND_ID } from '../../../browser/actions/workspaceCommands.js';
import { Severity, INotificationService } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { IOpenerService } from 'monaco-editor/esm/vs/platform/opener/common/opener.js';
import { IEditorService } from '../../../services/editor/common/editorService.js';
import { IQuickInputService } from 'monaco-editor/esm/vs/platform/quickinput/common/quickInput.js';
import { CancellationToken } from 'monaco-editor/esm/vs/base/common/cancellation.js';
import { alert } from 'monaco-editor/esm/vs/base/browser/ui/aria/aria.js';
import { IWorkbenchThemeService } from '../../../services/themes/common/workbenchThemeService.js';
import { ILabelService } from 'monaco-editor/esm/vs/platform/label/common/label.js';
import { ITextFileService } from '../../../services/textfile/common/textfiles.js';
import { IProductService } from 'monaco-editor/esm/vs/platform/product/common/productService.js';
import '../../../../../../override/vs/platform/dialogs/common/dialogs.js';
import { ActionViewItem } from 'monaco-editor/esm/vs/base/browser/ui/actionbar/actionViewItems.js';
import { EXTENSIONS_CONFIG } from '../../../services/extensionRecommendations/common/workspaceExtensionsConfig.js';
import { isCancellationError, getErrorMessage } from 'monaco-editor/esm/vs/base/common/errors.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { manageExtensionIcon, preReleaseIcon, syncIgnoredIcon, syncEnabledIcon, warningIcon, infoIcon, trustIcon, errorIcon } from './extensionsIcons.js';
import { language, isWeb, isIOS } from 'monaco-editor/esm/vs/base/common/platform.js';
import { IExtensionManifestPropertiesService } from '../../../services/extensions/common/extensionManifestPropertiesService.js';
import { isVirtualWorkspace } from '../../../../platform/workspace/common/virtualWorkspace.js';
import { MarkdownString, escapeMarkdownSyntaxTokens } from 'monaco-editor/esm/vs/base/common/htmlContent.js';
import { IPaneCompositePartService } from '../../../services/panecomposite/browser/panecomposite.js';
import { fromNow } from '../../../../base/common/date.js';
import { IPreferencesService } from '../../../services/preferences/common/preferences.js';
import { getLocale } from '../../../../platform/languagePacks/common/languagePacks.js';
import { isString } from 'monaco-editor/esm/vs/base/common/types.js';
import { showWindowLogActionId } from '../../../services/log/common/logConstants.js';
import { ITelemetryService } from 'monaco-editor/esm/vs/platform/telemetry/common/telemetry.js';
import { IDialogService } from '../../../../platform/dialogs/common/dialogs.js';
let PromptExtensionInstallFailureAction = class PromptExtensionInstallFailureAction extends Action {
    constructor(extension, version, installOperation, error, productService, openerService, notificationService, dialogService, commandService, logService, extensionManagementServerService, instantiationService, galleryService, extensionManifestPropertiesService) {
        super('extension.promptExtensionInstallFailure');
        this.extension = extension;
        this.version = version;
        this.installOperation = installOperation;
        this.error = error;
        this.productService = productService;
        this.openerService = openerService;
        this.notificationService = notificationService;
        this.dialogService = dialogService;
        this.commandService = commandService;
        this.logService = logService;
        this.extensionManagementServerService = extensionManagementServerService;
        this.instantiationService = instantiationService;
        this.galleryService = galleryService;
        this.extensionManifestPropertiesService = extensionManifestPropertiesService;
    }
    async run() {
        if (isCancellationError(this.error)) {
            return;
        }
        this.logService.error(this.error);
        if (this.error.name === ExtensionManagementErrorCode.Unsupported) {
            const productName = isWeb ? ( (localize('VS Code for Web', "{0} for the Web", this.productService.nameLong))) : this.productService.nameLong;
            const message = ( (localize(
                'cannot be installed',
                "The '{0}' extension is not available in {1}. Click 'More Information' to learn more.",
                this.extension.displayName || this.extension.identifier.id,
                productName
            )));
            const { confirmed } = await this.dialogService.confirm({
                type: Severity.Info,
                message,
                primaryButton: ( (localize(
                    { key: 'more information', comment: ['&& denotes a mnemonic'] },
                    "&&More Information"
                ))),
                cancelButton: ( (localize('close', "Close")))
            });
            if (confirmed) {
                this.openerService.open(isWeb ? ( (URI.parse('https://aka.ms/vscode-web-extensions-guide'))) : ( (URI.parse('https://aka.ms/vscode-remote'))));
            }
            return;
        }
        if ([ExtensionManagementErrorCode.Incompatible, ExtensionManagementErrorCode.IncompatibleTargetPlatform, ExtensionManagementErrorCode.Malicious, ExtensionManagementErrorCode.ReleaseVersionNotFound, ExtensionManagementErrorCode.Deprecated].includes(this.error.name)) {
            await this.dialogService.info(getErrorMessage(this.error));
            return;
        }
        if (ExtensionManagementErrorCode.Signature === this.error.name) {
            await this.dialogService.prompt({
                type: 'error',
                message: ( (localize(
                    'signature verification failed',
                    "{0} cannot verify the '{1}' extension. Are you sure you want to install it?",
                    this.productService.nameLong,
                    this.extension.displayName || this.extension.identifier.id
                ))),
                buttons: [{
                        label: ( (localize('install anyway', "Install Anyway"))),
                        run: () => {
                            const installAction = this.instantiationService.createInstance(InstallAction, { donotVerifySignature: true });
                            installAction.extension = this.extension;
                            return installAction.run();
                        }
                    }],
                cancelButton: ( (localize('cancel', "Cancel")))
            });
            return;
        }
        const operationMessage = this.installOperation === 3  ? ( (localize(
            'update operation',
            "Error while updating '{0}' extension.",
            this.extension.displayName || this.extension.identifier.id
        )))
            : ( (localize(
            'install operation',
            "Error while installing '{0}' extension.",
            this.extension.displayName || this.extension.identifier.id
        )));
        let additionalMessage;
        const promptChoices = [];
        const downloadUrl = await this.getDownloadUrl();
        if (downloadUrl) {
            additionalMessage = ( (localize(
                'check logs',
                "Please check the [log]({0}) for more details.",
                `command:${showWindowLogActionId}`
            )));
            promptChoices.push({
                label: ( (localize('download', "Try Downloading Manually..."))),
                run: () => this.openerService.open(downloadUrl).then(() => {
                    this.notificationService.prompt(Severity.Info, ( (localize(
                        'install vsix',
                        'Once downloaded, please manually install the downloaded VSIX of \'{0}\'.',
                        this.extension.identifier.id
                    ))), [{
                            label: ( (localize('installVSIX', "Install from VSIX..."))),
                            run: () => this.commandService.executeCommand(SELECT_INSTALL_VSIX_EXTENSION_COMMAND_ID)
                        }]);
                })
            });
        }
        const message = `${operationMessage}${additionalMessage ? ` ${additionalMessage}` : ''}`;
        this.notificationService.prompt(Severity.Error, message, promptChoices);
    }
    async getDownloadUrl() {
        if (isIOS) {
            return undefined;
        }
        if (!this.extension.gallery) {
            return undefined;
        }
        if (!this.productService.extensionsGallery) {
            return undefined;
        }
        if (!this.extensionManagementServerService.localExtensionManagementServer && !this.extensionManagementServerService.remoteExtensionManagementServer) {
            return undefined;
        }
        let targetPlatform = this.extension.gallery.properties.targetPlatform;
        if (targetPlatform !== "universal"  && targetPlatform !== "undefined"  && this.extensionManagementServerService.remoteExtensionManagementServer) {
            try {
                const manifest = await this.galleryService.getManifest(this.extension.gallery, CancellationToken.None);
                if (manifest && this.extensionManifestPropertiesService.prefersExecuteOnWorkspace(manifest)) {
                    targetPlatform = await this.extensionManagementServerService.remoteExtensionManagementServer.extensionManagementService.getTargetPlatform();
                }
            }
            catch (error) {
                this.logService.error(error);
                return undefined;
            }
        }
        if (targetPlatform === "unknown" ) {
            return undefined;
        }
        return (
             (URI.parse(
                `${this.productService.extensionsGallery.serviceUrl}/publishers/${this.extension.publisher}/vsextensions/${this.extension.name}/${this.version}/vspackage${targetPlatform !== "undefined"  ? `?targetPlatform=${targetPlatform}` : ''}`
            ))
        );
    }
};
PromptExtensionInstallFailureAction = ( (__decorate([
    ( (__param(4, IProductService))),
    ( (__param(5, IOpenerService))),
    ( (__param(6, INotificationService))),
    ( (__param(7, IDialogService))),
    ( (__param(8, ICommandService))),
    ( (__param(9, ILogService))),
    ( (__param(10, IExtensionManagementServerService))),
    ( (__param(11, IInstantiationService))),
    ( (__param(12, IExtensionGalleryService))),
    ( (__param(13, IExtensionManifestPropertiesService)))
], PromptExtensionInstallFailureAction)));
class ExtensionAction extends Action {
    constructor() {
        super(...arguments);
        this._extension = null;
    }
    static { this.EXTENSION_ACTION_CLASS = 'extension-action'; }
    static { this.TEXT_ACTION_CLASS = `${ExtensionAction.EXTENSION_ACTION_CLASS} text`; }
    static { this.LABEL_ACTION_CLASS = `${ExtensionAction.EXTENSION_ACTION_CLASS} label`; }
    static { this.ICON_ACTION_CLASS = `${ExtensionAction.EXTENSION_ACTION_CLASS} icon`; }
    get extension() { return this._extension; }
    set extension(extension) { this._extension = extension; this.update(); }
}
let InstallAction = class InstallAction extends ExtensionAction {
    static { this.Class = `${ExtensionAction.LABEL_ACTION_CLASS} prominent install`; }
    set manifest(manifest) {
        this._manifest = manifest;
        this.updateLabel();
    }
    constructor(options, extensionsWorkbenchService, instantiationService, runtimeExtensionService, workbenchThemeService, labelService, dialogService, preferencesService, telemetryService) {
        super('extensions.install', ( (localize('install', "Install"))), InstallAction.Class, false);
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.instantiationService = instantiationService;
        this.runtimeExtensionService = runtimeExtensionService;
        this.workbenchThemeService = workbenchThemeService;
        this.labelService = labelService;
        this.dialogService = dialogService;
        this.preferencesService = preferencesService;
        this.telemetryService = telemetryService;
        this._manifest = null;
        this.updateThrottler = ( (new Throttler()));
        this.options = { ...options, isMachineScoped: false };
        this.update();
        this._register(this.labelService.onDidChangeFormatters(() => this.updateLabel(), this));
    }
    update() {
        this.updateThrottler.queue(() => this.computeAndUpdateEnablement());
    }
    async computeAndUpdateEnablement() {
        this.enabled = false;
        if (!this.extension) {
            return;
        }
        if (this.extension.isBuiltin) {
            return;
        }
        if (this.extensionsWorkbenchService.canSetLanguage(this.extension)) {
            return;
        }
        if (this.extension.state === 3  && (await this.extensionsWorkbenchService.canInstall(this.extension))) {
            this.enabled = this.options.installPreReleaseVersion ? this.extension.hasPreReleaseVersion : this.extension.hasReleaseVersion;
            this.updateLabel();
        }
    }
    async run() {
        if (!this.extension) {
            return;
        }
        if (this.extension.deprecationInfo) {
            let detail = ( (localize(
                'deprecated message',
                "This extension is deprecated as it is no longer being maintained."
            )));
            let DeprecationChoice;
            ( ((function(DeprecationChoice) {
                DeprecationChoice[DeprecationChoice["InstallAnyway"] = 0] = "InstallAnyway";
                DeprecationChoice[DeprecationChoice["ShowAlternateExtension"] = 1] = "ShowAlternateExtension";
                DeprecationChoice[DeprecationChoice["ConfigureSettings"] = 2] = "ConfigureSettings";
                DeprecationChoice[DeprecationChoice["Cancel"] = 3] = "Cancel";
            })(DeprecationChoice || (DeprecationChoice = {}))));
            const buttons = [
                {
                    label: ( (localize('install anyway', "Install Anyway"))),
                    run: () => DeprecationChoice.InstallAnyway
                }
            ];
            if (this.extension.deprecationInfo.extension) {
                detail = ( (localize(
                    'deprecated with alternate extension message',
                    "This extension is deprecated. Use the {0} extension instead.",
                    this.extension.deprecationInfo.extension.displayName
                )));
                const alternateExtension = this.extension.deprecationInfo.extension;
                buttons.push({
                    label: ( (localize(
                        { key: 'Show alternate extension', comment: ['&& denotes a mnemonic'] },
                        "&&Open {0}",
                        this.extension.deprecationInfo.extension.displayName
                    ))),
                    run: async () => {
                        const [extension] = await this.extensionsWorkbenchService.getExtensions([{ id: alternateExtension.id, preRelease: alternateExtension.preRelease }], CancellationToken.None);
                        await this.extensionsWorkbenchService.open(extension);
                        return DeprecationChoice.ShowAlternateExtension;
                    }
                });
            }
            else if (this.extension.deprecationInfo.settings) {
                detail = ( (localize(
                    'deprecated with alternate settings message',
                    "This extension is deprecated as this functionality is now built-in to VS Code."
                )));
                const settings = this.extension.deprecationInfo.settings;
                buttons.push({
                    label: ( (localize(
                        { key: 'configure in settings', comment: ['&& denotes a mnemonic'] },
                        "&&Configure Settings"
                    ))),
                    run: async () => {
                        await this.preferencesService.openSettings({ query: ( (settings.map(setting => `@id:${setting}`))).join(' ') });
                        return DeprecationChoice.ConfigureSettings;
                    }
                });
            }
            else if (this.extension.deprecationInfo.additionalInfo) {
                detail = ( (new MarkdownString(`${detail} ${this.extension.deprecationInfo.additionalInfo}`)));
            }
            const { result } = await this.dialogService.prompt({
                type: Severity.Warning,
                message: ( (localize(
                    'install confirmation',
                    "Are you sure you want to install '{0}'?",
                    this.extension.displayName
                ))),
                detail: isString(detail) ? detail : undefined,
                custom: isString(detail) ? undefined : {
                    markdownDetails: [{
                            markdown: detail
                        }]
                },
                buttons,
                cancelButton: {
                    run: () => DeprecationChoice.Cancel
                }
            });
            if (result !== DeprecationChoice.InstallAnyway) {
                return;
            }
        }
        this.extensionsWorkbenchService.open(this.extension, { showPreReleaseVersion: this.options.installPreReleaseVersion });
        alert(( (localize(
            'installExtensionStart',
            "Installing extension {0} started. An editor is now open with more details on this extension",
            this.extension.displayName
        ))));
        this.telemetryService.publicLog('extensions:action:install', { ...this.extension.telemetryData, actionId: this.id });
        const extension = await this.install(this.extension);
        if (extension?.local) {
            alert(( (localize(
                'installExtensionComplete',
                "Installing extension {0} is completed.",
                this.extension.displayName
            ))));
            const runningExtension = await this.getRunningExtension(extension.local);
            if (runningExtension && !(runningExtension.activationEvents && ( (runningExtension.activationEvents.some(activationEent => activationEent.startsWith('onLanguage')))))) {
                const action = await this.getThemeAction(extension);
                if (action) {
                    action.extension = extension;
                    try {
                        return action.run({ showCurrentTheme: true, ignoreFocusLost: true });
                    }
                    finally {
                        action.dispose();
                    }
                }
            }
        }
    }
    async getThemeAction(extension) {
        const colorThemes = await this.workbenchThemeService.getColorThemes();
        if (( (colorThemes.some(theme => isThemeFromExtension(theme, extension))))) {
            return this.instantiationService.createInstance(SetColorThemeAction);
        }
        const fileIconThemes = await this.workbenchThemeService.getFileIconThemes();
        if (( (fileIconThemes.some(theme => isThemeFromExtension(theme, extension))))) {
            return this.instantiationService.createInstance(SetFileIconThemeAction);
        }
        const productIconThemes = await this.workbenchThemeService.getProductIconThemes();
        if (( (productIconThemes.some(theme => isThemeFromExtension(theme, extension))))) {
            return this.instantiationService.createInstance(SetProductIconThemeAction);
        }
        return undefined;
    }
    async install(extension) {
        try {
            return await this.extensionsWorkbenchService.install(extension, this.options);
        }
        catch (error) {
            await this.instantiationService.createInstance(PromptExtensionInstallFailureAction, extension, extension.latestVersion, 2 , error).run();
            return undefined;
        }
    }
    async getRunningExtension(extension) {
        const runningExtension = await this.runtimeExtensionService.getExtension(extension.identifier.id);
        if (runningExtension) {
            return runningExtension;
        }
        if (this.runtimeExtensionService.canAddExtension(toExtensionDescription(extension))) {
            return (
                 (new Promise((c, e) => {
                    const disposable = this.runtimeExtensionService.onDidChangeExtensions(async () => {
                        const runningExtension = await this.runtimeExtensionService.getExtension(extension.identifier.id);
                        if (runningExtension) {
                            disposable.dispose();
                            c(runningExtension);
                        }
                    });
                }))
            );
        }
        return null;
    }
    updateLabel() {
        this.label = this.getLabel();
    }
    getLabel(primary) {
        if (this.options.installPreReleaseVersion && this.extension?.hasPreReleaseVersion) {
            return primary ? ( (localize('install pre-release', "Install Pre-Release"))) : ( (localize('install pre-release version', "Install Pre-Release Version")));
        }
        if (this.extension?.hasPreReleaseVersion) {
            return primary ? ( (localize('install', "Install"))) : ( (localize('install release version', "Install Release Version")));
        }
        return (
             (localize('install', "Install"))
        );
    }
};
InstallAction = ( (__decorate([
    ( (__param(1, IExtensionsWorkbenchService))),
    ( (__param(2, IInstantiationService))),
    ( (__param(3, IExtensionService))),
    ( (__param(4, IWorkbenchThemeService))),
    ( (__param(5, ILabelService))),
    ( (__param(6, IDialogService))),
    ( (__param(7, IPreferencesService))),
    ( (__param(8, ITelemetryService)))
], InstallAction)));
class InstallingLabelAction extends ExtensionAction {
    static { this.LABEL = ( (localize('installing', "Installing"))); }
    static { this.CLASS = `${ExtensionAction.LABEL_ACTION_CLASS} install installing`; }
    constructor() {
        super('extension.installing', InstallingLabelAction.LABEL, InstallingLabelAction.CLASS, false);
    }
    update() {
        this.class = `${InstallingLabelAction.CLASS}${this.extension && this.extension.state === 0  ? '' : ' hide'}`;
    }
}
(class InstallInOtherServerAction extends ExtensionAction {
    static { this.INSTALL_LABEL = ( (localize('install', "Install"))); }
    static { this.INSTALLING_LABEL = ( (localize('installing', "Installing"))); }
    static { this.Class = `${ExtensionAction.LABEL_ACTION_CLASS} prominent install`; }
    static { this.InstallingClass = `${ExtensionAction.LABEL_ACTION_CLASS} install installing`; }
    constructor(id, server, canInstallAnyWhere, extensionsWorkbenchService, extensionManagementServerService, extensionManifestPropertiesService) {
        super(id, InstallInOtherServerAction.INSTALL_LABEL, InstallInOtherServerAction.Class, false);
        this.server = server;
        this.canInstallAnyWhere = canInstallAnyWhere;
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.extensionManagementServerService = extensionManagementServerService;
        this.extensionManifestPropertiesService = extensionManifestPropertiesService;
        this.updateWhenCounterExtensionChanges = true;
        this.update();
    }
    update() {
        this.enabled = false;
        this.class = InstallInOtherServerAction.Class;
        if (this.canInstall()) {
            const extensionInOtherServer = this.extensionsWorkbenchService.installed.filter(e => areSameExtensions(e.identifier, this.extension.identifier) && e.server === this.server)[0];
            if (extensionInOtherServer) {
                if (extensionInOtherServer.state === 0  && !extensionInOtherServer.local) {
                    this.enabled = true;
                    this.label = InstallInOtherServerAction.INSTALLING_LABEL;
                    this.class = InstallInOtherServerAction.InstallingClass;
                }
            }
            else {
                this.enabled = true;
                this.label = this.getInstallLabel();
            }
        }
    }
    canInstall() {
        if (!this.extension
            || !this.server
            || !this.extension.local
            || this.extension.state !== 1
            || this.extension.type !== 1
            || this.extension.enablementState === 2  || this.extension.enablementState === 0  || this.extension.enablementState === 4 ) {
            return false;
        }
        if (isLanguagePackExtension(this.extension.local.manifest)) {
            return true;
        }
        if (this.server === this.extensionManagementServerService.localExtensionManagementServer && this.extensionManifestPropertiesService.prefersExecuteOnUI(this.extension.local.manifest)) {
            return true;
        }
        if (this.server === this.extensionManagementServerService.remoteExtensionManagementServer && this.extensionManifestPropertiesService.prefersExecuteOnWorkspace(this.extension.local.manifest)) {
            return true;
        }
        if (this.server === this.extensionManagementServerService.webExtensionManagementServer && this.extensionManifestPropertiesService.prefersExecuteOnWeb(this.extension.local.manifest)) {
            return true;
        }
        if (this.canInstallAnyWhere) {
            if (this.server === this.extensionManagementServerService.localExtensionManagementServer && this.extensionManifestPropertiesService.canExecuteOnUI(this.extension.local.manifest)) {
                return true;
            }
            if (this.server === this.extensionManagementServerService.remoteExtensionManagementServer && this.extensionManifestPropertiesService.canExecuteOnWorkspace(this.extension.local.manifest)) {
                return true;
            }
        }
        return false;
    }
    async run() {
        if (!this.extension?.local) {
            return;
        }
        if (!this.extension?.server) {
            return;
        }
        if (!this.server) {
            return;
        }
        this.extensionsWorkbenchService.open(this.extension);
        alert(( (localize(
            'installExtensionStart',
            "Installing extension {0} started. An editor is now open with more details on this extension",
            this.extension.displayName
        ))));
        return this.extensionsWorkbenchService.installInServer(this.extension, this.server);
    }
});
let UninstallAction = class UninstallAction extends ExtensionAction {
    static { this.UninstallLabel = ( (localize('uninstallAction', "Uninstall"))); }
    static { this.UninstallingLabel = ( (localize('Uninstalling', "Uninstalling"))); }
    static { this.UninstallClass = `${ExtensionAction.LABEL_ACTION_CLASS} uninstall`; }
    static { this.UnInstallingClass = `${ExtensionAction.LABEL_ACTION_CLASS} uninstall uninstalling`; }
    constructor(extensionsWorkbenchService) {
        super('extensions.uninstall', UninstallAction.UninstallLabel, UninstallAction.UninstallClass, false);
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.update();
    }
    update() {
        if (!this.extension) {
            this.enabled = false;
            return;
        }
        const state = this.extension.state;
        if (state === 2 ) {
            this.label = UninstallAction.UninstallingLabel;
            this.class = UninstallAction.UnInstallingClass;
            this.enabled = false;
            return;
        }
        this.label = UninstallAction.UninstallLabel;
        this.class = UninstallAction.UninstallClass;
        this.tooltip = UninstallAction.UninstallLabel;
        if (state !== 1 ) {
            this.enabled = false;
            return;
        }
        if (this.extension.isBuiltin) {
            this.enabled = false;
            return;
        }
        this.enabled = true;
    }
    async run() {
        if (!this.extension) {
            return;
        }
        alert(( (localize(
            'uninstallExtensionStart',
            "Uninstalling extension {0} started.",
            this.extension.displayName
        ))));
        return this.extensionsWorkbenchService.uninstall(this.extension).then(() => {
            alert(( (localize(
                'uninstallExtensionComplete',
                "Please reload Visual Studio Code to complete the uninstallation of the extension {0}.",
                this.extension.displayName
            ))));
        });
    }
};
UninstallAction = ( (__decorate([
    ( (__param(0, IExtensionsWorkbenchService)))
], UninstallAction)));
class AbstractUpdateAction extends ExtensionAction {
    static { this.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} prominent update`; }
    static { this.DisabledClass = `${AbstractUpdateAction.EnabledClass} disabled`; }
    constructor(id, label, extensionsWorkbenchService) {
        super(id, label, AbstractUpdateAction.DisabledClass, false);
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.updateThrottler = ( (new Throttler()));
        this.update();
    }
    update() {
        this.updateThrottler.queue(() => this.computeAndUpdateEnablement());
    }
    async computeAndUpdateEnablement() {
        this.enabled = false;
        this.class = UpdateAction.DisabledClass;
        if (!this.extension) {
            return;
        }
        if (this.extension.deprecationInfo) {
            return;
        }
        const canInstall = await this.extensionsWorkbenchService.canInstall(this.extension);
        const isInstalled = this.extension.state === 1 ;
        this.enabled = canInstall && isInstalled && this.extension.outdated;
        this.class = this.enabled ? AbstractUpdateAction.EnabledClass : AbstractUpdateAction.DisabledClass;
    }
}
let UpdateAction = class UpdateAction extends AbstractUpdateAction {
    constructor(verbose, extensionsWorkbenchService, instantiationService) {
        super(`extensions.update`, ( (localize('update', "Update"))), extensionsWorkbenchService);
        this.verbose = verbose;
        this.instantiationService = instantiationService;
    }
    update() {
        super.update();
        if (this.extension) {
            this.label = this.verbose ? ( (localize('update to', "Update to v{0}", this.extension.latestVersion))) : ( (localize('update', "Update")));
        }
    }
    async run() {
        if (!this.extension) {
            return;
        }
        alert(( (localize(
            'updateExtensionStart',
            "Updating extension {0} to version {1} started.",
            this.extension.displayName,
            this.extension.latestVersion
        ))));
        return this.install(this.extension);
    }
    async install(extension) {
        try {
            await this.extensionsWorkbenchService.install(extension, extension.local?.preRelease ? { installPreReleaseVersion: true } : undefined);
            alert(( (localize(
                'updateExtensionComplete',
                "Updating extension {0} to version {1} completed.",
                extension.displayName,
                extension.latestVersion
            ))));
        }
        catch (err) {
            this.instantiationService.createInstance(PromptExtensionInstallFailureAction, extension, extension.latestVersion, 3 , err).run();
        }
    }
};
UpdateAction = ( (__decorate([
    ( (__param(1, IExtensionsWorkbenchService))),
    ( (__param(2, IInstantiationService)))
], UpdateAction)));
(class MigrateDeprecatedExtensionAction extends ExtensionAction {
    static { this.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} migrate`; }
    static { this.DisabledClass = `${MigrateDeprecatedExtensionAction.EnabledClass} disabled`; }
    constructor(small, extensionsWorkbenchService) {
        super('extensionsAction.migrateDeprecatedExtension', ( (localize('migrateExtension', "Migrate"))), MigrateDeprecatedExtensionAction.DisabledClass, false);
        this.small = small;
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.update();
    }
    update() {
        this.enabled = false;
        this.class = MigrateDeprecatedExtensionAction.DisabledClass;
        if (!this.extension?.local) {
            return;
        }
        if (this.extension.state !== 1 ) {
            return;
        }
        if (!this.extension.deprecationInfo?.extension) {
            return;
        }
        const id = this.extension.deprecationInfo.extension.id;
        if (( (this.extensionsWorkbenchService.local.some(e => areSameExtensions(e.identifier, { id }))))) {
            return;
        }
        this.enabled = true;
        this.class = MigrateDeprecatedExtensionAction.EnabledClass;
        this.tooltip = ( (localize(
            'migrate to',
            "Migrate to {0}",
            this.extension.deprecationInfo.extension.displayName
        )));
        this.label = this.small ? ( (localize('migrate', "Migrate"))) : this.tooltip;
    }
    async run() {
        if (!this.extension?.deprecationInfo?.extension) {
            return;
        }
        const local = this.extension.local;
        await this.extensionsWorkbenchService.uninstall(this.extension);
        const [extension] = await this.extensionsWorkbenchService.getExtensions([{ id: this.extension.deprecationInfo.extension.id, preRelease: this.extension.deprecationInfo?.extension?.preRelease }], CancellationToken.None);
        await this.extensionsWorkbenchService.install(extension, { isMachineScoped: local?.isMachineScoped });
    }
});
let ExtensionDropDownAction = class ExtensionDropDownAction extends ExtensionAction {
    constructor(id, label, cssClass, enabled, instantiationService) {
        super(id, label, cssClass, enabled);
        this.instantiationService = instantiationService;
        this._actionViewItem = null;
    }
    createActionViewItem() {
        this._actionViewItem = this.instantiationService.createInstance(DropDownMenuActionViewItem, this);
        return this._actionViewItem;
    }
    run({ actionGroups, disposeActionsOnHide }) {
        this._actionViewItem?.showMenu(actionGroups, disposeActionsOnHide);
        return Promise.resolve();
    }
};
ExtensionDropDownAction = ( (__decorate([
    ( (__param(4, IInstantiationService)))
], ExtensionDropDownAction)));
let DropDownMenuActionViewItem = class DropDownMenuActionViewItem extends ActionViewItem {
    constructor(action, contextMenuService) {
        super(null, action, { icon: true, label: true });
        this.contextMenuService = contextMenuService;
    }
    showMenu(menuActionGroups, disposeActionsOnHide) {
        if (this.element) {
            const actions = this.getActions(menuActionGroups);
            const elementPosition = dom.getDomNodePagePosition(this.element);
            const anchor = { x: elementPosition.left, y: elementPosition.top + elementPosition.height + 10 };
            this.contextMenuService.showContextMenu({
                getAnchor: () => anchor,
                getActions: () => actions,
                actionRunner: this.actionRunner,
                onHide: () => { if (disposeActionsOnHide) {
                    disposeIfDisposable(actions);
                } }
            });
        }
    }
    getActions(menuActionGroups) {
        let actions = [];
        for (const menuActions of menuActionGroups) {
            actions = [...actions, ...menuActions, ( (new Separator()))];
        }
        return actions.length ? actions.slice(0, actions.length - 1) : actions;
    }
};
DropDownMenuActionViewItem = ( (__decorate([
    ( (__param(1, IContextMenuService)))
], DropDownMenuActionViewItem)));
async function getContextMenuActionsGroups(extension, contextKeyService, instantiationService) {
    return instantiationService.invokeFunction(async (accessor) => {
        const extensionsWorkbenchService = accessor.get(IExtensionsWorkbenchService);
        const menuService = accessor.get(IMenuService);
        const extensionRecommendationsService = accessor.get(IExtensionRecommendationsService);
        const extensionIgnoredRecommendationsService = accessor.get(IExtensionIgnoredRecommendationsService);
        const workbenchThemeService = accessor.get(IWorkbenchThemeService);
        const cksOverlay = [];
        if (extension) {
            cksOverlay.push(['extension', extension.identifier.id]);
            cksOverlay.push(['isBuiltinExtension', extension.isBuiltin]);
            cksOverlay.push(['isDefaultApplicationScopedExtension', extension.local && isApplicationScopedExtension(extension.local.manifest)]);
            cksOverlay.push(['isApplicationScopedExtension', extension.local && extension.local.isApplicationScoped]);
            cksOverlay.push(['extensionHasConfiguration', extension.local && !!extension.local.manifest.contributes && !!extension.local.manifest.contributes.configuration]);
            cksOverlay.push(['extensionHasKeybindings', extension.local && !!extension.local.manifest.contributes && !!extension.local.manifest.contributes.keybindings]);
            cksOverlay.push(['extensionHasCommands', extension.local && !!extension.local.manifest.contributes && !!extension.local.manifest.contributes?.commands]);
            cksOverlay.push(['isExtensionRecommended', !!extensionRecommendationsService.getAllRecommendationsWithReason()[extension.identifier.id.toLowerCase()]]);
            cksOverlay.push(['isExtensionWorkspaceRecommended', extensionRecommendationsService.getAllRecommendationsWithReason()[extension.identifier.id.toLowerCase()]?.reasonId === 0 ]);
            cksOverlay.push(['isUserIgnoredRecommendation', ( (extensionIgnoredRecommendationsService.globalIgnoredRecommendations.some(e => e === extension.identifier.id.toLowerCase())))]);
            if (extension.state === 1 ) {
                cksOverlay.push(['extensionStatus', 'installed']);
            }
            cksOverlay.push(['installedExtensionIsPreReleaseVersion', !!extension.local?.isPreReleaseVersion]);
            cksOverlay.push(['installedExtensionIsOptedTpPreRelease', !!extension.local?.preRelease]);
            cksOverlay.push(['galleryExtensionIsPreReleaseVersion', !!extension.gallery?.properties.isPreReleaseVersion]);
            cksOverlay.push(['extensionHasPreReleaseVersion', extension.hasPreReleaseVersion]);
            cksOverlay.push(['extensionHasReleaseVersion', extension.hasReleaseVersion]);
            const [colorThemes, fileIconThemes, productIconThemes] = await Promise.all([workbenchThemeService.getColorThemes(), workbenchThemeService.getFileIconThemes(), workbenchThemeService.getProductIconThemes()]);
            cksOverlay.push(['extensionHasColorThemes', ( (colorThemes.some(theme => isThemeFromExtension(theme, extension))))]);
            cksOverlay.push(['extensionHasFileIconThemes', ( (fileIconThemes.some(theme => isThemeFromExtension(theme, extension))))]);
            cksOverlay.push(['extensionHasProductIconThemes', ( (productIconThemes.some(theme => isThemeFromExtension(theme, extension))))]);
            cksOverlay.push(['canSetLanguage', extensionsWorkbenchService.canSetLanguage(extension)]);
            cksOverlay.push(['isActiveLanguagePackExtension', extension.gallery && language === getLocale(extension.gallery)]);
        }
        const menu = menuService.createMenu(MenuId.ExtensionContext, contextKeyService.createOverlay(cksOverlay));
        const actionsGroups = menu.getActions({ shouldForwardArgs: true });
        menu.dispose();
        return actionsGroups;
    });
}
function toActions(actionsGroups, instantiationService) {
    const result = [];
    for (const [, actions] of actionsGroups) {
        result.push(( (actions.map(action => {
            if (action instanceof SubmenuAction) {
                return action;
            }
            return instantiationService.createInstance(MenuItemExtensionAction, action);
        }))));
    }
    return result;
}
(class ManageExtensionAction extends ExtensionDropDownAction {
    static { this.ID = 'extensions.manage'; }
    static { this.Class = `${ExtensionAction.ICON_ACTION_CLASS} manage ` + ThemeIcon.asClassName(manageExtensionIcon); }
    static { this.HideManageExtensionClass = `${ManageExtensionAction.Class} hide`; }
    constructor(instantiationService, extensionService, contextKeyService) {
        super(ManageExtensionAction.ID, '', '', true, instantiationService);
        this.extensionService = extensionService;
        this.contextKeyService = contextKeyService;
        this.tooltip = ( (localize('manage', "Manage")));
        this.update();
    }
    async getActionGroups() {
        const groups = [];
        const contextMenuActionsGroups = await getContextMenuActionsGroups(this.extension, this.contextKeyService, this.instantiationService);
        const themeActions = [], installActions = [], otherActionGroups = [];
        for (const [group, actions] of contextMenuActionsGroups) {
            if (group === INSTALL_ACTIONS_GROUP) {
                installActions.push(...toActions([[group, actions]], this.instantiationService)[0]);
            }
            else if (group === THEME_ACTIONS_GROUP) {
                themeActions.push(...toActions([[group, actions]], this.instantiationService)[0]);
            }
            else {
                otherActionGroups.push(...toActions([[group, actions]], this.instantiationService));
            }
        }
        if (themeActions.length) {
            groups.push(themeActions);
        }
        groups.push([
            this.instantiationService.createInstance(EnableGloballyAction),
            this.instantiationService.createInstance(EnableForWorkspaceAction)
        ]);
        groups.push([
            this.instantiationService.createInstance(DisableGloballyAction),
            this.instantiationService.createInstance(DisableForWorkspaceAction)
        ]);
        groups.push([
            ...(installActions.length ? installActions : []),
            this.instantiationService.createInstance(InstallAnotherVersionAction),
            this.instantiationService.createInstance(UninstallAction),
        ]);
        otherActionGroups.forEach(actions => groups.push(actions));
        groups.forEach(group => group.forEach(extensionAction => {
            if (extensionAction instanceof ExtensionAction) {
                extensionAction.extension = this.extension;
            }
        }));
        return groups;
    }
    async run() {
        await this.extensionService.whenInstalledExtensionsRegistered();
        return super.run({ actionGroups: await this.getActionGroups(), disposeActionsOnHide: true });
    }
    update() {
        this.class = ManageExtensionAction.HideManageExtensionClass;
        this.enabled = false;
        if (this.extension) {
            const state = this.extension.state;
            this.enabled = state === 1 ;
            this.class = this.enabled || state === 2  ? ManageExtensionAction.Class : ManageExtensionAction.HideManageExtensionClass;
            this.tooltip = state === 2  ? ( (localize('ManageExtensionAction.uninstallingTooltip', "Uninstalling"))) : '';
        }
    }
});
let MenuItemExtensionAction = class MenuItemExtensionAction extends ExtensionAction {
    constructor(action, extensionsWorkbenchService) {
        super(action.id, action.label);
        this.action = action;
        this.extensionsWorkbenchService = extensionsWorkbenchService;
    }
    update() {
        if (!this.extension) {
            return;
        }
        if (this.action.id === TOGGLE_IGNORE_EXTENSION_ACTION_ID) {
            this.checked = !this.extensionsWorkbenchService.isExtensionIgnoredToSync(this.extension);
        }
        else {
            this.checked = this.action.checked;
        }
    }
    async run() {
        if (this.extension) {
            await this.action.run(this.extension.local ? getExtensionId(this.extension.local.manifest.publisher, this.extension.local.manifest.name)
                : this.extension.gallery ? getExtensionId(this.extension.gallery.publisher, this.extension.gallery.name)
                    : this.extension.identifier.id);
        }
    }
};
MenuItemExtensionAction = ( (__decorate([
    ( (__param(1, IExtensionsWorkbenchService)))
], MenuItemExtensionAction)));
(class SwitchToPreReleaseVersionAction extends ExtensionAction {
    static { this.ID = 'workbench.extensions.action.switchToPreReleaseVersion'; }
    static { this.TITLE = { value: ( (localize('switch to pre-release version', "Switch to Pre-Release Version"))), original: 'Switch to  Pre-Release Version' }; }
    constructor(icon, commandService) {
        super(SwitchToPreReleaseVersionAction.ID, icon ? '' : SwitchToPreReleaseVersionAction.TITLE.value, `${icon ? ExtensionAction.ICON_ACTION_CLASS + ' ' + ThemeIcon.asClassName(preReleaseIcon) : ExtensionAction.LABEL_ACTION_CLASS} hide-when-disabled switch-to-prerelease`, true);
        this.commandService = commandService;
        this.tooltip = ( (localize(
            'switch to pre-release version tooltip',
            "Switch to Pre-Release version of this extension"
        )));
        this.update();
    }
    update() {
        this.enabled = !!this.extension && !this.extension.isBuiltin && !this.extension.local?.isPreReleaseVersion && !this.extension.local?.preRelease && this.extension.hasPreReleaseVersion && this.extension.state === 1 ;
    }
    async run() {
        if (!this.enabled) {
            return;
        }
        return this.commandService.executeCommand(SwitchToPreReleaseVersionAction.ID, this.extension?.identifier.id);
    }
});
(class SwitchToReleasedVersionAction extends ExtensionAction {
    static { this.ID = 'workbench.extensions.action.switchToReleaseVersion'; }
    static { this.TITLE = { value: ( (localize('switch to release version', "Switch to Release Version"))), original: 'Switch to Release Version' }; }
    constructor(icon, commandService) {
        super(SwitchToReleasedVersionAction.ID, icon ? '' : SwitchToReleasedVersionAction.TITLE.value, `${icon ? ExtensionAction.ICON_ACTION_CLASS + ' ' + ThemeIcon.asClassName(preReleaseIcon) : ExtensionAction.LABEL_ACTION_CLASS} hide-when-disabled switch-to-released`);
        this.commandService = commandService;
        this.tooltip = ( (localize(
            'switch to release version tooltip',
            "Switch to Release version of this extension"
        )));
        this.update();
    }
    update() {
        this.enabled = !!this.extension && !this.extension.isBuiltin && this.extension.state === 1  && !!this.extension.local?.isPreReleaseVersion && !!this.extension.hasReleaseVersion;
    }
    async run() {
        if (!this.enabled) {
            return;
        }
        return this.commandService.executeCommand(SwitchToReleasedVersionAction.ID, this.extension?.identifier.id);
    }
});
let InstallAnotherVersionAction = class InstallAnotherVersionAction extends ExtensionAction {
    static { this.ID = 'workbench.extensions.action.install.anotherVersion'; }
    static { this.LABEL = ( (localize('install another version', "Install Another Version..."))); }
    constructor(extensionsWorkbenchService, extensionGalleryService, quickInputService, instantiationService, dialogService) {
        super(InstallAnotherVersionAction.ID, InstallAnotherVersionAction.LABEL, ExtensionAction.LABEL_ACTION_CLASS);
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.extensionGalleryService = extensionGalleryService;
        this.quickInputService = quickInputService;
        this.instantiationService = instantiationService;
        this.dialogService = dialogService;
        this.update();
    }
    update() {
        this.enabled = !!this.extension && !this.extension.isBuiltin && !!this.extension.gallery && !!this.extension.local && !!this.extension.server && this.extension.state === 1  && !this.extension.deprecationInfo;
    }
    async run() {
        if (!this.enabled) {
            return;
        }
        const targetPlatform = await this.extension.server.extensionManagementService.getTargetPlatform();
        const allVersions = await this.extensionGalleryService.getAllCompatibleVersions(this.extension.gallery, this.extension.local.preRelease, targetPlatform);
        if (!allVersions.length) {
            await this.dialogService.info(( (localize('no versions', "This extension has no other versions."))));
            return;
        }
        const picks = ( (allVersions.map((v, i) => {
            return {
                id: v.version,
                label: v.version,
                description: `${fromNow(( new Date(Date.parse(v.date))), true)}${v.isPreReleaseVersion ? ` (${( ( localize('pre-release', "pre-release")))})` : ''}${v.version === this.extension.version ? ` (${( ( localize('current', "current")))})` : ''}`,
                latest: i === 0,
                ariaLabel: `${v.isPreReleaseVersion ? 'Pre-Release version' : 'Release version'} ${v.version}`,
                isPreReleaseVersion: v.isPreReleaseVersion
            };
        })));
        const pick = await this.quickInputService.pick(picks, {
            placeHolder: ( (localize('selectVersion', "Select Version to Install"))),
            matchOnDetail: true
        });
        if (pick) {
            if (this.extension.version === pick.id) {
                return;
            }
            try {
                if (pick.latest) {
                    await this.extensionsWorkbenchService.install(this.extension, { installPreReleaseVersion: pick.isPreReleaseVersion });
                }
                else {
                    await this.extensionsWorkbenchService.installVersion(this.extension, pick.id, { installPreReleaseVersion: pick.isPreReleaseVersion });
                }
            }
            catch (error) {
                this.instantiationService.createInstance(PromptExtensionInstallFailureAction, this.extension, pick.latest ? this.extension.latestVersion : pick.id, 2 , error).run();
            }
        }
        return null;
    }
};
InstallAnotherVersionAction = ( (__decorate([
    ( (__param(0, IExtensionsWorkbenchService))),
    ( (__param(1, IExtensionGalleryService))),
    ( (__param(2, IQuickInputService))),
    ( (__param(3, IInstantiationService))),
    ( (__param(4, IDialogService)))
], InstallAnotherVersionAction)));
let EnableForWorkspaceAction = class EnableForWorkspaceAction extends ExtensionAction {
    static { this.ID = 'extensions.enableForWorkspace'; }
    static { this.LABEL = ( (localize('enableForWorkspaceAction', "Enable (Workspace)"))); }
    constructor(extensionsWorkbenchService, extensionEnablementService) {
        super(EnableForWorkspaceAction.ID, EnableForWorkspaceAction.LABEL, ExtensionAction.LABEL_ACTION_CLASS);
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.extensionEnablementService = extensionEnablementService;
        this.tooltip = ( (localize(
            'enableForWorkspaceActionToolTip',
            "Enable this extension only in this workspace"
        )));
        this.update();
    }
    update() {
        this.enabled = false;
        if (this.extension && this.extension.local) {
            this.enabled = this.extension.state === 1
                && !this.extensionEnablementService.isEnabled(this.extension.local)
                && this.extensionEnablementService.canChangeWorkspaceEnablement(this.extension.local);
        }
    }
    async run() {
        if (!this.extension) {
            return;
        }
        return this.extensionsWorkbenchService.setEnablement(this.extension, 9 );
    }
};
EnableForWorkspaceAction = ( (__decorate([
    ( (__param(0, IExtensionsWorkbenchService))),
    ( (__param(1, IWorkbenchExtensionEnablementService)))
], EnableForWorkspaceAction)));
let EnableGloballyAction = class EnableGloballyAction extends ExtensionAction {
    static { this.ID = 'extensions.enableGlobally'; }
    static { this.LABEL = ( (localize('enableGloballyAction', "Enable"))); }
    constructor(extensionsWorkbenchService, extensionEnablementService) {
        super(EnableGloballyAction.ID, EnableGloballyAction.LABEL, ExtensionAction.LABEL_ACTION_CLASS);
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.extensionEnablementService = extensionEnablementService;
        this.tooltip = ( (localize('enableGloballyActionToolTip', "Enable this extension")));
        this.update();
    }
    update() {
        this.enabled = false;
        if (this.extension && this.extension.local) {
            this.enabled = this.extension.state === 1
                && this.extensionEnablementService.isDisabledGlobally(this.extension.local)
                && this.extensionEnablementService.canChangeEnablement(this.extension.local);
        }
    }
    async run() {
        if (!this.extension) {
            return;
        }
        return this.extensionsWorkbenchService.setEnablement(this.extension, 8 );
    }
};
EnableGloballyAction = ( (__decorate([
    ( (__param(0, IExtensionsWorkbenchService))),
    ( (__param(1, IWorkbenchExtensionEnablementService)))
], EnableGloballyAction)));
let DisableForWorkspaceAction = class DisableForWorkspaceAction extends ExtensionAction {
    static { this.ID = 'extensions.disableForWorkspace'; }
    static { this.LABEL = ( (localize('disableForWorkspaceAction', "Disable (Workspace)"))); }
    constructor(workspaceContextService, extensionsWorkbenchService, extensionEnablementService, extensionService) {
        super(DisableForWorkspaceAction.ID, DisableForWorkspaceAction.LABEL, ExtensionAction.LABEL_ACTION_CLASS);
        this.workspaceContextService = workspaceContextService;
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.extensionEnablementService = extensionEnablementService;
        this.extensionService = extensionService;
        this.tooltip = ( (localize(
            'disableForWorkspaceActionToolTip',
            "Disable this extension only in this workspace"
        )));
        this.update();
        this._register(this.extensionService.onDidChangeExtensions(() => this.update()));
    }
    update() {
        this.enabled = false;
        if (this.extension && this.extension.local && ( (this.extensionService.extensions.some(
            e => areSameExtensions({ id: e.identifier.value, uuid: e.uuid }, this.extension.identifier) && this.workspaceContextService.getWorkbenchState() !== 1
        )))) {
            this.enabled = this.extension.state === 1
                && ((this.extension.enablementState === 8  || this.extension.enablementState === 9) )
                && this.extensionEnablementService.canChangeWorkspaceEnablement(this.extension.local);
        }
    }
    async run() {
        if (!this.extension) {
            return;
        }
        return this.extensionsWorkbenchService.setEnablement(this.extension, 7 );
    }
};
DisableForWorkspaceAction = ( (__decorate([
    ( (__param(0, IWorkspaceContextService))),
    ( (__param(1, IExtensionsWorkbenchService))),
    ( (__param(2, IWorkbenchExtensionEnablementService))),
    ( (__param(3, IExtensionService)))
], DisableForWorkspaceAction)));
let DisableGloballyAction = class DisableGloballyAction extends ExtensionAction {
    static { this.ID = 'extensions.disableGlobally'; }
    static { this.LABEL = ( (localize('disableGloballyAction', "Disable"))); }
    constructor(extensionsWorkbenchService, extensionEnablementService, extensionService) {
        super(DisableGloballyAction.ID, DisableGloballyAction.LABEL, ExtensionAction.LABEL_ACTION_CLASS);
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.extensionEnablementService = extensionEnablementService;
        this.extensionService = extensionService;
        this.tooltip = ( (localize('disableGloballyActionToolTip', "Disable this extension")));
        this.update();
        this._register(this.extensionService.onDidChangeExtensions(() => this.update()));
    }
    update() {
        this.enabled = false;
        if (this.extension && this.extension.local && ( (this.extensionService.extensions.some(
            e => areSameExtensions({ id: e.identifier.value, uuid: e.uuid }, this.extension.identifier)
        )))) {
            this.enabled = this.extension.state === 1
                && ((this.extension.enablementState === 8  || this.extension.enablementState === 9) )
                && this.extensionEnablementService.canChangeEnablement(this.extension.local);
        }
    }
    async run() {
        if (!this.extension) {
            return;
        }
        return this.extensionsWorkbenchService.setEnablement(this.extension, 6 );
    }
};
DisableGloballyAction = ( (__decorate([
    ( (__param(0, IExtensionsWorkbenchService))),
    ( (__param(1, IWorkbenchExtensionEnablementService))),
    ( (__param(2, IExtensionService)))
], DisableGloballyAction)));
(class ReloadAction extends ExtensionAction {
    static { this.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} reload`; }
    static { this.DisabledClass = `${ReloadAction.EnabledClass} disabled`; }
    constructor(hostService, extensionService) {
        super('extensions.reload', ( (localize('reloadAction', "Reload"))), ReloadAction.DisabledClass, false);
        this.hostService = hostService;
        this.extensionService = extensionService;
        this.updateWhenCounterExtensionChanges = true;
        this._register(this.extensionService.onDidChangeExtensions(() => this.update()));
        this.update();
    }
    update() {
        this.enabled = false;
        this.tooltip = '';
        if (!this.extension) {
            return;
        }
        const state = this.extension.state;
        if (state === 0  || state === 2 ) {
            return;
        }
        if (this.extension.local && this.extension.local.manifest && this.extension.local.manifest.contributes && this.extension.local.manifest.contributes.localizations && this.extension.local.manifest.contributes.localizations.length > 0) {
            return;
        }
        const reloadTooltip = this.extension.reloadRequiredStatus;
        this.enabled = reloadTooltip !== undefined;
        this.label = reloadTooltip !== undefined ? ( (localize('reload required', 'Reload Required'))) : '';
        this.tooltip = reloadTooltip !== undefined ? reloadTooltip : '';
        this.class = this.enabled ? ReloadAction.EnabledClass : ReloadAction.DisabledClass;
    }
    run() {
        return Promise.resolve(this.hostService.reload());
    }
});
function isThemeFromExtension(theme, extension) {
    return !!(extension && theme.extensionData && ExtensionIdentifier.equals(theme.extensionData.extensionId, extension.identifier.id));
}
function getQuickPickEntries(themes, currentTheme, extension, showCurrentTheme) {
    const picks = [];
    for (const theme of themes) {
        if (isThemeFromExtension(theme, extension) && !(showCurrentTheme && theme === currentTheme)) {
            picks.push({ label: theme.label, id: theme.id });
        }
    }
    if (showCurrentTheme) {
        picks.push({ type: 'separator', label: ( (localize('current', "current"))) });
        picks.push({ label: currentTheme.label, id: currentTheme.id });
    }
    return picks;
}
let SetColorThemeAction = class SetColorThemeAction extends ExtensionAction {
    static { this.ID = 'workbench.extensions.action.setColorTheme'; }
    static { this.TITLE = { value: ( (localize('workbench.extensions.action.setColorTheme', "Set Color Theme"))), original: 'Set Color Theme' }; }
    static { this.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} theme`; }
    static { this.DisabledClass = `${SetColorThemeAction.EnabledClass} disabled`; }
    constructor(extensionService, workbenchThemeService, quickInputService, extensionEnablementService) {
        super(SetColorThemeAction.ID, SetColorThemeAction.TITLE.value, SetColorThemeAction.DisabledClass, false);
        this.workbenchThemeService = workbenchThemeService;
        this.quickInputService = quickInputService;
        this.extensionEnablementService = extensionEnablementService;
        this._register(Event.any(extensionService.onDidChangeExtensions, workbenchThemeService.onDidColorThemeChange)(() => this.update(), this));
        this.update();
    }
    update() {
        this.workbenchThemeService.getColorThemes().then(colorThemes => {
            this.enabled = this.computeEnablement(colorThemes);
            this.class = this.enabled ? SetColorThemeAction.EnabledClass : SetColorThemeAction.DisabledClass;
        });
    }
    computeEnablement(colorThemes) {
        return !!this.extension && this.extension.state === 1  && this.extensionEnablementService.isEnabledEnablementState(this.extension.enablementState) && ( (colorThemes.some(th => isThemeFromExtension(th, this.extension))));
    }
    async run({ showCurrentTheme, ignoreFocusLost } = { showCurrentTheme: false, ignoreFocusLost: false }) {
        const colorThemes = await this.workbenchThemeService.getColorThemes();
        if (!this.computeEnablement(colorThemes)) {
            return;
        }
        const currentTheme = this.workbenchThemeService.getColorTheme();
        const delayer = ( (new Delayer(100)));
        const picks = getQuickPickEntries(colorThemes, currentTheme, this.extension, showCurrentTheme);
        const pickedTheme = await this.quickInputService.pick(picks, {
            placeHolder: ( (localize('select color theme', "Select Color Theme"))),
            onDidFocus: item => delayer.trigger(() => this.workbenchThemeService.setColorTheme(item.id, undefined)),
            ignoreFocusLost
        });
        return this.workbenchThemeService.setColorTheme(pickedTheme ? pickedTheme.id : currentTheme.id, 'auto');
    }
};
SetColorThemeAction = ( (__decorate([
    ( (__param(0, IExtensionService))),
    ( (__param(1, IWorkbenchThemeService))),
    ( (__param(2, IQuickInputService))),
    ( (__param(3, IWorkbenchExtensionEnablementService)))
], SetColorThemeAction)));
let SetFileIconThemeAction = class SetFileIconThemeAction extends ExtensionAction {
    static { this.ID = 'workbench.extensions.action.setFileIconTheme'; }
    static { this.TITLE = { value: ( (localize('workbench.extensions.action.setFileIconTheme', "Set File Icon Theme"))), original: 'Set File Icon Theme' }; }
    static { this.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} theme`; }
    static { this.DisabledClass = `${SetFileIconThemeAction.EnabledClass} disabled`; }
    constructor(extensionService, workbenchThemeService, quickInputService, extensionEnablementService) {
        super(SetFileIconThemeAction.ID, SetFileIconThemeAction.TITLE.value, SetFileIconThemeAction.DisabledClass, false);
        this.workbenchThemeService = workbenchThemeService;
        this.quickInputService = quickInputService;
        this.extensionEnablementService = extensionEnablementService;
        this._register(Event.any(extensionService.onDidChangeExtensions, workbenchThemeService.onDidFileIconThemeChange)(() => this.update(), this));
        this.update();
    }
    update() {
        this.workbenchThemeService.getFileIconThemes().then(fileIconThemes => {
            this.enabled = this.computeEnablement(fileIconThemes);
            this.class = this.enabled ? SetFileIconThemeAction.EnabledClass : SetFileIconThemeAction.DisabledClass;
        });
    }
    computeEnablement(colorThemfileIconThemess) {
        return !!this.extension && this.extension.state === 1  && this.extensionEnablementService.isEnabledEnablementState(this.extension.enablementState) && ( (colorThemfileIconThemess.some(th => isThemeFromExtension(th, this.extension))));
    }
    async run({ showCurrentTheme, ignoreFocusLost } = { showCurrentTheme: false, ignoreFocusLost: false }) {
        const fileIconThemes = await this.workbenchThemeService.getFileIconThemes();
        if (!this.computeEnablement(fileIconThemes)) {
            return;
        }
        const currentTheme = this.workbenchThemeService.getFileIconTheme();
        const delayer = ( (new Delayer(100)));
        const picks = getQuickPickEntries(fileIconThemes, currentTheme, this.extension, showCurrentTheme);
        const pickedTheme = await this.quickInputService.pick(picks, {
            placeHolder: ( (localize('select file icon theme', "Select File Icon Theme"))),
            onDidFocus: item => delayer.trigger(() => this.workbenchThemeService.setFileIconTheme(item.id, undefined)),
            ignoreFocusLost
        });
        return this.workbenchThemeService.setFileIconTheme(pickedTheme ? pickedTheme.id : currentTheme.id, 'auto');
    }
};
SetFileIconThemeAction = ( (__decorate([
    ( (__param(0, IExtensionService))),
    ( (__param(1, IWorkbenchThemeService))),
    ( (__param(2, IQuickInputService))),
    ( (__param(3, IWorkbenchExtensionEnablementService)))
], SetFileIconThemeAction)));
let SetProductIconThemeAction = class SetProductIconThemeAction extends ExtensionAction {
    static { this.ID = 'workbench.extensions.action.setProductIconTheme'; }
    static { this.TITLE = { value: ( (localize(
        'workbench.extensions.action.setProductIconTheme',
        "Set Product Icon Theme"
    ))), original: 'Set Product Icon Theme' }; }
    static { this.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} theme`; }
    static { this.DisabledClass = `${SetProductIconThemeAction.EnabledClass} disabled`; }
    constructor(extensionService, workbenchThemeService, quickInputService, extensionEnablementService) {
        super(SetProductIconThemeAction.ID, SetProductIconThemeAction.TITLE.value, SetProductIconThemeAction.DisabledClass, false);
        this.workbenchThemeService = workbenchThemeService;
        this.quickInputService = quickInputService;
        this.extensionEnablementService = extensionEnablementService;
        this._register(Event.any(extensionService.onDidChangeExtensions, workbenchThemeService.onDidProductIconThemeChange)(() => this.update(), this));
        this.update();
    }
    update() {
        this.workbenchThemeService.getProductIconThemes().then(productIconThemes => {
            this.enabled = this.computeEnablement(productIconThemes);
            this.class = this.enabled ? SetProductIconThemeAction.EnabledClass : SetProductIconThemeAction.DisabledClass;
        });
    }
    computeEnablement(productIconThemes) {
        return !!this.extension && this.extension.state === 1  && this.extensionEnablementService.isEnabledEnablementState(this.extension.enablementState) && ( (productIconThemes.some(th => isThemeFromExtension(th, this.extension))));
    }
    async run({ showCurrentTheme, ignoreFocusLost } = { showCurrentTheme: false, ignoreFocusLost: false }) {
        const productIconThemes = await this.workbenchThemeService.getProductIconThemes();
        if (!this.computeEnablement(productIconThemes)) {
            return;
        }
        const currentTheme = this.workbenchThemeService.getProductIconTheme();
        const delayer = ( (new Delayer(100)));
        const picks = getQuickPickEntries(productIconThemes, currentTheme, this.extension, showCurrentTheme);
        const pickedTheme = await this.quickInputService.pick(picks, {
            placeHolder: ( (localize('select product icon theme', "Select Product Icon Theme"))),
            onDidFocus: item => delayer.trigger(() => this.workbenchThemeService.setProductIconTheme(item.id, undefined)),
            ignoreFocusLost
        });
        return this.workbenchThemeService.setProductIconTheme(pickedTheme ? pickedTheme.id : currentTheme.id, 'auto');
    }
};
SetProductIconThemeAction = ( (__decorate([
    ( (__param(0, IExtensionService))),
    ( (__param(1, IWorkbenchThemeService))),
    ( (__param(2, IQuickInputService))),
    ( (__param(3, IWorkbenchExtensionEnablementService)))
], SetProductIconThemeAction)));
(class SetLanguageAction extends ExtensionAction {
    static { this.ID = 'workbench.extensions.action.setDisplayLanguage'; }
    static { this.TITLE = { value: ( (localize('workbench.extensions.action.setDisplayLanguage', "Set Display Language"))), original: 'Set Display Language' }; }
    static { this.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} language`; }
    static { this.DisabledClass = `${SetLanguageAction.EnabledClass} disabled`; }
    constructor(extensionsWorkbenchService) {
        super(SetLanguageAction.ID, SetLanguageAction.TITLE.value, SetLanguageAction.DisabledClass, false);
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.update();
    }
    update() {
        this.enabled = false;
        this.class = SetLanguageAction.DisabledClass;
        if (!this.extension) {
            return;
        }
        if (!this.extensionsWorkbenchService.canSetLanguage(this.extension)) {
            return;
        }
        if (this.extension.gallery && language === getLocale(this.extension.gallery)) {
            return;
        }
        this.enabled = true;
        this.class = SetLanguageAction.EnabledClass;
    }
    async run() {
        return this.extension && this.extensionsWorkbenchService.setLanguage(this.extension);
    }
});
(class ClearLanguageAction extends ExtensionAction {
    static { this.ID = 'workbench.extensions.action.clearLanguage'; }
    static { this.TITLE = { value: ( (localize('workbench.extensions.action.clearLanguage', "Clear Display Language"))), original: 'Clear Display Language' }; }
    static { this.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} language`; }
    static { this.DisabledClass = `${ClearLanguageAction.EnabledClass} disabled`; }
    constructor(extensionsWorkbenchService, localeService) {
        super(ClearLanguageAction.ID, ClearLanguageAction.TITLE.value, ClearLanguageAction.DisabledClass, false);
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.localeService = localeService;
        this.update();
    }
    update() {
        this.enabled = false;
        this.class = ClearLanguageAction.DisabledClass;
        if (!this.extension) {
            return;
        }
        if (!this.extensionsWorkbenchService.canSetLanguage(this.extension)) {
            return;
        }
        if (this.extension.gallery && language !== getLocale(this.extension.gallery)) {
            return;
        }
        this.enabled = true;
        this.class = ClearLanguageAction.EnabledClass;
    }
    async run() {
        return this.extension && this.localeService.clearLocalePreference();
    }
});
(class ShowRecommendedExtensionAction extends Action {
    static { this.ID = 'workbench.extensions.action.showRecommendedExtension'; }
    static { this.LABEL = ( (localize('showRecommendedExtension', "Show Recommended Extension"))); }
    constructor(extensionId, paneCompositeService, extensionWorkbenchService) {
        super(ShowRecommendedExtensionAction.ID, ShowRecommendedExtensionAction.LABEL, undefined, false);
        this.paneCompositeService = paneCompositeService;
        this.extensionWorkbenchService = extensionWorkbenchService;
        this.extensionId = extensionId;
    }
    async run() {
        const paneComposite = await this.paneCompositeService.openPaneComposite(VIEWLET_ID, 0 , true);
        const paneContainer = paneComposite?.getViewPaneContainer();
        paneContainer.search(`@id:${this.extensionId}`);
        paneContainer.focus();
        const [extension] = await this.extensionWorkbenchService.getExtensions([{ id: this.extensionId }], { source: 'install-recommendation' }, CancellationToken.None);
        if (extension) {
            return this.extensionWorkbenchService.open(extension);
        }
        return null;
    }
});
let InstallRecommendedExtensionAction = class InstallRecommendedExtensionAction extends Action {
    static { this.ID = 'workbench.extensions.action.installRecommendedExtension'; }
    static { this.LABEL = ( (localize('installRecommendedExtension', "Install Recommended Extension"))); }
    constructor(extensionId, paneCompositeService, instantiationService, extensionWorkbenchService) {
        super(InstallRecommendedExtensionAction.ID, InstallRecommendedExtensionAction.LABEL, undefined, false);
        this.paneCompositeService = paneCompositeService;
        this.instantiationService = instantiationService;
        this.extensionWorkbenchService = extensionWorkbenchService;
        this.extensionId = extensionId;
    }
    async run() {
        const viewlet = await this.paneCompositeService.openPaneComposite(VIEWLET_ID, 0 , true);
        const viewPaneContainer = viewlet?.getViewPaneContainer();
        viewPaneContainer.search(`@id:${this.extensionId}`);
        viewPaneContainer.focus();
        const [extension] = await this.extensionWorkbenchService.getExtensions([{ id: this.extensionId }], { source: 'install-recommendation' }, CancellationToken.None);
        if (extension) {
            await this.extensionWorkbenchService.open(extension);
            try {
                await this.extensionWorkbenchService.install(extension);
            }
            catch (err) {
                this.instantiationService.createInstance(PromptExtensionInstallFailureAction, extension, extension.latestVersion, 2 , err).run();
            }
        }
    }
};
InstallRecommendedExtensionAction = ( (__decorate([
    ( (__param(1, IPaneCompositePartService))),
    ( (__param(2, IInstantiationService))),
    ( (__param(3, IExtensionsWorkbenchService)))
], InstallRecommendedExtensionAction)));
(class IgnoreExtensionRecommendationAction extends Action {
    static { this.ID = 'extensions.ignore'; }
    static { this.Class = `${ExtensionAction.LABEL_ACTION_CLASS} ignore`; }
    constructor(extension, extensionRecommendationsManagementService) {
        super(IgnoreExtensionRecommendationAction.ID, 'Ignore Recommendation');
        this.extension = extension;
        this.extensionRecommendationsManagementService = extensionRecommendationsManagementService;
        this.class = IgnoreExtensionRecommendationAction.Class;
        this.tooltip = ( (localize('ignoreExtensionRecommendation', "Do not recommend this extension again")));
        this.enabled = true;
    }
    run() {
        this.extensionRecommendationsManagementService.toggleGlobalIgnoredRecommendation(this.extension.identifier.id, true);
        return Promise.resolve();
    }
});
(class UndoIgnoreExtensionRecommendationAction extends Action {
    static { this.ID = 'extensions.ignore'; }
    static { this.Class = `${ExtensionAction.LABEL_ACTION_CLASS} undo-ignore`; }
    constructor(extension, extensionRecommendationsManagementService) {
        super(UndoIgnoreExtensionRecommendationAction.ID, 'Undo');
        this.extension = extension;
        this.extensionRecommendationsManagementService = extensionRecommendationsManagementService;
        this.class = UndoIgnoreExtensionRecommendationAction.Class;
        this.tooltip = ( (localize('undo', "Undo")));
        this.enabled = true;
    }
    run() {
        this.extensionRecommendationsManagementService.toggleGlobalIgnoredRecommendation(this.extension.identifier.id, false);
        return Promise.resolve();
    }
});
let SearchExtensionsAction = class SearchExtensionsAction extends Action {
    constructor(searchValue, paneCompositeService) {
        super('extensions.searchExtensions', ( (localize('search recommendations', "Search Extensions"))), undefined, true);
        this.searchValue = searchValue;
        this.paneCompositeService = paneCompositeService;
    }
    async run() {
        const viewPaneContainer = (await this.paneCompositeService.openPaneComposite(VIEWLET_ID, 0 , true))?.getViewPaneContainer();
        viewPaneContainer.search(this.searchValue);
        viewPaneContainer.focus();
    }
};
SearchExtensionsAction = ( (__decorate([
    ( (__param(1, IPaneCompositePartService)))
], SearchExtensionsAction)));
let AbstractConfigureRecommendedExtensionsAction = class AbstractConfigureRecommendedExtensionsAction extends Action {
    constructor(id, label, contextService, fileService, textFileService, editorService, jsonEditingService, textModelResolverService) {
        super(id, label);
        this.contextService = contextService;
        this.fileService = fileService;
        this.textFileService = textFileService;
        this.editorService = editorService;
        this.jsonEditingService = jsonEditingService;
        this.textModelResolverService = textModelResolverService;
    }
    openExtensionsFile(extensionsFileResource) {
        return this.getOrCreateExtensionsFile(extensionsFileResource)
            .then(({ created, content }) => this.getSelectionPosition(content, extensionsFileResource, ['recommendations'])
            .then(selection => this.editorService.openEditor({
            resource: extensionsFileResource,
            options: {
                pinned: created,
                selection
            }
        })), error => Promise.reject(( (new Error( (localize(
            'OpenExtensionsFile.failed',
            "Unable to create 'extensions.json' file inside the '.vscode' folder ({0}).",
            error
        )))))));
    }
    openWorkspaceConfigurationFile(workspaceConfigurationFile) {
        return this.getOrUpdateWorkspaceConfigurationFile(workspaceConfigurationFile)
            .then(content => this.getSelectionPosition(( (content.value.toString())), content.resource, ['extensions', 'recommendations']))
            .then(selection => this.editorService.openEditor({
            resource: workspaceConfigurationFile,
            options: {
                selection,
                forceReload: true
            }
        }));
    }
    getOrUpdateWorkspaceConfigurationFile(workspaceConfigurationFile) {
        return Promise.resolve(this.fileService.readFile(workspaceConfigurationFile))
            .then(content => {
            const workspaceRecommendations = json.parse(( (content.value.toString())))['extensions'];
            if (!workspaceRecommendations || !workspaceRecommendations.recommendations) {
                return this.jsonEditingService.write(workspaceConfigurationFile, [{ path: ['extensions'], value: { recommendations: [] } }], true)
                    .then(() => this.fileService.readFile(workspaceConfigurationFile));
            }
            return content;
        });
    }
    getSelectionPosition(content, resource, path) {
        const tree = json.parseTree(content);
        const node = json.findNodeAtLocation(tree, path);
        if (node && node.parent && node.parent.children) {
            const recommendationsValueNode = node.parent.children[1];
            const lastExtensionNode = recommendationsValueNode.children && recommendationsValueNode.children.length ? recommendationsValueNode.children[recommendationsValueNode.children.length - 1] : null;
            const offset = lastExtensionNode ? lastExtensionNode.offset + lastExtensionNode.length : recommendationsValueNode.offset + 1;
            return Promise.resolve(this.textModelResolverService.createModelReference(resource))
                .then(reference => {
                const position = reference.object.textEditorModel.getPositionAt(offset);
                reference.dispose();
                return {
                    startLineNumber: position.lineNumber,
                    startColumn: position.column,
                    endLineNumber: position.lineNumber,
                    endColumn: position.column,
                };
            });
        }
        return Promise.resolve(undefined);
    }
    getOrCreateExtensionsFile(extensionsFileResource) {
        return Promise.resolve(this.fileService.readFile(extensionsFileResource)).then(content => {
            return { created: false, extensionsFileResource, content: ( (content.value.toString())) };
        }, err => {
            return this.textFileService.write(extensionsFileResource, ExtensionsConfigurationInitialContent).then(() => {
                return { created: true, extensionsFileResource, content: ExtensionsConfigurationInitialContent };
            });
        });
    }
};
AbstractConfigureRecommendedExtensionsAction = ( (__decorate([
    ( (__param(2, IWorkspaceContextService))),
    ( (__param(3, IFileService))),
    ( (__param(4, ITextFileService))),
    ( (__param(5, IEditorService))),
    ( (__param(6, IJSONEditingService))),
    ( (__param(7, ITextModelService)))
], AbstractConfigureRecommendedExtensionsAction)));
(class ConfigureWorkspaceRecommendedExtensionsAction extends AbstractConfigureRecommendedExtensionsAction {
    static { this.ID = 'workbench.extensions.action.configureWorkspaceRecommendedExtensions'; }
    static { this.LABEL = ( (localize(
        'configureWorkspaceRecommendedExtensions',
        "Configure Recommended Extensions (Workspace)"
    ))); }
    constructor(id, label, fileService, textFileService, contextService, editorService, jsonEditingService, textModelResolverService) {
        super(id, label, contextService, fileService, textFileService, editorService, jsonEditingService, textModelResolverService);
        this._register(this.contextService.onDidChangeWorkbenchState(() => this.update(), this));
        this.update();
    }
    update() {
        this.enabled = this.contextService.getWorkbenchState() !== 1 ;
    }
    run() {
        switch (this.contextService.getWorkbenchState()) {
            case 2 :
                return this.openExtensionsFile(this.contextService.getWorkspace().folders[0].toResource(EXTENSIONS_CONFIG));
            case 3 :
                return this.openWorkspaceConfigurationFile(this.contextService.getWorkspace().configuration);
        }
        return Promise.resolve();
    }
});
(class ConfigureWorkspaceFolderRecommendedExtensionsAction extends AbstractConfigureRecommendedExtensionsAction {
    static { this.ID = 'workbench.extensions.action.configureWorkspaceFolderRecommendedExtensions'; }
    static { this.LABEL = ( (localize(
        'configureWorkspaceFolderRecommendedExtensions',
        "Configure Recommended Extensions (Workspace Folder)"
    ))); }
    constructor(id, label, fileService, textFileService, contextService, editorService, jsonEditingService, textModelResolverService, commandService) {
        super(id, label, contextService, fileService, textFileService, editorService, jsonEditingService, textModelResolverService);
        this.commandService = commandService;
    }
    run() {
        const folderCount = this.contextService.getWorkspace().folders.length;
        const pickFolderPromise = folderCount === 1 ? Promise.resolve(this.contextService.getWorkspace().folders[0]) : this.commandService.executeCommand(PICK_WORKSPACE_FOLDER_COMMAND_ID);
        return Promise.resolve(pickFolderPromise)
            .then(workspaceFolder => {
            if (workspaceFolder) {
                return this.openExtensionsFile(workspaceFolder.toResource(EXTENSIONS_CONFIG));
            }
            return null;
        });
    }
});
(class ExtensionStatusLabelAction extends Action {
    static { this.ENABLED_CLASS = `${ExtensionAction.TEXT_ACTION_CLASS} extension-status-label`; }
    static { this.DISABLED_CLASS = `${ExtensionStatusLabelAction.ENABLED_CLASS} hide`; }
    get extension() { return this._extension; }
    set extension(extension) {
        if (!(this._extension && extension && areSameExtensions(this._extension.identifier, extension.identifier))) {
            this.initialStatus = null;
            this.status = null;
            this.enablementState = null;
        }
        this._extension = extension;
        this.update();
    }
    constructor(extensionService, extensionManagementServerService, extensionEnablementService) {
        super('extensions.action.statusLabel', '', ExtensionStatusLabelAction.DISABLED_CLASS, false);
        this.extensionService = extensionService;
        this.extensionManagementServerService = extensionManagementServerService;
        this.extensionEnablementService = extensionEnablementService;
        this.initialStatus = null;
        this.status = null;
        this.version = null;
        this.enablementState = null;
        this._extension = null;
    }
    update() {
        const label = this.computeLabel();
        this.label = label || '';
        this.class = label ? ExtensionStatusLabelAction.ENABLED_CLASS : ExtensionStatusLabelAction.DISABLED_CLASS;
    }
    computeLabel() {
        if (!this.extension) {
            return null;
        }
        const currentStatus = this.status;
        const currentVersion = this.version;
        const currentEnablementState = this.enablementState;
        this.status = this.extension.state;
        this.version = this.extension.version;
        if (this.initialStatus === null) {
            this.initialStatus = this.status;
        }
        this.enablementState = this.extension.enablementState;
        const canAddExtension = () => {
            const runningExtension = this.extensionService.extensions.filter(e => areSameExtensions({ id: e.identifier.value, uuid: e.uuid }, this.extension.identifier))[0];
            if (this.extension.local) {
                if (runningExtension && this.extension.version === runningExtension.version) {
                    return true;
                }
                return this.extensionService.canAddExtension(toExtensionDescription(this.extension.local));
            }
            return false;
        };
        const canRemoveExtension = () => {
            if (this.extension.local) {
                if (this.extensionService.extensions.every(e => !(areSameExtensions({ id: e.identifier.value, uuid: e.uuid }, this.extension.identifier) && this.extension.server === this.extensionManagementServerService.getExtensionManagementServer(toExtension(e))))) {
                    return true;
                }
                return this.extensionService.canRemoveExtension(toExtensionDescription(this.extension.local));
            }
            return false;
        };
        if (currentStatus !== null) {
            if (currentStatus === 0  && this.status === 1 ) {
                return canAddExtension() ? this.initialStatus === 1  && this.version !== currentVersion ? ( (localize('updated', "Updated"))) : ( (localize('installed', "Installed"))) : null;
            }
            if (currentStatus === 2  && this.status === 3 ) {
                this.initialStatus = this.status;
                return canRemoveExtension() ? ( (localize('uninstalled', "Uninstalled"))) : null;
            }
        }
        if (currentEnablementState !== null) {
            const currentlyEnabled = this.extensionEnablementService.isEnabledEnablementState(currentEnablementState);
            const enabled = this.extensionEnablementService.isEnabledEnablementState(this.enablementState);
            if (!currentlyEnabled && enabled) {
                return canAddExtension() ? ( (localize('enabled', "Enabled"))) : null;
            }
            if (currentlyEnabled && !enabled) {
                return canRemoveExtension() ? ( (localize('disabled', "Disabled"))) : null;
            }
        }
        return null;
    }
    run() {
        return Promise.resolve();
    }
});
(class ToggleSyncExtensionAction extends ExtensionDropDownAction {
    static { this.IGNORED_SYNC_CLASS = `${ExtensionAction.ICON_ACTION_CLASS} extension-sync ${ThemeIcon.asClassName(syncIgnoredIcon)}`; }
    static { this.SYNC_CLASS = `${ToggleSyncExtensionAction.ICON_ACTION_CLASS} extension-sync ${ThemeIcon.asClassName(syncEnabledIcon)}`; }
    constructor(configurationService, extensionsWorkbenchService, userDataSyncEnablementService, instantiationService) {
        super('extensions.sync', '', ToggleSyncExtensionAction.SYNC_CLASS, false, instantiationService);
        this.configurationService = configurationService;
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.userDataSyncEnablementService = userDataSyncEnablementService;
        this._register(Event.filter(this.configurationService.onDidChangeConfiguration, e => e.affectsConfiguration('settingsSync.ignoredExtensions'))(() => this.update()));
        this._register(userDataSyncEnablementService.onDidChangeEnablement(() => this.update()));
        this.update();
    }
    update() {
        this.enabled = !!this.extension && this.userDataSyncEnablementService.isEnabled() && this.extension.state === 1 ;
        if (this.extension) {
            const isIgnored = this.extensionsWorkbenchService.isExtensionIgnoredToSync(this.extension);
            this.class = isIgnored ? ToggleSyncExtensionAction.IGNORED_SYNC_CLASS : ToggleSyncExtensionAction.SYNC_CLASS;
            this.tooltip = isIgnored ? ( (localize('ignored', "This extension is ignored during sync"))) : ( (localize('synced', "This extension is synced")));
        }
    }
    async run() {
        return super.run({
            actionGroups: [
                [
                    ( (new Action(
                    'extensions.syncignore',
                    this.extensionsWorkbenchService.isExtensionIgnoredToSync(this.extension) ? ( (localize('sync', "Sync this extension"))) : ( (localize('do not sync', "Do not sync this extension"))),
                    undefined,
                    true,
                    () => this.extensionsWorkbenchService.toggleExtensionIgnoredToSync(this.extension)
                )))
                ]
            ], disposeActionsOnHide: true
        });
    }
});
(class ExtensionStatusAction extends ExtensionAction {
    static { this.CLASS = `${ExtensionAction.ICON_ACTION_CLASS} extension-status`; }
    get status() { return this._status; }
    constructor(extensionManagementServerService, labelService, commandService, workspaceTrustEnablementService, workspaceTrustService, extensionsWorkbenchService, extensionService, extensionManifestPropertiesService, contextService, productService, workbenchExtensionEnablementService) {
        super('extensions.status', '', `${ExtensionStatusAction.CLASS} hide`, false);
        this.extensionManagementServerService = extensionManagementServerService;
        this.labelService = labelService;
        this.commandService = commandService;
        this.workspaceTrustEnablementService = workspaceTrustEnablementService;
        this.workspaceTrustService = workspaceTrustService;
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.extensionService = extensionService;
        this.extensionManifestPropertiesService = extensionManifestPropertiesService;
        this.contextService = contextService;
        this.productService = productService;
        this.workbenchExtensionEnablementService = workbenchExtensionEnablementService;
        this.updateWhenCounterExtensionChanges = true;
        this._onDidChangeStatus = this._register(( (new Emitter())));
        this.onDidChangeStatus = this._onDidChangeStatus.event;
        this.updateThrottler = ( (new Throttler()));
        this._register(this.labelService.onDidChangeFormatters(() => this.update(), this));
        this._register(this.extensionService.onDidChangeExtensions(() => this.update()));
        this.update();
    }
    update() {
        this.updateThrottler.queue(() => this.computeAndUpdateStatus());
    }
    async computeAndUpdateStatus() {
        this.updateStatus(undefined, true);
        this.enabled = false;
        if (!this.extension) {
            return;
        }
        if (this.extension.isMalicious) {
            this.updateStatus({ icon: warningIcon, message: ( (new MarkdownString(
                 (localize('malicious tooltip', "This extension was reported to be problematic."))
            ))) }, true);
            return;
        }
        if (this.extension.deprecationInfo) {
            if (this.extension.deprecationInfo.extension) {
                const link = `[${this.extension.deprecationInfo.extension.displayName}](${( ( URI.parse(
                    `command:extension.open?${encodeURIComponent(JSON.stringify([this.extension.deprecationInfo.extension.id]))}`
                )))})`;
                this.updateStatus({ icon: warningIcon, message: ( (new MarkdownString( (localize(
                    'deprecated with alternate extension tooltip',
                    "This extension is deprecated. Use the {0} extension instead.",
                    link
                ))))) }, true);
            }
            else if (this.extension.deprecationInfo.settings) {
                const link = `[${( ( localize('settings', "settings")))}](${( ( URI.parse(
                    `command:workbench.action.openSettings?${encodeURIComponent(JSON.stringify([( ( this.extension.deprecationInfo.settings.map(setting => `@id:${setting}`))).join(' ')]))}`
                )))})`;
                this.updateStatus({ icon: warningIcon, message: ( (new MarkdownString( (localize(
                    'deprecated with alternate settings tooltip',
                    "This extension is deprecated as this functionality is now built-in to VS Code. Configure these {0} to use this functionality.",
                    link
                ))))) }, true);
            }
            else {
                const message = ( (new MarkdownString( (localize(
                    'deprecated tooltip',
                    "This extension is deprecated as it is no longer being maintained."
                )))));
                if (this.extension.deprecationInfo.additionalInfo) {
                    message.appendMarkdown(` ${this.extension.deprecationInfo.additionalInfo}`);
                }
                this.updateStatus({ icon: warningIcon, message }, true);
            }
            return;
        }
        if (this.extensionsWorkbenchService.canSetLanguage(this.extension)) {
            return;
        }
        if (this.extension.gallery && this.extension.state === 3  && !(await this.extensionsWorkbenchService.canInstall(this.extension))) {
            if (this.extensionManagementServerService.localExtensionManagementServer || this.extensionManagementServerService.remoteExtensionManagementServer) {
                const targetPlatform = await (this.extensionManagementServerService.localExtensionManagementServer ? this.extensionManagementServerService.localExtensionManagementServer.extensionManagementService.getTargetPlatform() : this.extensionManagementServerService.remoteExtensionManagementServer.extensionManagementService.getTargetPlatform());
                const message = ( (new MarkdownString(`${( ( localize(
                    'incompatible platform',
                    "The '{0}' extension is not available in {1} for {2}.",
                    this.extension.displayName || this.extension.identifier.id,
                    this.productService.nameLong,
                    TargetPlatformToString(targetPlatform)
                )))} [${( ( localize('learn more', "Learn More")))}](https://aka.ms/vscode-platform-specific-extensions)`)));
                this.updateStatus({ icon: warningIcon, message }, true);
                return;
            }
            if (this.extensionManagementServerService.webExtensionManagementServer) {
                const productName = ( (localize('VS Code for Web', "{0} for the Web", this.productService.nameLong)));
                const message = ( (new MarkdownString(`${( ( localize(
                    'not web tooltip',
                    "The '{0}' extension is not available in {1}.",
                    this.extension.displayName || this.extension.identifier.id,
                    productName
                )))} [${( ( localize('learn why', "Learn Why")))}](https://aka.ms/vscode-web-extensions-guide)`)));
                this.updateStatus({ icon: warningIcon, message }, true);
                return;
            }
        }
        if (!this.extension.local ||
            !this.extension.server ||
            this.extension.state !== 1 ) {
            return;
        }
        if (this.extension.enablementState === 2 ) {
            this.updateStatus({ message: ( (new MarkdownString( (localize(
                'disabled by environment',
                "This extension is disabled by the environment."
            ))))) }, true);
            return;
        }
        if (this.extension.enablementState === 3 ) {
            this.updateStatus({ message: ( (new MarkdownString( (localize(
                'enabled by environment',
                "This extension is enabled because it is required in the current environment."
            ))))) }, true);
            return;
        }
        if (this.extension.enablementState === 4 ) {
            const details = getWorkspaceSupportTypeMessage(this.extension.local.manifest.capabilities?.virtualWorkspaces);
            this.updateStatus({ icon: infoIcon, message: ( (new MarkdownString(details ? escapeMarkdownSyntaxTokens(details) : ( (localize(
                'disabled because of virtual workspace',
                "This extension has been disabled because it does not support virtual workspaces."
            )))))) }, true);
            return;
        }
        if (isVirtualWorkspace(this.contextService.getWorkspace())) {
            const virtualSupportType = this.extensionManifestPropertiesService.getExtensionVirtualWorkspaceSupportType(this.extension.local.manifest);
            const details = getWorkspaceSupportTypeMessage(this.extension.local.manifest.capabilities?.virtualWorkspaces);
            if (virtualSupportType === 'limited' || details) {
                this.updateStatus({ icon: warningIcon, message: ( (new MarkdownString(details ? escapeMarkdownSyntaxTokens(details) : ( (localize(
                    'extension limited because of virtual workspace',
                    "This extension has limited features because the current workspace is virtual."
                )))))) }, true);
                return;
            }
        }
        if (this.extension.enablementState === 0  ||
            (this.extension.enablementState === 5  && this.workbenchExtensionEnablementService.getDependenciesEnablementStates(this.extension.local).every(([, enablementState]) => this.workbenchExtensionEnablementService.isEnabledEnablementState(enablementState) || enablementState === 0 ))) {
            this.enabled = true;
            const untrustedDetails = getWorkspaceSupportTypeMessage(this.extension.local.manifest.capabilities?.untrustedWorkspaces);
            this.updateStatus({ icon: trustIcon, message: ( (new MarkdownString(
                untrustedDetails ? escapeMarkdownSyntaxTokens(untrustedDetails) : ( (localize(
                    'extension disabled because of trust requirement',
                    "This extension has been disabled because the current workspace is not trusted."
                )))
            ))) }, true);
            return;
        }
        if (this.workspaceTrustEnablementService.isWorkspaceTrustEnabled() && !this.workspaceTrustService.isWorkspaceTrusted()) {
            const untrustedSupportType = this.extensionManifestPropertiesService.getExtensionUntrustedWorkspaceSupportType(this.extension.local.manifest);
            const untrustedDetails = getWorkspaceSupportTypeMessage(this.extension.local.manifest.capabilities?.untrustedWorkspaces);
            if (untrustedSupportType === 'limited' || untrustedDetails) {
                this.enabled = true;
                this.updateStatus({ icon: trustIcon, message: ( (new MarkdownString(
                    untrustedDetails ? escapeMarkdownSyntaxTokens(untrustedDetails) : ( (localize(
                        'extension limited because of trust requirement',
                        "This extension has limited features because the current workspace is not trusted."
                    )))
                ))) }, true);
                return;
            }
        }
        if (this.extension.enablementState === 1 ) {
            if (!( (this.extensionsWorkbenchService.installed.some(
                e => areSameExtensions(e.identifier, this.extension.identifier) && e.server !== this.extension.server
            )))) {
                let message;
                if (this.extensionManagementServerService.localExtensionManagementServer === this.extension.server) {
                    if (this.extensionManifestPropertiesService.prefersExecuteOnWorkspace(this.extension.local.manifest)) {
                        if (this.extensionManagementServerService.remoteExtensionManagementServer) {
                            message = ( (new MarkdownString(`${( ( localize(
                                'Install in remote server to enable',
                                "This extension is disabled in this workspace because it is defined to run in the Remote Extension Host. Please install the extension in '{0}' to enable.",
                                this.extensionManagementServerService.remoteExtensionManagementServer.label
                            )))} [${( ( localize('learn more', "Learn More")))}](https://aka.ms/vscode-remote/developing-extensions/architecture)`)));
                        }
                    }
                }
                else if (this.extensionManagementServerService.remoteExtensionManagementServer === this.extension.server) {
                    if (this.extensionManifestPropertiesService.prefersExecuteOnUI(this.extension.local.manifest)) {
                        if (this.extensionManagementServerService.localExtensionManagementServer) {
                            message = ( (new MarkdownString(`${( ( localize(
                                'Install in local server to enable',
                                "This extension is disabled in this workspace because it is defined to run in the Local Extension Host. Please install the extension locally to enable.",
                                this.extensionManagementServerService.remoteExtensionManagementServer.label
                            )))} [${( ( localize('learn more', "Learn More")))}](https://aka.ms/vscode-remote/developing-extensions/architecture)`)));
                        }
                        else if (isWeb) {
                            message = ( (new MarkdownString(`${( ( localize(
                                'Defined to run in desktop',
                                "This extension is disabled because it is defined to run only in {0} for the Desktop.",
                                this.productService.nameLong
                            )))} [${( ( localize('learn more', "Learn More")))}](https://aka.ms/vscode-remote/developing-extensions/architecture)`)));
                        }
                    }
                }
                else if (this.extensionManagementServerService.webExtensionManagementServer === this.extension.server) {
                    message = ( (new MarkdownString(`${( ( localize(
                        'Cannot be enabled',
                        "This extension is disabled because it is not supported in {0} for the Web.",
                        this.productService.nameLong
                    )))} [${( ( localize('learn more', "Learn More")))}](https://aka.ms/vscode-remote/developing-extensions/architecture)`)));
                }
                if (message) {
                    this.updateStatus({ icon: warningIcon, message }, true);
                }
                return;
            }
        }
        if (this.extensionManagementServerService.remoteExtensionManagementServer) {
            if (isLanguagePackExtension(this.extension.local.manifest)) {
                if (!( (this.extensionsWorkbenchService.installed.some(
                    e => areSameExtensions(e.identifier, this.extension.identifier) && e.server !== this.extension.server
                )))) {
                    const message = this.extension.server === this.extensionManagementServerService.localExtensionManagementServer
                        ? ( (new MarkdownString( (localize(
                        'Install language pack also in remote server',
                        "Install the language pack extension on '{0}' to enable it there also.",
                        this.extensionManagementServerService.remoteExtensionManagementServer.label
                    )))))
                        : ( (new MarkdownString( (localize(
                        'Install language pack also locally',
                        "Install the language pack extension locally to enable it there also."
                    )))));
                    this.updateStatus({ icon: infoIcon, message }, true);
                }
                return;
            }
            const runningExtension = this.extensionService.extensions.filter(e => areSameExtensions({ id: e.identifier.value, uuid: e.uuid }, this.extension.identifier))[0];
            const runningExtensionServer = runningExtension ? this.extensionManagementServerService.getExtensionManagementServer(toExtension(runningExtension)) : null;
            if (this.extension.server === this.extensionManagementServerService.localExtensionManagementServer && runningExtensionServer === this.extensionManagementServerService.remoteExtensionManagementServer) {
                if (this.extensionManifestPropertiesService.prefersExecuteOnWorkspace(this.extension.local.manifest)) {
                    this.updateStatus({ icon: infoIcon, message: ( (new MarkdownString(`${( ( localize(
                        'enabled remotely',
                        "This extension is enabled in the Remote Extension Host because it prefers to run there."
                    )))} [${( ( localize('learn more', "Learn More")))}](https://aka.ms/vscode-remote/developing-extensions/architecture)`))) }, true);
                }
                return;
            }
            if (this.extension.server === this.extensionManagementServerService.remoteExtensionManagementServer && runningExtensionServer === this.extensionManagementServerService.localExtensionManagementServer) {
                if (this.extensionManifestPropertiesService.prefersExecuteOnUI(this.extension.local.manifest)) {
                    this.updateStatus({ icon: infoIcon, message: ( (new MarkdownString(`${( ( localize(
                        'enabled locally',
                        "This extension is enabled in the Local Extension Host because it prefers to run there."
                    )))} [${( ( localize('learn more', "Learn More")))}](https://aka.ms/vscode-remote/developing-extensions/architecture)`))) }, true);
                }
                return;
            }
            if (this.extension.server === this.extensionManagementServerService.remoteExtensionManagementServer && runningExtensionServer === this.extensionManagementServerService.webExtensionManagementServer) {
                if (this.extensionManifestPropertiesService.canExecuteOnWeb(this.extension.local.manifest)) {
                    this.updateStatus({ icon: infoIcon, message: ( (new MarkdownString(`${( ( localize(
                        'enabled in web worker',
                        "This extension is enabled in the Web Worker Extension Host because it prefers to run there."
                    )))} [${( ( localize('learn more', "Learn More")))}](https://aka.ms/vscode-remote/developing-extensions/architecture)`))) }, true);
                }
                return;
            }
        }
        if (this.extension.enablementState === 5 ) {
            this.updateStatus({ icon: warningIcon, message: ( (new MarkdownString( (localize(
                'extension disabled because of dependency',
                "This extension has been disabled because it depends on an extension that is disabled."
            ))))) }, true);
            return;
        }
        const isEnabled = this.workbenchExtensionEnablementService.isEnabled(this.extension.local);
        const isRunning = ( (this.extensionService.extensions.some(
            e => areSameExtensions({ id: e.identifier.value, uuid: e.uuid }, this.extension.identifier)
        )));
        if (isEnabled && isRunning) {
            if (this.extensionManagementServerService.localExtensionManagementServer && this.extensionManagementServerService.remoteExtensionManagementServer) {
                if (this.extension.server === this.extensionManagementServerService.remoteExtensionManagementServer) {
                    this.updateStatus({ message: ( (new MarkdownString( (localize(
                        'extension enabled on remote',
                        "Extension is enabled on '{0}'",
                        this.extension.server.label
                    ))))) }, true);
                    return;
                }
            }
            if (this.extension.enablementState === 8 ) {
                this.updateStatus({ message: ( (new MarkdownString(
                     (localize('globally enabled', "This extension is enabled globally."))
                ))) }, true);
                return;
            }
            if (this.extension.enablementState === 9 ) {
                this.updateStatus({ message: ( (new MarkdownString( (localize(
                    'workspace enabled',
                    "This extension is enabled for this workspace by the user."
                ))))) }, true);
                return;
            }
        }
        if (!isEnabled && !isRunning) {
            if (this.extension.enablementState === 6 ) {
                this.updateStatus({ message: ( (new MarkdownString(
                     (localize('globally disabled', "This extension is disabled globally by the user."))
                ))) }, true);
                return;
            }
            if (this.extension.enablementState === 7 ) {
                this.updateStatus({ message: ( (new MarkdownString( (localize(
                    'workspace disabled',
                    "This extension is disabled for this workspace by the user."
                ))))) }, true);
                return;
            }
        }
        if (isEnabled && !isRunning && !this.extension.local.isValid) {
            const errors = ( (this.extension.local.validations.filter(([severity]) => severity === Severity.Error).map(([, message]) => message)));
            this.updateStatus({ icon: errorIcon, message: ( (new MarkdownString(errors.join(' ').trim()))) }, true);
        }
    }
    updateStatus(status, updateClass) {
        if (this._status === status) {
            return;
        }
        if (this._status && status && this._status.message === status.message && this._status.icon?.id === status.icon?.id) {
            return;
        }
        this._status = status;
        if (updateClass) {
            if (this._status?.icon === errorIcon) {
                this.class = `${ExtensionStatusAction.CLASS} extension-status-error ${ThemeIcon.asClassName(errorIcon)}`;
            }
            else if (this._status?.icon === warningIcon) {
                this.class = `${ExtensionStatusAction.CLASS} extension-status-warning ${ThemeIcon.asClassName(warningIcon)}`;
            }
            else if (this._status?.icon === infoIcon) {
                this.class = `${ExtensionStatusAction.CLASS} extension-status-info ${ThemeIcon.asClassName(infoIcon)}`;
            }
            else if (this._status?.icon === trustIcon) {
                this.class = `${ExtensionStatusAction.CLASS} ${ThemeIcon.asClassName(trustIcon)}`;
            }
            else {
                this.class = `${ExtensionStatusAction.CLASS} hide`;
            }
        }
        this._onDidChangeStatus.fire();
    }
    async run() {
        if (this._status?.icon === trustIcon) {
            return this.commandService.executeCommand('workbench.trust.manage');
        }
    }
});
(class ReinstallAction extends Action {
    static { this.ID = 'workbench.extensions.action.reinstall'; }
    static { this.LABEL = ( (localize('reinstall', "Reinstall Extension..."))); }
    constructor(id = ReinstallAction.ID, label = ReinstallAction.LABEL, extensionsWorkbenchService, extensionManagementServerService, quickInputService, notificationService, hostService, instantiationService, extensionService) {
        super(id, label);
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.extensionManagementServerService = extensionManagementServerService;
        this.quickInputService = quickInputService;
        this.notificationService = notificationService;
        this.hostService = hostService;
        this.instantiationService = instantiationService;
        this.extensionService = extensionService;
    }
    get enabled() {
        return this.extensionsWorkbenchService.local.filter(l => !l.isBuiltin && l.local).length > 0;
    }
    run() {
        return this.quickInputService.pick(this.getEntries(), { placeHolder: ( (localize('selectExtensionToReinstall', "Select Extension to Reinstall"))) })
            .then(pick => pick && this.reinstallExtension(pick.extension));
    }
    getEntries() {
        return this.extensionsWorkbenchService.queryLocal()
            .then(local => {
            const entries = ( (local
                .filter(extension => !extension.isBuiltin && extension.server !== this.extensionManagementServerService.webExtensionManagementServer)
                .map(extension => {
                return {
                    id: extension.identifier.id,
                    label: extension.displayName,
                    description: extension.identifier.id,
                    extension,
                };
            })));
            return entries;
        });
    }
    reinstallExtension(extension) {
        return this.instantiationService.createInstance(SearchExtensionsAction, '@installed ').run()
            .then(() => {
            return this.extensionsWorkbenchService.reinstall(extension)
                .then(extension => {
                const requireReload = !(extension.local && this.extensionService.canAddExtension(toExtensionDescription(extension.local)));
                const message = requireReload ? ( (localize(
                    'ReinstallAction.successReload',
                    "Please reload Visual Studio Code to complete reinstalling the extension {0}.",
                    extension.identifier.id
                )))
                    : ( (localize(
                    'ReinstallAction.success',
                    "Reinstalling the extension {0} is completed.",
                    extension.identifier.id
                )));
                const actions = requireReload ? [{
                        label: ( (localize('InstallVSIXAction.reloadNow', "Reload Now"))),
                        run: () => this.hostService.reload()
                    }] : [];
                this.notificationService.prompt(Severity.Info, message, actions, { sticky: true });
            }, error => this.notificationService.error(error));
        });
    }
});
(class InstallSpecificVersionOfExtensionAction extends Action {
    static { this.ID = 'workbench.extensions.action.install.specificVersion'; }
    static { this.LABEL = ( (localize('install previous version', "Install Specific Version of Extension..."))); }
    constructor(id = InstallSpecificVersionOfExtensionAction.ID, label = InstallSpecificVersionOfExtensionAction.LABEL, extensionsWorkbenchService, quickInputService, instantiationService, extensionEnablementService) {
        super(id, label);
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.quickInputService = quickInputService;
        this.instantiationService = instantiationService;
        this.extensionEnablementService = extensionEnablementService;
    }
    get enabled() {
        return (
             (this.extensionsWorkbenchService.local.some(l => this.isEnabled(l)))
        );
    }
    async run() {
        const extensionPick = await this.quickInputService.pick(this.getExtensionEntries(), { placeHolder: ( (localize('selectExtension', "Select Extension"))), matchOnDetail: true });
        if (extensionPick && extensionPick.extension) {
            const action = this.instantiationService.createInstance(InstallAnotherVersionAction);
            action.extension = extensionPick.extension;
            await action.run();
            await this.instantiationService.createInstance(SearchExtensionsAction, extensionPick.extension.identifier.id).run();
        }
    }
    isEnabled(extension) {
        const action = this.instantiationService.createInstance(InstallAnotherVersionAction);
        action.extension = extension;
        return action.enabled && !!extension.local && this.extensionEnablementService.isEnabled(extension.local);
    }
    async getExtensionEntries() {
        const installed = await this.extensionsWorkbenchService.queryLocal();
        const entries = [];
        for (const extension of installed) {
            if (this.isEnabled(extension)) {
                entries.push({
                    id: extension.identifier.id,
                    label: extension.displayName || extension.identifier.id,
                    description: extension.identifier.id,
                    extension,
                });
            }
        }
        return entries.sort((e1, e2) => e1.extension.displayName.localeCompare(e2.extension.displayName));
    }
});
CommandsRegistry.registerCommand('workbench.extensions.action.showExtensionsForLanguage', function (accessor, fileExtension) {
    const paneCompositeService = accessor.get(IPaneCompositePartService);
    return paneCompositeService.openPaneComposite(VIEWLET_ID, 0 , true)
        .then(viewlet => viewlet?.getViewPaneContainer())
        .then(viewlet => {
        viewlet.search(`ext:${fileExtension.replace(/^\./, '')}`);
        viewlet.focus();
    });
});
CommandsRegistry.registerCommand('workbench.extensions.action.showExtensionsWithIds', function (accessor, extensionIds) {
    const paneCompositeService = accessor.get(IPaneCompositePartService);
    return paneCompositeService.openPaneComposite(VIEWLET_ID, 0 , true)
        .then(viewlet => viewlet?.getViewPaneContainer())
        .then(viewlet => {
        const query = ( (extensionIds
            .map(id => `@id:${id}`)))
            .join(' ');
        viewlet.search(query);
        viewlet.focus();
    });
});
registerColor('extensionButton.background', {
    dark: buttonBackground,
    light: buttonBackground,
    hcDark: null,
    hcLight: null
}, ( (localize(
    'extensionButtonBackground',
    "Button background color for extension actions."
))));
registerColor('extensionButton.foreground', {
    dark: buttonForeground,
    light: buttonForeground,
    hcDark: null,
    hcLight: null
}, ( (localize(
    'extensionButtonForeground',
    "Button foreground color for extension actions."
))));
registerColor('extensionButton.hoverBackground', {
    dark: buttonHoverBackground,
    light: buttonHoverBackground,
    hcDark: null,
    hcLight: null
}, ( (localize(
    'extensionButtonHoverBackground',
    "Button background hover color for extension actions."
))));
registerColor('extensionButton.separator', {
    dark: buttonSeparator,
    light: buttonSeparator,
    hcDark: buttonSeparator,
    hcLight: buttonSeparator
}, ( (localize('extensionButtonSeparator', "Button separator color for extension actions"))));
registerColor('extensionButton.prominentBackground', {
    dark: buttonBackground,
    light: buttonBackground,
    hcDark: null,
    hcLight: null
}, ( (localize(
    'extensionButtonProminentBackground',
    "Button background color for extension actions that stand out (e.g. install button)."
))));
registerColor('extensionButton.prominentForeground', {
    dark: buttonForeground,
    light: buttonForeground,
    hcDark: null,
    hcLight: null
}, ( (localize(
    'extensionButtonProminentForeground',
    "Button foreground color for extension actions that stand out (e.g. install button)."
))));
registerColor('extensionButton.prominentHoverBackground', {
    dark: buttonHoverBackground,
    light: buttonHoverBackground,
    hcDark: null,
    hcLight: null
}, ( (localize(
    'extensionButtonProminentHoverBackground',
    "Button background hover color for extension actions that stand out (e.g. install button)."
))));
registerThemingParticipant((theme, collector) => {
    const errorColor = theme.getColor(editorErrorForeground);
    if (errorColor) {
        collector.addRule(`.extension-editor .header .actions-status-container > .status ${ThemeIcon.asCSSSelector(errorIcon)} { color: ${errorColor}; }`);
        collector.addRule(`.extension-editor .body .subcontent .runtime-status ${ThemeIcon.asCSSSelector(errorIcon)} { color: ${errorColor}; }`);
        collector.addRule(`.monaco-hover.extension-hover .markdown-hover .hover-contents ${ThemeIcon.asCSSSelector(errorIcon)} { color: ${errorColor}; }`);
    }
    const warningColor = theme.getColor(editorWarningForeground);
    if (warningColor) {
        collector.addRule(`.extension-editor .header .actions-status-container > .status ${ThemeIcon.asCSSSelector(warningIcon)} { color: ${warningColor}; }`);
        collector.addRule(`.extension-editor .body .subcontent .runtime-status ${ThemeIcon.asCSSSelector(warningIcon)} { color: ${warningColor}; }`);
        collector.addRule(`.monaco-hover.extension-hover .markdown-hover .hover-contents ${ThemeIcon.asCSSSelector(warningIcon)} { color: ${warningColor}; }`);
    }
    const infoColor = theme.getColor(editorInfoForeground);
    if (infoColor) {
        collector.addRule(`.extension-editor .header .actions-status-container > .status ${ThemeIcon.asCSSSelector(infoIcon)} { color: ${infoColor}; }`);
        collector.addRule(`.extension-editor .body .subcontent .runtime-status ${ThemeIcon.asCSSSelector(infoIcon)} { color: ${infoColor}; }`);
        collector.addRule(`.monaco-hover.extension-hover .markdown-hover .hover-contents ${ThemeIcon.asCSSSelector(infoIcon)} { color: ${infoColor}; }`);
    }
});
export { AbstractConfigureRecommendedExtensionsAction, DisableForWorkspaceAction, DisableGloballyAction, DropDownMenuActionViewItem, EnableForWorkspaceAction, EnableGloballyAction, ExtensionAction, ExtensionDropDownAction, InstallAction, InstallAnotherVersionAction, InstallRecommendedExtensionAction, InstallingLabelAction, MenuItemExtensionAction, PromptExtensionInstallFailureAction, SearchExtensionsAction, SetColorThemeAction, SetFileIconThemeAction, SetProductIconThemeAction, UninstallAction, UpdateAction };
