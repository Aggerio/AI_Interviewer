import { __decorate, __param } from '../../../../../../../node_modules/tslib/tslib.es6.js';
import { Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { withNullAsUndefined } from 'monaco-editor/esm/vs/base/common/types.js';
import { IModelService } from 'monaco-editor/esm/vs/editor/common/services/model.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { AudioCue, IAudioCueService } from 'monaco-editor/esm/vs/platform/audioCues/browser/audioCueService.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IQuickInputService } from 'monaco-editor/esm/vs/platform/quickinput/common/quickInput.js';
import { ITerminalLogService } from '../../../../../platform/terminal/common/terminal.js';
import { ITerminalService } from '../../../terminal/browser/terminal.js';
import { TerminalContextKeys } from '../../../terminal/common/terminalContextKey.js';
import { BufferContentTracker } from './bufferContentTracker.js';
import { TerminalAccessibleWidget } from './terminalAccessibleWidget.js';
let AccessibleBufferWidget = class AccessibleBufferWidget extends TerminalAccessibleWidget {
    constructor(_instance, _xterm, _instantiationService, _modelService, _configurationService, _quickInputService, _audioCueService, _contextKeyService, _logService, _terminalService) {
        super("accessible-buffer" , _instance, _xterm, TerminalContextKeys.accessibleBufferFocus, _instantiationService, _modelService, _configurationService, _contextKeyService, _terminalService);
        this._quickInputService = _quickInputService;
        this._audioCueService = _audioCueService;
        this._logService = _logService;
        this._isUpdating = false;
        this._pendingUpdates = 0;
        this._bufferTracker = _instantiationService.createInstance(BufferContentTracker, _xterm);
        this.element.ariaRoleDescription = ( localize('terminal.integrated.accessibleBuffer', 'Terminal buffer'));
        this.updateEditor();
        this.add(this.editorWidget.onDidFocusEditorText(async () => {
            if (this.element.classList.contains("active" )) {
                return;
            }
            this.registerListeners();
            await this.updateEditor();
            this.element.classList.add("active" );
        }));
        this.layout();
    }
    navigateToCommand(type) {
        const currentLine = this.editorWidget.getPosition()?.lineNumber || this._getDefaultCursorPosition()?.lineNumber;
        const commands = this._getCommandsWithEditorLine();
        if (!commands?.length || !currentLine) {
            return;
        }
        const filteredCommands = type === "previous"  ? commands.filter(c => c.lineNumber < currentLine).sort((a, b) => b.lineNumber - a.lineNumber) : commands.filter(c => c.lineNumber > currentLine).sort((a, b) => a.lineNumber - b.lineNumber);
        if (!filteredCommands.length) {
            return;
        }
        this._cursorPosition = { lineNumber: filteredCommands[0].lineNumber, column: 1 };
        this._resetPosition();
    }
    _getEditorLineForCommand(command) {
        let line = command.marker?.line;
        if (line === undefined || !command.command.length || line < 0) {
            return;
        }
        line = this._bufferTracker.bufferToEditorLineMapping.get(line);
        if (line === undefined) {
            return;
        }
        return line + 1;
    }
    _getCommandsWithEditorLine() {
        const commands = this._instance.capabilities.get(2 )?.commands;
        if (!commands?.length) {
            return;
        }
        const result = [];
        for (const command of commands) {
            const lineNumber = this._getEditorLineForCommand(command);
            if (!lineNumber) {
                continue;
            }
            result.push({ command, lineNumber });
        }
        return result;
    }
    async createQuickPick() {
        this._cursorPosition = withNullAsUndefined(this.editorWidget.getPosition());
        const commands = this._getCommandsWithEditorLine();
        if (!commands) {
            return;
        }
        const quickPickItems = [];
        for (const { command, lineNumber } of commands) {
            const line = this._getEditorLineForCommand(command);
            if (!line) {
                continue;
            }
            quickPickItems.push({
                label: ( localize(
                    'terminal.integrated.symbolQuickPick.labelNoExitCode',
                    '{0}',
                    command.command
                )),
                lineNumber,
                exitCode: command.exitCode
            });
        }
        const quickPick = this._quickInputService.createQuickPick();
        quickPick.canSelectMany = false;
        quickPick.onDidChangeActive(() => {
            const activeItem = quickPick.activeItems[0];
            if (!activeItem) {
                return;
            }
            if (activeItem.exitCode) {
                this._audioCueService.playAudioCue(AudioCue.error, true);
            }
            this.editorWidget.revealLine(activeItem.lineNumber, 0);
        });
        quickPick.onDidHide(() => {
            this._resetPosition();
            quickPick.dispose();
        });
        quickPick.onDidAccept(() => {
            const item = quickPick.activeItems[0];
            const model = this.editorWidget.getModel();
            if (!model) {
                return;
            }
            if (!item && this._cursorPosition) {
                this._resetPosition();
            }
            else {
                this._cursorPosition = { lineNumber: item.lineNumber, column: 1 };
            }
            quickPick.dispose();
            this.editorWidget.focus();
            return;
        });
        quickPick.items = quickPickItems.reverse();
        return quickPick;
    }
    _resetPosition() {
        this._cursorPosition = this._cursorPosition ?? this._getDefaultCursorPosition();
        if (!this._cursorPosition) {
            return;
        }
        this.editorWidget.setPosition(this._cursorPosition);
        this.editorWidget.setScrollPosition({ scrollTop: this.editorWidget.getTopForLineNumber(this._cursorPosition.lineNumber) });
    }
    layout() {
        if (this._bufferTracker) {
            this._bufferTracker.reset();
        }
        super.layout();
    }
    async updateEditor(dataChanged) {
        if (this._isUpdating) {
            this._pendingUpdates++;
            return;
        }
        this._isUpdating = true;
        const model = await this._updateModel(dataChanged);
        if (!model) {
            return;
        }
        this._isUpdating = false;
        if (this._pendingUpdates) {
            this._logService.debug('TerminalAccessibleBuffer._updateEditor: pending updates', this._pendingUpdates);
            this._pendingUpdates--;
            await this.updateEditor(dataChanged);
        }
    }
    registerListeners() {
        super.registerListeners();
        this._xterm.raw.onWriteParsed(async () => {
            if (this._xterm.raw.buffer.active.baseY === 0) {
                await this.updateEditor(true);
            }
        });
        const onRequestUpdateEditor = Event.latch(this._xterm.raw.onScroll);
        this._listeners.push(onRequestUpdateEditor(async () => await this.updateEditor(true)));
    }
    _getDefaultCursorPosition() {
        const modelLineCount = this.editorWidget.getModel()?.getLineCount();
        return modelLineCount ? { lineNumber: modelLineCount, column: 1 } : undefined;
    }
    async _updateModel(dataChanged) {
        const linesBefore = this._bufferTracker.lines.length;
        this._bufferTracker.update();
        const linesAfter = this._bufferTracker.lines.length;
        const modelChanged = linesBefore !== linesAfter;
        let savedViewState;
        if (dataChanged) {
            savedViewState = withNullAsUndefined(this.editorWidget.saveViewState());
        }
        let model = this.editorWidget.getModel();
        const text = this._bufferTracker.lines.join('\n');
        if (model) {
            model.setValue(text);
        }
        else {
            model = await this.getTextModel(this._instance.resource.with({ fragment: `${"accessible-buffer" }-${text}` }));
        }
        this.editorWidget.setModel(model);
        const positionTopOfBuffer = this.editorWidget.getPosition()?.lineNumber === 1 && this.editorWidget.getPosition()?.column === 1;
        if (savedViewState) {
            this.editorWidget.restoreViewState(savedViewState);
        }
        else if (modelChanged || positionTopOfBuffer) {
            const defaultPosition = this._getDefaultCursorPosition();
            if (defaultPosition) {
                this.editorWidget.setPosition(defaultPosition);
                this.editorWidget.setScrollPosition({ scrollTop: this.editorWidget.getTopForLineNumber(defaultPosition.lineNumber) });
            }
        }
        return model;
    }
};
AccessibleBufferWidget = ( __decorate([
    ( __param(2, IInstantiationService)),
    ( __param(3, IModelService)),
    ( __param(4, IConfigurationService)),
    ( __param(5, IQuickInputService)),
    ( __param(6, IAudioCueService)),
    ( __param(7, IContextKeyService)),
    ( __param(8, ITerminalLogService)),
    ( __param(9, ITerminalService))
], AccessibleBufferWidget));
export { AccessibleBufferWidget };
