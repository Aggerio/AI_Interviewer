import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { IQuickInputService } from 'monaco-editor/esm/vs/platform/quickinput/common/quickInput.js';
import { getUriClasses, getColorClass, getColorStyleElement } from './terminalIcon.js';
import { configureTerminalProfileIcon } from './terminalIcons.js';
import * as nls from 'monaco-editor/esm/vs/nls.js';
import { IThemeService } from 'monaco-editor/esm/vs/platform/theme/common/themeService.js';
import { ThemeIcon } from 'monaco-editor/esm/vs/base/common/themables.js';
import { ITerminalProfileService, ITerminalProfileResolverService } from '../common/terminal.js';
import { getIconRegistry } from 'monaco-editor/esm/vs/platform/theme/common/iconRegistry.js';
import { basename } from 'monaco-editor/esm/vs/base/common/path.js';
import { Severity, INotificationService } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
let TerminalProfileQuickpick = class TerminalProfileQuickpick {
    constructor(_terminalProfileService, _terminalProfileResolverService, _configurationService, _quickInputService, _themeService, _notificationService) {
        this._terminalProfileService = _terminalProfileService;
        this._terminalProfileResolverService = _terminalProfileResolverService;
        this._configurationService = _configurationService;
        this._quickInputService = _quickInputService;
        this._themeService = _themeService;
        this._notificationService = _notificationService;
    }
    async showAndGetResult(type) {
        const platformKey = await this._terminalProfileService.getPlatformKey();
        const profilesKey = "terminal.integrated.profiles."  + platformKey;
        const result = await this._createAndShow(type);
        const defaultProfileKey = `${"terminal.integrated.defaultProfile." }${platformKey}`;
        if (!result) {
            return;
        }
        if (type === 'setDefault') {
            if ('command' in result.profile) {
                return;
            }
            else if ('id' in result.profile) {
                await this._configurationService.updateValue(defaultProfileKey, result.profile.title, 2 );
                return {
                    config: {
                        extensionIdentifier: result.profile.extensionIdentifier,
                        id: result.profile.id,
                        title: result.profile.title,
                        options: {
                            color: result.profile.color,
                            icon: result.profile.icon
                        }
                    },
                    keyMods: result.keyMods
                };
            }
            if ('isAutoDetected' in result.profile) {
                const profilesConfig = await this._configurationService.getValue(profilesKey);
                if (typeof profilesConfig === 'object') {
                    const newProfile = {
                        path: result.profile.path
                    };
                    if (result.profile.args) {
                        newProfile.args = result.profile.args;
                    }
                    profilesConfig[result.profile.profileName] = newProfile;
                }
                await this._configurationService.updateValue(profilesKey, profilesConfig, 2 );
            }
            await this._configurationService.updateValue(defaultProfileKey, result.profileName, 2 );
        }
        else if (type === 'createInstance') {
            if ('id' in result.profile) {
                return {
                    config: {
                        extensionIdentifier: result.profile.extensionIdentifier,
                        id: result.profile.id,
                        title: result.profile.title,
                        options: {
                            icon: result.profile.icon,
                            color: result.profile.color,
                        }
                    },
                    keyMods: result.keyMods
                };
            }
            else {
                return { config: result.profile, keyMods: result.keyMods };
            }
        }
        return 'profileName' in result.profile ? result.profile.profileName : result.profile.title;
    }
    async _createAndShow(type) {
        const platformKey = await this._terminalProfileService.getPlatformKey();
        const profiles = this._terminalProfileService.availableProfiles;
        const profilesKey = "terminal.integrated.profiles."  + platformKey;
        const defaultProfileName = this._terminalProfileService.getDefaultProfileName();
        let keyMods;
        const options = {
            placeHolder: type === 'createInstance' ? ( nls.localize(
                'terminal.integrated.selectProfileToCreate',
                "Select the terminal profile to create"
            )) : ( nls.localize(
                'terminal.integrated.chooseDefaultProfile',
                "Select your default terminal profile"
            )),
            onDidTriggerItemButton: async (context) => {
                if (!(await this._isProfileSafe(context.item.profile))) {
                    return;
                }
                if ('command' in context.item.profile) {
                    return;
                }
                if ('id' in context.item.profile) {
                    return;
                }
                const configProfiles = this._configurationService.getValue("terminal.integrated.profiles."  + platformKey);
                const existingProfiles = !!configProfiles ? ( Object.keys(configProfiles)) : [];
                const name = await this._quickInputService.input({
                    prompt: ( nls.localize('enterTerminalProfileName', "Enter terminal profile name")),
                    value: context.item.profile.profileName,
                    validateInput: async (input) => {
                        if (existingProfiles.includes(input)) {
                            return ( nls.localize(
                                'terminalProfileAlreadyExists',
                                "A terminal profile already exists with that name"
                            ));
                        }
                        return undefined;
                    }
                });
                if (!name) {
                    return;
                }
                const newConfigValue = { ...configProfiles };
                newConfigValue[name] = {
                    path: context.item.profile.path,
                    args: context.item.profile.args
                };
                await this._configurationService.updateValue(profilesKey, newConfigValue, 2 );
            },
            onKeyMods: mods => keyMods = mods
        };
        const quickPickItems = [];
        const configProfiles = profiles.filter(e => !e.isAutoDetected);
        const autoDetectedProfiles = profiles.filter(e => e.isAutoDetected);
        if (configProfiles.length > 0) {
            quickPickItems.push({ type: 'separator', label: ( nls.localize('terminalProfiles', "profiles")) });
            quickPickItems.push(...this._sortProfileQuickPickItems(( configProfiles.map(e => this._createProfileQuickPickItem(e))), defaultProfileName));
        }
        quickPickItems.push({ type: 'separator', label: ( nls.localize('ICreateContributedTerminalProfileOptions', "contributed")) });
        const contributedProfiles = [];
        for (const contributed of this._terminalProfileService.contributedProfiles) {
            let icon;
            if (typeof contributed.icon === 'string') {
                if (contributed.icon.startsWith('$(')) {
                    icon = ThemeIcon.fromString(contributed.icon);
                }
                else {
                    icon = ThemeIcon.fromId(contributed.icon);
                }
            }
            if (!icon || !getIconRegistry().getIcon(icon.id)) {
                icon = this._terminalProfileResolverService.getDefaultIcon();
            }
            const uriClasses = getUriClasses(contributed, this._themeService.getColorTheme().type, true);
            const colorClass = getColorClass(contributed);
            const iconClasses = [];
            if (uriClasses) {
                iconClasses.push(...uriClasses);
            }
            if (colorClass) {
                iconClasses.push(colorClass);
            }
            contributedProfiles.push({
                label: `$(${icon.id}) ${contributed.title}`,
                profile: {
                    extensionIdentifier: contributed.extensionIdentifier,
                    title: contributed.title,
                    icon: contributed.icon,
                    id: contributed.id,
                    color: contributed.color
                },
                profileName: contributed.title,
                iconClasses
            });
        }
        if (contributedProfiles.length > 0) {
            quickPickItems.push(...this._sortProfileQuickPickItems(contributedProfiles, defaultProfileName));
        }
        if (autoDetectedProfiles.length > 0) {
            quickPickItems.push({ type: 'separator', label: ( nls.localize('terminalProfiles.detected', "detected")) });
            quickPickItems.push(...this._sortProfileQuickPickItems(( autoDetectedProfiles.map(e => this._createProfileQuickPickItem(e))), defaultProfileName));
        }
        const styleElement = getColorStyleElement(this._themeService.getColorTheme());
        document.body.appendChild(styleElement);
        const result = await this._quickInputService.pick(quickPickItems, options);
        document.body.removeChild(styleElement);
        if (!result) {
            return undefined;
        }
        if (!(await this._isProfileSafe(result.profile))) {
            return undefined;
        }
        if (keyMods) {
            result.keyMods = keyMods;
        }
        return result;
    }
    async _isProfileSafe(profile) {
        const isUnsafePath = 'isUnsafePath' in profile && profile.isUnsafePath;
        const requiresUnsafePath = 'requiresUnsafePath' in profile && profile.requiresUnsafePath;
        if (!isUnsafePath && !requiresUnsafePath) {
            return true;
        }
        return await ( new Promise(r => {
            const unsafePaths = [];
            if (isUnsafePath) {
                unsafePaths.push(profile.path);
            }
            if (requiresUnsafePath) {
                unsafePaths.push(requiresUnsafePath);
            }
            const handle = this._notificationService.prompt(Severity.Warning, ( nls.localize(
                'unsafePathWarning',
                'This terminal profile uses a potentially unsafe path that can be modified by another user: {0}. Are you sure you want to use it?',
                `"${unsafePaths.join(',')}"`
            )), [{
                    label: ( nls.localize('yes', 'Yes')),
                    run: () => r(true)
                }, {
                    label: ( nls.localize('cancel', 'Cancel')),
                    run: () => r(false)
                }]);
            handle.onDidClose(() => r(false));
        }));
    }
    _createProfileQuickPickItem(profile) {
        const buttons = [{
                iconClass: ThemeIcon.asClassName(configureTerminalProfileIcon),
                tooltip: ( nls.localize('createQuickLaunchProfile', "Configure Terminal Profile"))
            }];
        const icon = (profile.icon && ThemeIcon.isThemeIcon(profile.icon)) ? profile.icon : Codicon.terminal;
        const label = `$(${icon.id}) ${profile.profileName}`;
        const friendlyPath = profile.isFromPath ? basename(profile.path) : profile.path;
        const colorClass = getColorClass(profile);
        const iconClasses = [];
        if (colorClass) {
            iconClasses.push(colorClass);
        }
        if (profile.args) {
            if (typeof profile.args === 'string') {
                return { label, description: `${profile.path} ${profile.args}`, profile, profileName: profile.profileName, buttons, iconClasses };
            }
            const argsString = ( profile.args.map(e => {
                if (e.includes(' ')) {
                    return `"${e.replace(/"/g, '\\"')}"`;
                }
                return e;
            })).join(' ');
            return { label, description: `${friendlyPath} ${argsString}`, profile, profileName: profile.profileName, buttons, iconClasses };
        }
        return { label, description: friendlyPath, profile, profileName: profile.profileName, buttons, iconClasses };
    }
    _sortProfileQuickPickItems(items, defaultProfileName) {
        return items.sort((a, b) => {
            if (b.profileName === defaultProfileName) {
                return 1;
            }
            if (a.profileName === defaultProfileName) {
                return -1;
            }
            return a.profileName.localeCompare(b.profileName);
        });
    }
};
TerminalProfileQuickpick = ( __decorate([
    ( __param(0, ITerminalProfileService)),
    ( __param(1, ITerminalProfileResolverService)),
    ( __param(2, IConfigurationService)),
    ( __param(3, IQuickInputService)),
    ( __param(4, IThemeService)),
    ( __param(5, INotificationService))
], TerminalProfileQuickpick));
export { TerminalProfileQuickpick };
