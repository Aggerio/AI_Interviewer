import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import { RunOnceScheduler } from 'monaco-editor/esm/vs/base/common/async.js';
import { CancellationToken, CancellationTokenSource } from 'monaco-editor/esm/vs/base/common/cancellation.js';
import { comparePaths, compareFileNames, compareFileExtensions } from 'monaco-editor/esm/vs/base/common/comparers.js';
import { memoize } from 'monaco-editor/esm/vs/base/common/decorators.js';
import * as errors from 'monaco-editor/esm/vs/base/common/errors.js';
import { Emitter, PauseableEmitter, Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { Lazy } from 'monaco-editor/esm/vs/base/common/lazy.js';
import { Disposable, DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { ResourceMap } from 'monaco-editor/esm/vs/base/common/map.js';
import { Schemas } from 'monaco-editor/esm/vs/base/common/network.js';
import { lcut } from 'monaco-editor/esm/vs/base/common/strings.js';
import { TernarySearchTree } from 'monaco-editor/esm/vs/base/common/ternarySearchTree.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { Range } from 'monaco-editor/esm/vs/editor/common/core/range.js';
import { OverviewRulerLane, MinimapPosition, FindMatch } from 'monaco-editor/esm/vs/editor/common/model.js';
import { ModelDecorationOptions } from 'monaco-editor/esm/vs/editor/common/model/textModel.js';
import { IModelService } from 'monaco-editor/esm/vs/editor/common/services/model.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { createDecorator, IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { ILabelService } from 'monaco-editor/esm/vs/platform/label/common/label.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { ITelemetryService } from 'monaco-editor/esm/vs/platform/telemetry/common/telemetry.js';
import { overviewRulerFindMatchForeground, minimapFindMatch } from 'monaco-editor/esm/vs/platform/theme/common/colorRegistry.js';
import { themeColorFromId } from 'monaco-editor/esm/vs/platform/theme/common/themeService.js';
import { IUriIdentityService } from 'monaco-editor/esm/vs/platform/uriIdentity/common/uriIdentity.js';
import { FindMatchDecorationModel } from '../../../../../../override/vs/workbench/contrib/notebook/browser/contrib/find/findMatchDecorationModel.js';
import { CellEditState } from '../../notebook/browser/notebookBrowser.js';
import { NotebookEditorWidget } from '../../../../../../override/vs/workbench/contrib/notebook/browser/notebookEditorWidget.js';
import { INotebookEditorService } from '../../notebook/browser/services/notebookEditorService.js';
import { NotebookCellsChangeType } from '../../notebook/common/notebookCommon.js';
import { INotebookSearchService } from './notebookSearch.js';
import { IReplaceService } from './replace.js';
import { isIFileMatchWithCells, rawCellPrefix, contentMatchesToTextSearchMatches, webviewMatchesToTextSearchMatches, CellSearchModel } from './searchNotebookHelpers.js';
import { ReplacePattern } from '../../../services/search/common/replace.js';
import { OneLineRange, resultIsMatch, ISearchService } from '../../../services/search/common/search.js';
import { editorMatchesToTextSearchResults, addContextToEditorMatches } from '../../../services/search/common/searchHelpers.js';
class Match {
    static { this.MAX_PREVIEW_CHARS = 250; }
    constructor(_parent, _fullPreviewLines, _fullPreviewRange, _documentRange) {
        this._parent = _parent;
        this._fullPreviewLines = _fullPreviewLines;
        this._oneLinePreviewText = _fullPreviewLines[_fullPreviewRange.startLineNumber];
        const adjustedEndCol = _fullPreviewRange.startLineNumber === _fullPreviewRange.endLineNumber ?
            _fullPreviewRange.endColumn :
            this._oneLinePreviewText.length;
        this._rangeInPreviewText = ( new OneLineRange(1, _fullPreviewRange.startColumn + 1, adjustedEndCol + 1));
        this._range = ( new Range(
            _documentRange.startLineNumber + 1,
            _documentRange.startColumn + 1,
            _documentRange.endLineNumber + 1,
            _documentRange.endColumn + 1
        ));
        this._fullPreviewRange = _fullPreviewRange;
        this._id = this._parent.id() + '>' + this._range + this.getMatchString();
    }
    id() {
        return this._id;
    }
    parent() {
        return this._parent;
    }
    text() {
        return this._oneLinePreviewText;
    }
    range() {
        return this._range;
    }
    preview() {
        let before = this._oneLinePreviewText.substring(0, this._rangeInPreviewText.startColumn - 1), inside = this.getMatchString(), after = this._oneLinePreviewText.substring(this._rangeInPreviewText.endColumn - 1);
        before = lcut(before, 26);
        before = before.trimLeft();
        let charsRemaining = Match.MAX_PREVIEW_CHARS - before.length;
        inside = inside.substr(0, charsRemaining);
        charsRemaining -= inside.length;
        after = after.substr(0, charsRemaining);
        return {
            before,
            inside,
            after,
        };
    }
    get replaceString() {
        const searchModel = this.parent().parent().searchModel;
        if (!searchModel.replacePattern) {
            throw new Error('searchModel.replacePattern must be set before accessing replaceString');
        }
        const fullMatchText = this.fullMatchText();
        let replaceString = searchModel.replacePattern.getReplaceString(fullMatchText, searchModel.preserveCase);
        if (replaceString !== null) {
            return replaceString;
        }
        const fullMatchTextWithoutCR = fullMatchText.replace(/\r\n/g, '\n');
        if (fullMatchTextWithoutCR !== fullMatchText) {
            replaceString = searchModel.replacePattern.getReplaceString(fullMatchTextWithoutCR, searchModel.preserveCase);
            if (replaceString !== null) {
                return replaceString;
            }
        }
        const contextMatchTextWithSurroundingContent = this.fullMatchText(true);
        replaceString = searchModel.replacePattern.getReplaceString(contextMatchTextWithSurroundingContent, searchModel.preserveCase);
        if (replaceString !== null) {
            return replaceString;
        }
        const contextMatchTextWithoutCR = contextMatchTextWithSurroundingContent.replace(/\r\n/g, '\n');
        if (contextMatchTextWithoutCR !== contextMatchTextWithSurroundingContent) {
            replaceString = searchModel.replacePattern.getReplaceString(contextMatchTextWithoutCR, searchModel.preserveCase);
            if (replaceString !== null) {
                return replaceString;
            }
        }
        return searchModel.replacePattern.pattern;
    }
    fullMatchText(includeSurrounding = false) {
        let thisMatchPreviewLines;
        if (includeSurrounding) {
            thisMatchPreviewLines = this._fullPreviewLines;
        }
        else {
            thisMatchPreviewLines = this._fullPreviewLines.slice(this._fullPreviewRange.startLineNumber, this._fullPreviewRange.endLineNumber + 1);
            thisMatchPreviewLines[thisMatchPreviewLines.length - 1] = thisMatchPreviewLines[thisMatchPreviewLines.length - 1].slice(0, this._fullPreviewRange.endColumn);
            thisMatchPreviewLines[0] = thisMatchPreviewLines[0].slice(this._fullPreviewRange.startColumn);
        }
        return thisMatchPreviewLines.join('\n');
    }
    rangeInPreview() {
        return {
            ...this._fullPreviewRange,
            startColumn: this._fullPreviewRange.startColumn + 1,
            endColumn: this._fullPreviewRange.endColumn + 1
        };
    }
    fullPreviewLines() {
        return this._fullPreviewLines.slice(this._fullPreviewRange.startLineNumber, this._fullPreviewRange.endLineNumber + 1);
    }
    getMatchString() {
        return this._oneLinePreviewText.substring(this._rangeInPreviewText.startColumn - 1, this._rangeInPreviewText.endColumn - 1);
    }
}
Match.__decorator = ( __decorate([
    memoize
], Match.prototype, "preview", null));
class CellMatch {
    constructor(_parent, _cell, _cellIndex) {
        this._parent = _parent;
        this._cell = _cell;
        this._cellIndex = _cellIndex;
        this._contentMatches = ( new Map());
        this._webviewMatches = ( new Map());
        this._context = ( new Map());
    }
    get context() {
        return ( new Map(this._context));
    }
    matches() {
        return [...( this._contentMatches.values()), ...( this._webviewMatches.values())];
    }
    get contentMatches() {
        return Array.from(( this._contentMatches.values()));
    }
    get webviewMatches() {
        return Array.from(( this._webviewMatches.values()));
    }
    remove(matches) {
        if (!Array.isArray(matches)) {
            matches = [matches];
        }
        for (const match of matches) {
            this._contentMatches.delete(match.id());
            this._webviewMatches.delete(match.id());
        }
    }
    addContentMatches(textSearchMatches) {
        const contentMatches = textSearchMatchesToNotebookMatches();
        contentMatches.forEach((match) => {
            this._contentMatches.set(match.id(), match);
        });
        this.addContext(textSearchMatches);
    }
    addContext(textSearchMatches) {
        if (this.cell instanceof CellSearchModel) {
            return;
        }
        this.cell.resolveTextModel().then((textModel) => {
            const textResultsWithContext = addContextToEditorMatches(textSearchMatches, textModel, this.parent.parent().query);
            const contexts = textResultsWithContext.filter((result => !resultIsMatch(result)));
            ( contexts.map(context => ({ ...context, lineNumber: context.lineNumber + 1 })))
                .forEach((context) => { this._context.set(context.lineNumber, context.text); });
        });
    }
    addWebviewMatches(textSearchMatches) {
        const webviewMatches = textSearchMatchesToNotebookMatches();
        webviewMatches.forEach((match) => {
            this._webviewMatches.set(match.id(), match);
        });
    }
    setCellModel(cell) {
        this._cell = cell;
    }
    get parent() {
        return this._parent;
    }
    get id() {
        return this._cell.id;
    }
    get cellIndex() {
        return this._cellIndex;
    }
    get cell() {
        return this._cell;
    }
}
class MatchInNotebook extends Match {
    constructor(_cellParent, _fullPreviewLines, _fullPreviewRange, _documentRange, webviewIndex) {
        super(_cellParent.parent, _fullPreviewLines, _fullPreviewRange, _documentRange);
        this._cellParent = _cellParent;
        this._id = this._parent.id() + '>' + this._cellParent.cellIndex + (webviewIndex ? '_' + webviewIndex : '') + '_' + this.notebookMatchTypeString() + this._range + this.getMatchString();
        this._webviewIndex = webviewIndex;
    }
    parent() {
        return this._cellParent.parent;
    }
    get cellParent() {
        return this._cellParent;
    }
    notebookMatchTypeString() {
        return this.isWebviewMatch() ? 'webview' : 'content';
    }
    isWebviewMatch() {
        return this._webviewIndex !== undefined;
    }
    get cellIndex() {
        return this._cellParent.cellIndex;
    }
    get webviewIndex() {
        return this._webviewIndex;
    }
    get cell() {
        return this._cellParent.cell;
    }
}
let FileMatch = class FileMatch extends Disposable {
    static { this._CURRENT_FIND_MATCH = ModelDecorationOptions.register({
        description: 'search-current-find-match',
        stickiness: 1 ,
        zIndex: 13,
        className: 'currentFindMatch',
        overviewRuler: {
            color: themeColorFromId(overviewRulerFindMatchForeground),
            position: OverviewRulerLane.Center
        },
        minimap: {
            color: themeColorFromId(minimapFindMatch),
            position: MinimapPosition.Inline
        }
    }); }
    static { this._FIND_MATCH = ModelDecorationOptions.register({
        description: 'search-find-match',
        stickiness: 1 ,
        className: 'findMatch',
        overviewRuler: {
            color: themeColorFromId(overviewRulerFindMatchForeground),
            position: OverviewRulerLane.Center
        },
        minimap: {
            color: themeColorFromId(minimapFindMatch),
            position: MinimapPosition.Inline
        }
    }); }
    static getDecorationOption(selected) {
        return (selected ? FileMatch._CURRENT_FIND_MATCH : FileMatch._FIND_MATCH);
    }
    get context() {
        return ( new Map(this._context));
    }
    get cellContext() {
        const cellContext = ( new Map());
        this._cellMatches.forEach(cellMatch => {
            cellContext.set(cellMatch.id, cellMatch.context);
        });
        return cellContext;
    }
    constructor(_query, _previewOptions, _maxResults, _parent, rawMatch, _closestRoot, searchInstanceID, modelService, replaceService, labelService, notebookEditorService) {
        super();
        this._query = _query;
        this._previewOptions = _previewOptions;
        this._maxResults = _maxResults;
        this._parent = _parent;
        this.rawMatch = rawMatch;
        this._closestRoot = _closestRoot;
        this.searchInstanceID = searchInstanceID;
        this.modelService = modelService;
        this.replaceService = replaceService;
        this.labelService = labelService;
        this.notebookEditorService = notebookEditorService;
        this._onChange = this._register(( new Emitter()));
        this.onChange = this._onChange.event;
        this._onDispose = this._register(( new Emitter()));
        this.onDispose = this._onDispose.event;
        this._model = null;
        this._modelListener = null;
        this._selectedMatch = null;
        this._modelDecorations = [];
        this._context = ( new Map());
        this._notebookEditorWidget = null;
        this._editorWidgetListener = null;
        this.replaceQ = Promise.resolve();
        this._resource = this.rawMatch.resource;
        this._textMatches = ( new Map());
        this._removedTextMatches = ( new Set());
        this._updateScheduler = ( new RunOnceScheduler(this.updateMatchesForModel.bind(this), 250));
        this._name = ( new Lazy(() => labelService.getUriBasenameLabel(this.resource)));
        this._cellMatches = ( new Map());
        this._notebookUpdateScheduler = ( new RunOnceScheduler(this.updateMatchesForEditorWidget.bind(this), 250));
        this.createMatches();
    }
    addWebviewMatchesToCell(cellID, webviewMatches) {
        const cellMatch = this.getCellMatch(cellID);
        if (cellMatch !== undefined) {
            cellMatch.addWebviewMatches(webviewMatches);
        }
    }
    addContentMatchesToCell(cellID, contentMatches) {
        const cellMatch = this.getCellMatch(cellID);
        if (cellMatch !== undefined) {
            cellMatch.addContentMatches(contentMatches);
        }
    }
    getCellMatch(cellID) {
        return this._cellMatches.get(cellID);
    }
    addCellMatch(rawCell) {
        const cellMatch = ( new CellMatch(this, rawCell.cell, rawCell.index));
        this._cellMatches.set(cellMatch.id, cellMatch);
        this.addWebviewMatchesToCell(rawCell.cell.id, rawCell.webviewResults);
        this.addContentMatchesToCell(rawCell.cell.id, rawCell.contentResults);
    }
    get closestRoot() {
        return this._closestRoot;
    }
    hasWebviewMatches() {
        return ( this.matches().some(m => m instanceof MatchInNotebook && m.isWebviewMatch()));
    }
    createMatches() {
        const model = this.modelService.getModel(this._resource);
        if (model) {
            this.bindModel(model);
            this.updateMatchesForModel();
        }
        else {
            const notebookEditorWidgetBorrow = this.notebookEditorService.retrieveExistingWidgetFromURI(this.resource);
            if (notebookEditorWidgetBorrow?.value) {
                this.bindNotebookEditorWidget(notebookEditorWidgetBorrow.value);
            }
            if (this.rawMatch.results) {
                this.rawMatch.results
                    .filter(resultIsMatch)
                    .forEach(rawMatch => {
                    textSearchResultToMatches(rawMatch, this)
                        .forEach(m => this.add(m));
                });
            }
            if (isIFileMatchWithCells(this.rawMatch)) {
                this.rawMatch.cellResults?.forEach(cell => this.addCellMatch(cell));
                this.setNotebookFindMatchDecorationsUsingCellMatches(this.cellMatches());
                this._onChange.fire({ forceUpdateModel: true });
            }
            this.addContext(this.rawMatch.results);
        }
    }
    bindModel(model) {
        this._model = model;
        this._modelListener = this._model.onDidChangeContent(() => {
            this._updateScheduler.schedule();
        });
        this._model.onWillDispose(() => this.onModelWillDispose());
        this.updateHighlights();
    }
    onModelWillDispose() {
        this.updateMatchesForModel();
        this.unbindModel();
    }
    unbindModel() {
        if (this._model) {
            this._updateScheduler.cancel();
            this._model.changeDecorations((accessor) => {
                this._modelDecorations = accessor.deltaDecorations(this._modelDecorations, []);
            });
            this._model = null;
            this._modelListener.dispose();
        }
    }
    updateMatchesForModel() {
        if (!this._model) {
            return;
        }
        this._textMatches = ( new Map());
        const wordSeparators = this._query.isWordMatch && this._query.wordSeparators ? this._query.wordSeparators : null;
        const matches = this._model
            .findMatches(this._query.pattern, this._model.getFullModelRange(), !!this._query.isRegExp, !!this._query.isCaseSensitive, wordSeparators, false, this._maxResults ?? Number.MAX_SAFE_INTEGER);
        this.updateMatches(matches, true, this._model);
    }
    async updatesMatchesForLineAfterReplace(lineNumber, modelChange) {
        if (!this._model) {
            return;
        }
        const range = {
            startLineNumber: lineNumber,
            startColumn: this._model.getLineMinColumn(lineNumber),
            endLineNumber: lineNumber,
            endColumn: this._model.getLineMaxColumn(lineNumber)
        };
        const oldMatches = Array.from(( this._textMatches.values())).filter(match => match.range().startLineNumber === lineNumber);
        oldMatches.forEach(match => this._textMatches.delete(match.id()));
        const wordSeparators = this._query.isWordMatch && this._query.wordSeparators ? this._query.wordSeparators : null;
        const matches = this._model.findMatches(this._query.pattern, range, !!this._query.isRegExp, !!this._query.isCaseSensitive, wordSeparators, false, this._maxResults ?? Number.MAX_SAFE_INTEGER);
        this.updateMatches(matches, modelChange, this._model);
    }
    updateMatches(matches, modelChange, model) {
        const textSearchResults = editorMatchesToTextSearchResults(matches, model, this._previewOptions);
        textSearchResults.forEach(textSearchResult => {
            textSearchResultToMatches(textSearchResult, this).forEach(match => {
                if (!( this._removedTextMatches.has(match.id()))) {
                    this.add(match);
                    if (this.isMatchSelected(match)) {
                        this._selectedMatch = match;
                    }
                }
            });
        });
        this.addContext(( addContextToEditorMatches(textSearchResults, model, this.parent().parent().query)
            .filter((result => !resultIsMatch(result)))
            .map(context => ({ ...context, lineNumber: context.lineNumber + 1 }))));
        this._onChange.fire({ forceUpdateModel: modelChange });
        this.updateHighlights();
    }
    updateHighlights() {
        if (!this._model) {
            return;
        }
        this._model.changeDecorations((accessor) => {
            const newDecorations = (this.parent().showHighlights
                ? ( this.matches().map(match => ({
                    range: match.range(),
                    options: FileMatch.getDecorationOption(this.isMatchSelected(match))
                })))
                : []);
            this._modelDecorations = accessor.deltaDecorations(this._modelDecorations, newDecorations);
        });
    }
    id() {
        return ( this.resource.toString());
    }
    parent() {
        return this._parent;
    }
    matches() {
        const cellMatches = Array.from(( this._cellMatches.values())).flatMap((e) => e.matches());
        return [...( this._textMatches.values()), ...cellMatches];
    }
    textMatches() {
        return Array.from(( this._textMatches.values()));
    }
    cellMatches() {
        return Array.from(( this._cellMatches.values()));
    }
    remove(matches) {
        if (!Array.isArray(matches)) {
            matches = [matches];
        }
        for (const match of matches) {
            this.removeMatch(match);
            this._removedTextMatches.add(match.id());
        }
        this._onChange.fire({ didRemove: true });
    }
    async replace(toReplace) {
        return this.replaceQ = this.replaceQ.finally(async () => {
            await this.replaceService.replace(toReplace);
            await this.updatesMatchesForLineAfterReplace(toReplace.range().startLineNumber, false);
        });
    }
    setSelectedMatch(match) {
        if (match) {
            if (!this.isMatchSelected(match) && match instanceof MatchInNotebook) {
                this._selectedMatch = match;
                return;
            }
            if (!( this._textMatches.has(match.id()))) {
                return;
            }
            if (this.isMatchSelected(match)) {
                return;
            }
        }
        this._selectedMatch = match;
        this.updateHighlights();
    }
    getSelectedMatch() {
        return this._selectedMatch;
    }
    isMatchSelected(match) {
        return !!this._selectedMatch && this._selectedMatch.id() === match.id();
    }
    count() {
        return this.matches().length;
    }
    get resource() {
        return this._resource;
    }
    name() {
        return this._name.value;
    }
    addContext(results) {
        if (!results) {
            return;
        }
        const contexts = results
            .filter((result => !resultIsMatch(result)));
        return contexts.forEach(context => this._context.set(context.lineNumber, context.text));
    }
    add(match, trigger) {
        this._textMatches.set(match.id(), match);
        if (trigger) {
            this._onChange.fire({ forceUpdateModel: true });
        }
    }
    removeMatch(match) {
        if (match instanceof MatchInNotebook) {
            match.cellParent.remove(match);
            if (match.cellParent.matches().length === 0) {
                this._cellMatches.delete(match.cellParent.id);
            }
        }
        else {
            this._textMatches.delete(match.id());
        }
        if (this.isMatchSelected(match)) {
            this.setSelectedMatch(null);
            this._findMatchDecorationModel?.clearCurrentFindMatchDecoration();
        }
        else {
            this.updateHighlights();
        }
        if (match instanceof MatchInNotebook) {
            this.setNotebookFindMatchDecorationsUsingCellMatches(this.cellMatches());
        }
    }
    async resolveFileStat(fileService) {
        this._fileStat = await fileService.stat(this.resource).catch(() => undefined);
    }
    get fileStat() {
        return this._fileStat;
    }
    set fileStat(stat) {
        this._fileStat = stat;
    }
    dispose() {
        this.setSelectedMatch(null);
        this.unbindModel();
        this.unbindNotebookEditorWidget();
        this._onDispose.fire();
        super.dispose();
    }
    hasOnlyReadOnlyMatches() {
        return this.matches().every(match => (match instanceof MatchInNotebook && match.isWebviewMatch()));
    }
    bindNotebookEditorWidget(widget) {
        if (this._notebookEditorWidget === widget) {
            return;
        }
        this._notebookEditorWidget = widget;
        this._editorWidgetListener = this._notebookEditorWidget.textModel?.onDidChangeContent((e) => {
            if (!( e.rawEvents.some(
                event => event.kind === NotebookCellsChangeType.ChangeCellContent || event.kind === NotebookCellsChangeType.ModelChange
            ))) {
                return;
            }
            this._notebookUpdateScheduler.schedule();
        }) ?? null;
        this._addNotebookHighlights();
    }
    unbindNotebookEditorWidget(widget) {
        if (widget && this._notebookEditorWidget !== widget) {
            return;
        }
        if (this._notebookEditorWidget) {
            this._notebookUpdateScheduler.cancel();
            this._editorWidgetListener?.dispose();
        }
        this._removeNotebookHighlights();
        this._notebookEditorWidget = null;
    }
    updateNotebookHighlights() {
        if (this.parent().showHighlights) {
            this._addNotebookHighlights();
            this.setNotebookFindMatchDecorationsUsingCellMatches(Array.from(( this._cellMatches.values())));
        }
        else {
            this._removeNotebookHighlights();
        }
    }
    _addNotebookHighlights() {
        if (!this._notebookEditorWidget) {
            return;
        }
        this._findMatchDecorationModel?.stopWebviewFind();
        this._findMatchDecorationModel?.dispose();
        this._findMatchDecorationModel = ( new FindMatchDecorationModel(this._notebookEditorWidget, this.searchInstanceID));
        if (this._selectedMatch instanceof MatchInNotebook) {
            this.highlightCurrentFindMatchDecoration(this._selectedMatch);
        }
    }
    _removeNotebookHighlights() {
        if (this._findMatchDecorationModel) {
            this._findMatchDecorationModel?.stopWebviewFind();
            this._findMatchDecorationModel?.dispose();
            this._findMatchDecorationModel = undefined;
        }
    }
    updateNotebookMatches(matches, modelChange) {
        if (!this._notebookEditorWidget) {
            return;
        }
        const oldCellMatches = ( new Map(this._cellMatches));
        if (this._notebookEditorWidget.getId() !== this._lastEditorWidgetIdForUpdate) {
            this._cellMatches.clear();
            this._lastEditorWidgetIdForUpdate = this._notebookEditorWidget.getId();
        }
        matches.forEach(match => {
            let existingCell = this._cellMatches.get(match.cell.id);
            if (this._notebookEditorWidget && !existingCell) {
                const index = this._notebookEditorWidget.getCellIndex(match.cell);
                const existingRawCell = oldCellMatches.get(`${rawCellPrefix}${index}`);
                if (existingRawCell) {
                    existingRawCell.setCellModel(match.cell);
                    existingCell = existingRawCell;
                }
            }
            const cell = existingCell ?? ( new CellMatch(this, match.cell, match.index));
            cell.addContentMatches(contentMatchesToTextSearchMatches(match.contentMatches, match.cell));
            cell.addWebviewMatches(webviewMatchesToTextSearchMatches(match.webviewMatches));
            this._cellMatches.set(cell.id, cell);
        });
        this._findMatchDecorationModel?.setAllFindMatchesDecorations(matches);
        if (this._selectedMatch instanceof MatchInNotebook) {
            this.highlightCurrentFindMatchDecoration(this._selectedMatch);
        }
        this._onChange.fire({ forceUpdateModel: modelChange });
    }
    setNotebookFindMatchDecorationsUsingCellMatches(cells) {
        if (!this._findMatchDecorationModel) {
            return;
        }
        const cellFindMatch = ( cells.map((cell) => {
            const webviewMatches = ( cell.webviewMatches.map(match => {
                return {
                    index: match.webviewIndex,
                };
            }));
            const findMatches = ( cell.contentMatches.map(match => {
                return ( new FindMatch(match.range(), [match.text()]));
            }));
            return {
                cell: cell.cell,
                index: cell.cellIndex,
                contentMatches: findMatches,
                webviewMatches: webviewMatches
            };
        }));
        try {
            this._findMatchDecorationModel.setAllFindMatchesDecorations(cellFindMatch);
        }
        catch (e) {
        }
    }
    async updateMatchesForEditorWidget() {
        if (!this._notebookEditorWidget) {
            return;
        }
        this._textMatches = ( new Map());
        const wordSeparators = this._query.isWordMatch && this._query.wordSeparators ? this._query.wordSeparators : null;
        const allMatches = await this._notebookEditorWidget
            .find(this._query.pattern, {
            regex: this._query.isRegExp,
            wholeWord: this._query.isWordMatch,
            caseSensitive: this._query.isCaseSensitive,
            wordSeparators: wordSeparators ?? undefined,
            includeMarkupInput: this._query.notebookInfo?.isInNotebookMarkdownInput,
            includeMarkupPreview: this._query.notebookInfo?.isInNotebookMarkdownPreview,
            includeCodeInput: this._query.notebookInfo?.isInNotebookCellInput,
            includeOutput: this._query.notebookInfo?.isInNotebookCellOutput,
        }, CancellationToken.None, false, true, this.searchInstanceID);
        this.updateNotebookMatches(allMatches, true);
    }
    async showMatch(match) {
        const offset = await this.highlightCurrentFindMatchDecoration(match);
        this.setSelectedMatch(match);
        this.revealCellRange(match, offset);
    }
    async highlightCurrentFindMatchDecoration(match) {
        if (!this._findMatchDecorationModel || match.cell instanceof CellSearchModel) {
            return null;
        }
        if (match.webviewIndex === undefined) {
            return this._findMatchDecorationModel.highlightCurrentFindMatchDecorationInCell(match.cell, match.range());
        }
        else {
            return this._findMatchDecorationModel.highlightCurrentFindMatchDecorationInWebview(match.cell, match.webviewIndex);
        }
    }
    revealCellRange(match, outputOffset) {
        if (!this._notebookEditorWidget || match.cell instanceof CellSearchModel) {
            return;
        }
        if (match.webviewIndex !== undefined) {
            const index = this._notebookEditorWidget.getCellIndex(match.cell);
            if (index !== undefined) {
                this._notebookEditorWidget.revealCellOffsetInCenterAsync(match.cell, outputOffset ?? 0);
            }
        }
        else {
            match.cell.updateEditState(CellEditState.Editing, 'focusNotebookCell');
            this._notebookEditorWidget.setCellEditorSelection(match.cell, match.range());
            this._notebookEditorWidget.revealRangeInCenterIfOutsideViewportAsync(match.cell, match.range());
        }
    }
};
FileMatch = ( __decorate([
    ( __param(7, IModelService)),
    ( __param(8, IReplaceService)),
    ( __param(9, ILabelService)),
    ( __param(10, INotebookEditorService))
], FileMatch));
let FolderMatch = class FolderMatch extends Disposable {
    constructor(_resource, _id, _index, _query, _parent, _searchModel, _closestRoot, replaceService, instantiationService, labelService, uriIdentityService) {
        super();
        this._resource = _resource;
        this._id = _id;
        this._index = _index;
        this._query = _query;
        this._parent = _parent;
        this._searchModel = _searchModel;
        this._closestRoot = _closestRoot;
        this.replaceService = replaceService;
        this.instantiationService = instantiationService;
        this.uriIdentityService = uriIdentityService;
        this._onChange = this._register(( new Emitter()));
        this.onChange = this._onChange.event;
        this._onDispose = this._register(( new Emitter()));
        this.onDispose = this._onDispose.event;
        this._replacingAll = false;
        this._fileMatches = ( new ResourceMap());
        this._folderMatches = ( new ResourceMap());
        this._folderMatchesMap = TernarySearchTree.forUris(key => this.uriIdentityService.extUri.ignorePathCasing(key));
        this._unDisposedFileMatches = ( new ResourceMap());
        this._unDisposedFolderMatches = ( new ResourceMap());
        this._name = ( new Lazy(() => this.resource ? labelService.getUriBasenameLabel(this.resource) : ''));
    }
    get searchModel() {
        return this._searchModel;
    }
    get showHighlights() {
        return this._parent.showHighlights;
    }
    get closestRoot() {
        return this._closestRoot;
    }
    set replacingAll(b) {
        this._replacingAll = b;
    }
    id() {
        return this._id;
    }
    get resource() {
        return this._resource;
    }
    index() {
        return this._index;
    }
    name() {
        return this._name.value;
    }
    parent() {
        return this._parent;
    }
    bindModel(model) {
        const fileMatch = this._fileMatches.get(model.uri);
        if (fileMatch) {
            fileMatch.bindModel(model);
        }
        else {
            const folderMatch = this.getFolderMatch(model.uri);
            const match = folderMatch?.getDownstreamFileMatch(model.uri);
            match?.bindModel(model);
        }
    }
    async bindNotebookEditorWidget(editor, resource) {
        const fileMatch = this._fileMatches.get(resource);
        if (fileMatch) {
            fileMatch.bindNotebookEditorWidget(editor);
            await fileMatch.updateMatchesForEditorWidget();
        }
        else {
            const folderMatches = this.folderMatchesIterator();
            for (const elem of folderMatches) {
                await elem.bindNotebookEditorWidget(editor, resource);
            }
        }
    }
    unbindNotebookEditorWidget(editor, resource) {
        const fileMatch = this._fileMatches.get(resource);
        if (fileMatch) {
            fileMatch.unbindNotebookEditorWidget(editor);
        }
        else {
            const folderMatches = this.folderMatchesIterator();
            for (const elem of folderMatches) {
                elem.unbindNotebookEditorWidget(editor, resource);
            }
        }
    }
    createIntermediateFolderMatch(resource, id, index, query, baseWorkspaceFolder) {
        const folderMatch = this.instantiationService.createInstance(FolderMatchWithResource, resource, id, index, query, this, this._searchModel, baseWorkspaceFolder);
        this.configureIntermediateMatch(folderMatch);
        this.doAddFolder(folderMatch);
        return folderMatch;
    }
    configureIntermediateMatch(folderMatch) {
        const disposable = folderMatch.onChange((event) => this.onFolderChange(folderMatch, event));
        folderMatch.onDispose(() => disposable.dispose());
    }
    clear(clearingAll = false) {
        const changed = this.allDownstreamFileMatches();
        this.disposeMatches();
        this._onChange.fire({ elements: changed, removed: true, added: false, clearingAll });
    }
    remove(matches) {
        if (!Array.isArray(matches)) {
            matches = [matches];
        }
        const allMatches = getFileMatches(matches);
        this.doRemoveFile(allMatches);
    }
    async replace(match) {
        return this.replaceService.replace([match]).then(() => {
            this.doRemoveFile([match], true, true, true);
        });
    }
    replaceAll() {
        const matches = this.matches();
        return this.batchReplace(matches);
    }
    matches() {
        return [...this.fileMatchesIterator(), ...this.folderMatchesIterator()];
    }
    fileMatchesIterator() {
        return ( this._fileMatches.values());
    }
    folderMatchesIterator() {
        return ( this._folderMatches.values());
    }
    isEmpty() {
        return (this.fileCount() + this.folderCount()) === 0;
    }
    getDownstreamFileMatch(uri) {
        const directChildFileMatch = this._fileMatches.get(uri);
        if (directChildFileMatch) {
            return directChildFileMatch;
        }
        const folderMatch = this.getFolderMatch(uri);
        const match = folderMatch?.getDownstreamFileMatch(uri);
        if (match) {
            return match;
        }
        return null;
    }
    allDownstreamFileMatches() {
        let recursiveChildren = [];
        const iterator = this.folderMatchesIterator();
        for (const elem of iterator) {
            recursiveChildren = recursiveChildren.concat(elem.allDownstreamFileMatches());
        }
        return [...this.fileMatchesIterator(), ...recursiveChildren];
    }
    fileCount() {
        return this._fileMatches.size;
    }
    folderCount() {
        return this._folderMatches.size;
    }
    count() {
        return this.fileCount() + this.folderCount();
    }
    recursiveFileCount() {
        return this.allDownstreamFileMatches().length;
    }
    recursiveMatchCount() {
        return this.allDownstreamFileMatches().reduce((prev, match) => prev + match.count(), 0);
    }
    get query() {
        return this._query;
    }
    addFileMatch(raw, silent, searchInstanceID) {
        const added = [];
        const updated = [];
        raw.forEach(rawFileMatch => {
            const existingFileMatch = this.getDownstreamFileMatch(rawFileMatch.resource);
            if (existingFileMatch) {
                rawFileMatch
                    .results
                    .filter(resultIsMatch)
                    .forEach(m => {
                    textSearchResultToMatches(m, existingFileMatch)
                        .forEach(m => existingFileMatch.add(m));
                });
                if (isIFileMatchWithCells(rawFileMatch)) {
                    rawFileMatch.cellResults?.forEach(rawCellMatch => {
                        const existingCellMatch = existingFileMatch.getCellMatch(rawCellMatch.cell.id);
                        if (existingCellMatch) {
                            existingCellMatch.addContentMatches(rawCellMatch.contentResults);
                            existingCellMatch.addContentMatches(rawCellMatch.webviewResults);
                        }
                        else {
                            existingFileMatch.addCellMatch(rawCellMatch);
                        }
                    });
                }
                updated.push(existingFileMatch);
                existingFileMatch.addContext(rawFileMatch.results);
            }
            else {
                if (this instanceof FolderMatchWorkspaceRoot || this instanceof FolderMatchNoRoot) {
                    const fileMatch = this.createAndConfigureFileMatch(rawFileMatch, searchInstanceID);
                    added.push(fileMatch);
                }
            }
        });
        const elements = [...added, ...updated];
        if (!silent && elements.length) {
            this._onChange.fire({ elements, added: !!added.length });
        }
    }
    doAddFile(fileMatch) {
        this._fileMatches.set(fileMatch.resource, fileMatch);
        if (( this._unDisposedFileMatches.has(fileMatch.resource))) {
            this._unDisposedFileMatches.delete(fileMatch.resource);
        }
    }
    hasOnlyReadOnlyMatches() {
        return Array.from(( this._fileMatches.values())).every(fm => fm.hasOnlyReadOnlyMatches());
    }
    uriHasParent(parent, child) {
        return this.uriIdentityService.extUri.isEqualOrParent(child, parent) && !this.uriIdentityService.extUri.isEqual(child, parent);
    }
    isInParentChain(folderMatch) {
        let matchItem = this;
        while (matchItem instanceof FolderMatch) {
            if (matchItem.id() === folderMatch.id()) {
                return true;
            }
            matchItem = matchItem.parent();
        }
        return false;
    }
    getFolderMatch(resource) {
        const folderMatch = this._folderMatchesMap.findSubstr(resource);
        return folderMatch;
    }
    doAddFolder(folderMatch) {
        if (this instanceof FolderMatchWithResource && !this.uriHasParent(this.resource, folderMatch.resource)) {
            throw Error(`${folderMatch.resource} does not belong as a child of ${this.resource}`);
        }
        else if (this.isInParentChain(folderMatch)) {
            throw Error(`${folderMatch.resource} is a parent of ${this.resource}`);
        }
        this._folderMatches.set(folderMatch.resource, folderMatch);
        this._folderMatchesMap.set(folderMatch.resource, folderMatch);
        if (( this._unDisposedFolderMatches.has(folderMatch.resource))) {
            this._unDisposedFolderMatches.delete(folderMatch.resource);
        }
    }
    async batchReplace(matches) {
        const allMatches = getFileMatches(matches);
        await this.replaceService.replace(allMatches);
        this.doRemoveFile(allMatches, true, true, true);
    }
    onFileChange(fileMatch, removed = false) {
        let added = false;
        if (!( this._fileMatches.has(fileMatch.resource))) {
            this.doAddFile(fileMatch);
            added = true;
        }
        if (fileMatch.count() === 0) {
            this.doRemoveFile([fileMatch], false, false);
            added = false;
            removed = true;
        }
        if (!this._replacingAll) {
            this._onChange.fire({ elements: [fileMatch], added: added, removed: removed });
        }
    }
    onFolderChange(folderMatch, event) {
        if (!( this._folderMatches.has(folderMatch.resource))) {
            this.doAddFolder(folderMatch);
        }
        if (folderMatch.isEmpty()) {
            this._folderMatches.delete(folderMatch.resource);
            folderMatch.dispose();
        }
        this._onChange.fire(event);
    }
    doRemoveFile(fileMatches, dispose = true, trigger = true, keepReadonly = false) {
        const removed = [];
        for (const match of fileMatches) {
            if (this._fileMatches.get(match.resource)) {
                if (keepReadonly && match.hasWebviewMatches()) {
                    continue;
                }
                this._fileMatches.delete(match.resource);
                if (dispose) {
                    match.dispose();
                }
                else {
                    this._unDisposedFileMatches.set(match.resource, match);
                }
                removed.push(match);
            }
            else {
                const folder = this.getFolderMatch(match.resource);
                if (folder) {
                    folder.doRemoveFile([match], dispose, trigger);
                }
                else {
                    throw Error(`FileMatch ${match.resource} is not located within FolderMatch ${this.resource}`);
                }
            }
        }
        if (trigger) {
            this._onChange.fire({ elements: removed, removed: true });
        }
    }
    disposeMatches() {
        [...( this._fileMatches.values())].forEach((fileMatch) => fileMatch.dispose());
        [...( this._folderMatches.values())].forEach((folderMatch) => folderMatch.disposeMatches());
        [...( this._unDisposedFileMatches.values())].forEach((fileMatch) => fileMatch.dispose());
        [...( this._unDisposedFolderMatches.values())].forEach((folderMatch) => folderMatch.disposeMatches());
        this._fileMatches.clear();
        this._folderMatches.clear();
        this._unDisposedFileMatches.clear();
        this._unDisposedFolderMatches.clear();
    }
    dispose() {
        this.disposeMatches();
        this._onDispose.fire();
        super.dispose();
    }
};
FolderMatch = ( __decorate([
    ( __param(7, IReplaceService)),
    ( __param(8, IInstantiationService)),
    ( __param(9, ILabelService)),
    ( __param(10, IUriIdentityService))
], FolderMatch));
let FolderMatchWithResource = class FolderMatchWithResource extends FolderMatch {
    constructor(_resource, _id, _index, _query, _parent, _searchModel, _closestRoot, replaceService, instantiationService, labelService, uriIdentityService) {
        super(_resource, _id, _index, _query, _parent, _searchModel, _closestRoot, replaceService, instantiationService, labelService, uriIdentityService);
        this._normalizedResource = ( new Lazy(
            () => this.uriIdentityService.extUri.removeTrailingPathSeparator(this.uriIdentityService.extUri.normalizePath(this.resource))
        ));
    }
    get resource() {
        return this._resource;
    }
    get normalizedResource() {
        return this._normalizedResource.value;
    }
};
FolderMatchWithResource = ( __decorate([
    ( __param(7, IReplaceService)),
    ( __param(8, IInstantiationService)),
    ( __param(9, ILabelService)),
    ( __param(10, IUriIdentityService))
], FolderMatchWithResource));
let FolderMatchWorkspaceRoot = class FolderMatchWorkspaceRoot extends FolderMatchWithResource {
    constructor(_resource, _id, _index, _query, _parent, _searchModel, replaceService, instantiationService, labelService, uriIdentityService) {
        super(_resource, _id, _index, _query, _parent, _searchModel, null, replaceService, instantiationService, labelService, uriIdentityService);
    }
    normalizedUriParent(uri) {
        return this.uriIdentityService.extUri.normalizePath(this.uriIdentityService.extUri.dirname(uri));
    }
    uriEquals(uri1, ur2) {
        return this.uriIdentityService.extUri.isEqual(uri1, ur2);
    }
    createFileMatch(query, previewOptions, maxResults, parent, rawFileMatch, closestRoot, searchInstanceID) {
        const fileMatch = this.instantiationService.createInstance(FileMatch, query, previewOptions, maxResults, parent, rawFileMatch, closestRoot, searchInstanceID);
        parent.doAddFile(fileMatch);
        const disposable = fileMatch.onChange(({ didRemove }) => parent.onFileChange(fileMatch, didRemove));
        fileMatch.onDispose(() => disposable.dispose());
        return fileMatch;
    }
    createAndConfigureFileMatch(rawFileMatch, searchInstanceID) {
        if (!this.uriHasParent(this.resource, rawFileMatch.resource)) {
            throw Error(`${rawFileMatch.resource} is not a descendant of ${this.resource}`);
        }
        const fileMatchParentParts = [];
        let uri = this.normalizedUriParent(rawFileMatch.resource);
        while (!this.uriEquals(this.normalizedResource, uri)) {
            fileMatchParentParts.unshift(uri);
            const prevUri = uri;
            uri = this.uriIdentityService.extUri.removeTrailingPathSeparator(this.normalizedUriParent(uri));
            if (this.uriEquals(prevUri, uri)) {
                throw Error(`${rawFileMatch.resource} is not correctly configured as a child of ${this.normalizedResource}`);
            }
        }
        const root = this.closestRoot ?? this;
        let parent = this;
        for (let i = 0; i < fileMatchParentParts.length; i++) {
            let folderMatch = parent.getFolderMatch(fileMatchParentParts[i]);
            if (!folderMatch) {
                folderMatch = parent.createIntermediateFolderMatch(fileMatchParentParts[i], ( fileMatchParentParts[i].toString()), -1, this._query, root);
            }
            parent = folderMatch;
        }
        return this.createFileMatch(this._query.contentPattern, this._query.previewOptions, this._query.maxResults, parent, rawFileMatch, root, searchInstanceID);
    }
};
FolderMatchWorkspaceRoot = ( __decorate([
    ( __param(6, IReplaceService)),
    ( __param(7, IInstantiationService)),
    ( __param(8, ILabelService)),
    ( __param(9, IUriIdentityService))
], FolderMatchWorkspaceRoot));
let FolderMatchNoRoot = class FolderMatchNoRoot extends FolderMatch {
    constructor(_id, _index, _query, _parent, _searchModel, replaceService, instantiationService, labelService, uriIdentityService) {
        super(null, _id, _index, _query, _parent, _searchModel, null, replaceService, instantiationService, labelService, uriIdentityService);
    }
    createAndConfigureFileMatch(rawFileMatch, searchInstanceID) {
        const fileMatch = this.instantiationService.createInstance(FileMatch, this._query.contentPattern, this._query.previewOptions, this._query.maxResults, this, rawFileMatch, null, searchInstanceID);
        this.doAddFile(fileMatch);
        const disposable = fileMatch.onChange(({ didRemove }) => this.onFileChange(fileMatch, didRemove));
        fileMatch.onDispose(() => disposable.dispose());
        return fileMatch;
    }
};
FolderMatchNoRoot = ( __decorate([
    ( __param(5, IReplaceService)),
    ( __param(6, IInstantiationService)),
    ( __param(7, ILabelService)),
    ( __param(8, IUriIdentityService))
], FolderMatchNoRoot));
let elemAIndex = -1;
let elemBIndex = -1;
function searchMatchComparer(elementA, elementB, sortOrder = "default" ) {
    if (elementA instanceof FileMatch && elementB instanceof FolderMatch) {
        return 1;
    }
    if (elementB instanceof FileMatch && elementA instanceof FolderMatch) {
        return -1;
    }
    if (elementA instanceof FolderMatch && elementB instanceof FolderMatch) {
        elemAIndex = elementA.index();
        elemBIndex = elementB.index();
        if (elemAIndex !== -1 && elemBIndex !== -1) {
            return elemAIndex - elemBIndex;
        }
        switch (sortOrder) {
            case "countDescending" :
                return elementB.count() - elementA.count();
            case "countAscending" :
                return elementA.count() - elementB.count();
            case "type" :
                return compareFileExtensions(elementA.name(), elementB.name());
            case "fileNames" :
                return compareFileNames(elementA.name(), elementB.name());
            default:
                if (!elementA.resource || !elementB.resource) {
                    return 0;
                }
                return comparePaths(elementA.resource.fsPath, elementB.resource.fsPath) || compareFileNames(elementA.name(), elementB.name());
        }
    }
    if (elementA instanceof FileMatch && elementB instanceof FileMatch) {
        switch (sortOrder) {
            case "countDescending" :
                return elementB.count() - elementA.count();
            case "countAscending" :
                return elementA.count() - elementB.count();
            case "type" :
                return compareFileExtensions(elementA.name(), elementB.name());
            case "fileNames" :
                return compareFileNames(elementA.name(), elementB.name());
            case "modified" : {
                const fileStatA = elementA.fileStat;
                const fileStatB = elementB.fileStat;
                if (fileStatA && fileStatB) {
                    return fileStatB.mtime - fileStatA.mtime;
                }
            }
            default:
                return comparePaths(elementA.resource.fsPath, elementB.resource.fsPath) || compareFileNames(elementA.name(), elementB.name());
        }
    }
    if (elementA instanceof MatchInNotebook && elementB instanceof MatchInNotebook) {
        return compareNotebookPos(elementA, elementB);
    }
    if (elementA instanceof Match && elementB instanceof Match) {
        return Range.compareRangesUsingStarts(elementA.range(), elementB.range());
    }
    return 0;
}
function compareNotebookPos(match1, match2) {
    if (match1.cellIndex === match2.cellIndex) {
        if (match1.webviewIndex !== undefined && match2.webviewIndex !== undefined) {
            return match1.webviewIndex - match2.webviewIndex;
        }
        else if (match1.webviewIndex === undefined && match2.webviewIndex === undefined) {
            return Range.compareRangesUsingStarts(match1.range(), match2.range());
        }
        else {
            if (match1.webviewIndex !== undefined) {
                return 1;
            }
            else {
                return -1;
            }
        }
    }
    else if (match1.cellIndex < match2.cellIndex) {
        return -1;
    }
    else {
        return 1;
    }
}
function searchComparer(elementA, elementB, sortOrder = "default" ) {
    const elemAParents = createParentList(elementA);
    const elemBParents = createParentList(elementB);
    let i = elemAParents.length - 1;
    let j = elemBParents.length - 1;
    while (i >= 0 && j >= 0) {
        if (elemAParents[i].id() !== elemBParents[j].id()) {
            return searchMatchComparer(elemAParents[i], elemBParents[j], sortOrder);
        }
        i--;
        j--;
    }
    const elemAAtEnd = i === 0;
    const elemBAtEnd = j === 0;
    if (elemAAtEnd && !elemBAtEnd) {
        return 1;
    }
    else if (!elemAAtEnd && elemBAtEnd) {
        return -1;
    }
    return 0;
}
function createParentList(element) {
    const parentArray = [];
    let currElement = element;
    while (!(currElement instanceof SearchResult)) {
        parentArray.push(currElement);
        currElement = currElement.parent();
    }
    return parentArray;
}
let SearchResult = class SearchResult extends Disposable {
    constructor(_searchModel, replaceService, instantiationService, modelService, uriIdentityService, notebookEditorService) {
        super();
        this._searchModel = _searchModel;
        this.replaceService = replaceService;
        this.instantiationService = instantiationService;
        this.modelService = modelService;
        this.uriIdentityService = uriIdentityService;
        this.notebookEditorService = notebookEditorService;
        this._onChange = this._register(( new PauseableEmitter({
            merge: this.mergeEvents
        })));
        this.onChange = this._onChange.event;
        this._folderMatches = [];
        this._otherFilesMatch = null;
        this._folderMatchesMap = TernarySearchTree.forUris(key => this.uriIdentityService.extUri.ignorePathCasing(key));
        this._showHighlights = false;
        this._query = null;
        this.disposePastResults = () => { };
        this._isDirty = false;
        this._rangeHighlightDecorations = this.instantiationService.createInstance(RangeHighlightDecorations);
        this._register(this.modelService.onModelAdded(model => this.onModelAdded(model)));
        this._register(this.notebookEditorService.onDidAddNotebookEditor(widget => {
            if (widget instanceof NotebookEditorWidget) {
                this.onDidAddNotebookEditorWidget(widget);
            }
        }));
        this._register(this.onChange(e => {
            if (e.removed) {
                this._isDirty = !this.isEmpty();
            }
        }));
    }
    async batchReplace(elementsToReplace) {
        try {
            this._onChange.pause();
            await Promise.all(( elementsToReplace.map(async (elem) => {
                const parent = elem.parent();
                if ((parent instanceof FolderMatch || parent instanceof FileMatch) && arrayContainsElementOrParent(parent, elementsToReplace)) {
                    return;
                }
                if (elem instanceof FileMatch) {
                    await elem.parent().replace(elem);
                }
                else if (elem instanceof Match) {
                    await elem.parent().replace(elem);
                }
                else if (elem instanceof FolderMatch) {
                    await elem.replaceAll();
                }
            })));
        }
        finally {
            this._onChange.resume();
        }
    }
    batchRemove(elementsToRemove) {
        const removedElems = [];
        try {
            this._onChange.pause();
            elementsToRemove.forEach((currentElement) => {
                if (!arrayContainsElementOrParent(currentElement, removedElems)) {
                    currentElement.parent().remove(currentElement);
                    removedElems.push(currentElement);
                }
            });
        }
        finally {
            this._onChange.resume();
        }
    }
    get isDirty() {
        return this._isDirty;
    }
    get query() {
        return this._query;
    }
    set query(query) {
        const oldFolderMatches = this.folderMatches();
        ( new Promise(resolve => this.disposePastResults = resolve))
            .then(() => oldFolderMatches.forEach(match => match.clear()))
            .then(() => oldFolderMatches.forEach(match => match.dispose()))
            .then(() => this._isDirty = false);
        this._rangeHighlightDecorations.removeHighlightRange();
        this._folderMatchesMap = TernarySearchTree.forUris(key => this.uriIdentityService.extUri.ignorePathCasing(key));
        if (!query) {
            return;
        }
        this._folderMatches = ( ( (query && query.folderQueries || [])
            .map(fq => fq.folder))
            .map((resource, index) => this._createBaseFolderMatch(resource, ( resource.toString()), index, query)));
        this._folderMatches.forEach(fm => this._folderMatchesMap.set(fm.resource, fm));
        this._otherFilesMatch = this._createBaseFolderMatch(null, 'otherFiles', this._folderMatches.length + 1, query);
        this._query = query;
    }
    mergeEvents(events) {
        const retEvent = {
            elements: [],
            added: false,
            removed: false,
        };
        events.forEach((e) => {
            if (e.added) {
                retEvent.added = true;
            }
            if (e.removed) {
                retEvent.removed = true;
            }
            retEvent.elements = retEvent.elements.concat(e.elements);
        });
        return retEvent;
    }
    onDidAddNotebookEditorWidget(widget) {
        this._onWillChangeModelListener?.dispose();
        this._onWillChangeModelListener = widget.onWillChangeModel((model) => {
            if (model) {
                this.onNotebookEditorWidgetRemoved(widget, model?.uri);
            }
        });
        this._onDidChangeModelListener?.dispose();
        this._onDidChangeModelListener = widget.onDidAttachViewModel(() => {
            if (widget.hasModel()) {
                this.onNotebookEditorWidgetAdded(widget, widget.textModel.uri);
            }
        });
    }
    onModelAdded(model) {
        const folderMatch = this._folderMatchesMap.findSubstr(model.uri);
        folderMatch?.bindModel(model);
    }
    async onNotebookEditorWidgetAdded(editor, resource) {
        const folderMatch = this._folderMatchesMap.findSubstr(resource);
        await folderMatch?.bindNotebookEditorWidget(editor, resource);
    }
    onNotebookEditorWidgetRemoved(editor, resource) {
        const folderMatch = this._folderMatchesMap.findSubstr(resource);
        folderMatch?.unbindNotebookEditorWidget(editor, resource);
    }
    _createBaseFolderMatch(resource, id, index, query) {
        let folderMatch;
        if (resource) {
            folderMatch = this.instantiationService.createInstance(FolderMatchWorkspaceRoot, resource, id, index, query, this, this._searchModel);
        }
        else {
            folderMatch = this.instantiationService.createInstance(FolderMatchNoRoot, id, index, query, this, this._searchModel);
        }
        const disposable = folderMatch.onChange((event) => this._onChange.fire(event));
        folderMatch.onDispose(() => disposable.dispose());
        return folderMatch;
    }
    get searchModel() {
        return this._searchModel;
    }
    add(allRaw, searchInstanceID, silent = false) {
        const { byFolder, other } = this.groupFilesByFolder(allRaw);
        byFolder.forEach(raw => {
            if (!raw.length) {
                return;
            }
            const folderMatch = this.getFolderMatch(raw[0].resource);
            folderMatch?.addFileMatch(raw, silent, searchInstanceID);
        });
        this._otherFilesMatch?.addFileMatch(other, silent, searchInstanceID);
        this.disposePastResults();
    }
    clear() {
        this.folderMatches().forEach((folderMatch) => folderMatch.clear(true));
        this.disposeMatches();
        this._folderMatches = [];
        this._otherFilesMatch = null;
    }
    remove(matches) {
        if (!Array.isArray(matches)) {
            matches = [matches];
        }
        matches.forEach(m => {
            if (m instanceof FolderMatch) {
                m.clear();
            }
        });
        const fileMatches = matches.filter(m => m instanceof FileMatch);
        const { byFolder, other } = this.groupFilesByFolder(fileMatches);
        byFolder.forEach(matches => {
            if (!matches.length) {
                return;
            }
            this.getFolderMatch(matches[0].resource).remove(matches);
        });
        if (other.length) {
            this.getFolderMatch(other[0].resource).remove(other);
        }
    }
    replace(match) {
        return this.getFolderMatch(match.resource).replace(match);
    }
    replaceAll(progress) {
        this.replacingAll = true;
        const promise = this.replaceService.replace(this.matches(), progress);
        return promise.then(() => {
            this.replacingAll = false;
            this.clear();
        }, () => {
            this.replacingAll = false;
        });
    }
    folderMatches() {
        return this._otherFilesMatch ?
            [
                ...this._folderMatches,
                this._otherFilesMatch
            ] :
            [
                ...this._folderMatches
            ];
    }
    matches() {
        const matches = [];
        this.folderMatches().forEach(folderMatch => {
            matches.push(folderMatch.allDownstreamFileMatches());
        });
        return [].concat(...matches);
    }
    isEmpty() {
        return this.folderMatches().every((folderMatch) => folderMatch.isEmpty());
    }
    fileCount() {
        return this.folderMatches().reduce((prev, match) => prev + match.recursiveFileCount(), 0);
    }
    count() {
        return this.matches().reduce((prev, match) => prev + match.count(), 0);
    }
    get showHighlights() {
        return this._showHighlights;
    }
    toggleHighlights(value) {
        if (this._showHighlights === value) {
            return;
        }
        this._showHighlights = value;
        let selectedMatch = null;
        this.matches().forEach((fileMatch) => {
            fileMatch.updateHighlights();
            fileMatch.updateNotebookHighlights();
            if (!selectedMatch) {
                selectedMatch = fileMatch.getSelectedMatch();
            }
        });
        if (this._showHighlights && selectedMatch) {
            this._rangeHighlightDecorations.highlightRange(selectedMatch.parent().resource, selectedMatch.range());
        }
        else {
            this._rangeHighlightDecorations.removeHighlightRange();
        }
    }
    get rangeHighlightDecorations() {
        return this._rangeHighlightDecorations;
    }
    getFolderMatch(resource) {
        const folderMatch = this._folderMatchesMap.findSubstr(resource);
        return folderMatch ? folderMatch : this._otherFilesMatch;
    }
    set replacingAll(running) {
        this.folderMatches().forEach((folderMatch) => {
            folderMatch.replacingAll = running;
        });
    }
    groupFilesByFolder(fileMatches) {
        const rawPerFolder = ( new ResourceMap());
        const otherFileMatches = [];
        this._folderMatches.forEach(fm => rawPerFolder.set(fm.resource, []));
        fileMatches.forEach(rawFileMatch => {
            const folderMatch = this.getFolderMatch(rawFileMatch.resource);
            if (!folderMatch) {
                return;
            }
            const resource = folderMatch.resource;
            if (resource) {
                rawPerFolder.get(resource).push(rawFileMatch);
            }
            else {
                otherFileMatches.push(rawFileMatch);
            }
        });
        return {
            byFolder: rawPerFolder,
            other: otherFileMatches
        };
    }
    disposeMatches() {
        this.folderMatches().forEach(folderMatch => folderMatch.dispose());
        this._folderMatches = [];
        this._folderMatchesMap = TernarySearchTree.forUris(key => this.uriIdentityService.extUri.ignorePathCasing(key));
        this._rangeHighlightDecorations.removeHighlightRange();
    }
    dispose() {
        this._onWillChangeModelListener?.dispose();
        this._onDidChangeModelListener?.dispose();
        this.disposePastResults();
        this.disposeMatches();
        this._rangeHighlightDecorations.dispose();
        super.dispose();
    }
};
SearchResult = ( __decorate([
    ( __param(1, IReplaceService)),
    ( __param(2, IInstantiationService)),
    ( __param(3, IModelService)),
    ( __param(4, IUriIdentityService)),
    ( __param(5, INotebookEditorService))
], SearchResult));
let SearchModel = class SearchModel extends Disposable {
    constructor(searchService, telemetryService, configurationService, instantiationService, logService, notebookSearchService) {
        super();
        this.searchService = searchService;
        this.telemetryService = telemetryService;
        this.configurationService = configurationService;
        this.instantiationService = instantiationService;
        this.logService = logService;
        this.notebookSearchService = notebookSearchService;
        this._searchQuery = null;
        this._replaceActive = false;
        this._replaceString = null;
        this._replacePattern = null;
        this._preserveCase = false;
        this._startStreamDelay = Promise.resolve();
        this._resultQueue = [];
        this._onReplaceTermChanged = this._register(( new Emitter()));
        this.onReplaceTermChanged = this._onReplaceTermChanged.event;
        this.currentCancelTokenSource = null;
        this.searchCancelledForNewSearch = false;
        this._searchResult = this.instantiationService.createInstance(SearchResult, this);
    }
    isReplaceActive() {
        return this._replaceActive;
    }
    set replaceActive(replaceActive) {
        this._replaceActive = replaceActive;
    }
    get replacePattern() {
        return this._replacePattern;
    }
    get replaceString() {
        return this._replaceString || '';
    }
    set preserveCase(value) {
        this._preserveCase = value;
    }
    get preserveCase() {
        return this._preserveCase;
    }
    set replaceString(replaceString) {
        this._replaceString = replaceString;
        if (this._searchQuery) {
            this._replacePattern = ( new ReplacePattern(replaceString, this._searchQuery.contentPattern));
        }
        this._onReplaceTermChanged.fire();
    }
    get searchResult() {
        return this._searchResult;
    }
    async doSearch(query, progressEmitter, searchQuery, searchInstanceID, onProgress) {
        const searchStart = Date.now();
        const tokenSource = this.currentCancelTokenSource = ( new CancellationTokenSource());
        const onProgressCall = (p) => {
            progressEmitter.fire();
            this.onSearchProgress(p, searchInstanceID);
            onProgress?.(p);
        };
        const notebookResult = await this.notebookSearchService.notebookSearch(query, this.currentCancelTokenSource.token, searchInstanceID, onProgressCall);
        const currentResult = await this.searchService.textSearch(searchQuery, this.currentCancelTokenSource.token, onProgressCall, notebookResult?.scannedFiles);
        tokenSource.dispose();
        const searchLength = Date.now() - searchStart;
        this.logService.trace(`whole search time | ${searchLength}ms`);
        return notebookResult ? { ...currentResult, ...notebookResult.completeData } : currentResult;
    }
    async search(query, onProgress) {
        this.cancelSearch(true);
        this._searchQuery = query;
        if (!this.searchConfig.searchOnType) {
            this.searchResult.clear();
        }
        const searchInstanceID = ( Date.now().toString());
        this._searchResult.query = this._searchQuery;
        const progressEmitter = ( new Emitter());
        this._replacePattern = ( new ReplacePattern(this.replaceString, this._searchQuery.contentPattern));
        this._startStreamDelay = ( new Promise(resolve => setTimeout(resolve, this.searchConfig.searchOnType ? 150 : 0)));
        const currentRequest = this.doSearch(query, progressEmitter, this._searchQuery, searchInstanceID, onProgress);
        const start = Date.now();
        Promise.race([currentRequest, Event.toPromise(progressEmitter.event)]).finally(() => {
            this.telemetryService.publicLog('searchResultsFirstRender', { duration: Date.now() - start });
        });
        currentRequest.then(value => this.onSearchCompleted(value, Date.now() - start, searchInstanceID), e => this.onSearchError(e, Date.now() - start));
        try {
            return await currentRequest;
        }
        finally {
            this.telemetryService.publicLog('searchResultsFinished', { duration: Date.now() - start });
        }
    }
    onSearchCompleted(completed, duration, searchInstanceID) {
        if (!this._searchQuery) {
            throw new Error('onSearchCompleted must be called after a search is started');
        }
        this._searchResult.add(this._resultQueue, searchInstanceID);
        this._resultQueue.length = 0;
        const options = Object.assign({}, this._searchQuery.contentPattern);
        delete options.pattern;
        const stats = completed && completed.stats;
        const fileSchemeOnly = this._searchQuery.folderQueries.every(fq => fq.folder.scheme === Schemas.file);
        const otherSchemeOnly = this._searchQuery.folderQueries.every(fq => fq.folder.scheme !== Schemas.file);
        const scheme = fileSchemeOnly ? Schemas.file :
            otherSchemeOnly ? 'other' :
                'mixed';
        this.telemetryService.publicLog('searchResultsShown', {
            count: this._searchResult.count(),
            fileCount: this._searchResult.fileCount(),
            options,
            duration,
            type: stats && stats.type,
            scheme,
            searchOnTypeEnabled: this.searchConfig.searchOnType
        });
        return completed;
    }
    onSearchError(e, duration) {
        if (errors.isCancellationError(e)) {
            this.onSearchCompleted(this.searchCancelledForNewSearch
                ? { exit: 1 , results: [], messages: [] }
                : null, duration, '');
            this.searchCancelledForNewSearch = false;
        }
    }
    async onSearchProgress(p, searchInstanceID) {
        if (p.resource) {
            this._resultQueue.push(p);
            await this._startStreamDelay;
            if (this._resultQueue.length) {
                this._searchResult.add(this._resultQueue, searchInstanceID, true);
                this._resultQueue.length = 0;
            }
        }
    }
    get searchConfig() {
        return this.configurationService.getValue('search');
    }
    cancelSearch(cancelledForNewSearch = false) {
        if (this.currentCancelTokenSource) {
            this.searchCancelledForNewSearch = cancelledForNewSearch;
            this.currentCancelTokenSource.cancel();
            return true;
        }
        return false;
    }
    dispose() {
        this.cancelSearch();
        this.searchResult.dispose();
        super.dispose();
    }
};
SearchModel = ( __decorate([
    ( __param(0, ISearchService)),
    ( __param(1, ITelemetryService)),
    ( __param(2, IConfigurationService)),
    ( __param(3, IInstantiationService)),
    ( __param(4, ILogService)),
    ( __param(5, INotebookSearchService))
], SearchModel));
let SearchWorkbenchService = class SearchWorkbenchService {
    constructor(instantiationService) {
        this.instantiationService = instantiationService;
        this._searchModel = null;
    }
    get searchModel() {
        if (!this._searchModel) {
            this._searchModel = this.instantiationService.createInstance(SearchModel);
        }
        return this._searchModel;
    }
};
SearchWorkbenchService = ( __decorate([
    ( __param(0, IInstantiationService))
], SearchWorkbenchService));
const ISearchWorkbenchService = ( createDecorator('searchWorkbenchService'));
let RangeHighlightDecorations = class RangeHighlightDecorations {
    constructor(_modelService) {
        this._modelService = _modelService;
        this._decorationId = null;
        this._model = null;
        this._modelDisposables = ( new DisposableStore());
    }
    removeHighlightRange() {
        if (this._model && this._decorationId) {
            const decorationId = this._decorationId;
            this._model.changeDecorations((accessor) => {
                accessor.removeDecoration(decorationId);
            });
        }
        this._decorationId = null;
    }
    highlightRange(resource, range, ownerId = 0) {
        let model;
        if (URI.isUri(resource)) {
            model = this._modelService.getModel(resource);
        }
        else {
            model = resource;
        }
        if (model) {
            this.doHighlightRange(model, range);
        }
    }
    doHighlightRange(model, range) {
        this.removeHighlightRange();
        model.changeDecorations((accessor) => {
            this._decorationId = accessor.addDecoration(range, RangeHighlightDecorations._RANGE_HIGHLIGHT_DECORATION);
        });
        this.setModel(model);
    }
    setModel(model) {
        if (this._model !== model) {
            this.clearModelListeners();
            this._model = model;
            this._modelDisposables.add(this._model.onDidChangeDecorations((e) => {
                this.clearModelListeners();
                this.removeHighlightRange();
                this._model = null;
            }));
            this._modelDisposables.add(this._model.onWillDispose(() => {
                this.clearModelListeners();
                this.removeHighlightRange();
                this._model = null;
            }));
        }
    }
    clearModelListeners() {
        this._modelDisposables.clear();
    }
    dispose() {
        if (this._model) {
            this.removeHighlightRange();
            this._modelDisposables.dispose();
            this._model = null;
        }
    }
    static { this._RANGE_HIGHLIGHT_DECORATION = ModelDecorationOptions.register({
        description: 'search-range-highlight',
        stickiness: 1 ,
        className: 'rangeHighlight',
        isWholeLine: true
    }); }
};
RangeHighlightDecorations = ( __decorate([
    ( __param(0, IModelService))
], RangeHighlightDecorations));
function textSearchResultToMatches(rawMatch, fileMatch) {
    const previewLines = rawMatch.preview.text.split('\n');
    if (Array.isArray(rawMatch.ranges)) {
        return ( rawMatch.ranges.map((r, i) => {
            const previewRange = rawMatch.preview.matches[i];
            return ( new Match(fileMatch, previewLines, previewRange, r));
        }));
    }
    else {
        const previewRange = rawMatch.preview.matches;
        const match = ( new Match(fileMatch, previewLines, previewRange, rawMatch.ranges));
        return [match];
    }
}
function textSearchMatchesToNotebookMatches(textSearchMatches, cell) {
    const notebookMatches = [];
    return notebookMatches;
}
function arrayContainsElementOrParent(element, testArray) {
    do {
        if (testArray.includes(element)) {
            return true;
        }
    } while (!(element.parent() instanceof SearchResult) && (element = element.parent()));
    return false;
}
function getFileMatches(matches) {
    const folderMatches = [];
    const fileMatches = [];
    matches.forEach((e) => {
        if (e instanceof FileMatch) {
            fileMatches.push(e);
        }
        else {
            folderMatches.push(e);
        }
    });
    return fileMatches.concat(( folderMatches.map(e => e.allDownstreamFileMatches())).flat());
}
export { CellMatch, FileMatch, FolderMatch, FolderMatchNoRoot, FolderMatchWithResource, FolderMatchWorkspaceRoot, ISearchWorkbenchService, Match, MatchInNotebook, RangeHighlightDecorations, SearchModel, SearchResult, SearchWorkbenchService, arrayContainsElementOrParent, compareNotebookPos, searchComparer, searchMatchComparer, textSearchMatchesToNotebookMatches };
