import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import { MarkdownString } from 'monaco-editor/esm/vs/base/common/htmlContent.js';
import { compare, firstNonWhitespaceIndex, compareSubstring } from 'monaco-editor/esm/vs/base/common/strings.js';
import { Range } from 'monaco-editor/esm/vs/editor/common/core/range.js';
import { ILanguageService } from 'monaco-editor/esm/vs/editor/common/languages/language.js';
import { SnippetParser } from 'monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetParser.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { ISnippetsService } from './snippets.js';
import { Snippet } from './snippetsFile.js';
import { isPatternInWord } from 'monaco-editor/esm/vs/base/common/filters.js';
import { StopWatch } from 'monaco-editor/esm/vs/base/common/stopwatch.js';
import { ILanguageConfigurationService } from 'monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js';
import { getWordAtText } from 'monaco-editor/esm/vs/editor/common/core/wordHelper.js';
import { CommandsRegistry } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
const markSnippetAsUsed = '_snippet.markAsUsed';
CommandsRegistry.registerCommand(markSnippetAsUsed, (accessor, ...args) => {
    const snippetsService = accessor.get(ISnippetsService);
    const [first] = args;
    if (first instanceof Snippet) {
        snippetsService.updateUsageTimestamp(first);
    }
});
class SnippetCompletion {
    constructor(snippet, range) {
        this.snippet = snippet;
        this.label = { label: snippet.prefix, description: snippet.name };
        this.detail = ( localize(
            'detail.snippet',
            "{0} ({1})",
            snippet.description || snippet.name,
            snippet.source
        ));
        this.insertText = snippet.codeSnippet;
        this.extensionId = snippet.extensionId;
        this.range = range;
        this.sortText = `${snippet.snippetSource === 3  ? 'z' : 'a'}-${snippet.prefix}`;
        this.kind = 27 ;
        this.insertTextRules = 4 ;
        this.command = { id: markSnippetAsUsed, title: '', arguments: [snippet] };
    }
    resolve() {
        this.documentation = ( new MarkdownString()).appendCodeblock('', SnippetParser.asInsertText(this.snippet.codeSnippet));
        return this;
    }
    static compareByLabel(a, b) {
        return compare(a.label.label, b.label.label);
    }
}
let SnippetCompletionProvider = class SnippetCompletionProvider {
    constructor(_languageService, _snippets, _languageConfigurationService) {
        this._languageService = _languageService;
        this._snippets = _snippets;
        this._languageConfigurationService = _languageConfigurationService;
        this._debugDisplayName = 'snippetCompletions';
    }
    async provideCompletionItems(model, position, context) {
        const sw = ( new StopWatch());
        const languageId = this._getLanguageIdAtPosition(model, position);
        const languageConfig = this._languageConfigurationService.getLanguageConfiguration(languageId);
        const snippets = ( new Set(await this._snippets.getSnippets(languageId)));
        const lineContentLow = model.getLineContent(position.lineNumber).toLowerCase();
        const wordUntil = model.getWordUntilPosition(position).word.toLowerCase();
        const suggestions = [];
        const columnOffset = position.column - 1;
        const triggerCharacterLow = context.triggerCharacter?.toLowerCase() ?? '';
        snippet: for (const snippet of snippets) {
            if (context.triggerKind === 1  && !snippet.prefixLow.startsWith(triggerCharacterLow)) {
                continue snippet;
            }
            const word = getWordAtText(1, languageConfig.getWordDefinition(), snippet.prefixLow, 0);
            if (wordUntil && word && !isPatternInWord(wordUntil, 0, wordUntil.length, snippet.prefixLow, 0, snippet.prefixLow.length)) {
                continue snippet;
            }
            const minPos = firstNonWhitespaceIndex(snippet.prefixLow) === 0
                ? Math.max(0, model.getLineFirstNonWhitespaceColumn(position.lineNumber) - 1)
                : 0;
            column: for (let pos = Math.max(minPos, columnOffset - snippet.prefixLow.length); pos < lineContentLow.length; pos++) {
                if (!isPatternInWord(lineContentLow, pos, columnOffset, snippet.prefixLow, 0, snippet.prefixLow.length)) {
                    continue column;
                }
                const prefixRestLen = snippet.prefixLow.length - (columnOffset - pos);
                const endsWithPrefixRest = compareSubstring(lineContentLow, snippet.prefixLow, columnOffset, columnOffset + prefixRestLen, columnOffset - pos);
                const startPosition = position.with(undefined, pos + 1);
                if (wordUntil && position.equals(startPosition)) {
                    continue snippet;
                }
                let endColumn = endsWithPrefixRest === 0 ? position.column + prefixRestLen : position.column;
                if (columnOffset < lineContentLow.length) {
                    const autoClosingPairs = languageConfig.getAutoClosingPairs();
                    const standardAutoClosingPairConditionals = autoClosingPairs.autoClosingPairsCloseSingleChar.get(lineContentLow[columnOffset]);
                    if (standardAutoClosingPairConditionals?.some(p =>
                    p.open === lineContentLow[startPosition.column - 1] &&
                        snippet.prefix.startsWith(p.open) &&
                        snippet.prefix[snippet.prefix.length - 1] === p.close)) {
                        endColumn++;
                    }
                }
                const replace = Range.fromPositions(startPosition, { lineNumber: position.lineNumber, column: endColumn });
                const insert = replace.setEndPosition(position.lineNumber, position.column);
                suggestions.push(( new SnippetCompletion(snippet, { replace, insert })));
                snippets.delete(snippet);
                break;
            }
        }
        if (!triggerCharacterLow) {
            const endsInWhitespace = /\s/.test(lineContentLow[position.column - 2]);
            if (endsInWhitespace || !lineContentLow ) {
                for (const snippet of snippets) {
                    const insert = Range.fromPositions(position);
                    const replace = lineContentLow.indexOf(snippet.prefixLow, columnOffset) === columnOffset ? insert.setEndPosition(position.lineNumber, position.column + snippet.prefixLow.length) : insert;
                    suggestions.push(( new SnippetCompletion(snippet, { replace, insert })));
                }
            }
        }
        suggestions.sort(SnippetCompletion.compareByLabel);
        for (let i = 0; i < suggestions.length; i++) {
            const item = suggestions[i];
            let to = i + 1;
            for (; to < suggestions.length && item.label === suggestions[to].label; to++) {
                suggestions[to].label.label = ( localize(
                    'snippetSuggest.longLabel',
                    "{0}, {1}",
                    suggestions[to].label.label,
                    suggestions[to].snippet.name
                ));
            }
            if (to > i + 1) {
                suggestions[i].label.label = ( localize(
                    'snippetSuggest.longLabel',
                    "{0}, {1}",
                    suggestions[i].label.label,
                    suggestions[i].snippet.name
                ));
                i = to;
            }
        }
        return {
            suggestions,
            duration: sw.elapsed()
        };
    }
    resolveCompletionItem(item) {
        return (item instanceof SnippetCompletion) ? item.resolve() : item;
    }
    _getLanguageIdAtPosition(model, position) {
        model.tokenization.tokenizeIfCheap(position.lineNumber);
        let languageId = model.getLanguageIdAtPosition(position.lineNumber, position.column);
        if (!this._languageService.getLanguageName(languageId)) {
            languageId = model.getLanguageId();
        }
        return languageId;
    }
};
SnippetCompletionProvider = ( __decorate([
    ( __param(0, ILanguageService)),
    ( __param(1, ISnippetsService)),
    ( __param(2, ILanguageConfigurationService))
], SnippetCompletionProvider));
export { SnippetCompletion, SnippetCompletionProvider };
