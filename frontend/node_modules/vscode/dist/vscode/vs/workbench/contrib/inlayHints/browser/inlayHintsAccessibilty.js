import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import * as dom from 'monaco-editor/esm/vs/base/browser/dom.js';
import { CancellationTokenSource } from 'monaco-editor/esm/vs/base/common/cancellation.js';
import { DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { EditorAction2, registerEditorContribution } from 'monaco-editor/esm/vs/editor/browser/editorExtensions.js';
import { EditorContextKeys } from 'monaco-editor/esm/vs/editor/common/editorContextKeys.js';
import { asCommandLink } from 'monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHints.js';
import { InlayHintsController } from 'monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHintsController.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { registerAction2 } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { AudioCue, IAudioCueService } from 'monaco-editor/esm/vs/platform/audioCues/browser/audioCueService.js';
import { RawContextKey, IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { Link } from 'monaco-editor/esm/vs/platform/opener/browser/link.js';
let InlayHintsAccessibility = class InlayHintsAccessibility {
    static { this.IsReading = ( new RawContextKey(
        'isReadingLineWithInlayHints',
        false,
        { type: 'boolean', description: ( localize(
            'isReadingLineWithInlayHints',
            "Whether the current line and its inlay hints are currently focused"
        )) }
    )); }
    static { this.ID = 'editor.contrib.InlayHintsAccessibility'; }
    static get(editor) {
        return editor.getContribution(InlayHintsAccessibility.ID) ?? undefined;
    }
    constructor(_editor, contextKeyService, _audioCueService, _instaService) {
        this._editor = _editor;
        this._audioCueService = _audioCueService;
        this._instaService = _instaService;
        this._sessionDispoosables = ( new DisposableStore());
        this._ariaElement = document.createElement('span');
        this._ariaElement.style.position = 'fixed';
        this._ariaElement.className = 'inlayhint-accessibility-element';
        this._ariaElement.tabIndex = 0;
        this._ariaElement.setAttribute('aria-description', ( localize('description', "Code with Inlay Hint Information")));
        this._ctxIsReading = InlayHintsAccessibility.IsReading.bindTo(contextKeyService);
    }
    dispose() {
        this._sessionDispoosables.dispose();
        this._ctxIsReading.reset();
        this._ariaElement.remove();
    }
    _reset() {
        dom.clearNode(this._ariaElement);
        this._sessionDispoosables.clear();
        this._ctxIsReading.reset();
    }
    async _read(line, hints) {
        this._sessionDispoosables.clear();
        if (!this._ariaElement.isConnected) {
            this._editor.getDomNode()?.appendChild(this._ariaElement);
        }
        if (!this._editor.hasModel() || !this._ariaElement.isConnected) {
            this._ctxIsReading.set(false);
            return;
        }
        const cts = ( new CancellationTokenSource());
        this._sessionDispoosables.add(cts);
        for (const hint of hints) {
            await hint.resolve(cts.token);
        }
        if (cts.token.isCancellationRequested) {
            return;
        }
        const model = this._editor.getModel();
        const newChildren = [];
        let start = 0;
        let tooLongToRead = false;
        for (const item of hints) {
            const part = model.getValueInRange({ startLineNumber: line, startColumn: start + 1, endLineNumber: line, endColumn: item.hint.position.column });
            if (part.length > 0) {
                newChildren.push(part);
                start = item.hint.position.column - 1;
            }
            if (start > 750) {
                newChildren.push('â€¦');
                tooLongToRead = true;
                break;
            }
            const em = document.createElement('em');
            const { label } = item.hint;
            if (typeof label === 'string') {
                em.innerText = label;
            }
            else {
                for (const part of label) {
                    if (part.command) {
                        const link = this._instaService.createInstance(Link, em, { href: asCommandLink(part.command), label: part.label, title: part.command.title }, undefined);
                        this._sessionDispoosables.add(link);
                    }
                    else {
                        em.innerText += part.label;
                    }
                }
            }
            newChildren.push(em);
        }
        if (!tooLongToRead) {
            newChildren.push(model.getValueInRange({ startLineNumber: line, startColumn: start + 1, endLineNumber: line, endColumn: Number.MAX_SAFE_INTEGER }));
        }
        dom.reset(this._ariaElement, ...newChildren);
        this._ariaElement.focus();
        this._ctxIsReading.set(true);
        this._sessionDispoosables.add(dom.addDisposableListener(this._ariaElement, 'focusout', () => {
            this._reset();
        }));
    }
    startInlayHintsReading() {
        if (!this._editor.hasModel()) {
            return;
        }
        const line = this._editor.getPosition().lineNumber;
        const hints = InlayHintsController.get(this._editor)?.getInlayHintsForLine(line);
        if (!hints || hints.length === 0) {
            this._audioCueService.playAudioCue(AudioCue.noInlayHints);
        }
        else {
            this._read(line, hints);
        }
    }
    stopInlayHintsReading() {
        this._reset();
        this._editor.focus();
    }
};
InlayHintsAccessibility = ( __decorate([
    ( __param(1, IContextKeyService)),
    ( __param(2, IAudioCueService)),
    ( __param(3, IInstantiationService))
], InlayHintsAccessibility));
registerAction2(class StartReadHints extends EditorAction2 {
    constructor() {
        super({
            id: 'inlayHints.startReadingLineWithHint',
            title: {
                value: ( localize('read.title', 'Read Line With Inline Hints')),
                original: 'Read Line With Inline Hints'
            },
            precondition: EditorContextKeys.hasInlayHintsProvider,
            f1: true
        });
    }
    runEditorCommand(_accessor, editor) {
        const ctrl = InlayHintsAccessibility.get(editor);
        ctrl?.startInlayHintsReading();
    }
});
registerAction2(class StopReadHints extends EditorAction2 {
    constructor() {
        super({
            id: 'inlayHints.stopReadingLineWithHint',
            title: {
                value: ( localize('stop.title', 'Stop Inlay Hints Reading')),
                original: 'Stop Inlay Hints Reading'
            },
            precondition: InlayHintsAccessibility.IsReading,
            f1: true,
            keybinding: {
                weight: 100 ,
                primary: 9
            }
        });
    }
    runEditorCommand(_accessor, editor) {
        const ctrl = InlayHintsAccessibility.get(editor);
        ctrl?.stopInlayHintsReading();
    }
});
registerEditorContribution(InlayHintsAccessibility.ID, InlayHintsAccessibility, 4 );
export { InlayHintsAccessibility };
