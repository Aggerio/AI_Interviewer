import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import * as dom from 'monaco-editor/esm/vs/base/browser/dom.js';
import { StandardKeyboardEvent } from 'monaco-editor/esm/vs/base/browser/keyboardEvent.js';
import { SimpleIconLabel } from '../../../../base/browser/ui/iconLabel/simpleIconLabel.js';
import { RunOnceScheduler } from 'monaco-editor/esm/vs/base/common/async.js';
import { DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { ILanguageService } from 'monaco-editor/esm/vs/editor/common/languages/language.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { ICommandService } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { IUserDataProfilesService } from 'monaco-editor/esm/vs/platform/userDataProfile/common/userDataProfile.js';
import { IUserDataSyncEnablementService } from '../../../../platform/userDataSync/common/userDataSync.js';
import { POLICY_SETTING_TAG } from '../common/preferences.js';
import { IWorkbenchConfigurationService } from '../../../services/configuration/common/configuration.js';
import { IHoverService } from '../../../services/hover/browser/hover.js';
const $ = dom.$;
let cachedSyncIgnoredSettingsSet = ( new Set());
let cachedSyncIgnoredSettings = [];
let SettingsTreeIndicatorsLabel = class SettingsTreeIndicatorsLabel {
    constructor(container, configurationService, hoverService, userDataSyncEnablementService, languageService, userDataProfilesService, commandService) {
        this.configurationService = configurationService;
        this.hoverService = hoverService;
        this.userDataSyncEnablementService = userDataSyncEnablementService;
        this.languageService = languageService;
        this.userDataProfilesService = userDataProfilesService;
        this.commandService = commandService;
        this.keybindingListeners = ( new DisposableStore());
        this.focusedIndex = 0;
        this.defaultHoverOptions = {
            hoverPosition: 2 ,
            showPointer: true,
            compact: false,
            trapFocus: true
        };
        this.indicatorsContainerElement = dom.append(container, $('.setting-indicators-container'));
        this.indicatorsContainerElement.style.display = 'inline';
        this.profilesEnabled = this.userDataProfilesService.isEnabled();
        this.workspaceTrustIndicator = this.createWorkspaceTrustIndicator();
        this.scopeOverridesIndicator = this.createScopeOverridesIndicator();
        this.syncIgnoredIndicator = this.createSyncIgnoredIndicator();
        this.defaultOverrideIndicator = this.createDefaultOverrideIndicator();
        this.allIndicators = [this.workspaceTrustIndicator, this.scopeOverridesIndicator, this.syncIgnoredIndicator, this.defaultOverrideIndicator];
    }
    addHoverDisposables(disposables, element, showHover) {
        disposables.clear();
        const scheduler = disposables.add(( new RunOnceScheduler(() => {
            const hover = showHover(false);
            if (hover) {
                disposables.add(hover);
            }
        }, this.configurationService.getValue('workbench.hover.delay'))));
        disposables.add(dom.addDisposableListener(element, dom.EventType.MOUSE_OVER, () => {
            if (!scheduler.isScheduled()) {
                scheduler.schedule();
            }
        }));
        disposables.add(dom.addDisposableListener(element, dom.EventType.MOUSE_LEAVE, () => {
            scheduler.cancel();
        }));
        disposables.add(dom.addDisposableListener(element, dom.EventType.KEY_DOWN, (e) => {
            const evt = ( new StandardKeyboardEvent(e));
            if (evt.equals(10 ) || evt.equals(3 )) {
                const hover = showHover(true);
                if (hover) {
                    disposables.add(hover);
                }
                e.preventDefault();
            }
        }));
    }
    createWorkspaceTrustIndicator() {
        const workspaceTrustElement = $('span.setting-indicator.setting-item-workspace-trust');
        const workspaceTrustLabel = ( new SimpleIconLabel(workspaceTrustElement));
        workspaceTrustLabel.text = '$(warning) ' + ( localize('workspaceUntrustedLabel', "Setting value not applied"));
        const content = ( localize(
            'trustLabel',
            "The setting value can only be applied in a trusted workspace."
        ));
        const disposables = ( new DisposableStore());
        const showHover = (focus) => {
            return this.hoverService.showHover({
                ...this.defaultHoverOptions,
                content,
                target: workspaceTrustElement,
                actions: [{
                        label: ( localize('manageWorkspaceTrust', "Manage Workspace Trust")),
                        commandId: 'workbench.trust.manage',
                        run: (target) => {
                            this.commandService.executeCommand('workbench.trust.manage');
                        }
                    }],
            }, focus);
        };
        this.addHoverDisposables(disposables, workspaceTrustElement, showHover);
        return {
            element: workspaceTrustElement,
            label: workspaceTrustLabel,
            disposables
        };
    }
    createScopeOverridesIndicator() {
        const otherOverridesElement = $('span.setting-item-overrides');
        const otherOverridesLabel = ( new SimpleIconLabel(otherOverridesElement));
        return {
            element: otherOverridesElement,
            label: otherOverridesLabel,
            disposables: ( new DisposableStore())
        };
    }
    createSyncIgnoredIndicator() {
        const syncIgnoredElement = $('span.setting-indicator.setting-item-ignored');
        const syncIgnoredLabel = ( new SimpleIconLabel(syncIgnoredElement));
        syncIgnoredLabel.text = ( localize('extensionSyncIgnoredLabel', 'Not synced'));
        const syncIgnoredHoverContent = ( localize('syncIgnoredTitle', "This setting is ignored during sync"));
        const disposables = ( new DisposableStore());
        const showHover = (focus) => {
            return this.hoverService.showHover({
                ...this.defaultHoverOptions,
                content: syncIgnoredHoverContent,
                target: syncIgnoredElement
            }, focus);
        };
        this.addHoverDisposables(disposables, syncIgnoredElement, showHover);
        return {
            element: syncIgnoredElement,
            label: syncIgnoredLabel,
            disposables: ( new DisposableStore())
        };
    }
    createDefaultOverrideIndicator() {
        const defaultOverrideIndicator = $('span.setting-indicator.setting-item-default-overridden');
        const defaultOverrideLabel = ( new SimpleIconLabel(defaultOverrideIndicator));
        defaultOverrideLabel.text = ( localize('defaultOverriddenLabel', "Default value changed"));
        return {
            element: defaultOverrideIndicator,
            label: defaultOverrideLabel,
            disposables: ( new DisposableStore())
        };
    }
    render() {
        const indicatorsToShow = this.allIndicators.filter(indicator => {
            return indicator.element.style.display !== 'none';
        });
        this.indicatorsContainerElement.innerText = '';
        this.indicatorsContainerElement.style.display = 'none';
        if (indicatorsToShow.length) {
            this.indicatorsContainerElement.style.display = 'inline';
            dom.append(this.indicatorsContainerElement, $('span', undefined, '('));
            for (let i = 0; i < indicatorsToShow.length - 1; i++) {
                dom.append(this.indicatorsContainerElement, indicatorsToShow[i].element);
                dom.append(this.indicatorsContainerElement, $('span.comma', undefined, ' â€¢ '));
            }
            dom.append(this.indicatorsContainerElement, indicatorsToShow[indicatorsToShow.length - 1].element);
            dom.append(this.indicatorsContainerElement, $('span', undefined, ')'));
            this.resetIndicatorNavigationKeyBindings(indicatorsToShow);
        }
    }
    resetIndicatorNavigationKeyBindings(indicators) {
        this.keybindingListeners.clear();
        this.indicatorsContainerElement.role = indicators.length >= 1 ? 'toolbar' : 'button';
        if (!indicators.length) {
            return;
        }
        const firstElement = indicators[0].focusElement ?? indicators[0].element;
        firstElement.tabIndex = 0;
        this.keybindingListeners.add(dom.addDisposableListener(this.indicatorsContainerElement, 'keydown', (e) => {
            const ev = ( new StandardKeyboardEvent(e));
            let handled = true;
            if (ev.equals(14 )) {
                this.focusIndicatorAt(indicators, 0);
            }
            else if (ev.equals(13 )) {
                this.focusIndicatorAt(indicators, indicators.length - 1);
            }
            else if (ev.equals(17 )) {
                const indexToFocus = (this.focusedIndex + 1) % indicators.length;
                this.focusIndicatorAt(indicators, indexToFocus);
            }
            else if (ev.equals(15 )) {
                const indexToFocus = this.focusedIndex ? this.focusedIndex - 1 : indicators.length - 1;
                this.focusIndicatorAt(indicators, indexToFocus);
            }
            else {
                handled = false;
            }
            if (handled) {
                e.preventDefault();
                e.stopPropagation();
            }
        }));
    }
    focusIndicatorAt(indicators, index) {
        if (index === this.focusedIndex) {
            return;
        }
        const indicator = indicators[index];
        const elementToFocus = indicator.focusElement ?? indicator.element;
        elementToFocus.tabIndex = 0;
        elementToFocus.focus();
        const currentlyFocusedIndicator = indicators[this.focusedIndex];
        const previousFocusedElement = currentlyFocusedIndicator.focusElement ?? currentlyFocusedIndicator.element;
        previousFocusedElement.tabIndex = -1;
        this.focusedIndex = index;
    }
    updateWorkspaceTrust(element) {
        this.workspaceTrustIndicator.element.style.display = element.isUntrusted ? 'inline' : 'none';
        this.render();
    }
    updateSyncIgnored(element, ignoredSettings) {
        this.syncIgnoredIndicator.element.style.display = this.userDataSyncEnablementService.isEnabled()
            && ignoredSettings.includes(element.setting.key) ? 'inline' : 'none';
        this.render();
        if (cachedSyncIgnoredSettings !== ignoredSettings) {
            cachedSyncIgnoredSettings = ignoredSettings;
            cachedSyncIgnoredSettingsSet = ( new Set(cachedSyncIgnoredSettings));
        }
    }
    getInlineScopeDisplayText(completeScope) {
        const [scope, language] = completeScope.split(':');
        const localizedScope = scope === 'user' ?
            ( localize('user', "User")) : scope === 'workspace' ?
            ( localize('workspace', "Workspace")) : ( localize('remote', "Remote"));
        if (language) {
            return `${this.languageService.getLanguageName(language)} > ${localizedScope}`;
        }
        return localizedScope;
    }
    dispose() {
        this.keybindingListeners.dispose();
        for (const indicator of this.allIndicators) {
            indicator.disposables.dispose();
        }
    }
    updateScopeOverrides(element, onDidClickOverrideElement, onApplyFilter) {
        this.scopeOverridesIndicator.element.innerText = '';
        this.scopeOverridesIndicator.element.style.display = 'none';
        this.scopeOverridesIndicator.focusElement = this.scopeOverridesIndicator.element;
        if (element.hasPolicyValue) {
            this.scopeOverridesIndicator.element.style.display = 'inline';
            this.scopeOverridesIndicator.element.classList.add('setting-indicator');
            this.scopeOverridesIndicator.label.text = '$(warning) ' + ( localize('policyLabelText', "Setting value not applied"));
            const content = ( localize(
                'policyDescription',
                "This setting is managed by your organization and its applied value cannot be changed."
            ));
            const showHover = (focus) => {
                return this.hoverService.showHover({
                    ...this.defaultHoverOptions,
                    content,
                    actions: [{
                            label: ( localize('policyFilterLink', "View policy settings")),
                            commandId: '_settings.action.viewPolicySettings',
                            run: (_) => {
                                onApplyFilter.fire(`@${POLICY_SETTING_TAG}`);
                            }
                        }],
                    target: this.scopeOverridesIndicator.element
                }, focus);
            };
            this.addHoverDisposables(this.scopeOverridesIndicator.disposables, this.scopeOverridesIndicator.element, showHover);
        }
        else if (this.profilesEnabled && element.settingsTarget === 3  && this.configurationService.isSettingAppliedForAllProfiles(element.setting.key)) {
            this.scopeOverridesIndicator.element.style.display = 'inline';
            this.scopeOverridesIndicator.element.classList.add('setting-indicator');
            this.scopeOverridesIndicator.label.text = ( localize('applicationSetting', "Applies to all profiles"));
            const content = ( localize(
                'applicationSettingDescription',
                "The setting is not specific to the current profile, and will retain its value when switching profiles."
            ));
            const showHover = (focus) => {
                return this.hoverService.showHover({
                    ...this.defaultHoverOptions,
                    content,
                    target: this.scopeOverridesIndicator.element
                }, focus);
            };
            this.addHoverDisposables(this.scopeOverridesIndicator.disposables, this.scopeOverridesIndicator.element, showHover);
        }
        else if (element.overriddenScopeList.length || element.overriddenDefaultsLanguageList.length) {
            if (element.overriddenScopeList.length === 1 && !element.overriddenDefaultsLanguageList.length) {
                this.scopeOverridesIndicator.element.style.display = 'inline';
                this.scopeOverridesIndicator.element.classList.remove('setting-indicator');
                this.scopeOverridesIndicator.disposables.clear();
                const prefaceText = element.isConfigured ?
                    ( localize('alsoConfiguredIn', "Also modified in")) :
                    ( localize('configuredIn', "Modified in"));
                this.scopeOverridesIndicator.label.text = `${prefaceText} `;
                const overriddenScope = element.overriddenScopeList[0];
                const view = dom.append(this.scopeOverridesIndicator.element, $('a.modified-scope', undefined, this.getInlineScopeDisplayText(overriddenScope)));
                view.tabIndex = -1;
                this.scopeOverridesIndicator.focusElement = view;
                const onClickOrKeydown = (e) => {
                    const [scope, language] = overriddenScope.split(':');
                    onDidClickOverrideElement.fire({
                        settingKey: element.setting.key,
                        scope: scope,
                        language
                    });
                    e.preventDefault();
                    e.stopPropagation();
                };
                this.scopeOverridesIndicator.disposables.add(dom.addDisposableListener(view, dom.EventType.CLICK, (e) => {
                    onClickOrKeydown(e);
                }));
                this.scopeOverridesIndicator.disposables.add(dom.addDisposableListener(view, dom.EventType.KEY_DOWN, (e) => {
                    const ev = ( new StandardKeyboardEvent(e));
                    if (ev.equals(10 ) || ev.equals(3 )) {
                        onClickOrKeydown(e);
                    }
                }));
            }
            else {
                this.scopeOverridesIndicator.element.style.display = 'inline';
                this.scopeOverridesIndicator.element.classList.add('setting-indicator');
                const scopeOverridesLabelText = element.isConfigured ?
                    ( localize('alsoConfiguredElsewhere', "Also modified elsewhere")) :
                    ( localize('configuredElsewhere', "Modified elsewhere"));
                this.scopeOverridesIndicator.label.text = scopeOverridesLabelText;
                let contentMarkdownString = '';
                if (element.overriddenScopeList.length) {
                    const prefaceText = element.isConfigured ?
                        ( localize(
                            'alsoModifiedInScopes',
                            "The setting has also been modified in the following scopes:"
                        )) :
                        ( localize(
                            'modifiedInScopes',
                            "The setting has been modified in the following scopes:"
                        ));
                    contentMarkdownString = prefaceText;
                    for (const scope of element.overriddenScopeList) {
                        const scopeDisplayText = this.getInlineScopeDisplayText(scope);
                        contentMarkdownString += `\n- [${scopeDisplayText}](${encodeURIComponent(scope)} "${getAccessibleScopeDisplayText(scope, this.languageService)}")`;
                    }
                }
                if (element.overriddenDefaultsLanguageList.length) {
                    if (contentMarkdownString) {
                        contentMarkdownString += `\n\n`;
                    }
                    const prefaceText = ( localize(
                        'hasDefaultOverridesForLanguages',
                        "The following languages have default overrides:"
                    ));
                    contentMarkdownString += prefaceText;
                    for (const language of element.overriddenDefaultsLanguageList) {
                        const scopeDisplayText = this.languageService.getLanguageName(language);
                        contentMarkdownString += `\n- [${scopeDisplayText}](${encodeURIComponent(`default:${language}`)} "${scopeDisplayText}")`;
                    }
                }
                const content = {
                    value: contentMarkdownString,
                    isTrusted: false,
                    supportHtml: false
                };
                const showHover = (focus) => {
                    return this.hoverService.showHover({
                        ...this.defaultHoverOptions,
                        content,
                        linkHandler: (url) => {
                            const [scope, language] = decodeURIComponent(url).split(':');
                            onDidClickOverrideElement.fire({
                                settingKey: element.setting.key,
                                scope: scope,
                                language
                            });
                        },
                        target: this.scopeOverridesIndicator.element
                    }, focus);
                };
                this.addHoverDisposables(this.scopeOverridesIndicator.disposables, this.scopeOverridesIndicator.element, showHover);
            }
        }
        this.render();
    }
    updateDefaultOverrideIndicator(element) {
        this.defaultOverrideIndicator.element.style.display = 'none';
        const sourceToDisplay = getDefaultValueSourceToDisplay(element);
        if (sourceToDisplay !== undefined) {
            this.defaultOverrideIndicator.element.style.display = 'inline';
            this.defaultOverrideIndicator.disposables.clear();
            const defaultOverrideHoverContent = ( localize(
                'defaultOverriddenDetails',
                "Default setting value overridden by {0}",
                sourceToDisplay
            ));
            const showHover = (focus) => {
                return this.hoverService.showHover({
                    content: defaultOverrideHoverContent,
                    target: this.defaultOverrideIndicator.element,
                    hoverPosition: 2 ,
                    showPointer: true,
                    compact: false
                }, focus);
            };
            this.addHoverDisposables(this.defaultOverrideIndicator.disposables, this.defaultOverrideIndicator.element, showHover);
        }
        this.render();
    }
};
SettingsTreeIndicatorsLabel = ( __decorate([
    ( __param(1, IWorkbenchConfigurationService)),
    ( __param(2, IHoverService)),
    ( __param(3, IUserDataSyncEnablementService)),
    ( __param(4, ILanguageService)),
    ( __param(5, IUserDataProfilesService)),
    ( __param(6, ICommandService))
], SettingsTreeIndicatorsLabel));
function getDefaultValueSourceToDisplay(element) {
    let sourceToDisplay;
    const defaultValueSource = element.defaultValueSource;
    if (defaultValueSource) {
        if (typeof defaultValueSource !== 'string') {
            sourceToDisplay = defaultValueSource.displayName ?? defaultValueSource.id;
        }
        else if (typeof defaultValueSource === 'string') {
            sourceToDisplay = defaultValueSource;
        }
    }
    return sourceToDisplay;
}
function getAccessibleScopeDisplayText(completeScope, languageService) {
    const [scope, language] = completeScope.split(':');
    const localizedScope = scope === 'user' ?
        ( localize('user', "User")) : scope === 'workspace' ?
        ( localize('workspace', "Workspace")) : ( localize('remote', "Remote"));
    if (language) {
        return ( localize(
            'modifiedInScopeForLanguage',
            "The {0} scope for {1}",
            localizedScope,
            languageService.getLanguageName(language)
        ));
    }
    return localizedScope;
}
function getAccessibleScopeDisplayMidSentenceText(completeScope, languageService) {
    const [scope, language] = completeScope.split(':');
    const localizedScope = scope === 'user' ?
        ( localize('user', "User")) : scope === 'workspace' ?
        ( localize('workspace', "Workspace")) : ( localize('remote', "Remote"));
    if (language) {
        return ( localize(
            'modifiedInScopeForLanguageMidSentence',
            "the {0} scope for {1}",
            localizedScope.toLowerCase(),
            languageService.getLanguageName(language)
        ));
    }
    return localizedScope;
}
function getIndicatorsLabelAriaLabel(element, configurationService, userDataProfilesService, languageService) {
    const ariaLabelSections = [];
    if (element.isUntrusted) {
        ariaLabelSections.push(( localize(
            'workspaceUntrustedAriaLabel',
            "Workspace untrusted; setting value not applied"
        )));
    }
    if (element.hasPolicyValue) {
        ariaLabelSections.push(( localize(
            'policyDescriptionAccessible',
            "Managed by organization policy; setting value not applied"
        )));
    }
    else if (userDataProfilesService.isEnabled() && element.settingsTarget === 3  && configurationService.isSettingAppliedForAllProfiles(element.setting.key)) {
        ariaLabelSections.push(( localize(
            'applicationSettingDescriptionAccessible',
            "Setting value retained when switching profiles"
        )));
    }
    else {
        const otherOverridesStart = element.isConfigured ?
            ( localize('alsoConfiguredIn', "Also modified in")) :
            ( localize('configuredIn', "Modified in"));
        const otherOverridesList = ( element.overriddenScopeList
            .map(scope => getAccessibleScopeDisplayMidSentenceText(scope, languageService))).join(', ');
        if (element.overriddenScopeList.length) {
            ariaLabelSections.push(`${otherOverridesStart} ${otherOverridesList}`);
        }
    }
    if (( cachedSyncIgnoredSettingsSet.has(element.setting.key))) {
        ariaLabelSections.push(( localize('syncIgnoredAriaLabel', "Setting ignored during sync")));
    }
    const sourceToDisplay = getDefaultValueSourceToDisplay(element);
    if (sourceToDisplay !== undefined) {
        ariaLabelSections.push(( localize(
            'defaultOverriddenDetailsAriaLabel',
            "{0} overrides the default value",
            sourceToDisplay
        )));
    }
    const otherLanguageOverridesList = ( element.overriddenDefaultsLanguageList
        .map(language => languageService.getLanguageName(language))).join(', ');
    if (element.overriddenDefaultsLanguageList.length) {
        const otherLanguageOverridesText = ( localize(
            'defaultOverriddenLanguagesList',
            "Language-specific default values exist for {0}",
            otherLanguageOverridesList
        ));
        ariaLabelSections.push(otherLanguageOverridesText);
    }
    const ariaLabel = ariaLabelSections.join('. ');
    return ariaLabel;
}
export { SettingsTreeIndicatorsLabel, getIndicatorsLabelAriaLabel };
