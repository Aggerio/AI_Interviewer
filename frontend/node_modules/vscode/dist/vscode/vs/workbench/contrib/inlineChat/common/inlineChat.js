import { localize } from 'monaco-editor/esm/vs/nls.js';
import { MenuId } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { Extensions as Extensions$1 } from 'monaco-editor/esm/vs/platform/configuration/common/configurationRegistry.js';
import { createDecorator } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { registerColor, editorWidgetBackground, editorWidgetBorder, widgetShadow, editorHoverHighlight, focusBorder, inputPlaceholderForeground, inputBackground, transparent, diffInserted, diffRemoved } from 'monaco-editor/esm/vs/platform/theme/common/colorRegistry.js';
import { Extensions } from '../../../common/configuration.js';
const IInlineChatService = ( createDecorator('IInlineChatService'));
MenuId.for('inlineChatWidget');
MenuId.for('inlineChatWidget.markdownMessage');
MenuId.for('inlineChatWidget.status');
MenuId.for('inlineChatWidget.feedback');
MenuId.for('inlineChatWidget.undo');
MenuId.for('inlineChatWidget.toggle');
registerColor('inlineChat.background', { dark: editorWidgetBackground, light: editorWidgetBackground, hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, ( localize(
    'inlineChat.background',
    "Background color of the interactive editor widget"
)));
registerColor('inlineChat.border', { dark: editorWidgetBorder, light: editorWidgetBorder, hcDark: editorWidgetBorder, hcLight: editorWidgetBorder }, ( localize('inlineChat.border', "Border color of the interactive editor widget")));
registerColor('inlineChat.shadow', { dark: widgetShadow, light: widgetShadow, hcDark: widgetShadow, hcLight: widgetShadow }, ( localize('inlineChat.shadow', "Shadow color of the interactive editor widget")));
registerColor('inlineChat.regionHighlight', { dark: editorHoverHighlight, light: editorHoverHighlight, hcDark: editorHoverHighlight, hcLight: editorHoverHighlight }, ( localize(
    'inlineChat.regionHighlight',
    "Background highlighting of the current interactive region. Must be transparent."
)), true);
registerColor('inlineChatInput.border', { dark: editorWidgetBorder, light: editorWidgetBorder, hcDark: editorWidgetBorder, hcLight: editorWidgetBorder }, ( localize('inlineChatInput.border', "Border color of the interactive editor input")));
registerColor('inlineChatInput.focusBorder', { dark: focusBorder, light: focusBorder, hcDark: focusBorder, hcLight: focusBorder }, ( localize(
    'inlineChatInput.focusBorder',
    "Border color of the interactive editor input when focused"
)));
registerColor('inlineChatInput.placeholderForeground', { dark: inputPlaceholderForeground, light: inputPlaceholderForeground, hcDark: inputPlaceholderForeground, hcLight: inputPlaceholderForeground }, ( localize(
    'inlineChatInput.placeholderForeground',
    "Foreground color of the interactive editor input placeholder"
)));
registerColor('inlineChatInput.background', { dark: inputBackground, light: inputBackground, hcDark: inputBackground, hcLight: inputBackground }, ( localize(
    'inlineChatInput.background',
    "Background color of the interactive editor input"
)));
registerColor('inlineChatDiff.inserted', { dark: ( transparent(diffInserted, .5)), light: ( transparent(diffInserted, .5)), hcDark: ( transparent(diffInserted, .5)), hcLight: ( transparent(diffInserted, .5)) }, ( localize(
    'inlineChatDiff.inserted',
    "Background color of inserted text in the interactive editor input"
)));
registerColor('inlineChatDiff.removed', { dark: ( transparent(diffRemoved, .5)), light: ( transparent(diffRemoved, .5)), hcDark: ( transparent(diffRemoved, .5)), hcLight: ( transparent(diffRemoved, .5)) }, ( localize(
    'inlineChatDiff.removed',
    "Background color of removed text in the interactive editor input"
)));
( Registry.as(Extensions.ConfigurationMigration)).registerConfigurationMigrations([{
        key: 'interactiveEditor.editMode', migrateFn: (value) => {
            return [['inlineChat.mode', { value: value }]];
        }
    }]);
( Registry.as(Extensions$1.Configuration)).registerConfiguration({
    id: 'editor',
    properties: {
        'inlineChat.mode': {
            description: ( localize(
                'mode',
                "Configure if changes crafted in the interactive editor are applied directly to the document or are previewed first."
            )),
            default: "livePreview" ,
            type: 'string',
            enum: ["livePreview" , "preview" , "live" ],
            markdownEnumDescriptions: [
                ( localize(
                    'mode.livePreview',
                    "Changes are applied directly to the document and are highlighted visually via inline or side-by-side diffs. Ending a session will keep the changes."
                )),
                ( localize(
                    'mode.preview',
                    "Changes are previewed only and need to be accepted via the apply button. Ending a session will discard the changes."
                )),
                ( localize(
                    'mode.live',
                    "Changes are applied directly to the document but can be highlighted via inline diffs. Ending a session will keep the changes."
                )),
            ]
        },
        'inlineChat.showDiff': {
            description: ( localize(
                'showDiff',
                "Enable/disable showing the diff when edits are generated. Works only with inlineChat.mode equal to live or livePreview."
            )),
            default: true,
            type: 'boolean'
        }
    }
});
export { IInlineChatService };
