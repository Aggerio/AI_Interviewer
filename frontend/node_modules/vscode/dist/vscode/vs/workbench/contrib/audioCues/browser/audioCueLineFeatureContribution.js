import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import { IDebugService } from '../../debug/common/debug.js';
import { Disposable, DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { IEditorService } from '../../../services/editor/common/editorService.js';
import { Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { isDiffEditor, isCodeEditor } from 'monaco-editor/esm/vs/editor/browser/editorBrowser.js';
import { MarkerSeverity, IMarkerService } from 'monaco-editor/esm/vs/platform/markers/common/markers.js';
import { FoldingController } from 'monaco-editor/esm/vs/editor/contrib/folding/browser/folding.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { observableFromEvent, derived, autorun, debouncedObservable, wasEventTriggeredRecently, autorunDelta, constObservable, observableFromPromise } from 'monaco-editor/esm/vs/base/common/observable.js';
import { AudioCue, IAudioCueService } from 'monaco-editor/esm/vs/platform/audioCues/browser/audioCueService.js';
import { CachedFunction } from 'monaco-editor/esm/vs/base/common/cache.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
let AudioCueLineFeatureContribution = class AudioCueLineFeatureContribution extends Disposable {
    constructor(editorService, instantiationService, audioCueService, _configurationService) {
        super();
        this.editorService = editorService;
        this.instantiationService = instantiationService;
        this.audioCueService = audioCueService;
        this._configurationService = _configurationService;
        this.store = this._register(( new DisposableStore()));
        this.features = [
            this.instantiationService.createInstance(MarkerLineFeature, AudioCue.error, MarkerSeverity.Error),
            this.instantiationService.createInstance(MarkerLineFeature, AudioCue.warning, MarkerSeverity.Warning),
            this.instantiationService.createInstance(FoldedAreaLineFeature),
            this.instantiationService.createInstance(BreakpointLineFeature),
        ];
        this.isEnabledCache = ( new CachedFunction(
            (cue) => observableFromEvent(this.audioCueService.onEnabledChanged(cue), () => this.audioCueService.isEnabled(cue))
        ));
        const someAudioCueFeatureIsEnabled = derived('someAudioCueFeatureIsEnabled', (reader) => ( this.features.some((feature) => this.isEnabledCache.get(feature.audioCue).read(reader))));
        const activeEditorObservable = observableFromEvent(this.editorService.onDidActiveEditorChange, (_) => {
            const activeTextEditorControl = this.editorService.activeTextEditorControl;
            const editor = isDiffEditor(activeTextEditorControl)
                ? activeTextEditorControl.getOriginalEditor()
                : isCodeEditor(activeTextEditorControl)
                    ? activeTextEditorControl
                    : undefined;
            return editor && editor.hasModel() ? { editor, model: editor.getModel() } : undefined;
        });
        this._register(autorun('updateAudioCuesEnabled', (reader) => {
            this.store.clear();
            if (!someAudioCueFeatureIsEnabled.read(reader)) {
                return;
            }
            const activeEditor = activeEditorObservable.read(reader);
            if (activeEditor) {
                this.registerAudioCuesForEditor(activeEditor.editor, activeEditor.model, this.store);
            }
        }));
    }
    registerAudioCuesForEditor(editor, editorModel, store) {
        const curPosition = observableFromEvent(editor.onDidChangeCursorPosition, (args) => {
            if (args &&
                args.reason !== 3  &&
                args.reason !== 0 ) {
                return undefined;
            }
            return editor.getPosition();
        });
        const debouncedPosition = debouncedObservable(curPosition, this._configurationService.getValue('audioCues.debouncePositionChanges') ? 300 : 0, store);
        const isTyping = wasEventTriggeredRecently(editorModel.onDidChangeContent.bind(editorModel), 1000, store);
        const featureStates = ( this.features.map((feature) => {
            const lineFeatureState = feature.getObservableState(editor, editorModel);
            const isFeaturePresent = derived(`isPresentInLine:${feature.audioCue.name}`, (reader) => {
                if (!this.isEnabledCache.get(feature.audioCue).read(reader)) {
                    return false;
                }
                const position = debouncedPosition.read(reader);
                if (!position) {
                    return false;
                }
                return lineFeatureState.read(reader).isPresent(position);
            });
            return derived(`typingDebouncedFeatureState:\n${feature.audioCue.name}`, (reader) => feature.debounceWhileTyping && isTyping.read(reader)
                ? (debouncedPosition.read(reader), isFeaturePresent.get())
                : isFeaturePresent.read(reader));
        }));
        const state = derived('states', (reader) => ({
            lineNumber: debouncedPosition.read(reader),
            featureStates: ( new Map(( this.features.map((feature, idx) => [
                feature,
                featureStates[idx].read(reader),
            ])))),
        }));
        store.add(autorunDelta('Play Audio Cue', state, ({ lastValue, newValue }) => {
            const newFeatures = this.features.filter(feature => newValue?.featureStates.get(feature) &&
                (!lastValue?.featureStates?.get(feature) || newValue.lineNumber !== lastValue.lineNumber));
            this.audioCueService.playAudioCues(( newFeatures.map(f => f.audioCue)));
        }));
    }
};
AudioCueLineFeatureContribution = ( __decorate([
    ( __param(0, IEditorService)),
    ( __param(1, IInstantiationService)),
    ( __param(2, IAudioCueService)),
    ( __param(3, IConfigurationService))
], AudioCueLineFeatureContribution));
let MarkerLineFeature = class MarkerLineFeature {
    constructor(audioCue, severity, markerService) {
        this.audioCue = audioCue;
        this.severity = severity;
        this.markerService = markerService;
        this.debounceWhileTyping = true;
        this._previousLine = 0;
    }
    getObservableState(editor, model) {
        return observableFromEvent(Event.filter(this.markerService.onMarkerChanged, (changedUris) => ( changedUris.some((u) => ( u.toString()) === ( model.uri.toString())))), () =>  ({
            isPresent: (position) => {
                const lineChanged = position.lineNumber !== this._previousLine;
                this._previousLine = position.lineNumber;
                const hasMarker = ( this.markerService
                    .read({ resource: model.uri })
                    .some((m) => {
                    const onLine = m.severity === this.severity && m.startLineNumber <= position.lineNumber && position.lineNumber <= m.endLineNumber;
                    return lineChanged ? onLine : onLine && (position.lineNumber <= m.endLineNumber && m.startColumn <= position.column && m.endColumn >= position.column);
                }));
                return hasMarker;
            },
        }));
    }
};
MarkerLineFeature = ( __decorate([
    ( __param(2, IMarkerService))
], MarkerLineFeature));
class FoldedAreaLineFeature {
    constructor() {
        this.audioCue = AudioCue.foldedArea;
    }
    getObservableState(editor, model) {
        const foldingController = FoldingController.get(editor);
        if (!foldingController) {
            return constObservable({
                isPresent: () => false,
            });
        }
        const foldingModel = observableFromPromise(foldingController.getFoldingModel() ?? Promise.resolve(undefined));
        return ( foldingModel.map((v) => ({
            isPresent: (position) => {
                const regionAtLine = v.value?.getRegionAtLine(position.lineNumber);
                const hasFolding = !regionAtLine
                    ? false
                    : regionAtLine.isCollapsed &&
                        regionAtLine.startLineNumber === position.lineNumber;
                return hasFolding;
            },
        })));
    }
}
let BreakpointLineFeature = class BreakpointLineFeature {
    constructor(debugService) {
        this.debugService = debugService;
        this.audioCue = AudioCue.break;
    }
    getObservableState(editor, model) {
        return observableFromEvent(this.debugService.getModel().onDidChangeBreakpoints, () =>  ({
            isPresent: (position) => {
                const breakpoints = this.debugService
                    .getModel()
                    .getBreakpoints({ uri: model.uri, lineNumber: position.lineNumber });
                const hasBreakpoints = breakpoints.length > 0;
                return hasBreakpoints;
            },
        }));
    }
};
BreakpointLineFeature = ( __decorate([
    ( __param(0, IDebugService))
], BreakpointLineFeature));
export { AudioCueLineFeatureContribution };
