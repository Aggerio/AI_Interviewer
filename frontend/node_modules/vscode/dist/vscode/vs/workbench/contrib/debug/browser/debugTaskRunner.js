import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import * as nls from 'monaco-editor/esm/vs/nls.js';
import Severity from 'monaco-editor/esm/vs/base/common/severity.js';
import { Markers } from '../../markers/common/markers.js';
import { ITaskService } from '../../tasks/common/taskService.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import '../../../../../../override/vs/platform/dialogs/common/dialogs.js';
import { withUndefinedAsNull } from 'monaco-editor/esm/vs/base/common/types.js';
import { MarkerSeverity, IMarkerService } from 'monaco-editor/esm/vs/platform/markers/common/markers.js';
import { IViewsService } from '../../../common/views.js';
import { IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
import { createErrorWithActions } from 'monaco-editor/esm/vs/base/common/errorMessage.js';
import { Action } from 'monaco-editor/esm/vs/base/common/actions.js';
import { DEBUG_CONFIGURE_COMMAND_ID, DEBUG_CONFIGURE_LABEL } from './debugCommands.js';
import { ICommandService } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { IDialogService } from '../../../../platform/dialogs/common/dialogs.js';
function once(match, event) {
    return (listener, thisArgs = null, disposables) => {
        const result = event(e => {
            if (match(e)) {
                result.dispose();
                return listener.call(thisArgs, e);
            }
        }, null, disposables);
        return result;
    };
}
const DEBUG_TASK_ERROR_CHOICE_KEY = 'debug.taskerrorchoice';
let DebugTaskRunner = class DebugTaskRunner {
    constructor(taskService, markerService, configurationService, viewsService, dialogService, storageService, commandService) {
        this.taskService = taskService;
        this.markerService = markerService;
        this.configurationService = configurationService;
        this.viewsService = viewsService;
        this.dialogService = dialogService;
        this.storageService = storageService;
        this.commandService = commandService;
        this.canceled = false;
    }
    cancel() {
        this.canceled = true;
    }
    async runTaskAndCheckErrors(root, taskId) {
        try {
            this.canceled = false;
            const taskSummary = await this.runTask(root, taskId);
            if (this.canceled || (taskSummary && taskSummary.exitCode === undefined)) {
                return 0 ;
            }
            const errorCount = taskId ? this.markerService.read({ severities: MarkerSeverity.Error, take: 2 }).length : 0;
            const successExitCode = taskSummary && taskSummary.exitCode === 0;
            const failureExitCode = taskSummary && taskSummary.exitCode !== 0;
            const onTaskErrors = this.configurationService.getValue('debug').onTaskErrors;
            if (successExitCode || onTaskErrors === 'debugAnyway' || (errorCount === 0 && !failureExitCode)) {
                return 1 ;
            }
            if (onTaskErrors === 'showErrors') {
                await this.viewsService.openView(Markers.MARKERS_VIEW_ID, true);
                return Promise.resolve(0 );
            }
            if (onTaskErrors === 'abort') {
                return Promise.resolve(0 );
            }
            const taskLabel = typeof taskId === 'string' ? taskId : taskId ? taskId.name : '';
            const message = errorCount > 1
                ? ( nls.localize(
                'preLaunchTaskErrors',
                "Errors exist after running preLaunchTask '{0}'.",
                taskLabel
            ))
                : errorCount === 1
                    ? ( nls.localize(
                'preLaunchTaskError',
                "Error exists after running preLaunchTask '{0}'.",
                taskLabel
            ))
                    : taskSummary && typeof taskSummary.exitCode === 'number'
                        ? ( nls.localize(
                'preLaunchTaskExitCode',
                "The preLaunchTask '{0}' terminated with exit code {1}.",
                taskLabel,
                taskSummary.exitCode
            ))
                        : ( nls.localize(
                'preLaunchTaskTerminated',
                "The preLaunchTask '{0}' terminated.",
                taskLabel
            ));
            let DebugChoice;
            ( (function(DebugChoice) {
                DebugChoice[DebugChoice["DebugAnyway"] = 1] = "DebugAnyway";
                DebugChoice[DebugChoice["ShowErrors"] = 2] = "ShowErrors";
                DebugChoice[DebugChoice["Cancel"] = 0] = "Cancel";
            })(DebugChoice || (DebugChoice = {})));
            const { result, checkboxChecked } = await this.dialogService.prompt({
                type: Severity.Warning,
                message,
                buttons: [
                    {
                        label: ( nls.localize(
                            { key: 'debugAnyway', comment: ['&& denotes a mnemonic'] },
                            "&&Debug Anyway"
                        )),
                        run: () => DebugChoice.DebugAnyway
                    },
                    {
                        label: ( nls.localize({ key: 'showErrors', comment: ['&& denotes a mnemonic'] }, "&&Show Errors")),
                        run: () => DebugChoice.ShowErrors
                    }
                ],
                cancelButton: {
                    label: ( nls.localize('abort', "Abort")),
                    run: () => DebugChoice.Cancel
                },
                checkbox: {
                    label: ( nls.localize('remember', "Remember my choice in user settings")),
                }
            });
            const debugAnyway = result === DebugChoice.DebugAnyway;
            const abort = result === DebugChoice.Cancel;
            if (checkboxChecked) {
                this.configurationService.updateValue('debug.onTaskErrors', result === DebugChoice.DebugAnyway ? 'debugAnyway' : abort ? 'abort' : 'showErrors');
            }
            if (abort) {
                return Promise.resolve(0 );
            }
            if (debugAnyway) {
                return 1 ;
            }
            await this.viewsService.openView(Markers.MARKERS_VIEW_ID, true);
            return Promise.resolve(0 );
        }
        catch (err) {
            const taskConfigureAction = this.taskService.configureAction();
            const choiceMap = JSON.parse(this.storageService.get(DEBUG_TASK_ERROR_CHOICE_KEY, 1 , '{}'));
            let choice = -1;
            let DebugChoice;
            ( (function(DebugChoice) {
                DebugChoice[DebugChoice["DebugAnyway"] = 0] = "DebugAnyway";
                DebugChoice[DebugChoice["ConfigureTask"] = 1] = "ConfigureTask";
                DebugChoice[DebugChoice["Cancel"] = 2] = "Cancel";
            })(DebugChoice || (DebugChoice = {})));
            if (choiceMap[err.message] !== undefined) {
                choice = choiceMap[err.message];
            }
            else {
                const { result, checkboxChecked } = await this.dialogService.prompt({
                    type: Severity.Error,
                    message: err.message,
                    buttons: [
                        {
                            label: ( nls.localize(
                                { key: 'debugAnyway', comment: ['&& denotes a mnemonic'] },
                                "&&Debug Anyway"
                            )),
                            run: () => DebugChoice.DebugAnyway
                        },
                        {
                            label: taskConfigureAction.label,
                            run: () => DebugChoice.ConfigureTask
                        }
                    ],
                    cancelButton: {
                        run: () => DebugChoice.Cancel
                    },
                    checkbox: {
                        label: ( nls.localize('rememberTask', "Remember my choice for this task"))
                    }
                });
                choice = result;
                if (checkboxChecked) {
                    choiceMap[err.message] = choice;
                    this.storageService.store(DEBUG_TASK_ERROR_CHOICE_KEY, JSON.stringify(choiceMap), 1 , 1 );
                }
            }
            if (choice === DebugChoice.ConfigureTask) {
                await taskConfigureAction.run();
            }
            return choice === DebugChoice.DebugAnyway ? 1  : 0 ;
        }
    }
    async runTask(root, taskId) {
        if (!taskId) {
            return Promise.resolve(null);
        }
        if (!root) {
            return Promise.reject(( new Error(( nls.localize(
                'invalidTaskReference',
                "Task '{0}' can not be referenced from a launch configuration that is in a different workspace folder.",
                typeof taskId === 'string' ? taskId : taskId.type
            )))));
        }
        const task = await this.taskService.getTask(root, taskId);
        if (!task) {
            const errorMessage = typeof taskId === 'string'
                ? ( nls.localize('DebugTaskNotFoundWithTaskId', "Could not find the task '{0}'.", taskId))
                : ( nls.localize('DebugTaskNotFound', "Could not find the specified task."));
            return Promise.reject(createErrorWithActions(errorMessage, [( new Action(
                DEBUG_CONFIGURE_COMMAND_ID,
                DEBUG_CONFIGURE_LABEL,
                undefined,
                true,
                () => this.commandService.executeCommand(DEBUG_CONFIGURE_COMMAND_ID)
            ))]));
        }
        let taskStarted = false;
        const inactivePromise = ( new Promise((c, e) => once(e => {
            return (e.kind === "inactive"
                || (e.kind === "processEnded"  && e.exitCode === undefined))
                && e.taskId === task._id;
        }, this.taskService.onDidStateChange)(e => {
            taskStarted = true;
            c(e.kind === "processEnded"  ? { exitCode: e.exitCode } : null);
        })));
        const promise = this.taskService.getActiveTasks().then(async (tasks) => {
            if (tasks.find(t => t._id === task._id)) {
                const busyTasks = await this.taskService.getBusyTasks();
                if (busyTasks.find(t => t._id === task._id)) {
                    taskStarted = true;
                    return inactivePromise;
                }
                return Promise.resolve(null);
            }
            once(e => (((e.kind === "active") ) || ((e.kind === "dependsOnStarted") )) && e.taskId === task._id, this.taskService.onDidStateChange)(() => {
                taskStarted = true;
            });
            const taskPromise = this.taskService.run(task);
            if (task.configurationProperties.isBackground) {
                return inactivePromise;
            }
            return taskPromise.then(withUndefinedAsNull);
        });
        return ( new Promise((c, e) => {
            const waitForInput = ( new Promise(
                resolve => once(e => ((e.kind === "acquiredInput") ) && e.taskId === task._id, this.taskService.onDidStateChange)(() => {
                    resolve();
                })
            ));
            promise.then(result => {
                taskStarted = true;
                c(result);
            }, error => e(error));
            waitForInput.then(() => {
                const waitTime = task.configurationProperties.isBackground ? 5000 : 10000;
                setTimeout(() => {
                    if (!taskStarted) {
                        const errorMessage = typeof taskId === 'string'
                            ? ( nls.localize(
                            'taskNotTrackedWithTaskId',
                            "The task '{0}' cannot be tracked. Make sure to have a problem matcher defined.",
                            taskId
                        ))
                            : ( nls.localize(
                            'taskNotTracked',
                            "The task '{0}' cannot be tracked. Make sure to have a problem matcher defined.",
                            JSON.stringify(taskId)
                        ));
                        e({ severity: Severity.Error, message: errorMessage });
                    }
                }, waitTime);
            });
        }));
    }
};
DebugTaskRunner = ( __decorate([
    ( __param(0, ITaskService)),
    ( __param(1, IMarkerService)),
    ( __param(2, IConfigurationService)),
    ( __param(3, IViewsService)),
    ( __param(4, IDialogService)),
    ( __param(5, IStorageService)),
    ( __param(6, ICommandService))
], DebugTaskRunner));
export { DebugTaskRunner };
