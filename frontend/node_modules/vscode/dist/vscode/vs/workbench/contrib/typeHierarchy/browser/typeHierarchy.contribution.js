import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import { CancellationTokenSource } from 'monaco-editor/esm/vs/base/common/cancellation.js';
import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { isCancellationError } from 'monaco-editor/esm/vs/base/common/errors.js';
import { Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { registerEditorContribution, EditorAction2 } from 'monaco-editor/esm/vs/editor/browser/editorExtensions.js';
import { ICodeEditorService } from 'monaco-editor/esm/vs/editor/browser/services/codeEditorService.js';
import { Range } from 'monaco-editor/esm/vs/editor/common/core/range.js';
import { PeekContext } from 'monaco-editor/esm/vs/editor/contrib/peekView/browser/peekView.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { registerAction2, MenuId } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { ContextKeyExpr, RawContextKey, IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
import { TypeHierarchyTreePeekWidget } from './typeHierarchyPeek.js';
import { TypeHierarchyProviderRegistry, TypeHierarchyModel } from '../common/typeHierarchy.js';
const _ctxHasTypeHierarchyProvider = ( new RawContextKey('editorHasTypeHierarchyProvider', false, ( localize(
    'editorHasTypeHierarchyProvider',
    'Whether a type hierarchy provider is available'
))));
const _ctxTypeHierarchyVisible = ( new RawContextKey('typeHierarchyVisible', false, ( localize('typeHierarchyVisible', 'Whether type hierarchy peek is currently showing'))));
const _ctxTypeHierarchyDirection = ( new RawContextKey(
    'typeHierarchyDirection',
    undefined,
    { type: 'string', description: ( localize(
        'typeHierarchyDirection',
        'whether type hierarchy shows super types or subtypes'
    )) }
));
function sanitizedDirection(candidate) {
    return candidate === "subtypes"  || candidate === "supertypes"
        ? candidate
        : "subtypes" ;
}
let TypeHierarchyController = class TypeHierarchyController {
    static { this.Id = 'typeHierarchy'; }
    static get(editor) {
        return editor.getContribution(TypeHierarchyController.Id);
    }
    static { this._storageDirectionKey = 'typeHierarchy/defaultDirection'; }
    constructor(_editor, _contextKeyService, _storageService, _editorService, _instantiationService) {
        this._editor = _editor;
        this._contextKeyService = _contextKeyService;
        this._storageService = _storageService;
        this._editorService = _editorService;
        this._instantiationService = _instantiationService;
        this._disposables = ( new DisposableStore());
        this._sessionDisposables = ( new DisposableStore());
        this._ctxHasProvider = _ctxHasTypeHierarchyProvider.bindTo(this._contextKeyService);
        this._ctxIsVisible = _ctxTypeHierarchyVisible.bindTo(this._contextKeyService);
        this._ctxDirection = _ctxTypeHierarchyDirection.bindTo(this._contextKeyService);
        this._disposables.add(Event.any(_editor.onDidChangeModel, _editor.onDidChangeModelLanguage, TypeHierarchyProviderRegistry.onDidChange)(() => {
            this._ctxHasProvider.set(_editor.hasModel() && ( TypeHierarchyProviderRegistry.has(_editor.getModel())));
        }));
        this._disposables.add(this._sessionDisposables);
    }
    dispose() {
        this._disposables.dispose();
    }
    async startTypeHierarchyFromEditor() {
        this._sessionDisposables.clear();
        if (!this._editor.hasModel()) {
            return;
        }
        const document = this._editor.getModel();
        const position = this._editor.getPosition();
        if (!( TypeHierarchyProviderRegistry.has(document))) {
            return;
        }
        const cts = ( new CancellationTokenSource());
        const model = TypeHierarchyModel.create(document, position, cts.token);
        const direction = sanitizedDirection(this._storageService.get(TypeHierarchyController._storageDirectionKey, 0 , "subtypes" ));
        this._showTypeHierarchyWidget(position, direction, model, cts);
    }
    _showTypeHierarchyWidget(position, direction, model, cts) {
        this._ctxIsVisible.set(true);
        this._ctxDirection.set(direction);
        Event.any(this._editor.onDidChangeModel, this._editor.onDidChangeModelLanguage)(this.endTypeHierarchy, this, this._sessionDisposables);
        this._widget = this._instantiationService.createInstance(TypeHierarchyTreePeekWidget, this._editor, position, direction);
        this._widget.showLoading();
        this._sessionDisposables.add(this._widget.onDidClose(() => {
            this.endTypeHierarchy();
            this._storageService.store(TypeHierarchyController._storageDirectionKey, this._widget.direction, 0 , 0 );
        }));
        this._sessionDisposables.add({ dispose() { cts.dispose(true); } });
        this._sessionDisposables.add(this._widget);
        model.then(model => {
            if (cts.token.isCancellationRequested) {
                return;
            }
            if (model) {
                this._sessionDisposables.add(model);
                this._widget.showModel(model);
            }
            else {
                this._widget.showMessage(( localize('no.item', "No results")));
            }
        }).catch(err => {
            if (isCancellationError(err)) {
                this.endTypeHierarchy();
                return;
            }
            this._widget.showMessage(( localize('error', "Failed to show type hierarchy")));
        });
    }
    async startTypeHierarchyFromTypeHierarchy() {
        if (!this._widget) {
            return;
        }
        const model = this._widget.getModel();
        const typeItem = this._widget.getFocused();
        if (!typeItem || !model) {
            return;
        }
        const newEditor = await this._editorService.openCodeEditor({ resource: typeItem.item.uri }, this._editor);
        if (!newEditor) {
            return;
        }
        const newModel = model.fork(typeItem.item);
        this._sessionDisposables.clear();
        TypeHierarchyController.get(newEditor)?._showTypeHierarchyWidget(Range.lift(newModel.root.selectionRange).getStartPosition(), this._widget.direction, Promise.resolve(newModel), ( new CancellationTokenSource()));
    }
    showSupertypes() {
        this._widget?.updateDirection("supertypes" );
        this._ctxDirection.set("supertypes" );
    }
    showSubtypes() {
        this._widget?.updateDirection("subtypes" );
        this._ctxDirection.set("subtypes" );
    }
    endTypeHierarchy() {
        this._sessionDisposables.clear();
        this._ctxIsVisible.set(false);
        this._editor.focus();
    }
};
TypeHierarchyController = ( __decorate([
    ( __param(1, IContextKeyService)),
    ( __param(2, IStorageService)),
    ( __param(3, ICodeEditorService)),
    ( __param(4, IInstantiationService))
], TypeHierarchyController));
registerEditorContribution(TypeHierarchyController.Id, TypeHierarchyController, 0 );
registerAction2(class extends EditorAction2 {
    constructor() {
        super({
            id: 'editor.showTypeHierarchy',
            title: { value: ( localize('title', "Peek Type Hierarchy")), original: 'Peek Type Hierarchy' },
            menu: {
                id: MenuId.EditorContextPeek,
                group: 'navigation',
                order: 1000,
                when: ( ContextKeyExpr.and(_ctxHasTypeHierarchyProvider, PeekContext.notInPeekEditor)),
            },
            precondition: ( ContextKeyExpr.and(_ctxHasTypeHierarchyProvider, PeekContext.notInPeekEditor))
        });
    }
    async runEditorCommand(_accessor, editor) {
        return TypeHierarchyController.get(editor)?.startTypeHierarchyFromEditor();
    }
});
registerAction2(class extends EditorAction2 {
    constructor() {
        super({
            id: 'editor.showSupertypes',
            title: { value: ( localize('title.supertypes', "Show Supertypes")), original: 'Show Supertypes' },
            icon: Codicon.typeHierarchySuper,
            precondition: ( ContextKeyExpr.and(_ctxTypeHierarchyVisible, ( _ctxTypeHierarchyDirection.isEqualTo("subtypes" )))),
            keybinding: {
                weight: 200 ,
                primary: 1024  + 512  + 38 ,
            },
            menu: {
                id: TypeHierarchyTreePeekWidget.TitleMenu,
                when: ( _ctxTypeHierarchyDirection.isEqualTo("subtypes" )),
                order: 1,
            }
        });
    }
    runEditorCommand(_accessor, editor) {
        return TypeHierarchyController.get(editor)?.showSupertypes();
    }
});
registerAction2(class extends EditorAction2 {
    constructor() {
        super({
            id: 'editor.showSubtypes',
            title: { value: ( localize('title.subtypes', "Show Subtypes")), original: 'Show Subtypes' },
            icon: Codicon.typeHierarchySub,
            precondition: ( ContextKeyExpr.and(_ctxTypeHierarchyVisible, ( _ctxTypeHierarchyDirection.isEqualTo("supertypes" )))),
            keybinding: {
                weight: 200 ,
                primary: 1024  + 512  + 38 ,
            },
            menu: {
                id: TypeHierarchyTreePeekWidget.TitleMenu,
                when: ( _ctxTypeHierarchyDirection.isEqualTo("supertypes" )),
                order: 1,
            }
        });
    }
    runEditorCommand(_accessor, editor) {
        return TypeHierarchyController.get(editor)?.showSubtypes();
    }
});
registerAction2(class extends EditorAction2 {
    constructor() {
        super({
            id: 'editor.refocusTypeHierarchy',
            title: { value: ( localize('title.refocusTypeHierarchy', "Refocus Type Hierarchy")), original: 'Refocus Type Hierarchy' },
            precondition: _ctxTypeHierarchyVisible,
            keybinding: {
                weight: 200 ,
                primary: 1024  + 3
            }
        });
    }
    async runEditorCommand(_accessor, editor) {
        return TypeHierarchyController.get(editor)?.startTypeHierarchyFromTypeHierarchy();
    }
});
registerAction2(class extends EditorAction2 {
    constructor() {
        super({
            id: 'editor.closeTypeHierarchy',
            title: ( localize('close', 'Close')),
            icon: Codicon.close,
            precondition: _ctxTypeHierarchyVisible,
            keybinding: {
                weight: 200  + 10,
                primary: 9 ,
                when: ContextKeyExpr.not('config.editor.stablePeek')
            },
            menu: {
                id: TypeHierarchyTreePeekWidget.TitleMenu,
                order: 1000
            }
        });
    }
    runEditorCommand(_accessor, editor) {
        return TypeHierarchyController.get(editor)?.endTypeHierarchy();
    }
});
