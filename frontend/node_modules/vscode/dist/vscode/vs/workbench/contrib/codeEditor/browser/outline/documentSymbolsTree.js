import { __decorate, __param } from '../../../../../../../node_modules/tslib/tslib.es6.js';
import './documentSymbolsTree.css.js';
import * as dom from 'monaco-editor/esm/vs/base/browser/dom.js';
import { HighlightedLabel } from 'monaco-editor/esm/vs/base/browser/ui/highlightedlabel/highlightedLabel.js';
import { createMatches } from 'monaco-editor/esm/vs/base/common/filters.js';
import { Range } from 'monaco-editor/esm/vs/editor/common/core/range.js';
import { getAriaLabelForSymbol, symbolKindNames, SymbolKinds } from 'monaco-editor/esm/vs/editor/common/languages.js';
import { OutlineModel, OutlineElement, OutlineGroup } from 'monaco-editor/esm/vs/editor/contrib/documentSymbols/browser/outlineModel.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { IconLabel } from 'monaco-editor/esm/vs/base/browser/ui/iconLabel/iconLabel.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { MarkerSeverity } from 'monaco-editor/esm/vs/platform/markers/common/markers.js';
import { IThemeService } from 'monaco-editor/esm/vs/platform/theme/common/themeService.js';
import { listErrorForeground, listWarningForeground } from 'monaco-editor/esm/vs/platform/theme/common/colorRegistry.js';
import { IdleValue } from 'monaco-editor/esm/vs/base/common/async.js';
import { ITextResourceConfigurationService } from 'monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js';
import { ThemeIcon } from 'monaco-editor/esm/vs/base/common/themables.js';
class DocumentSymbolNavigationLabelProvider {
    getKeyboardNavigationLabel(element) {
        if (element instanceof OutlineGroup) {
            return element.label;
        }
        else {
            return element.symbol.name;
        }
    }
}
class DocumentSymbolAccessibilityProvider {
    constructor(_ariaLabel) {
        this._ariaLabel = _ariaLabel;
    }
    getWidgetAriaLabel() {
        return this._ariaLabel;
    }
    getAriaLabel(element) {
        if (element instanceof OutlineGroup) {
            return element.label;
        }
        else {
            return getAriaLabelForSymbol(element.symbol.name, element.symbol.kind);
        }
    }
}
class DocumentSymbolIdentityProvider {
    getId(element) {
        return element.id;
    }
}
class DocumentSymbolGroupTemplate {
    static { this.id = 'DocumentSymbolGroupTemplate'; }
    constructor(labelContainer, label) {
        this.labelContainer = labelContainer;
        this.label = label;
    }
}
class DocumentSymbolTemplate {
    static { this.id = 'DocumentSymbolTemplate'; }
    constructor(container, iconLabel, iconClass, decoration) {
        this.container = container;
        this.iconLabel = iconLabel;
        this.iconClass = iconClass;
        this.decoration = decoration;
    }
}
class DocumentSymbolVirtualDelegate {
    getHeight(_element) {
        return 22;
    }
    getTemplateId(element) {
        return element instanceof OutlineGroup
            ? DocumentSymbolGroupTemplate.id
            : DocumentSymbolTemplate.id;
    }
}
class DocumentSymbolGroupRenderer {
    constructor() {
        this.templateId = DocumentSymbolGroupTemplate.id;
    }
    renderTemplate(container) {
        const labelContainer = dom.$('.outline-element-label');
        container.classList.add('outline-element');
        dom.append(container, labelContainer);
        return ( new DocumentSymbolGroupTemplate(labelContainer, ( new HighlightedLabel(labelContainer))));
    }
    renderElement(node, _index, template) {
        template.label.set(node.element.label, createMatches(node.filterData));
    }
    disposeTemplate(_template) {
    }
}
let DocumentSymbolRenderer = class DocumentSymbolRenderer {
    constructor(_renderMarker, _configurationService, _themeService) {
        this._renderMarker = _renderMarker;
        this._configurationService = _configurationService;
        this._themeService = _themeService;
        this.templateId = DocumentSymbolTemplate.id;
    }
    renderTemplate(container) {
        container.classList.add('outline-element');
        const iconLabel = ( new IconLabel(container, { supportHighlights: true }));
        const iconClass = dom.$('.outline-element-icon');
        const decoration = dom.$('.outline-element-decoration');
        container.prepend(iconClass);
        container.appendChild(decoration);
        return ( new DocumentSymbolTemplate(container, iconLabel, iconClass, decoration));
    }
    renderElement(node, _index, template) {
        const { element } = node;
        const extraClasses = ['nowrap'];
        const options = {
            matches: createMatches(node.filterData),
            labelEscapeNewLines: true,
            extraClasses,
            title: ( localize(
                'title.template',
                "{0} ({1})",
                element.symbol.name,
                symbolKindNames[element.symbol.kind]
            ))
        };
        if (this._configurationService.getValue("outline.icons" )) {
            template.iconClass.className = '';
            template.iconClass.classList.add('outline-element-icon', 'inline', ...ThemeIcon.asClassNameArray(SymbolKinds.toIcon(element.symbol.kind)));
        }
        if (element.symbol.tags.indexOf(1 ) >= 0) {
            extraClasses.push(`deprecated`);
            options.matches = [];
        }
        template.iconLabel.setLabel(element.symbol.name, element.symbol.detail, options);
        if (this._renderMarker) {
            this._renderMarkerInfo(element, template);
        }
    }
    _renderMarkerInfo(element, template) {
        if (!element.marker) {
            dom.hide(template.decoration);
            template.container.style.removeProperty('--outline-element-color');
            return;
        }
        const { count, topSev } = element.marker;
        const color = this._themeService.getColorTheme().getColor(topSev === MarkerSeverity.Error ? listErrorForeground : listWarningForeground);
        const cssColor = color ? ( color.toString()) : 'inherit';
        if (this._configurationService.getValue("outline.problems.colors" )) {
            template.container.style.setProperty('--outline-element-color', cssColor);
        }
        else {
            template.container.style.removeProperty('--outline-element-color');
        }
        if (!this._configurationService.getValue("outline.problems.badges" )) {
            dom.hide(template.decoration);
        }
        else if (count > 0) {
            dom.show(template.decoration);
            template.decoration.classList.remove('bubble');
            template.decoration.innerText = count < 10 ? ( count.toString()) : '+9';
            template.decoration.title = count === 1 ? ( localize('1.problem', "1 problem in this element")) : ( localize('N.problem', "{0} problems in this element", count));
            template.decoration.style.setProperty('--outline-element-color', cssColor);
        }
        else {
            dom.show(template.decoration);
            template.decoration.classList.add('bubble');
            template.decoration.innerText = '\uea71';
            template.decoration.title = ( localize('deep.problem', "Contains elements with problems"));
            template.decoration.style.setProperty('--outline-element-color', cssColor);
        }
    }
    disposeTemplate(_template) {
        _template.iconLabel.dispose();
    }
};
DocumentSymbolRenderer = ( __decorate([
    ( __param(1, IConfigurationService)),
    ( __param(2, IThemeService))
], DocumentSymbolRenderer));
let DocumentSymbolFilter = class DocumentSymbolFilter {
    static { this.kindToConfigName = ( Object.freeze({
        [0 ]: 'showFiles',
        [1 ]: 'showModules',
        [2 ]: 'showNamespaces',
        [3 ]: 'showPackages',
        [4 ]: 'showClasses',
        [5 ]: 'showMethods',
        [6 ]: 'showProperties',
        [7 ]: 'showFields',
        [8 ]: 'showConstructors',
        [9 ]: 'showEnums',
        [10 ]: 'showInterfaces',
        [11 ]: 'showFunctions',
        [12 ]: 'showVariables',
        [13 ]: 'showConstants',
        [14 ]: 'showStrings',
        [15 ]: 'showNumbers',
        [16 ]: 'showBooleans',
        [17 ]: 'showArrays',
        [18 ]: 'showObjects',
        [19 ]: 'showKeys',
        [20 ]: 'showNull',
        [21 ]: 'showEnumMembers',
        [22 ]: 'showStructs',
        [23 ]: 'showEvents',
        [24 ]: 'showOperators',
        [25 ]: 'showTypeParameters',
    })); }
    constructor(_prefix, _textResourceConfigService) {
        this._prefix = _prefix;
        this._textResourceConfigService = _textResourceConfigService;
    }
    filter(element) {
        const outline = OutlineModel.get(element);
        if (!(element instanceof OutlineElement)) {
            return true;
        }
        const configName = DocumentSymbolFilter.kindToConfigName[element.symbol.kind];
        const configKey = `${this._prefix}.${configName}`;
        return this._textResourceConfigService.getValue(outline?.uri, configKey);
    }
};
DocumentSymbolFilter = ( __decorate([
    ( __param(1, ITextResourceConfigurationService))
], DocumentSymbolFilter));
class DocumentSymbolComparator {
    constructor() {
        this._collator = ( new IdleValue(() => new Intl.Collator(undefined, { numeric: true })));
    }
    compareByPosition(a, b) {
        if (a instanceof OutlineGroup && b instanceof OutlineGroup) {
            return a.order - b.order;
        }
        else if (a instanceof OutlineElement && b instanceof OutlineElement) {
            return Range.compareRangesUsingStarts(a.symbol.range, b.symbol.range) || this._collator.value.compare(a.symbol.name, b.symbol.name);
        }
        return 0;
    }
    compareByType(a, b) {
        if (a instanceof OutlineGroup && b instanceof OutlineGroup) {
            return a.order - b.order;
        }
        else if (a instanceof OutlineElement && b instanceof OutlineElement) {
            return a.symbol.kind - b.symbol.kind || this._collator.value.compare(a.symbol.name, b.symbol.name);
        }
        return 0;
    }
    compareByName(a, b) {
        if (a instanceof OutlineGroup && b instanceof OutlineGroup) {
            return a.order - b.order;
        }
        else if (a instanceof OutlineElement && b instanceof OutlineElement) {
            return this._collator.value.compare(a.symbol.name, b.symbol.name) || Range.compareRangesUsingStarts(a.symbol.range, b.symbol.range);
        }
        return 0;
    }
}
export { DocumentSymbolAccessibilityProvider, DocumentSymbolComparator, DocumentSymbolFilter, DocumentSymbolGroupRenderer, DocumentSymbolIdentityProvider, DocumentSymbolNavigationLabelProvider, DocumentSymbolRenderer, DocumentSymbolVirtualDelegate };
