/// <reference path="./../../../../../../debugProtocol.d.ts" />

import { ServiceIdentifier } from '../../../../platform/instantiation/common/instantiation.js';
import { Event } from '../../../../base/common/event.js';
import { IDisposable } from '../../../../base/common/lifecycle.js';
import { VSBuffer } from '../../../../base/common/buffer.js';
import { CancellationToken } from '../../../../base/common/cancellation.js';
import Severity from '../../../../base/common/severity.js';
import { URI } from '../../../../base/common/uri.js';
import { IPosition, Position } from '../../../../editor/common/core/position.js';
import { IRange } from '../../../../editor/common/core/range.js';
import { ITextModel } from '../../../../editor/common/model.js';
import { ConfigurationTarget } from '../../../../platform/configuration/common/configuration.js';
import { ITelemetryEndpoint } from '../../../../platform/telemetry/common/telemetry.js';
import { IWorkspaceFolder } from '../../../../platform/workspace/common/workspace.js';
import { IEditorPane } from '../../../common/editor.js';
import { DebugCompoundRoot } from './debugCompoundRoot.js';
import { Source } from './debugSource.js';
import { ITaskIdentifier } from '../../tasks/common/tasks.js';
import { IEditorService } from '../../../services/editor/common/editorService.js';

interface IRawModelUpdate {
    sessionId: string;
    threads: DebugProtocol.Thread[];
    stoppedDetails?: IRawStoppedDetails;
}
interface IRawStoppedDetails {
    reason?: string;
    description?: string;
    threadId?: number;
    text?: string;
    totalFrames?: number;
    allThreadsStopped?: boolean;
    framesErrorMessage?: string;
    hitBreakpointIds?: number[];
}
interface ITreeElement {
    getId(): string;
}
interface IReplElement extends ITreeElement {
    toString(includeSource?: boolean): string;
    readonly sourceData?: IReplElementSource;
}
interface IReplElementSource {
    readonly source: Source;
    readonly lineNumber: number;
    readonly column: number;
}
interface IExpressionContainer extends ITreeElement {
    readonly hasChildren: boolean;
    evaluateLazy(): Promise<void>;
    getChildren(): Promise<IExpression[]>;
    readonly reference?: number;
    readonly memoryReference?: string;
    readonly value: string;
    readonly type?: string;
    valueChanged?: boolean;
    readonly presentationHint?: DebugProtocol.VariablePresentationHint | undefined;
}
interface IExpression extends IExpressionContainer {
    name: string;
}
interface IDebugger {
    readonly type: string;
    createDebugAdapter(session: IDebugSession): Promise<IDebugAdapter>;
    runInTerminal(args: DebugProtocol.RunInTerminalRequestArguments, sessionId: string): Promise<number | undefined>;
    startDebugging(args: IConfig, parentSessionId: string): Promise<boolean>;
    getCustomTelemetryEndpoint(): ITelemetryEndpoint | undefined;
    getInitialConfigurationContent(initialConfigs?: IConfig[]): Promise<string>;
}
interface IDebuggerMetadata {
    label: string;
    type: string;
    strings?: {
        [key in DebuggerString]: string;
    };
    interestedInLanguage(languageId: string): boolean;
}
declare const enum State {
    Inactive = 0,
    Initializing = 1,
    Stopped = 2,
    Running = 3
}
interface AdapterEndEvent {
    error?: Error;
    sessionLengthInSeconds: number;
    emittedStopped: boolean;
}
interface LoadedSourceEvent {
    reason: 'new' | 'changed' | 'removed';
    source: Source;
}
type IDebugSessionReplMode = 'separate' | 'mergeWithParent';
interface IDebugSessionOptions {
    noDebug?: boolean;
    parentSession?: IDebugSession;
    lifecycleManagedByParent?: boolean;
    repl?: IDebugSessionReplMode;
    compoundRoot?: DebugCompoundRoot;
    compact?: boolean;
    startedByUser?: boolean;
    saveBeforeRestart?: boolean;
    suppressDebugToolbar?: boolean;
    suppressDebugStatusbar?: boolean;
    suppressDebugView?: boolean;
}
interface IDataBreakpointInfoResponse {
    dataId: string | null;
    description: string;
    canPersist?: boolean;
    accessTypes?: DebugProtocol.DataBreakpointAccessType[];
}
interface IMemoryInvalidationEvent {
    fromOffset: number;
    toOffset: number;
}
declare const enum MemoryRangeType {
    Valid = 0,
    Unreadable = 1,
    Error = 2
}
interface IMemoryRange {
    type: MemoryRangeType;
    offset: number;
    length: number;
}
interface IValidMemoryRange extends IMemoryRange {
    type: MemoryRangeType.Valid;
    offset: number;
    length: number;
    data: VSBuffer;
}
interface IUnreadableMemoryRange extends IMemoryRange {
    type: MemoryRangeType.Unreadable;
}
interface IErrorMemoryRange extends IMemoryRange {
    type: MemoryRangeType.Error;
    error: string;
}
/**
 * Union type of memory that can be returned from read(). Since a read request
 * could encompass multiple previously-read ranges, multiple of these types
 * are possible to return.
 */
type MemoryRange = IValidMemoryRange | IUnreadableMemoryRange | IErrorMemoryRange;
/**
 * An IMemoryRegion corresponds to a contiguous range of memory referred to
 * by a DAP `memoryReference`.
 */
interface IMemoryRegion extends IDisposable {
    /**
     * Event that fires when memory changes. Can be a result of memory events or
     * `write` requests.
     */
    readonly onDidInvalidate: Event<IMemoryInvalidationEvent>;
    /**
     * Whether writes are supported on this memory region.
     */
    readonly writable: boolean;
    /**
     * Requests memory ranges from the debug adapter. It returns a list of memory
     * ranges that overlap (but may exceed!) the given offset. Use the `offset`
     * and `length` of each range for display.
     */
    read(fromOffset: number, toOffset: number): Promise<MemoryRange[]>;
    /**
     * Writes memory to the debug adapter at the given offset.
     */
    write(offset: number, data: VSBuffer): Promise<number>;
}
/** Data that can be inserted in {@link IDebugSession.appendToRepl} */
interface INewReplElementData {
    /**
     * Output string to display
     */
    output: string;
    /**
     * Expression data to display. Will result in the item being expandable in
     * the REPL. Its value will be used if {@link output} is not provided.
     */
    expression?: IExpression;
    /**
     * Output severity.
     */
    sev: Severity;
    /**
     * Originating location.
     */
    source?: IReplElementSource;
}
interface IDebugSession extends ITreeElement {
    readonly configuration: IConfig;
    readonly unresolvedConfiguration: IConfig | undefined;
    readonly state: State;
    readonly root: IWorkspaceFolder | undefined;
    readonly parentSession: IDebugSession | undefined;
    readonly subId: string | undefined;
    readonly compact: boolean;
    readonly compoundRoot: DebugCompoundRoot | undefined;
    readonly saveBeforeRestart: boolean;
    readonly name: string;
    readonly autoExpandLazyVariables: boolean;
    readonly suppressDebugToolbar: boolean;
    readonly suppressDebugStatusbar: boolean;
    readonly suppressDebugView: boolean;
    readonly lifecycleManagedByParent: boolean;
    setSubId(subId: string | undefined): void;
    getMemory(memoryReference: string): IMemoryRegion;
    setName(name: string): void;
    readonly onDidChangeName: Event<string>;
    getLabel(): string;
    getSourceForUri(modelUri: URI): Source | undefined;
    getSource(raw?: DebugProtocol.Source): Source;
    setConfiguration(configuration: {
        resolved: IConfig;
        unresolved: IConfig | undefined;
    }): void;
    rawUpdate(data: IRawModelUpdate): void;
    getThread(threadId: number): IThread | undefined;
    getAllThreads(): IThread[];
    clearThreads(removeThreads: boolean, reference?: number): void;
    getStoppedDetails(): IRawStoppedDetails | undefined;
    getReplElements(): IReplElement[];
    hasSeparateRepl(): boolean;
    removeReplExpressions(): void;
    addReplExpression(stackFrame: IStackFrame | undefined, name: string): Promise<void>;
    appendToRepl(data: INewReplElementData): void;
    readonly onDidEndAdapter: Event<AdapterEndEvent | undefined>;
    readonly onDidChangeState: Event<void>;
    readonly onDidChangeReplElements: Event<void>;
    readonly capabilities: DebugProtocol.Capabilities;
    readonly onDidLoadedSource: Event<LoadedSourceEvent>;
    readonly onDidCustomEvent: Event<DebugProtocol.Event>;
    readonly onDidProgressStart: Event<DebugProtocol.ProgressStartEvent>;
    readonly onDidProgressUpdate: Event<DebugProtocol.ProgressUpdateEvent>;
    readonly onDidProgressEnd: Event<DebugProtocol.ProgressEndEvent>;
    readonly onDidInvalidateMemory: Event<DebugProtocol.MemoryEvent>;
    initialize(dbgr: IDebugger): Promise<void>;
    launchOrAttach(config: IConfig): Promise<void>;
    restart(): Promise<void>;
    terminate(restart?: boolean): Promise<void>;
    disconnect(restart?: boolean, suspend?: boolean): Promise<void>;
    sendBreakpoints(modelUri: URI, bpts: IBreakpoint[], sourceModified: boolean): Promise<void>;
    sendFunctionBreakpoints(fbps: IFunctionBreakpoint[]): Promise<void>;
    dataBreakpointInfo(name: string, variablesReference?: number): Promise<IDataBreakpointInfoResponse | undefined>;
    sendDataBreakpoints(dbps: IDataBreakpoint[]): Promise<void>;
    sendInstructionBreakpoints(dbps: IInstructionBreakpoint[]): Promise<void>;
    sendExceptionBreakpoints(exbpts: IExceptionBreakpoint[]): Promise<void>;
    breakpointsLocations(uri: URI, lineNumber: number): Promise<IPosition[]>;
    getDebugProtocolBreakpoint(breakpointId: string): DebugProtocol.Breakpoint | undefined;
    stackTrace(threadId: number, startFrame: number, levels: number, token: CancellationToken): Promise<DebugProtocol.StackTraceResponse | undefined>;
    exceptionInfo(threadId: number): Promise<IExceptionInfo | undefined>;
    scopes(frameId: number, threadId: number): Promise<DebugProtocol.ScopesResponse | undefined>;
    variables(variablesReference: number, threadId: number | undefined, filter: 'indexed' | 'named' | undefined, start: number | undefined, count: number | undefined): Promise<DebugProtocol.VariablesResponse | undefined>;
    evaluate(expression: string, frameId?: number, context?: string): Promise<DebugProtocol.EvaluateResponse | undefined>;
    customRequest(request: string, args: any): Promise<DebugProtocol.Response | undefined>;
    cancel(progressId: string): Promise<DebugProtocol.CancelResponse | undefined>;
    disassemble(memoryReference: string, offset: number, instructionOffset: number, instructionCount: number): Promise<DebugProtocol.DisassembledInstruction[] | undefined>;
    readMemory(memoryReference: string, offset: number, count: number): Promise<DebugProtocol.ReadMemoryResponse | undefined>;
    writeMemory(memoryReference: string, offset: number, data: string, allowPartial?: boolean): Promise<DebugProtocol.WriteMemoryResponse | undefined>;
    restartFrame(frameId: number, threadId: number): Promise<void>;
    next(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;
    stepIn(threadId: number, targetId?: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;
    stepInTargets(frameId: number): Promise<DebugProtocol.StepInTarget[] | undefined>;
    stepOut(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;
    stepBack(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;
    continue(threadId: number): Promise<void>;
    reverseContinue(threadId: number): Promise<void>;
    pause(threadId: number): Promise<void>;
    terminateThreads(threadIds: number[]): Promise<void>;
    completions(frameId: number | undefined, threadId: number, text: string, position: Position, overwriteBefore: number, token: CancellationToken): Promise<DebugProtocol.CompletionsResponse | undefined>;
    setVariable(variablesReference: number | undefined, name: string, value: string): Promise<DebugProtocol.SetVariableResponse | undefined>;
    setExpression(frameId: number, expression: string, value: string): Promise<DebugProtocol.SetExpressionResponse | undefined>;
    loadSource(resource: URI): Promise<DebugProtocol.SourceResponse | undefined>;
    getLoadedSources(): Promise<Source[]>;
    gotoTargets(source: DebugProtocol.Source, line: number, column?: number): Promise<DebugProtocol.GotoTargetsResponse | undefined>;
    goto(threadId: number, targetId: number): Promise<DebugProtocol.GotoResponse | undefined>;
}
interface IThread extends ITreeElement {
    /**
     * Process the thread belongs to
     */
    readonly session: IDebugSession;
    /**
     * Id of the thread generated by the debug adapter backend.
     */
    readonly threadId: number;
    /**
     * Name of the thread.
     */
    readonly name: string;
    /**
     * Information about the current thread stop event. Undefined if thread is not stopped.
     */
    readonly stoppedDetails: IRawStoppedDetails | undefined;
    /**
     * Information about the exception if an 'exception' stopped event raised and DA supports the 'exceptionInfo' request, otherwise undefined.
     */
    readonly exceptionInfo: Promise<IExceptionInfo | undefined>;
    readonly stateLabel: string;
    /**
     * Gets the callstack if it has already been received from the debug
     * adapter.
     */
    getCallStack(): ReadonlyArray<IStackFrame>;
    /**
     * Gets the top stack frame that is not hidden if the callstack has already been received from the debug adapter
     */
    getTopStackFrame(): IStackFrame | undefined;
    /**
     * Invalidates the callstack cache
     */
    clearCallStack(): void;
    /**
     * Indicates whether this thread is stopped. The callstack for stopped
     * threads can be retrieved from the debug adapter.
     */
    readonly stopped: boolean;
    next(granularity?: DebugProtocol.SteppingGranularity): Promise<any>;
    stepIn(granularity?: DebugProtocol.SteppingGranularity): Promise<any>;
    stepOut(granularity?: DebugProtocol.SteppingGranularity): Promise<any>;
    stepBack(granularity?: DebugProtocol.SteppingGranularity): Promise<any>;
    continue(): Promise<any>;
    pause(): Promise<any>;
    terminate(): Promise<any>;
    reverseContinue(): Promise<any>;
}
interface IScope extends IExpressionContainer {
    readonly name: string;
    readonly expensive: boolean;
    readonly range?: IRange;
    readonly hasChildren: boolean;
}
interface IStackFrame extends ITreeElement {
    readonly thread: IThread;
    readonly name: string;
    readonly presentationHint: string | undefined;
    readonly frameId: number;
    readonly range: IRange;
    readonly source: Source;
    readonly canRestart: boolean;
    readonly instructionPointerReference?: string;
    getScopes(): Promise<IScope[]>;
    getMostSpecificScopes(range: IRange): Promise<ReadonlyArray<IScope>>;
    forgetScopes(): void;
    restart(): Promise<any>;
    toString(): string;
    openInEditor(editorService: IEditorService, preserveFocus?: boolean, sideBySide?: boolean, pinned?: boolean): Promise<IEditorPane | undefined>;
    equals(other: IStackFrame): boolean;
}
interface IEnablement extends ITreeElement {
    readonly enabled: boolean;
}
interface IBreakpointData {
    readonly id?: string;
    readonly lineNumber: number;
    readonly column?: number;
    readonly enabled?: boolean;
    readonly condition?: string;
    readonly logMessage?: string;
    readonly hitCondition?: string;
}
interface IBreakpointUpdateData {
    readonly condition?: string;
    readonly hitCondition?: string;
    readonly logMessage?: string;
    readonly lineNumber?: number;
    readonly column?: number;
}
interface IBaseBreakpoint extends IEnablement {
    readonly condition?: string;
    readonly hitCondition?: string;
    readonly logMessage?: string;
    readonly verified: boolean;
    readonly supported: boolean;
    readonly message?: string;
    readonly sessionsThatVerified: string[];
    getIdFromAdapter(sessionId: string): number | undefined;
}
interface IBreakpoint extends IBaseBreakpoint {
    /** URI where the breakpoint was first set by the user. */
    readonly originalUri: URI;
    /** URI where the breakpoint is currently shown; may be moved by debugger */
    readonly uri: URI;
    readonly lineNumber: number;
    readonly endLineNumber?: number;
    readonly column?: number;
    readonly endColumn?: number;
    readonly adapterData: any;
    readonly sessionAgnosticData: {
        lineNumber: number;
        column: number | undefined;
    };
}
interface IFunctionBreakpoint extends IBaseBreakpoint {
    readonly name: string;
}
interface IExceptionBreakpoint extends IBaseBreakpoint {
    readonly filter: string;
    readonly label: string;
    readonly description: string | undefined;
}
interface IDataBreakpoint extends IBaseBreakpoint {
    readonly description: string;
    readonly dataId: string;
    readonly canPersist: boolean;
    readonly accessType: DebugProtocol.DataBreakpointAccessType;
}
interface IInstructionBreakpoint extends IBaseBreakpoint {
    readonly instructionReference: string;
    readonly offset?: number;
}
interface IExceptionInfo {
    readonly id?: string;
    readonly description?: string;
    readonly breakMode: string | null;
    readonly details?: DebugProtocol.ExceptionDetails;
}
interface IViewModel extends ITreeElement {
    /**
     * Returns the focused debug session or undefined if no session is stopped.
     */
    readonly focusedSession: IDebugSession | undefined;
    /**
     * Returns the focused thread or undefined if no thread is stopped.
     */
    readonly focusedThread: IThread | undefined;
    /**
     * Returns the focused stack frame or undefined if there are no stack frames.
     */
    readonly focusedStackFrame: IStackFrame | undefined;
    getSelectedExpression(): {
        expression: IExpression;
        settingWatch: boolean;
    } | undefined;
    setSelectedExpression(expression: IExpression | undefined, settingWatch: boolean): void;
    updateViews(): void;
    isMultiSessionView(): boolean;
    onDidFocusSession: Event<IDebugSession | undefined>;
    onDidFocusThread: Event<{
        thread: IThread | undefined;
        explicit: boolean;
        session: IDebugSession | undefined;
    }>;
    onDidFocusStackFrame: Event<{
        stackFrame: IStackFrame | undefined;
        explicit: boolean;
        session: IDebugSession | undefined;
    }>;
    onDidSelectExpression: Event<{
        expression: IExpression;
        settingWatch: boolean;
    } | undefined>;
    onDidEvaluateLazyExpression: Event<IExpressionContainer>;
    onWillUpdateViews: Event<void>;
    evaluateLazyExpression(expression: IExpressionContainer): void;
}
interface IEvaluate {
    evaluate(session: IDebugSession, stackFrame: IStackFrame, context: string): Promise<void>;
}
interface IDebugModel extends ITreeElement {
    getSession(sessionId: string | undefined, includeInactive?: boolean): IDebugSession | undefined;
    getSessions(includeInactive?: boolean): IDebugSession[];
    getBreakpoints(filter?: {
        uri?: URI;
        originalUri?: URI;
        lineNumber?: number;
        column?: number;
        enabledOnly?: boolean;
    }): ReadonlyArray<IBreakpoint>;
    areBreakpointsActivated(): boolean;
    getFunctionBreakpoints(): ReadonlyArray<IFunctionBreakpoint>;
    getDataBreakpoints(): ReadonlyArray<IDataBreakpoint>;
    /**
     * Returns list of all exception breakpoints.
     */
    getExceptionBreakpoints(): ReadonlyArray<IExceptionBreakpoint>;
    /**
     * Returns list of exception breakpoints for the given session
     * @param sessionId Session id. If falsy, returns the breakpoints from the last set fallback session.
     */
    getExceptionBreakpointsForSession(sessionId?: string): ReadonlyArray<IExceptionBreakpoint>;
    getInstructionBreakpoints(): ReadonlyArray<IInstructionBreakpoint>;
    getWatchExpressions(): ReadonlyArray<IExpression & IEvaluate>;
    onDidChangeBreakpoints: Event<IBreakpointsChangeEvent | undefined>;
    onDidChangeCallStack: Event<void>;
    onDidChangeWatchExpressions: Event<IExpression | undefined>;
    fetchCallstack(thread: IThread, levels?: number): Promise<void>;
}
/**
 * An event describing a change to the set of [breakpoints](#debug.Breakpoint).
 */
interface IBreakpointsChangeEvent {
    added?: Array<IBreakpoint | IFunctionBreakpoint | IDataBreakpoint | IInstructionBreakpoint>;
    removed?: Array<IBreakpoint | IFunctionBreakpoint | IDataBreakpoint | IInstructionBreakpoint>;
    changed?: Array<IBreakpoint | IFunctionBreakpoint | IDataBreakpoint | IInstructionBreakpoint>;
    sessionOnly: boolean;
}
interface IEnvConfig {
    internalConsoleOptions?: 'neverOpen' | 'openOnSessionStart' | 'openOnFirstSessionStart';
    preRestartTask?: string | ITaskIdentifier;
    postRestartTask?: string | ITaskIdentifier;
    preLaunchTask?: string | ITaskIdentifier;
    postDebugTask?: string | ITaskIdentifier;
    debugServer?: number;
    noDebug?: boolean;
    suppressMultipleSessionWarning?: boolean;
}
interface IConfigPresentation {
    hidden?: boolean;
    group?: string;
    order?: number;
}
interface IConfig extends IEnvConfig {
    type: string;
    request: string;
    name: string;
    presentation?: IConfigPresentation;
    windows?: IEnvConfig;
    osx?: IEnvConfig;
    linux?: IEnvConfig;
    __configurationTarget?: ConfigurationTarget;
    __sessionId?: string;
    __restart?: any;
    __autoAttach?: boolean;
    port?: number;
}
interface ICompound {
    name: string;
    stopAll?: boolean;
    preLaunchTask?: string | ITaskIdentifier;
    configurations: (string | {
        name: string;
        folder: string;
    })[];
    presentation?: IConfigPresentation;
}
interface IDebugAdapter extends IDisposable {
    readonly onError: Event<Error>;
    readonly onExit: Event<number | null>;
    onRequest(callback: (request: DebugProtocol.Request) => void): void;
    onEvent(callback: (event: DebugProtocol.Event) => void): void;
    startSession(): Promise<void>;
    sendMessage(message: DebugProtocol.ProtocolMessage): void;
    sendResponse(response: DebugProtocol.Response): void;
    sendRequest(command: string, args: any, clb: (result: DebugProtocol.Response) => void, timeout?: number): number;
    stopSession(): Promise<void>;
}
interface IDebugAdapterFactory extends ITerminalLauncher {
    createDebugAdapter(session: IDebugSession): IDebugAdapter;
    substituteVariables(folder: IWorkspaceFolder | undefined, config: IConfig): Promise<IConfig>;
}
interface IDebugAdapterExecutableOptions {
    cwd?: string;
    env?: {
        [key: string]: string;
    };
}
interface IDebugAdapterExecutable {
    readonly type: 'executable';
    readonly command: string;
    readonly args: string[];
    readonly options?: IDebugAdapterExecutableOptions;
}
interface IDebugAdapterServer {
    readonly type: 'server';
    readonly port: number;
    readonly host?: string;
}
interface IDebugAdapterNamedPipeServer {
    readonly type: 'pipeServer';
    readonly path: string;
}
interface IDebugAdapterInlineImpl extends IDisposable {
    readonly onDidSendMessage: Event<DebugProtocol.Message>;
    handleMessage(message: DebugProtocol.Message): void;
}
interface IDebugAdapterImpl {
    readonly type: 'implementation';
    readonly implementation: IDebugAdapterInlineImpl;
}
type IAdapterDescriptor = IDebugAdapterExecutable | IDebugAdapterServer | IDebugAdapterNamedPipeServer | IDebugAdapterImpl;
declare enum DebugConfigurationProviderTriggerKind {
    /**
     *	`DebugConfigurationProvider.provideDebugConfigurations` is called to provide the initial debug configurations for a newly created launch.json.
     */
    Initial = 1,
    /**
     * `DebugConfigurationProvider.provideDebugConfigurations` is called to provide dynamically generated debug configurations when the user asks for them through the UI (e.g. via the "Select and Start Debugging" command).
     */
    Dynamic = 2
}
interface IDebugConfigurationProvider {
    readonly type: string;
    readonly triggerKind: DebugConfigurationProviderTriggerKind;
    resolveDebugConfiguration?(folderUri: URI | undefined, debugConfiguration: IConfig, token: CancellationToken): Promise<IConfig | null | undefined>;
    resolveDebugConfigurationWithSubstitutedVariables?(folderUri: URI | undefined, debugConfiguration: IConfig, token: CancellationToken): Promise<IConfig | null | undefined>;
    provideDebugConfigurations?(folderUri: URI | undefined, token: CancellationToken): Promise<IConfig[]>;
}
interface IDebugAdapterDescriptorFactory {
    readonly type: string;
    createDebugAdapterDescriptor(session: IDebugSession): Promise<IAdapterDescriptor>;
}
interface ITerminalLauncher {
    runInTerminal(args: DebugProtocol.RunInTerminalRequestArguments, sessionId: string): Promise<number | undefined>;
}
interface IConfigurationManager {
    /**
     * Returns an object containing the selected launch configuration and the selected configuration name. Both these fields can be null (no folder workspace).
     */
    readonly selectedConfiguration: {
        launch: ILaunch | undefined;
        getConfig: () => Promise<IConfig | undefined>;
        name: string | undefined;
        type: string | undefined;
    };
    selectConfiguration(launch: ILaunch | undefined, name?: string, config?: IConfig, dynamicConfigOptions?: {
        type?: string;
    }): Promise<void>;
    getLaunches(): ReadonlyArray<ILaunch>;
    getLaunch(workspaceUri: URI | undefined): ILaunch | undefined;
    getAllConfigurations(): {
        launch: ILaunch;
        name: string;
        presentation?: IConfigPresentation;
    }[];
    removeRecentDynamicConfigurations(name: string, type: string): void;
    getRecentDynamicConfigurations(): {
        name: string;
        type: string;
    }[];
    /**
     * Allows to register on change of selected debug configuration.
     */
    onDidSelectConfiguration: Event<void>;
    hasDebugConfigurationProvider(debugType: string): boolean;
    getDynamicProviders(): Promise<{
        label: string;
        type: string;
        pick: () => Promise<{
            launch: ILaunch;
            config: IConfig;
        } | undefined>;
    }[]>;
    registerDebugConfigurationProvider(debugConfigurationProvider: IDebugConfigurationProvider): IDisposable;
    unregisterDebugConfigurationProvider(debugConfigurationProvider: IDebugConfigurationProvider): void;
    resolveConfigurationByProviders(folderUri: URI | undefined, type: string | undefined, debugConfiguration: any, token: CancellationToken): Promise<any>;
}
declare enum DebuggerString {
    UnverifiedBreakpoints = "unverifiedBreakpoints"
}
interface IAdapterManager {
    onDidRegisterDebugger: Event<void>;
    hasEnabledDebuggers(): boolean;
    getDebugAdapterDescriptor(session: IDebugSession): Promise<IAdapterDescriptor | undefined>;
    getDebuggerLabel(type: string): string | undefined;
    someDebuggerInterestedInLanguage(language: string): boolean;
    getDebugger(type: string): IDebuggerMetadata | undefined;
    activateDebuggers(activationEvent: string, debugType?: string): Promise<void>;
    registerDebugAdapterFactory(debugTypes: string[], debugAdapterFactory: IDebugAdapterFactory): IDisposable;
    createDebugAdapter(session: IDebugSession): IDebugAdapter | undefined;
    registerDebugAdapterDescriptorFactory(debugAdapterDescriptorFactory: IDebugAdapterDescriptorFactory): IDisposable;
    unregisterDebugAdapterDescriptorFactory(debugAdapterDescriptorFactory: IDebugAdapterDescriptorFactory): void;
    substituteVariables(debugType: string, folder: IWorkspaceFolder | undefined, config: IConfig): Promise<IConfig>;
    runInTerminal(debugType: string, args: DebugProtocol.RunInTerminalRequestArguments, sessionId: string): Promise<number | undefined>;
    getEnabledDebugger(type: string): (IDebugger & IDebuggerMetadata) | undefined;
    guessDebugger(gettingConfigurations: boolean): Promise<(IDebugger & IDebuggerMetadata) | undefined>;
    get onDidDebuggersExtPointRead(): Event<void>;
}
interface ILaunch {
    /**
     * Resource pointing to the launch.json this object is wrapping.
     */
    readonly uri: URI;
    /**
     * Name of the launch.
     */
    readonly name: string;
    /**
     * Workspace of the launch. Can be undefined.
     */
    readonly workspace: IWorkspaceFolder | undefined;
    /**
     * Should this launch be shown in the debug dropdown.
     */
    readonly hidden: boolean;
    /**
     * Returns a configuration with the specified name.
     * Returns undefined if there is no configuration with the specified name.
     */
    getConfiguration(name: string): IConfig | undefined;
    /**
     * Returns a compound with the specified name.
     * Returns undefined if there is no compound with the specified name.
     */
    getCompound(name: string): ICompound | undefined;
    /**
     * Returns the names of all configurations and compounds.
     * Ignores configurations which are invalid.
     */
    getConfigurationNames(ignoreCompoundsAndPresentation?: boolean): string[];
    /**
     * Opens the launch.json file. Creates if it does not exist.
     */
    openConfigFile(options: {
        preserveFocus: boolean;
        type?: string;
        suppressInitialConfigs?: boolean;
    }, token?: CancellationToken): Promise<{
        editor: IEditorPane | null;
        created: boolean;
    }>;
}
declare const IDebugService: ServiceIdentifier<IDebugService>;
interface IDebugService {
    readonly _serviceBrand: undefined;
    /**
     * Gets the current debug state.
     */
    readonly state: State;
    readonly initializingOptions?: IDebugSessionOptions | undefined;
    /**
     * Allows to register on debug state changes.
     */
    onDidChangeState: Event<State>;
    /**
     * Allows to register on new session events.
     */
    onDidNewSession: Event<IDebugSession>;
    /**
     * Allows to register on sessions about to be created (not yet fully initialised)
     */
    onWillNewSession: Event<IDebugSession>;
    /**
     * Allows to register on end session events.
     */
    onDidEndSession: Event<IDebugSession>;
    /**
     * Gets the configuration manager.
     */
    getConfigurationManager(): IConfigurationManager;
    /**
     * Gets the adapter manager.
     */
    getAdapterManager(): IAdapterManager;
    /**
     * Sets the focused stack frame and evaluates all expressions against the newly focused stack frame,
     */
    focusStackFrame(focusedStackFrame: IStackFrame | undefined, thread?: IThread, session?: IDebugSession, options?: {
        explicit?: boolean;
        preserveFocus?: boolean;
        sideBySide?: boolean;
        pinned?: boolean;
    }): Promise<void>;
    /**
     * Returns true if breakpoints can be set for a given editor model. Depends on mode.
     */
    canSetBreakpointsIn(model: ITextModel): boolean;
    /**
     * Adds new breakpoints to the model for the file specified with the uri. Notifies debug adapter of breakpoint changes.
     */
    addBreakpoints(uri: URI, rawBreakpoints: IBreakpointData[], ariaAnnounce?: boolean): Promise<IBreakpoint[]>;
    /**
     * Updates the breakpoints.
     */
    updateBreakpoints(originalUri: URI, data: Map<string, IBreakpointUpdateData>, sendOnResourceSaved: boolean): Promise<void>;
    /**
     * Enables or disables all breakpoints. If breakpoint is passed only enables or disables the passed breakpoint.
     * Notifies debug adapter of breakpoint changes.
     */
    enableOrDisableBreakpoints(enable: boolean, breakpoint?: IEnablement): Promise<void>;
    /**
     * Sets the global activated property for all breakpoints.
     * Notifies debug adapter of breakpoint changes.
     */
    setBreakpointsActivated(activated: boolean): Promise<void>;
    /**
     * Removes all breakpoints. If id is passed only removes the breakpoint associated with that id.
     * Notifies debug adapter of breakpoint changes.
     */
    removeBreakpoints(id?: string): Promise<any>;
    /**
     * Adds a new function breakpoint for the given name.
     */
    addFunctionBreakpoint(name?: string, id?: string): void;
    /**
     * Updates an already existing function breakpoint.
     * Notifies debug adapter of breakpoint changes.
     */
    updateFunctionBreakpoint(id: string, update: {
        name?: string;
        hitCondition?: string;
        condition?: string;
    }): Promise<void>;
    /**
     * Removes all function breakpoints. If id is passed only removes the function breakpoint with the passed id.
     * Notifies debug adapter of breakpoint changes.
     */
    removeFunctionBreakpoints(id?: string): Promise<void>;
    /**
     * Adds a new data breakpoint.
     */
    addDataBreakpoint(label: string, dataId: string, canPersist: boolean, accessTypes: DebugProtocol.DataBreakpointAccessType[] | undefined, accessType: DebugProtocol.DataBreakpointAccessType): Promise<void>;
    /**
     * Removes all data breakpoints. If id is passed only removes the data breakpoint with the passed id.
     * Notifies debug adapter of breakpoint changes.
     */
    removeDataBreakpoints(id?: string): Promise<void>;
    /**
     * Adds a new instruction breakpoint.
     */
    addInstructionBreakpoint(address: string, offset: number, condition?: string, hitCondition?: string): Promise<void>;
    /**
     * Removes all instruction breakpoints. If address is passed only removes the instruction breakpoint with the passed address.
     * The address should be the address string supplied by the debugger from the "Disassemble" request.
     * Notifies debug adapter of breakpoint changes.
     */
    removeInstructionBreakpoints(address?: string): Promise<void>;
    setExceptionBreakpointCondition(breakpoint: IExceptionBreakpoint, condition: string | undefined): Promise<void>;
    setExceptionBreakpointsForSession(session: IDebugSession, data: DebugProtocol.ExceptionBreakpointsFilter[]): void;
    /**
     * Sends all breakpoints to the passed session.
     * If session is not passed, sends all breakpoints to each session.
     */
    sendAllBreakpoints(session?: IDebugSession): Promise<any>;
    /**
     * Adds a new watch expression and evaluates it against the debug adapter.
     */
    addWatchExpression(name?: string): void;
    /**
     * Renames a watch expression and evaluates it against the debug adapter.
     */
    renameWatchExpression(id: string, newName: string): void;
    /**
     * Moves a watch expression to a new possition. Used for reordering watch expressions.
     */
    moveWatchExpression(id: string, position: number): void;
    /**
     * Removes all watch expressions. If id is passed only removes the watch expression with the passed id.
     */
    removeWatchExpressions(id?: string): void;
    /**
     * Starts debugging. If the configOrName is not passed uses the selected configuration in the debug dropdown.
     * Also saves all files, manages if compounds are present in the configuration
     * and resolveds configurations via DebugConfigurationProviders.
     *
     * Returns true if the start debugging was successful. For compound launches, all configurations have to start successfully for it to return success.
     * On errors the startDebugging will throw an error, however some error and cancelations are handled and in that case will simply return false.
     */
    startDebugging(launch: ILaunch | undefined, configOrName?: IConfig | string, options?: IDebugSessionOptions, saveBeforeStart?: boolean): Promise<boolean>;
    /**
     * Restarts a session or creates a new one if there is no active session.
     */
    restartSession(session: IDebugSession, restartData?: any): Promise<any>;
    /**
     * Stops the session. If no session is specified then all sessions are stopped.
     */
    stopSession(session: IDebugSession | undefined, disconnect?: boolean, suspend?: boolean): Promise<any>;
    /**
     * Makes unavailable all sources with the passed uri. Source will appear as grayed out in callstack view.
     */
    sourceIsNotAvailable(uri: URI): void;
    /**
     * Gets the current debug model.
     */
    getModel(): IDebugModel;
    /**
     * Gets the current view model.
     */
    getViewModel(): IViewModel;
    /**
     * Resumes execution and pauses until the given position is reached.
     */
    runTo(uri: URI, lineNumber: number, column?: number): Promise<void>;
}

export { AdapterEndEvent, DebugConfigurationProviderTriggerKind, DebuggerString, IAdapterDescriptor, IAdapterManager, IBaseBreakpoint, IBreakpoint, IBreakpointData, IBreakpointUpdateData, IBreakpointsChangeEvent, ICompound, IConfig, IConfigPresentation, IConfigurationManager, IDataBreakpoint, IDataBreakpointInfoResponse, IDebugAdapter, IDebugAdapterDescriptorFactory, IDebugAdapterExecutable, IDebugAdapterExecutableOptions, IDebugAdapterFactory, IDebugAdapterImpl, IDebugAdapterInlineImpl, IDebugAdapterNamedPipeServer, IDebugAdapterServer, IDebugConfigurationProvider, IDebugModel, IDebugService, IDebugSession, IDebugSessionOptions, IDebugSessionReplMode, IDebugger, IDebuggerMetadata, IEnablement, IErrorMemoryRange, IEvaluate, IExceptionBreakpoint, IExceptionInfo, IExpression, IExpressionContainer, IFunctionBreakpoint, IInstructionBreakpoint, ILaunch, IMemoryInvalidationEvent, IMemoryRange, IMemoryRegion, INewReplElementData, IRawModelUpdate, IRawStoppedDetails, IReplElement, IReplElementSource, IScope, IStackFrame, IThread, ITreeElement, IUnreadableMemoryRange, IValidMemoryRange, IViewModel, LoadedSourceEvent, MemoryRange, MemoryRangeType, State };
