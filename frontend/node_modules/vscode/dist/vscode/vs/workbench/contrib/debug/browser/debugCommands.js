import * as nls from 'monaco-editor/esm/vs/nls.js';
import { List } from 'monaco-editor/esm/vs/base/browser/ui/list/listWidget.js';
import { KeybindingsRegistry } from 'monaco-editor/esm/vs/platform/keybinding/common/keybindingsRegistry.js';
import { IListService } from 'monaco-editor/esm/vs/platform/list/browser/listService.js';
import { IDebugService, CONTEXT_DISASSEMBLY_VIEW_FOCUS, CONTEXT_JUMP_TO_CURSOR_SUPPORTED, CONTEXT_IN_DEBUG_REPL, CONTEXT_IN_DEBUG_MODE, CONTEXT_DEBUG_STATE, CONTEXT_STEP_INTO_TARGETS_SUPPORTED, CONTEXT_FOCUSED_SESSION_IS_ATTACH, REPL_VIEW_ID, CONTEXT_BREAKPOINTS_FOCUSED, CONTEXT_WATCH_EXPRESSIONS_FOCUSED, CONTEXT_VARIABLES_FOCUSED, CONTEXT_EXPRESSION_SELECTED, CONTEXT_BREAKPOINT_INPUT_FOCUSED } from '../common/debug.js';
import { Expression, Variable, Breakpoint, FunctionBreakpoint, DataBreakpoint } from '../common/debugModel.js';
import { isCodeEditor } from 'monaco-editor/esm/vs/editor/browser/editorBrowser.js';
import { MenuRegistry, MenuId } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { IEditorService } from '../../../services/editor/common/editorService.js';
import { EditorContextKeys } from 'monaco-editor/esm/vs/editor/common/editorContextKeys.js';
import { IContextKeyService, ContextKeyExpr } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { openBreakpointSource } from './breakpointsView.js';
import { INotificationService } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { InputFocusedContext } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkeys.js';
import { PanelFocusContext } from '../../../common/contextkeys.js';
import { CommandsRegistry } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { ITextResourcePropertiesService } from 'monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js';
import { IClipboardService } from 'monaco-editor/esm/vs/platform/clipboard/common/clipboardService.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { IQuickInputService } from 'monaco-editor/esm/vs/platform/quickinput/common/quickInput.js';
import { IViewsService } from '../../../common/views.js';
import { isWeb, isWindows } from 'monaco-editor/esm/vs/base/common/platform.js';
import { showLoadedScriptMenu } from '../common/loadedScriptsPicker.js';
import { showDebugSessionMenu } from './debugSessionPicker.js';
const ADD_CONFIGURATION_ID = 'debug.addConfiguration';
const TOGGLE_INLINE_BREAKPOINT_ID = 'editor.debug.action.toggleInlineBreakpoint';
const COPY_STACK_TRACE_ID = 'debug.copyStackTrace';
const REVERSE_CONTINUE_ID = 'workbench.action.debug.reverseContinue';
const STEP_BACK_ID = 'workbench.action.debug.stepBack';
const RESTART_SESSION_ID = 'workbench.action.debug.restart';
const TERMINATE_THREAD_ID = 'workbench.action.debug.terminateThread';
const STEP_OVER_ID = 'workbench.action.debug.stepOver';
const STEP_INTO_ID = 'workbench.action.debug.stepInto';
const STEP_INTO_TARGET_ID = 'workbench.action.debug.stepIntoTarget';
const STEP_OUT_ID = 'workbench.action.debug.stepOut';
const PAUSE_ID = 'workbench.action.debug.pause';
const DISCONNECT_ID = 'workbench.action.debug.disconnect';
const DISCONNECT_AND_SUSPEND_ID = 'workbench.action.debug.disconnectAndSuspend';
const STOP_ID = 'workbench.action.debug.stop';
const RESTART_FRAME_ID = 'workbench.action.debug.restartFrame';
const CONTINUE_ID = 'workbench.action.debug.continue';
const FOCUS_REPL_ID = 'workbench.debug.action.focusRepl';
const JUMP_TO_CURSOR_ID = 'debug.jumpToCursor';
const FOCUS_SESSION_ID = 'workbench.action.debug.focusProcess';
const SELECT_AND_START_ID = 'workbench.action.debug.selectandstart';
const SELECT_DEBUG_CONSOLE_ID = 'workbench.action.debug.selectDebugConsole';
const SELECT_DEBUG_SESSION_ID = 'workbench.action.debug.selectDebugSession';
const DEBUG_CONFIGURE_COMMAND_ID = 'workbench.action.debug.configure';
const DEBUG_START_COMMAND_ID = 'workbench.action.debug.start';
const EDIT_EXPRESSION_COMMAND_ID = 'debug.renameWatchExpression';
const SET_EXPRESSION_COMMAND_ID = 'debug.setWatchExpression';
const REMOVE_EXPRESSION_COMMAND_ID = 'debug.removeWatchExpression';
const NEXT_DEBUG_CONSOLE_ID = 'workbench.action.debug.nextConsole';
const PREV_DEBUG_CONSOLE_ID = 'workbench.action.debug.prevConsole';
const SHOW_LOADED_SCRIPTS_ID = 'workbench.action.debug.showLoadedScripts';
const CALLSTACK_TOP_ID = 'workbench.action.debug.callStackTop';
const CALLSTACK_BOTTOM_ID = 'workbench.action.debug.callStackBottom';
const CALLSTACK_UP_ID = 'workbench.action.debug.callStackUp';
const CALLSTACK_DOWN_ID = 'workbench.action.debug.callStackDown';
const DEBUG_COMMAND_CATEGORY = { original: 'Debug', value: ( nls.localize('debug', 'Debug')) };
const RESTART_LABEL = { value: ( nls.localize('restartDebug', "Restart")), original: 'Restart' };
const STEP_OVER_LABEL = { value: ( nls.localize('stepOverDebug', "Step Over")), original: 'Step Over' };
const STEP_INTO_LABEL = { value: ( nls.localize('stepIntoDebug', "Step Into")), original: 'Step Into' };
const STEP_INTO_TARGET_LABEL = { value: ( nls.localize('stepIntoTargetDebug', "Step Into Target")), original: 'Step Into Target' };
const STEP_OUT_LABEL = { value: ( nls.localize('stepOutDebug', "Step Out")), original: 'Step Out' };
const PAUSE_LABEL = { value: ( nls.localize('pauseDebug', "Pause")), original: 'Pause' };
const DISCONNECT_LABEL = { value: ( nls.localize('disconnect', "Disconnect")), original: 'Disconnect' };
const DISCONNECT_AND_SUSPEND_LABEL = { value: ( nls.localize('disconnectSuspend', "Disconnect and Suspend")), original: 'Disconnect and Suspend' };
const STOP_LABEL = { value: ( nls.localize('stop', "Stop")), original: 'Stop' };
const CONTINUE_LABEL = { value: ( nls.localize('continueDebug', "Continue")), original: 'Continue' };
const FOCUS_SESSION_LABEL = { value: ( nls.localize('focusSession', "Focus Session")), original: 'Focus Session' };
const SELECT_AND_START_LABEL = { value: ( nls.localize('selectAndStartDebugging', "Select and Start Debugging")), original: 'Select and Start Debugging' };
const DEBUG_CONFIGURE_LABEL = ( nls.localize('openLaunchJson', "Open '{0}'", 'launch.json'));
const NEXT_DEBUG_CONSOLE_LABEL = { value: ( nls.localize('nextDebugConsole', "Focus Next Debug Console")), original: 'Focus Next Debug Console' };
const PREV_DEBUG_CONSOLE_LABEL = { value: ( nls.localize('prevDebugConsole', "Focus Previous Debug Console")), original: 'Focus Previous Debug Console' };
const OPEN_LOADED_SCRIPTS_LABEL = { value: ( nls.localize('openLoadedScript', "Open Loaded Script...")), original: 'Open Loaded Script...' };
const CALLSTACK_TOP_LABEL = { value: ( nls.localize('callStackTop', "Navigate to Top of Call Stack")), original: 'Navigate to Top of Call Stack' };
const CALLSTACK_BOTTOM_LABEL = { value: ( nls.localize('callStackBottom', "Navigate to Bottom of Call Stack")), original: 'Navigate to Bottom of Call Stack' };
const CALLSTACK_UP_LABEL = { value: ( nls.localize('callStackUp', "Navigate Up Call Stack")), original: 'Navigate Up Call Stack' };
const CALLSTACK_DOWN_LABEL = { value: ( nls.localize('callStackDown', "Navigate Down Call Stack")), original: 'Navigate Down Call Stack' };
const SELECT_DEBUG_CONSOLE_LABEL = { value: ( nls.localize('selectDebugConsole', "Select Debug Console")), original: 'Select Debug Console' };
const SELECT_DEBUG_SESSION_LABEL = { value: ( nls.localize('selectDebugSession', "Select Debug Session")), original: 'Select Debug Session' };
const DEBUG_QUICK_ACCESS_PREFIX = 'debug ';
const DEBUG_CONSOLE_QUICK_ACCESS_PREFIX = 'debug consoles ';
function isThreadContext(obj) {
    return obj && typeof obj.sessionId === 'string' && typeof obj.threadId === 'string';
}
async function getThreadAndRun(accessor, sessionAndThreadId, run) {
    const debugService = accessor.get(IDebugService);
    let thread;
    if (isThreadContext(sessionAndThreadId)) {
        const session = debugService.getModel().getSession(sessionAndThreadId.sessionId);
        if (session) {
            thread = session.getAllThreads().find(t => t.getId() === sessionAndThreadId.threadId);
        }
    }
    else if (isSessionContext(sessionAndThreadId)) {
        const session = debugService.getModel().getSession(sessionAndThreadId.sessionId);
        if (session) {
            const threads = session.getAllThreads();
            thread = threads.length > 0 ? threads[0] : undefined;
        }
    }
    if (!thread) {
        thread = debugService.getViewModel().focusedThread;
        if (!thread) {
            const focusedSession = debugService.getViewModel().focusedSession;
            const threads = focusedSession ? focusedSession.getAllThreads() : undefined;
            thread = threads && threads.length ? threads[0] : undefined;
        }
    }
    if (thread) {
        await run(thread);
    }
}
function isStackFrameContext(obj) {
    return obj && typeof obj.sessionId === 'string' && typeof obj.threadId === 'string' && typeof obj.frameId === 'string';
}
function getFrame(debugService, context) {
    if (isStackFrameContext(context)) {
        const session = debugService.getModel().getSession(context.sessionId);
        if (session) {
            const thread = session.getAllThreads().find(t => t.getId() === context.threadId);
            if (thread) {
                return thread.getCallStack().find(sf => sf.getId() === context.frameId);
            }
        }
    }
    else {
        return debugService.getViewModel().focusedStackFrame;
    }
    return undefined;
}
function isSessionContext(obj) {
    return obj && typeof obj.sessionId === 'string';
}
async function changeDebugConsoleFocus(accessor, next) {
    const debugService = accessor.get(IDebugService);
    const viewsService = accessor.get(IViewsService);
    const sessions = debugService.getModel().getSessions(true).filter(s => s.hasSeparateRepl());
    let currSession = debugService.getViewModel().focusedSession;
    let nextIndex = 0;
    if (sessions.length > 0 && currSession) {
        while (currSession && !currSession.hasSeparateRepl()) {
            currSession = currSession.parentSession;
        }
        if (currSession) {
            const currIndex = sessions.indexOf(currSession);
            if (next) {
                nextIndex = (currIndex === (sessions.length - 1) ? 0 : (currIndex + 1));
            }
            else {
                nextIndex = (currIndex === 0 ? (sessions.length - 1) : (currIndex - 1));
            }
        }
    }
    await debugService.focusStackFrame(undefined, undefined, sessions[nextIndex], { explicit: true });
    if (!viewsService.isViewVisible(REPL_VIEW_ID)) {
        await viewsService.openView(REPL_VIEW_ID, true);
    }
}
async function navigateCallStack(debugService, down) {
    const frame = debugService.getViewModel().focusedStackFrame;
    if (frame) {
        let callStack = frame.thread.getCallStack();
        let index = callStack.findIndex(elem => elem.frameId === frame.frameId);
        let nextVisibleFrame;
        if (down) {
            if (index >= callStack.length - 1) {
                if (frame.thread.reachedEndOfCallStack) {
                    goToTopOfCallStack(debugService);
                    return;
                }
                else {
                    await debugService.getModel().fetchCallstack(frame.thread, 20);
                    callStack = frame.thread.getCallStack();
                    index = callStack.findIndex(elem => elem.frameId === frame.frameId);
                }
            }
            nextVisibleFrame = findNextVisibleFrame(true, callStack, index);
        }
        else {
            if (index <= 0) {
                goToBottomOfCallStack(debugService);
                return;
            }
            nextVisibleFrame = findNextVisibleFrame(false, callStack, index);
        }
        if (nextVisibleFrame) {
            debugService.focusStackFrame(nextVisibleFrame);
        }
    }
}
async function goToBottomOfCallStack(debugService) {
    const thread = debugService.getViewModel().focusedThread;
    if (thread) {
        await debugService.getModel().fetchCallstack(thread);
        const callStack = thread.getCallStack();
        if (callStack.length > 0) {
            const nextVisibleFrame = findNextVisibleFrame(false, callStack, 0);
            if (nextVisibleFrame) {
                debugService.focusStackFrame(nextVisibleFrame);
            }
        }
    }
}
function goToTopOfCallStack(debugService) {
    const thread = debugService.getViewModel().focusedThread;
    if (thread) {
        debugService.focusStackFrame(thread.getTopStackFrame());
    }
}
function findNextVisibleFrame(down, callStack, startIndex) {
    if (startIndex >= callStack.length) {
        startIndex = callStack.length - 1;
    }
    else if (startIndex < 0) {
        startIndex = 0;
    }
    let index = startIndex;
    let currFrame;
    do {
        if (down) {
            if (index === callStack.length - 1) {
                index = 0;
            }
            else {
                index++;
            }
        }
        else {
            if (index === 0) {
                index = callStack.length - 1;
            }
            else {
                index--;
            }
        }
        currFrame = callStack[index];
        if (!(currFrame.source.presentationHint === 'deemphasize' || currFrame.presentationHint === 'deemphasize')) {
            return currFrame;
        }
    } while (index !== startIndex);
    return undefined;
}
CommandsRegistry.registerCommand({
    id: COPY_STACK_TRACE_ID,
    handler: async (accessor, _, context) => {
        const textResourcePropertiesService = accessor.get(ITextResourcePropertiesService);
        const clipboardService = accessor.get(IClipboardService);
        const debugService = accessor.get(IDebugService);
        const frame = getFrame(debugService, context);
        if (frame) {
            const eol = textResourcePropertiesService.getEOL(frame.source.uri);
            await clipboardService.writeText(( frame.thread.getCallStack().map(sf => ( sf.toString()))).join(eol));
        }
    }
});
CommandsRegistry.registerCommand({
    id: REVERSE_CONTINUE_ID,
    handler: async (accessor, _, context) => {
        await getThreadAndRun(accessor, context, thread => thread.reverseContinue());
    }
});
CommandsRegistry.registerCommand({
    id: STEP_BACK_ID,
    handler: async (accessor, _, context) => {
        const contextKeyService = accessor.get(IContextKeyService);
        if (CONTEXT_DISASSEMBLY_VIEW_FOCUS.getValue(contextKeyService)) {
            await getThreadAndRun(accessor, context, (thread) => thread.stepBack('instruction'));
        }
        else {
            await getThreadAndRun(accessor, context, (thread) => thread.stepBack());
        }
    }
});
CommandsRegistry.registerCommand({
    id: TERMINATE_THREAD_ID,
    handler: async (accessor, _, context) => {
        await getThreadAndRun(accessor, context, thread => thread.terminate());
    }
});
CommandsRegistry.registerCommand({
    id: JUMP_TO_CURSOR_ID,
    handler: async (accessor) => {
        const debugService = accessor.get(IDebugService);
        const stackFrame = debugService.getViewModel().focusedStackFrame;
        const editorService = accessor.get(IEditorService);
        const activeEditorControl = editorService.activeTextEditorControl;
        const notificationService = accessor.get(INotificationService);
        const quickInputService = accessor.get(IQuickInputService);
        if (stackFrame && isCodeEditor(activeEditorControl) && activeEditorControl.hasModel()) {
            const position = activeEditorControl.getPosition();
            const resource = activeEditorControl.getModel().uri;
            const source = stackFrame.thread.session.getSourceForUri(resource);
            if (source) {
                const response = await stackFrame.thread.session.gotoTargets(source.raw, position.lineNumber, position.column);
                const targets = response?.body.targets;
                if (targets && targets.length) {
                    let id = targets[0].id;
                    if (targets.length > 1) {
                        const picks = ( targets.map(t => ({ label: t.label, _id: t.id })));
                        const pick = await quickInputService.pick(picks, { placeHolder: ( nls.localize('chooseLocation', "Choose the specific location")) });
                        if (!pick) {
                            return;
                        }
                        id = pick._id;
                    }
                    return await stackFrame.thread.session.goto(stackFrame.thread.threadId, id).catch(e => notificationService.warn(e));
                }
            }
        }
        return notificationService.warn(( nls.localize(
            'noExecutableCode',
            "No executable code is associated at the current cursor position."
        )));
    }
});
CommandsRegistry.registerCommand({
    id: CALLSTACK_TOP_ID,
    handler: async (accessor, _, context) => {
        const debugService = accessor.get(IDebugService);
        goToTopOfCallStack(debugService);
    }
});
CommandsRegistry.registerCommand({
    id: CALLSTACK_BOTTOM_ID,
    handler: async (accessor, _, context) => {
        const debugService = accessor.get(IDebugService);
        await goToBottomOfCallStack(debugService);
    }
});
CommandsRegistry.registerCommand({
    id: CALLSTACK_UP_ID,
    handler: async (accessor, _, context) => {
        const debugService = accessor.get(IDebugService);
        navigateCallStack(debugService, false);
    }
});
CommandsRegistry.registerCommand({
    id: CALLSTACK_DOWN_ID,
    handler: async (accessor, _, context) => {
        const debugService = accessor.get(IDebugService);
        navigateCallStack(debugService, true);
    }
});
MenuRegistry.appendMenuItem(MenuId.EditorContext, {
    command: {
        id: JUMP_TO_CURSOR_ID,
        title: ( nls.localize('jumpToCursor', "Jump to Cursor")),
        category: DEBUG_COMMAND_CATEGORY
    },
    when: ( ContextKeyExpr.and(CONTEXT_JUMP_TO_CURSOR_SUPPORTED, EditorContextKeys.editorTextFocus)),
    group: 'debug',
    order: 3
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: NEXT_DEBUG_CONSOLE_ID,
    weight: 200  + 1,
    when: CONTEXT_IN_DEBUG_REPL,
    primary: 2048  | 12 ,
    mac: { primary: 1024  | 2048  | 94  },
    handler: async (accessor, _, context) => {
        changeDebugConsoleFocus(accessor, true);
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: PREV_DEBUG_CONSOLE_ID,
    weight: 200  + 1,
    when: CONTEXT_IN_DEBUG_REPL,
    primary: 2048  | 11 ,
    mac: { primary: 1024  | 2048  | 92  },
    handler: async (accessor, _, context) => {
        changeDebugConsoleFocus(accessor, false);
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: RESTART_SESSION_ID,
    weight: 200 ,
    primary: 1024  | 2048  | 63 ,
    when: CONTEXT_IN_DEBUG_MODE,
    handler: async (accessor, _, context) => {
        const debugService = accessor.get(IDebugService);
        const configurationService = accessor.get(IConfigurationService);
        let session;
        if (isSessionContext(context)) {
            session = debugService.getModel().getSession(context.sessionId);
        }
        else {
            session = debugService.getViewModel().focusedSession;
        }
        if (!session) {
            const { launch, name } = debugService.getConfigurationManager().selectedConfiguration;
            await debugService.startDebugging(launch, name, { noDebug: false, startedByUser: true });
        }
        else {
            const showSubSessions = configurationService.getValue('debug').showSubSessionsInToolBar;
            while (!showSubSessions && session.lifecycleManagedByParent && session.parentSession) {
                session = session.parentSession;
            }
            session.removeReplExpressions();
            await debugService.restartSession(session);
        }
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: STEP_OVER_ID,
    weight: 200 ,
    primary: 68 ,
    secondary: isWeb ? [((512  | 68) )] : undefined,
    when: ( CONTEXT_DEBUG_STATE.isEqualTo('stopped')),
    handler: async (accessor, _, context) => {
        const contextKeyService = accessor.get(IContextKeyService);
        if (CONTEXT_DISASSEMBLY_VIEW_FOCUS.getValue(contextKeyService)) {
            await getThreadAndRun(accessor, context, (thread) => thread.next('instruction'));
        }
        else {
            await getThreadAndRun(accessor, context, (thread) => thread.next());
        }
    }
});
const STEP_INTO_KEYBINDING = (isWeb && isWindows) ? ((512  | 69) ) : 69 ;
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: STEP_INTO_ID,
    weight: 200  + 10,
    primary: STEP_INTO_KEYBINDING,
    when: ( CONTEXT_DEBUG_STATE.notEqualsTo('inactive')),
    handler: async (accessor, _, context) => {
        const contextKeyService = accessor.get(IContextKeyService);
        if (CONTEXT_DISASSEMBLY_VIEW_FOCUS.getValue(contextKeyService)) {
            await getThreadAndRun(accessor, context, (thread) => thread.stepIn('instruction'));
        }
        else {
            await getThreadAndRun(accessor, context, (thread) => thread.stepIn());
        }
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: STEP_OUT_ID,
    weight: 200 ,
    primary: 1024  | 69 ,
    when: ( CONTEXT_DEBUG_STATE.isEqualTo('stopped')),
    handler: async (accessor, _, context) => {
        const contextKeyService = accessor.get(IContextKeyService);
        if (CONTEXT_DISASSEMBLY_VIEW_FOCUS.getValue(contextKeyService)) {
            await getThreadAndRun(accessor, context, (thread) => thread.stepOut('instruction'));
        }
        else {
            await getThreadAndRun(accessor, context, (thread) => thread.stepOut());
        }
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: PAUSE_ID,
    weight: 200  + 2,
    primary: 64 ,
    when: ( CONTEXT_DEBUG_STATE.isEqualTo('running')),
    handler: async (accessor, _, context) => {
        await getThreadAndRun(accessor, context, thread => thread.pause());
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: STEP_INTO_TARGET_ID,
    primary: STEP_INTO_KEYBINDING | 2048 ,
    when: ( ContextKeyExpr.and(CONTEXT_STEP_INTO_TARGETS_SUPPORTED, CONTEXT_IN_DEBUG_MODE, ( CONTEXT_DEBUG_STATE.isEqualTo('stopped')))),
    weight: 200 ,
    handler: async (accessor, _, context) => {
        const quickInputService = accessor.get(IQuickInputService);
        const debugService = accessor.get(IDebugService);
        const session = debugService.getViewModel().focusedSession;
        const frame = debugService.getViewModel().focusedStackFrame;
        if (!frame || !session) {
            return;
        }
        const editor = await accessor.get(IEditorService).openEditor({
            resource: frame.source.uri,
            options: { revealIfOpened: true }
        });
        let codeEditor;
        if (editor) {
            const ctrl = editor?.getControl();
            if (isCodeEditor(ctrl)) {
                codeEditor = ctrl;
            }
        }
        const qp = quickInputService.createQuickPick();
        qp.busy = true;
        qp.show();
        qp.onDidChangeActive(([item]) => {
            if (codeEditor && item && item.target.line !== undefined) {
                codeEditor.revealLineInCenterIfOutsideViewport(item.target.line);
                codeEditor.setSelection({
                    startLineNumber: item.target.line,
                    startColumn: item.target.column || 1,
                    endLineNumber: item.target.endLine || item.target.line,
                    endColumn: item.target.endColumn || item.target.column || 1,
                });
            }
        });
        qp.onDidAccept(() => {
            if (qp.activeItems.length) {
                session.stepIn(frame.thread.threadId, qp.activeItems[0].target.id);
            }
        });
        qp.onDidHide(() => qp.dispose());
        session.stepInTargets(frame.frameId).then(targets => {
            qp.busy = false;
            if (targets?.length) {
                qp.items = targets?.map(target => ({ target, label: target.label }));
            }
            else {
                qp.placeholder = ( nls.localize('editor.debug.action.stepIntoTargets.none', "No step targets available"));
            }
        });
    }
});
async function stopHandler(accessor, _, context, disconnect, suspend) {
    const debugService = accessor.get(IDebugService);
    let session;
    if (isSessionContext(context)) {
        session = debugService.getModel().getSession(context.sessionId);
    }
    else {
        session = debugService.getViewModel().focusedSession;
    }
    const configurationService = accessor.get(IConfigurationService);
    const showSubSessions = configurationService.getValue('debug').showSubSessionsInToolBar;
    while (!showSubSessions && session && session.lifecycleManagedByParent && session.parentSession) {
        session = session.parentSession;
    }
    await debugService.stopSession(session, disconnect, suspend);
}
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: DISCONNECT_ID,
    weight: 200 ,
    primary: 1024  | 63 ,
    when: ( ContextKeyExpr.and(CONTEXT_FOCUSED_SESSION_IS_ATTACH, CONTEXT_IN_DEBUG_MODE)),
    handler: (accessor, _, context) => stopHandler(accessor, _, context, true)
});
CommandsRegistry.registerCommand({
    id: DISCONNECT_AND_SUSPEND_ID,
    handler: (accessor, _, context) => stopHandler(accessor, _, context, true, true)
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: STOP_ID,
    weight: 200 ,
    primary: 1024  | 63 ,
    when: ( ContextKeyExpr.and(( CONTEXT_FOCUSED_SESSION_IS_ATTACH.toNegated()), CONTEXT_IN_DEBUG_MODE)),
    handler: (accessor, _, context) => stopHandler(accessor, _, context, false)
});
CommandsRegistry.registerCommand({
    id: RESTART_FRAME_ID,
    handler: async (accessor, _, context) => {
        const debugService = accessor.get(IDebugService);
        const notificationService = accessor.get(INotificationService);
        const frame = getFrame(debugService, context);
        if (frame) {
            try {
                await frame.restart();
            }
            catch (e) {
                notificationService.error(e);
            }
        }
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: CONTINUE_ID,
    weight: 200  + 10,
    primary: 63 ,
    when: ( CONTEXT_DEBUG_STATE.isEqualTo('stopped')),
    handler: async (accessor, _, context) => {
        await getThreadAndRun(accessor, context, thread => thread.continue());
    }
});
CommandsRegistry.registerCommand({
    id: SHOW_LOADED_SCRIPTS_ID,
    handler: async (accessor) => {
        await showLoadedScriptMenu(accessor);
    }
});
CommandsRegistry.registerCommand({
    id: FOCUS_REPL_ID,
    handler: async (accessor) => {
        const viewsService = accessor.get(IViewsService);
        await viewsService.openView(REPL_VIEW_ID, true);
    }
});
CommandsRegistry.registerCommand({
    id: 'debug.startFromConfig',
    handler: async (accessor, config) => {
        const debugService = accessor.get(IDebugService);
        await debugService.startDebugging(undefined, config);
    }
});
CommandsRegistry.registerCommand({
    id: FOCUS_SESSION_ID,
    handler: async (accessor, session) => {
        const debugService = accessor.get(IDebugService);
        const editorService = accessor.get(IEditorService);
        const stoppedChildSession = debugService.getModel().getSessions().find(s => s.parentSession === session && s.state === 2 );
        if (stoppedChildSession && session.state !== 2 ) {
            session = stoppedChildSession;
        }
        await debugService.focusStackFrame(undefined, undefined, session, { explicit: true });
        const stackFrame = debugService.getViewModel().focusedStackFrame;
        if (stackFrame) {
            await stackFrame.openInEditor(editorService, true);
        }
    }
});
CommandsRegistry.registerCommand({
    id: SELECT_AND_START_ID,
    handler: async (accessor) => {
        const quickInputService = accessor.get(IQuickInputService);
        quickInputService.quickAccess.show(DEBUG_QUICK_ACCESS_PREFIX);
    }
});
CommandsRegistry.registerCommand({
    id: SELECT_DEBUG_CONSOLE_ID,
    handler: async (accessor) => {
        const quickInputService = accessor.get(IQuickInputService);
        quickInputService.quickAccess.show(DEBUG_CONSOLE_QUICK_ACCESS_PREFIX);
    }
});
CommandsRegistry.registerCommand({
    id: SELECT_DEBUG_SESSION_ID,
    handler: async (accessor) => {
        showDebugSessionMenu(accessor, SELECT_AND_START_ID);
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: 'debug.toggleBreakpoint',
    weight: 200  + 5,
    when: ( ContextKeyExpr.and(CONTEXT_BREAKPOINTS_FOCUSED, ( InputFocusedContext.toNegated()))),
    primary: 10 ,
    handler: (accessor) => {
        const listService = accessor.get(IListService);
        const debugService = accessor.get(IDebugService);
        const list = listService.lastFocusedList;
        if (list instanceof List) {
            const focused = list.getFocusedElements();
            if (focused && focused.length) {
                debugService.enableOrDisableBreakpoints(!focused[0].enabled, focused[0]);
            }
        }
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: 'debug.enableOrDisableBreakpoint',
    weight: 200 ,
    primary: undefined,
    when: EditorContextKeys.editorTextFocus,
    handler: (accessor) => {
        const debugService = accessor.get(IDebugService);
        const editorService = accessor.get(IEditorService);
        const control = editorService.activeTextEditorControl;
        if (isCodeEditor(control)) {
            const model = control.getModel();
            if (model) {
                const position = control.getPosition();
                if (position) {
                    const bps = debugService.getModel().getBreakpoints({ uri: model.uri, lineNumber: position.lineNumber });
                    if (bps.length) {
                        debugService.enableOrDisableBreakpoints(!bps[0].enabled, bps[0]);
                    }
                }
            }
        }
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: EDIT_EXPRESSION_COMMAND_ID,
    weight: 200  + 5,
    when: CONTEXT_WATCH_EXPRESSIONS_FOCUSED,
    primary: 60 ,
    mac: { primary: 3  },
    handler: (accessor, expression) => {
        const debugService = accessor.get(IDebugService);
        if (!(expression instanceof Expression)) {
            const listService = accessor.get(IListService);
            const focused = listService.lastFocusedList;
            if (focused) {
                const elements = focused.getFocus();
                if (Array.isArray(elements) && elements[0] instanceof Expression) {
                    expression = elements[0];
                }
            }
        }
        if (expression instanceof Expression) {
            debugService.getViewModel().setSelectedExpression(expression, false);
        }
    }
});
CommandsRegistry.registerCommand({
    id: SET_EXPRESSION_COMMAND_ID,
    handler: async (accessor, expression) => {
        const debugService = accessor.get(IDebugService);
        if (expression instanceof Expression || expression instanceof Variable) {
            debugService.getViewModel().setSelectedExpression(expression, true);
        }
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: 'debug.setVariable',
    weight: 200  + 5,
    when: CONTEXT_VARIABLES_FOCUSED,
    primary: 60 ,
    mac: { primary: 3  },
    handler: (accessor) => {
        const listService = accessor.get(IListService);
        const debugService = accessor.get(IDebugService);
        const focused = listService.lastFocusedList;
        if (focused) {
            const elements = focused.getFocus();
            if (Array.isArray(elements) && elements[0] instanceof Variable) {
                debugService.getViewModel().setSelectedExpression(elements[0], false);
            }
        }
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: REMOVE_EXPRESSION_COMMAND_ID,
    weight: 200 ,
    when: ( ContextKeyExpr.and(CONTEXT_WATCH_EXPRESSIONS_FOCUSED, ( CONTEXT_EXPRESSION_SELECTED.toNegated()))),
    primary: 20 ,
    mac: { primary: 2048  | 1  },
    handler: (accessor, expression) => {
        const debugService = accessor.get(IDebugService);
        if (expression instanceof Expression) {
            debugService.removeWatchExpressions(expression.getId());
            return;
        }
        const listService = accessor.get(IListService);
        const focused = listService.lastFocusedList;
        if (focused) {
            let elements = focused.getFocus();
            if (Array.isArray(elements) && elements[0] instanceof Expression) {
                const selection = focused.getSelection();
                if (selection && selection.indexOf(elements[0]) >= 0) {
                    elements = selection;
                }
                elements.forEach((e) => debugService.removeWatchExpressions(e.getId()));
            }
        }
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: 'debug.removeBreakpoint',
    weight: 200 ,
    when: ( ContextKeyExpr.and(CONTEXT_BREAKPOINTS_FOCUSED, ( CONTEXT_BREAKPOINT_INPUT_FOCUSED.toNegated()))),
    primary: 20 ,
    mac: { primary: 2048  | 1  },
    handler: (accessor) => {
        const listService = accessor.get(IListService);
        const debugService = accessor.get(IDebugService);
        const list = listService.lastFocusedList;
        if (list instanceof List) {
            const focused = list.getFocusedElements();
            const element = focused.length ? focused[0] : undefined;
            if (element instanceof Breakpoint) {
                debugService.removeBreakpoints(element.getId());
            }
            else if (element instanceof FunctionBreakpoint) {
                debugService.removeFunctionBreakpoints(element.getId());
            }
            else if (element instanceof DataBreakpoint) {
                debugService.removeDataBreakpoints(element.getId());
            }
        }
    }
});
const inlineBreakpointHandler = (accessor) => {
    const debugService = accessor.get(IDebugService);
    const editorService = accessor.get(IEditorService);
    const control = editorService.activeTextEditorControl;
    if (isCodeEditor(control)) {
        const position = control.getPosition();
        if (position && control.hasModel() && debugService.canSetBreakpointsIn(control.getModel())) {
            const modelUri = control.getModel().uri;
            const breakpointAlreadySet = ( debugService.getModel().getBreakpoints({ lineNumber: position.lineNumber, uri: modelUri })
                .some(
                bp => (bp.sessionAgnosticData.column === position.column || (!bp.column && position.column <= 1))
            ));
            if (!breakpointAlreadySet) {
                debugService.addBreakpoints(modelUri, [{ lineNumber: position.lineNumber, column: position.column > 1 ? position.column : undefined }]);
            }
        }
    }
};
KeybindingsRegistry.registerCommandAndKeybindingRule({
    weight: 200 ,
    primary: 1024  | 67 ,
    when: EditorContextKeys.editorTextFocus,
    id: TOGGLE_INLINE_BREAKPOINT_ID,
    handler: inlineBreakpointHandler
});
MenuRegistry.appendMenuItem(MenuId.EditorContext, {
    command: {
        id: TOGGLE_INLINE_BREAKPOINT_ID,
        title: ( nls.localize('addInlineBreakpoint', "Add Inline Breakpoint")),
        category: DEBUG_COMMAND_CATEGORY
    },
    when: ( ContextKeyExpr.and(CONTEXT_IN_DEBUG_MODE, ( PanelFocusContext.toNegated()), EditorContextKeys.editorTextFocus)),
    group: 'debug',
    order: 1
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: 'debug.openBreakpointToSide',
    weight: 200 ,
    when: CONTEXT_BREAKPOINTS_FOCUSED,
    primary: 2048  | 3 ,
    secondary: [512  | 3 ],
    handler: (accessor) => {
        const listService = accessor.get(IListService);
        const list = listService.lastFocusedList;
        if (list instanceof List) {
            const focus = list.getFocusedElements();
            if (focus.length && focus[0] instanceof Breakpoint) {
                return openBreakpointSource(focus[0], true, false, true, accessor.get(IDebugService), accessor.get(IEditorService));
            }
        }
        return undefined;
    }
});
export { ADD_CONFIGURATION_ID, CALLSTACK_BOTTOM_ID, CALLSTACK_BOTTOM_LABEL, CALLSTACK_DOWN_ID, CALLSTACK_DOWN_LABEL, CALLSTACK_TOP_ID, CALLSTACK_TOP_LABEL, CALLSTACK_UP_ID, CALLSTACK_UP_LABEL, CONTINUE_ID, CONTINUE_LABEL, COPY_STACK_TRACE_ID, DEBUG_COMMAND_CATEGORY, DEBUG_CONFIGURE_COMMAND_ID, DEBUG_CONFIGURE_LABEL, DEBUG_CONSOLE_QUICK_ACCESS_PREFIX, DEBUG_QUICK_ACCESS_PREFIX, DEBUG_START_COMMAND_ID, DISCONNECT_AND_SUSPEND_ID, DISCONNECT_AND_SUSPEND_LABEL, DISCONNECT_ID, DISCONNECT_LABEL, EDIT_EXPRESSION_COMMAND_ID, FOCUS_REPL_ID, FOCUS_SESSION_ID, FOCUS_SESSION_LABEL, JUMP_TO_CURSOR_ID, NEXT_DEBUG_CONSOLE_ID, NEXT_DEBUG_CONSOLE_LABEL, OPEN_LOADED_SCRIPTS_LABEL, PAUSE_ID, PAUSE_LABEL, PREV_DEBUG_CONSOLE_ID, PREV_DEBUG_CONSOLE_LABEL, REMOVE_EXPRESSION_COMMAND_ID, RESTART_FRAME_ID, RESTART_LABEL, RESTART_SESSION_ID, REVERSE_CONTINUE_ID, SELECT_AND_START_ID, SELECT_AND_START_LABEL, SELECT_DEBUG_CONSOLE_ID, SELECT_DEBUG_CONSOLE_LABEL, SELECT_DEBUG_SESSION_ID, SELECT_DEBUG_SESSION_LABEL, SET_EXPRESSION_COMMAND_ID, SHOW_LOADED_SCRIPTS_ID, STEP_BACK_ID, STEP_INTO_ID, STEP_INTO_LABEL, STEP_INTO_TARGET_ID, STEP_INTO_TARGET_LABEL, STEP_OUT_ID, STEP_OUT_LABEL, STEP_OVER_ID, STEP_OVER_LABEL, STOP_ID, STOP_LABEL, TERMINATE_THREAD_ID, TOGGLE_INLINE_BREAKPOINT_ID };
