import { bufferToStream, streamToBuffer } from 'monaco-editor/esm/vs/base/common/buffer.js';
import { CancellationError } from 'monaco-editor/esm/vs/base/common/errors.js';
import { Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { Schemas } from 'monaco-editor/esm/vs/base/common/network.js';
import { filter } from 'monaco-editor/esm/vs/base/common/objects.js';
import { NotebookCellsChangeType, NotebookSetting } from './notebookCommon.js';
import { SimpleNotebookProviderInfo } from './notebookService.js';
class NotebookFileWorkingCopyModel extends Disposable {
    constructor(_notebookModel, _notebookService, _configurationService) {
        super();
        this._notebookModel = _notebookModel;
        this._notebookService = _notebookService;
        this._configurationService = _configurationService;
        this._onDidChangeContent = this._register(( new Emitter()));
        this.onDidChangeContent = this._onDidChangeContent.event;
        this.configuration = undefined;
        this.onWillDispose = _notebookModel.onWillDispose.bind(_notebookModel);
        this._register(_notebookModel.onDidChangeContent(e => {
            for (const rawEvent of e.rawEvents) {
                if (rawEvent.kind === NotebookCellsChangeType.Initialize) {
                    continue;
                }
                if (rawEvent.transient) {
                    continue;
                }
                this._onDidChangeContent.fire({
                    isRedoing: false,
                    isUndoing: false,
                    isInitial: false,
                });
                break;
            }
        }));
        if (_notebookModel.uri.scheme === Schemas.vscodeRemote) {
            this.configuration = {
                backupDelay: 10000
            };
            if (this._configurationService.getValue(NotebookSetting.remoteSaving)) {
                this.save = async (options, token) => {
                    const serializer = await this.getNotebookSerializer();
                    if (token.isCancellationRequested) {
                        throw new CancellationError();
                    }
                    const stat = await serializer.save(this._notebookModel.uri, this._notebookModel.versionId, options, token);
                    return stat;
                };
            }
        }
    }
    dispose() {
        this._notebookModel.dispose();
        super.dispose();
    }
    get notebookModel() {
        return this._notebookModel;
    }
    async snapshot(token) {
        const serializer = await this.getNotebookSerializer();
        const data = {
            metadata: filter(this._notebookModel.metadata, key => !serializer.options.transientDocumentMetadata[key]),
            cells: [],
        };
        for (const cell of this._notebookModel.cells) {
            const cellData = {
                cellKind: cell.cellKind,
                language: cell.language,
                mime: cell.mime,
                source: cell.getValue(),
                outputs: [],
                internalMetadata: cell.internalMetadata
            };
            cellData.outputs = !serializer.options.transientOutputs ? cell.outputs : [];
            cellData.metadata = filter(cell.metadata, key => !serializer.options.transientCellMetadata[key]);
            data.cells.push(cellData);
        }
        const bytes = await serializer.notebookToData(data);
        if (token.isCancellationRequested) {
            throw new CancellationError();
        }
        return bufferToStream(bytes);
    }
    async update(stream, token) {
        const serializer = await this.getNotebookSerializer();
        const bytes = await streamToBuffer(stream);
        const data = await serializer.dataToNotebook(bytes);
        if (token.isCancellationRequested) {
            throw new CancellationError();
        }
        this._notebookModel.reset(data.cells, data.metadata, serializer.options);
    }
    async getNotebookSerializer() {
        const info = await this._notebookService.withNotebookDataProvider(this.notebookModel.viewType);
        if (!(info instanceof SimpleNotebookProviderInfo)) {
            throw new Error('CANNOT open file notebook with this provider');
        }
        return info.serializer;
    }
    get versionId() {
        return this._notebookModel.alternativeVersionId;
    }
    pushStackElement() {
        this._notebookModel.pushStackElement('save', undefined, undefined);
    }
}
export { NotebookFileWorkingCopyModel };
