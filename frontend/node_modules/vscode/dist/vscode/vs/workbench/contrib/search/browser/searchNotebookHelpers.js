import { TextSearchMatch } from '../../../services/search/common/search.js';
import { Range } from 'monaco-editor/esm/vs/editor/common/core/range.js';
import { PieceTreeTextBufferBuilder } from 'monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';
import { SearchParams } from 'monaco-editor/esm/vs/editor/common/model/textModelSearch.js';
import { Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
function isIFileMatchWithCells(object) {
    return 'cellResults' in object;
}
function contentMatchesToTextSearchMatches(contentMatches, cell) {
    let previousEndLine = -1;
    const contextGroupings = [];
    let currentContextGrouping = [];
    contentMatches.forEach((match) => {
        if (match.range.startLineNumber !== previousEndLine) {
            if (currentContextGrouping.length > 0) {
                contextGroupings.push([...currentContextGrouping]);
                currentContextGrouping = [];
            }
        }
        currentContextGrouping.push(match);
        previousEndLine = match.range.endLineNumber;
    });
    if (currentContextGrouping.length > 0) {
        contextGroupings.push([...currentContextGrouping]);
    }
    const textSearchResults = ( contextGroupings.map((grouping) => {
        const lineTexts = [];
        const firstLine = grouping[0].range.startLineNumber;
        const lastLine = grouping[grouping.length - 1].range.endLineNumber;
        for (let i = firstLine; i <= lastLine; i++) {
            lineTexts.push(cell.textBuffer.getLineContent(i));
        }
        return ( new TextSearchMatch(lineTexts.join('\n') + '\n', ( grouping.map(m => ( new Range(
            m.range.startLineNumber - 1,
            m.range.startColumn - 1,
            m.range.endLineNumber - 1,
            m.range.endColumn - 1
        ))))));
    }));
    return textSearchResults;
}
function webviewMatchesToTextSearchMatches(webviewMatches) {
    return ( webviewMatches
        .map(rawMatch => (rawMatch.searchPreviewInfo) ?
        ( new TextSearchMatch(rawMatch.searchPreviewInfo.line, ( new Range(
            0,
            rawMatch.searchPreviewInfo.range.start,
            0,
            rawMatch.searchPreviewInfo.range.end
        )), undefined, rawMatch.index)) : undefined)).filter((e) => !!e);
}
const rawCellPrefix = 'rawCell#';
class CellSearchModel extends Disposable {
    constructor(_source, _textBuffer, _uri, _cellIndex) {
        super();
        this._source = _source;
        this._textBuffer = _textBuffer;
        this._uri = _uri;
        this._cellIndex = _cellIndex;
    }
    get id() {
        return `${rawCellPrefix}${this._cellIndex}`;
    }
    get uri() {
        return this._uri;
    }
    getFullModelRange() {
        const lineCount = this.textBuffer.getLineCount();
        return ( new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount)));
    }
    getLineMaxColumn(lineNumber) {
        if (lineNumber < 1 || lineNumber > this.textBuffer.getLineCount()) {
            throw new Error('Illegal value for lineNumber');
        }
        return this.textBuffer.getLineLength(lineNumber) + 1;
    }
    get textBuffer() {
        if (this._textBuffer) {
            return this._textBuffer;
        }
        const builder = ( new PieceTreeTextBufferBuilder());
        builder.acceptChunk(this._source);
        const bufferFactory = builder.finish(true);
        const { textBuffer, disposable } = bufferFactory.create(1 );
        this._textBuffer = textBuffer;
        this._register(disposable);
        return this._textBuffer;
    }
    find(target) {
        const searchParams = ( new SearchParams(target, false, false, null));
        const searchData = searchParams.parseSearchRequest();
        if (!searchData) {
            return [];
        }
        const fullRange = this.getFullModelRange();
        return this.textBuffer.findMatchesLineByLine(fullRange, searchData, true, 5000);
    }
}
export { CellSearchModel, contentMatchesToTextSearchMatches, isIFileMatchWithCells, rawCellPrefix, webviewMatchesToTextSearchMatches };
