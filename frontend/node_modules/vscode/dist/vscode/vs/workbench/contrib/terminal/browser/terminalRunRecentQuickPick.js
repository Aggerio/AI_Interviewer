import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import { Toggle } from 'monaco-editor/esm/vs/base/browser/ui/toggle/toggle.js';
import { isMacintosh } from 'monaco-editor/esm/vs/base/common/platform.js';
import { IModelService } from 'monaco-editor/esm/vs/editor/common/services/model.js';
import { ITextModelService } from 'monaco-editor/esm/vs/editor/common/services/resolverService.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IQuickInputService } from 'monaco-editor/esm/vs/platform/quickinput/common/quickInput.js';
import { collapseTildePath } from '../../../../platform/terminal/common/terminalEnvironment.js';
import { asCssVariable, inputActiveOptionBorder, inputActiveOptionForeground, inputActiveOptionBackground } from 'monaco-editor/esm/vs/platform/theme/common/colorRegistry.js';
import { ThemeIcon } from 'monaco-editor/esm/vs/base/common/themables.js';
import { commandHistoryRemoveIcon, commandHistoryOutputIcon, commandHistoryFuzzySearchIcon } from './terminalIcons.js';
import { getCommandHistory, getShellFileHistory, getDirectoryHistory } from '../common/history.js';
import { terminalStrings } from '../common/terminalStrings.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { fromNow } from '../../../../base/common/date.js';
import { IEditorService } from '../../../services/editor/common/editorService.js';
import { showWithPinnedItems } from '../../../../platform/quickinput/browser/quickPickPin.js';
import { IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
async function showRunRecentQuickPick(accessor, instance, terminalInRunCommandPicker, type, filterMode, value) {
    if (!instance.xterm) {
        return;
    }
    const editorService = accessor.get(IEditorService);
    const instantiationService = accessor.get(IInstantiationService);
    const quickInputService = accessor.get(IQuickInputService);
    const storageService = accessor.get(IStorageService);
    const runRecentStorageKey = `${"terminal.pinnedRecentCommands" }.${instance.shellType}`;
    let placeholder;
    let items = [];
    const commandMap = ( new Set());
    const removeFromCommandHistoryButton = {
        iconClass: ThemeIcon.asClassName(commandHistoryRemoveIcon),
        tooltip: ( localize('removeCommand', "Remove from Command History"))
    };
    const commandOutputButton = {
        iconClass: ThemeIcon.asClassName(commandHistoryOutputIcon),
        tooltip: ( localize('viewCommandOutput', "View Command Output")),
        alwaysVisible: false
    };
    if (type === 'command') {
        placeholder = isMacintosh ? ( localize(
            'selectRecentCommandMac',
            'Select a command to run (hold Option-key to edit the command)'
        )) : ( localize(
            'selectRecentCommand',
            'Select a command to run (hold Alt-key to edit the command)'
        ));
        const cmdDetection = instance.capabilities.get(2 );
        const commands = cmdDetection?.commands;
        const executingCommand = cmdDetection?.executingCommand;
        if (executingCommand) {
            commandMap.add(executingCommand);
        }
        function formatLabel(label) {
            return label
                .replace(/\r?\n/g, '\u23CE')
                .replace(/\s\s\s+/g, '\u22EF');
        }
        if (commands && commands.length > 0) {
            for (const entry of commands) {
                const label = entry.command.trim();
                if (label.length === 0 || ( commandMap.has(label))) {
                    continue;
                }
                let description = collapseTildePath(entry.cwd, instance.userHome, instance.os === 1  ? '\\' : '/');
                if (entry.exitCode) {
                    if (entry.exitCode === -1) {
                        description += ' failed';
                    }
                    else {
                        description += ` exitCode: ${entry.exitCode}`;
                    }
                }
                description = description.trim();
                const buttons = [commandOutputButton];
                const lastItem = items.length > 0 ? items[items.length - 1] : undefined;
                if (lastItem?.type !== 'separator' && lastItem?.label === label) {
                    lastItem.id = ( entry.timestamp.toString());
                    lastItem.description = description;
                    continue;
                }
                items.push({
                    label: formatLabel(label),
                    rawLabel: label,
                    description,
                    id: ( entry.timestamp.toString()),
                    command: entry,
                    buttons: entry.hasOutput() ? buttons : undefined
                });
                commandMap.add(label);
            }
            items = items.reverse();
        }
        if (executingCommand) {
            items.unshift({
                label: formatLabel(executingCommand),
                rawLabel: executingCommand,
                description: cmdDetection.cwd
            });
        }
        if (items.length > 0) {
            items.unshift({ type: 'separator', label: terminalStrings.currentSessionCategory });
        }
        const history = instantiationService.invokeFunction(getCommandHistory);
        const previousSessionItems = [];
        for (const [label, info] of history.entries) {
            if (!( commandMap.has(label)) && info.shellType === instance.shellType) {
                previousSessionItems.unshift({
                    label: formatLabel(label),
                    rawLabel: label,
                    buttons: [removeFromCommandHistoryButton]
                });
                commandMap.add(label);
            }
        }
        if (previousSessionItems.length > 0) {
            items.push({ type: 'separator', label: terminalStrings.previousSessionCategory }, ...previousSessionItems);
        }
        const shellFileHistory = await instantiationService.invokeFunction(getShellFileHistory, instance.shellType);
        const dedupedShellFileItems = [];
        for (const label of shellFileHistory) {
            if (!( commandMap.has(label))) {
                dedupedShellFileItems.unshift({
                    label: formatLabel(label),
                    rawLabel: label
                });
            }
        }
        if (dedupedShellFileItems.length > 0) {
            items.push({ type: 'separator', label: ( localize('shellFileHistoryCategory', '{0} history', instance.shellType)) }, ...dedupedShellFileItems);
        }
    }
    else {
        placeholder = isMacintosh
            ? ( localize(
            'selectRecentDirectoryMac',
            'Select a directory to go to (hold Option-key to edit the command)'
        ))
            : ( localize(
            'selectRecentDirectory',
            'Select a directory to go to (hold Alt-key to edit the command)'
        ));
        const cwds = instance.capabilities.get(0 )?.cwds || [];
        if (cwds && cwds.length > 0) {
            for (const label of cwds) {
                items.push({ label, rawLabel: label });
            }
            items = items.reverse();
            items.unshift({ type: 'separator', label: terminalStrings.currentSessionCategory });
        }
        const history = instantiationService.invokeFunction(getDirectoryHistory);
        const previousSessionItems = [];
        for (const [label, info] of history.entries) {
            if ((info === null || info.remoteAuthority === instance.remoteAuthority) && !cwds.includes(label)) {
                previousSessionItems.unshift({
                    label,
                    rawLabel: label,
                    buttons: [removeFromCommandHistoryButton]
                });
            }
        }
        if (previousSessionItems.length > 0) {
            items.push({ type: 'separator', label: terminalStrings.previousSessionCategory }, ...previousSessionItems);
        }
    }
    if (items.length === 0) {
        return;
    }
    const fuzzySearchToggle = ( new Toggle({
        title: 'Fuzzy search',
        icon: commandHistoryFuzzySearchIcon,
        isChecked: filterMode === 'fuzzy',
        inputActiveOptionBorder: asCssVariable(inputActiveOptionBorder),
        inputActiveOptionForeground: asCssVariable(inputActiveOptionForeground),
        inputActiveOptionBackground: asCssVariable(inputActiveOptionBackground)
    }));
    fuzzySearchToggle.onChange(() => {
        instantiationService.invokeFunction(showRunRecentQuickPick, instance, terminalInRunCommandPicker, type, fuzzySearchToggle.checked ? 'fuzzy' : 'contiguous', quickPick.value);
    });
    const outputProvider = instantiationService.createInstance(TerminalOutputProvider);
    const quickPick = quickInputService.createQuickPick();
    const originalItems = items;
    quickPick.items = [...originalItems];
    quickPick.sortByLabel = false;
    quickPick.placeholder = placeholder;
    quickPick.matchOnLabelMode = filterMode || 'contiguous';
    quickPick.toggles = [fuzzySearchToggle];
    quickPick.onDidTriggerItemButton(async (e) => {
        if (e.button === removeFromCommandHistoryButton) {
            if (type === 'command') {
                instantiationService.invokeFunction(getCommandHistory)?.remove(e.item.label);
            }
            else {
                instantiationService.invokeFunction(getDirectoryHistory)?.remove(e.item.label);
            }
        }
        else if (e.button === commandOutputButton) {
            const selectedCommand = e.item.command;
            const output = selectedCommand?.getOutput();
            if (output && selectedCommand?.command) {
                const textContent = await outputProvider.provideTextContent(( URI.from({
                    scheme: TerminalOutputProvider.scheme,
                    path: `${selectedCommand.command}... ${fromNow(selectedCommand.timestamp, true)}`,
                    fragment: output,
                    query: `terminal-output-${selectedCommand.timestamp}-${instance.instanceId}`
                })));
                if (textContent) {
                    await editorService.openEditor({
                        resource: textContent.uri
                    });
                }
            }
        }
        await instantiationService.invokeFunction(showRunRecentQuickPick, instance, terminalInRunCommandPicker, type, filterMode, value);
    });
    quickPick.onDidChangeValue(async (value) => {
        if (!value) {
            await instantiationService.invokeFunction(showRunRecentQuickPick, instance, terminalInRunCommandPicker, type, filterMode, value);
        }
    });
    quickPick.onDidAccept(async () => {
        const result = quickPick.activeItems[0];
        let text;
        if (type === 'cwd') {
            text = `cd ${await instance.preparePathForShell(result.rawLabel)}`;
        }
        else {
            text = result.rawLabel;
        }
        quickPick.hide();
        instance.runCommand(text, !quickPick.keyMods.alt);
        if (quickPick.keyMods.alt) {
            instance.focus();
        }
    });
    if (value) {
        quickPick.value = value;
    }
    return ( new Promise(r => {
        terminalInRunCommandPicker.set(true);
        showWithPinnedItems(storageService, runRecentStorageKey, quickPick, true);
        quickPick.onDidHide(() => {
            terminalInRunCommandPicker.set(false);
            r();
        });
    }));
}
let TerminalOutputProvider = class TerminalOutputProvider {
    static { this.scheme = 'TERMINAL_OUTPUT'; }
    constructor(textModelResolverService, _modelService) {
        this._modelService = _modelService;
        textModelResolverService.registerTextModelContentProvider(TerminalOutputProvider.scheme, this);
    }
    async provideTextContent(resource) {
        const existing = this._modelService.getModel(resource);
        if (existing && !existing.isDisposed()) {
            return existing;
        }
        return this._modelService.createModel(resource.fragment, null, resource, false);
    }
};
TerminalOutputProvider = ( __decorate([
    ( __param(0, ITextModelService)),
    ( __param(1, IModelService))
], TerminalOutputProvider));
export { showRunRecentQuickPick };
