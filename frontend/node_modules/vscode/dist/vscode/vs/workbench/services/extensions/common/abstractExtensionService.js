import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import { Barrier } from 'monaco-editor/esm/vs/base/common/async.js';
import { toErrorMessage } from 'monaco-editor/esm/vs/base/common/errorMessage.js';
import { Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { Schemas } from 'monaco-editor/esm/vs/base/common/network.js';
import * as performance from 'monaco-editor/esm/vs/base/common/performance.js';
import { isEqualOrParent } from 'monaco-editor/esm/vs/base/common/resources.js';
import { StopWatch } from 'monaco-editor/esm/vs/base/common/stopwatch.js';
import * as nls from 'monaco-editor/esm/vs/nls.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import '../../../../../../override/vs/platform/dialogs/common/dialogs.js';
import { ImplicitActivationEvents } from '../../../../platform/extensionManagement/common/implicitActivationEvents.js';
import { ExtensionIdentifierMap, ExtensionIdentifier } from 'monaco-editor/esm/vs/platform/extensions/common/extensions.js';
import { IFileService } from 'monaco-editor/esm/vs/platform/files/common/files.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { handleVetos } from '../../../../platform/lifecycle/common/lifecycle.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { Severity, INotificationService } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { IProductService } from 'monaco-editor/esm/vs/platform/product/common/productService.js';
import { RemoteAuthorityResolverError, getRemoteAuthorityPrefix, IRemoteAuthorityResolverService, RemoteAuthorityResolverErrorCode } from '../../../../platform/remote/common/remoteAuthorityResolver.js';
import { IRemoteExtensionsScannerService } from '../../../../platform/remote/common/remoteExtensionsScanner.js';
import { ITelemetryService } from 'monaco-editor/esm/vs/platform/telemetry/common/telemetry.js';
import { IWorkspaceContextService } from 'monaco-editor/esm/vs/platform/workspace/common/workspace.js';
import { IWorkbenchEnvironmentService } from '../../environment/common/environmentService.js';
import { IWorkbenchExtensionEnablementService, IWorkbenchExtensionManagementService } from '../../extensionManagement/common/extensionManagement.js';
import { LockableExtensionDescriptionRegistry } from './extensionDescriptionRegistry.js';
import { parseExtensionDevOptions } from './extensionDevOptions.js';
import { extensionHostKindToString } from './extensionHostKind.js';
import { createExtensionHostManager } from './extensionHostManager.js';
import { IExtensionManifestPropertiesService } from './extensionManifestPropertiesService.js';
import { RemoteRunningLocation, LocalProcessRunningLocation, LocalWebWorkerRunningLocation } from './extensionRunningLocation.js';
import { ExtensionRunningLocationTracker, filterExtensionIdentifiers } from './extensionRunningLocationTracker.js';
import { ExtensionPointContribution, ActivationTimes, toExtension } from './extensions.js';
import { ExtensionsRegistry, ExtensionMessageCollector } from './extensionsRegistry.js';
import { checkActivateWorkspaceContainsExtension, checkGlobFileExists } from './workspaceContains.js';
import { ILifecycleService } from '../../lifecycle/common/lifecycle.js';
import { IRemoteAgentService } from '../../remote/common/remoteAgentService.js';
import { IDialogService } from '../../../../platform/dialogs/common/dialogs.js';
const hasOwnProperty = Object.hasOwnProperty;
const NO_OP_VOID_PROMISE = Promise.resolve(undefined);
let AbstractExtensionService = class AbstractExtensionService extends Disposable {
    constructor(_extensionsProposedApi, _extensionHostFactory, _extensionHostKindPicker, _instantiationService, _notificationService, _environmentService, _telemetryService, _extensionEnablementService, _fileService, _productService, _extensionManagementService, _contextService, _configurationService, _extensionManifestPropertiesService, _logService, _remoteAgentService, _remoteExtensionsScannerService, _lifecycleService, _remoteAuthorityResolverService, _dialogService) {
        super();
        this._extensionsProposedApi = _extensionsProposedApi;
        this._extensionHostFactory = _extensionHostFactory;
        this._extensionHostKindPicker = _extensionHostKindPicker;
        this._instantiationService = _instantiationService;
        this._notificationService = _notificationService;
        this._environmentService = _environmentService;
        this._telemetryService = _telemetryService;
        this._extensionEnablementService = _extensionEnablementService;
        this._fileService = _fileService;
        this._productService = _productService;
        this._extensionManagementService = _extensionManagementService;
        this._contextService = _contextService;
        this._configurationService = _configurationService;
        this._extensionManifestPropertiesService = _extensionManifestPropertiesService;
        this._logService = _logService;
        this._remoteAgentService = _remoteAgentService;
        this._remoteExtensionsScannerService = _remoteExtensionsScannerService;
        this._lifecycleService = _lifecycleService;
        this._remoteAuthorityResolverService = _remoteAuthorityResolverService;
        this._dialogService = _dialogService;
        this._onDidRegisterExtensions = this._register(( (new Emitter())));
        this.onDidRegisterExtensions = this._onDidRegisterExtensions.event;
        this._onDidChangeExtensionsStatus = this._register(( (new Emitter())));
        this.onDidChangeExtensionsStatus = this._onDidChangeExtensionsStatus.event;
        this._onDidChangeExtensions = this._register(( (new Emitter({ leakWarningThreshold: 400 }))));
        this.onDidChangeExtensions = this._onDidChangeExtensions.event;
        this._onWillActivateByEvent = this._register(( (new Emitter())));
        this.onWillActivateByEvent = this._onWillActivateByEvent.event;
        this._onDidChangeResponsiveChange = this._register(( (new Emitter())));
        this.onDidChangeResponsiveChange = this._onDidChangeResponsiveChange.event;
        this._onWillStop = this._register(( (new Emitter())));
        this.onWillStop = this._onWillStop.event;
        this._activationEventReader = ( (new ImplicitActivationAwareReader()));
        this._registry = ( (new LockableExtensionDescriptionRegistry(this._activationEventReader)));
        this._installedExtensionsReady = ( (new Barrier()));
        this._extensionStatus = ( (new ExtensionIdentifierMap()));
        this._allRequestedActivateEvents = ( (new Set()));
        this._remoteCrashTracker = ( (new ExtensionHostCrashTracker()));
        this._deltaExtensionsQueue = [];
        this._inHandleDeltaExtensions = false;
        this._extensionHostManagers = [];
        this._resolveAuthorityAttempt = 0;
        this._register(this._fileService.onWillActivateFileSystemProvider(e => {
            if (e.scheme !== Schemas.vscodeRemote) {
                e.join(this.activateByEvent(`onFileSystem:${e.scheme}`));
            }
        }));
        this._runningLocations = ( (new ExtensionRunningLocationTracker(
            this._registry,
            this._extensionHostKindPicker,
            this._environmentService,
            this._configurationService,
            this._logService,
            this._extensionManifestPropertiesService
        )));
        this._register(this._extensionEnablementService.onEnablementChanged((extensions) => {
            const toAdd = [];
            const toRemove = [];
            for (const extension of extensions) {
                if (this._safeInvokeIsEnabled(extension)) {
                    toAdd.push(extension);
                }
                else {
                    toRemove.push(extension);
                }
            }
            this._handleDeltaExtensions(( (new DeltaExtensionsQueueItem(toAdd, toRemove))));
        }));
        this._register(this._extensionManagementService.onDidChangeProfile(({ added, removed }) => {
            if (added.length || removed.length) {
                this._handleDeltaExtensions(( (new DeltaExtensionsQueueItem(added, removed))));
            }
        }));
        this._register(this._extensionManagementService.onDidInstallExtensions((result) => {
            const extensions = [];
            for (const { local, operation } of result) {
                if (local && operation !== 4  && this._safeInvokeIsEnabled(local)) {
                    extensions.push(local);
                }
            }
            if (extensions.length) {
                this._handleDeltaExtensions(( (new DeltaExtensionsQueueItem(extensions, []))));
            }
        }));
        this._register(this._extensionManagementService.onDidUninstallExtension((event) => {
            if (!event.error) {
                this._handleDeltaExtensions(( (new DeltaExtensionsQueueItem([], [event.identifier.id]))));
            }
        }));
        this._register(this._lifecycleService.onDidShutdown(() => {
            const connection = this._remoteAgentService.getConnection();
            connection?.dispose();
            this._doStopExtensionHosts();
        }));
    }
    _getExtensionHostManagers(kind) {
        return this._extensionHostManagers.filter(extHostManager => extHostManager.kind === kind);
    }
    _getExtensionHostManagerByRunningLocation(runningLocation) {
        for (const extensionHostManager of this._extensionHostManagers) {
            if (extensionHostManager.representsRunningLocation(runningLocation)) {
                return extensionHostManager;
            }
        }
        return null;
    }
    async _handleDeltaExtensions(item) {
        this._deltaExtensionsQueue.push(item);
        if (this._inHandleDeltaExtensions) {
            return;
        }
        let lock = null;
        try {
            this._inHandleDeltaExtensions = true;
            await this._installedExtensionsReady.wait();
            lock = await this._registry.acquireLock('handleDeltaExtensions');
            while (this._deltaExtensionsQueue.length > 0) {
                const item = this._deltaExtensionsQueue.shift();
                await this._deltaExtensions(lock, item.toAdd, item.toRemove);
            }
        }
        finally {
            this._inHandleDeltaExtensions = false;
            lock?.dispose();
        }
    }
    async _deltaExtensions(lock, _toAdd, _toRemove) {
        let toRemove = [];
        for (let i = 0, len = _toRemove.length; i < len; i++) {
            const extensionOrId = _toRemove[i];
            const extensionId = (typeof extensionOrId === 'string' ? extensionOrId : extensionOrId.identifier.id);
            const extension = (typeof extensionOrId === 'string' ? null : extensionOrId);
            const extensionDescription = this._registry.getExtensionDescription(extensionId);
            if (!extensionDescription) {
                continue;
            }
            if (extension && extensionDescription.extensionLocation.scheme !== extension.location.scheme) {
                continue;
            }
            if (!this.canRemoveExtension(extensionDescription)) {
                continue;
            }
            toRemove.push(extensionDescription);
        }
        const toAdd = [];
        for (let i = 0, len = _toAdd.length; i < len; i++) {
            const extension = _toAdd[i];
            const extensionDescription = await this._scanSingleExtension(extension);
            if (!extensionDescription) {
                continue;
            }
            if (!this._canAddExtension(extensionDescription, toRemove)) {
                continue;
            }
            toAdd.push(extensionDescription);
        }
        if (toAdd.length === 0 && toRemove.length === 0) {
            return;
        }
        const result = this._registry.deltaExtensions(lock, toAdd, ( (toRemove.map(e => e.identifier))));
        this._onDidChangeExtensions.fire({ added: toAdd, removed: toRemove });
        toRemove = toRemove.concat(result.removedDueToLooping);
        if (result.removedDueToLooping.length > 0) {
            this._notificationService.notify({
                severity: Severity.Error,
                message: ( (nls.localize(
                    'looping',
                    "The following extensions contain dependency loops and have been disabled: {0}",
                    ( (result.removedDueToLooping.map(e => `'${e.identifier.value}'`))).join(', ')
                )))
            });
        }
        this._doHandleExtensionPoints([].concat(toAdd).concat(toRemove));
        await this._updateExtensionsOnExtHosts(toAdd, ( (toRemove.map(e => e.identifier))));
        for (let i = 0; i < toAdd.length; i++) {
            this._activateAddedExtensionIfNeeded(toAdd[i]);
        }
    }
    async _updateExtensionsOnExtHosts(toAdd, toRemove) {
        const removedRunningLocation = this._runningLocations.deltaExtensions(toAdd, toRemove);
        const promises = ( (this._extensionHostManagers.map(
            extHostManager => this._updateExtensionsOnExtHost(extHostManager, toAdd, toRemove, removedRunningLocation)
        )));
        await Promise.all(promises);
    }
    async _updateExtensionsOnExtHost(extensionHostManager, toAdd, toRemove, removedRunningLocation) {
        const myToAdd = this._runningLocations.filterByExtensionHostManager(toAdd, extensionHostManager);
        const myToRemove = filterExtensionIdentifiers(toRemove, removedRunningLocation, extRunningLocation => extensionHostManager.representsRunningLocation(extRunningLocation));
        const addActivationEvents = ImplicitActivationEvents.createActivationEventsMap(toAdd);
        await extensionHostManager.deltaExtensions({ toRemove, toAdd, addActivationEvents, myToRemove, myToAdd: ( (myToAdd.map(extension => extension.identifier))) });
    }
    canAddExtension(extension) {
        return this._canAddExtension(extension, []);
    }
    _canAddExtension(extension, extensionsBeingRemoved) {
        const existing = this._registry.getExtensionDescriptionByIdOrUUID(extension.identifier, extension.id);
        if (existing) {
            const isBeingRemoved = ( (extensionsBeingRemoved.some(
                (extensionDescription) => ExtensionIdentifier.equals(extension.identifier, extensionDescription.identifier)
            )));
            if (!isBeingRemoved) {
                return false;
            }
        }
        const extensionKinds = this._runningLocations.readExtensionKinds(extension);
        const isRemote = extension.extensionLocation.scheme === Schemas.vscodeRemote;
        const extensionHostKind = this._extensionHostKindPicker.pickExtensionHostKind(extension.identifier, extensionKinds, !isRemote, isRemote, 0 );
        if (extensionHostKind === null) {
            return false;
        }
        return true;
    }
    canRemoveExtension(extension) {
        const extensionDescription = this._registry.getExtensionDescription(extension.identifier);
        if (!extensionDescription) {
            return false;
        }
        if (this._extensionStatus.get(extensionDescription.identifier)?.activationStarted) {
            return false;
        }
        return true;
    }
    async _activateAddedExtensionIfNeeded(extensionDescription) {
        let shouldActivate = false;
        let shouldActivateReason = null;
        let hasWorkspaceContains = false;
        const activationEvents = this._activationEventReader.readActivationEvents(extensionDescription);
        for (let activationEvent of activationEvents) {
            if (activationEvent === 'onUri') {
                activationEvent = `onUri:${ExtensionIdentifier.toKey(extensionDescription.identifier)}`;
            }
            if (( (this._allRequestedActivateEvents.has(activationEvent)))) {
                shouldActivate = true;
                shouldActivateReason = activationEvent;
                break;
            }
            if (activationEvent === '*') {
                shouldActivate = true;
                shouldActivateReason = activationEvent;
                break;
            }
            if (/^workspaceContains/.test(activationEvent)) {
                hasWorkspaceContains = true;
            }
            if (activationEvent === 'onStartupFinished') {
                shouldActivate = true;
                shouldActivateReason = activationEvent;
                break;
            }
        }
        if (shouldActivate) {
            await Promise.all(( (this._extensionHostManagers.map(
                extHostManager => extHostManager.activate(extensionDescription.identifier, { startup: false, extensionId: extensionDescription.identifier, activationEvent: shouldActivateReason })
            )))).then(() => { });
        }
        else if (hasWorkspaceContains) {
            const workspace = await this._contextService.getCompleteWorkspace();
            const forceUsingSearch = !!this._environmentService.remoteAuthority;
            const host = {
                logService: this._logService,
                folders: ( (workspace.folders.map(folder => folder.uri))),
                forceUsingSearch: forceUsingSearch,
                exists: (uri) => this._fileService.exists(uri),
                checkExists: (folders, includes, token) => this._instantiationService.invokeFunction((accessor) => checkGlobFileExists(accessor, folders, includes, token))
            };
            const result = await checkActivateWorkspaceContainsExtension(host, extensionDescription);
            if (!result) {
                return;
            }
            await Promise.all(( (this._extensionHostManagers.map(
                extHostManager => extHostManager.activate(extensionDescription.identifier, { startup: false, extensionId: extensionDescription.identifier, activationEvent: result.activationEvent })
            )))).then(() => { });
        }
    }
    async _initialize() {
        performance.mark('code/willLoadExtensions');
        this._startExtensionHostsIfNecessary(true, []);
        const lock = await this._registry.acquireLock('_initialize');
        try {
            const resolvedExtensions = await this._resolveExtensions();
            this._processExtensions(lock, resolvedExtensions);
            const allExtensions = this._registry.getAllExtensionDescriptions();
            for (const extHostManager of this._extensionHostManagers) {
                if (extHostManager.startup !== 1 ) {
                    const extensions = this._runningLocations.filterByExtensionHostManager(allExtensions, extHostManager);
                    extHostManager.start(allExtensions, ( (extensions.map(extension => extension.identifier))));
                }
            }
        }
        finally {
            lock.dispose();
        }
        this._releaseBarrier();
        performance.mark('code/didLoadExtensions');
        await this._handleExtensionTests();
    }
    _processExtensions(lock, resolvedExtensions) {
        const { allowRemoteExtensionsInLocalWebWorker, hasLocalProcess } = resolvedExtensions;
        const localExtensions = checkEnabledAndProposedAPI(this._extensionEnablementService, this._extensionsProposedApi, resolvedExtensions.local, false);
        let remoteExtensions = checkEnabledAndProposedAPI(this._extensionEnablementService, this._extensionsProposedApi, resolvedExtensions.remote, false);
        this._runningLocations.initializeRunningLocation(localExtensions, remoteExtensions);
        this._startExtensionHostsIfNecessary(true, []);
        const remoteExtensionsThatNeedToRunLocally = (allowRemoteExtensionsInLocalWebWorker ? this._runningLocations.filterByExtensionHostKind(remoteExtensions, 2 ) : []);
        const localProcessExtensions = (hasLocalProcess ? this._runningLocations.filterByExtensionHostKind(localExtensions, 1 ) : []);
        const localWebWorkerExtensions = this._runningLocations.filterByExtensionHostKind(localExtensions, 2 );
        remoteExtensions = this._runningLocations.filterByExtensionHostKind(remoteExtensions, 3 );
        for (const ext of remoteExtensionsThatNeedToRunLocally) {
            if (!includes(localWebWorkerExtensions, ext.identifier)) {
                localWebWorkerExtensions.push(ext);
            }
        }
        const allExtensions = remoteExtensions.concat(localProcessExtensions).concat(localWebWorkerExtensions);
        const result = this._registry.deltaExtensions(lock, allExtensions, []);
        if (result.removedDueToLooping.length > 0) {
            this._notificationService.notify({
                severity: Severity.Error,
                message: ( (nls.localize(
                    'looping',
                    "The following extensions contain dependency loops and have been disabled: {0}",
                    ( (result.removedDueToLooping.map(e => `'${e.identifier.value}'`))).join(', ')
                )))
            });
        }
        this._doHandleExtensionPoints(this._registry.getAllExtensionDescriptions());
    }
    async _handleExtensionTests() {
        if (!this._environmentService.isExtensionDevelopment || !this._environmentService.extensionTestsLocationURI) {
            return;
        }
        const extensionHostManager = this.findTestExtensionHost(this._environmentService.extensionTestsLocationURI);
        if (!extensionHostManager) {
            const msg = ( (nls.localize(
                'extensionTestError',
                "No extension host found that can launch the test runner at {0}.",
                 (this._environmentService.extensionTestsLocationURI.toString())
            )));
            console.error(msg);
            this._notificationService.error(msg);
            return;
        }
        let exitCode;
        try {
            exitCode = await extensionHostManager.extensionTestsExecute();
        }
        catch (err) {
            console.error(err);
            exitCode = 1 ;
        }
        this._onExtensionHostExit(exitCode);
    }
    findTestExtensionHost(testLocation) {
        let runningLocation = null;
        for (const extension of this._registry.getAllExtensionDescriptions()) {
            if (isEqualOrParent(testLocation, extension.extensionLocation)) {
                runningLocation = this._runningLocations.getRunningLocation(extension.identifier);
                break;
            }
        }
        if (runningLocation === null) {
            if (testLocation.scheme === Schemas.vscodeRemote) {
                runningLocation = ( (new RemoteRunningLocation()));
            }
            else {
                runningLocation = ( (new LocalProcessRunningLocation(0)));
            }
        }
        if (runningLocation !== null) {
            return this._getExtensionHostManagerByRunningLocation(runningLocation);
        }
        return null;
    }
    _releaseBarrier() {
        this._installedExtensionsReady.open();
        this._onDidRegisterExtensions.fire(undefined);
        this._onDidChangeExtensionsStatus.fire(( (this._registry.getAllExtensionDescriptions().map(e => e.identifier))));
    }
    async _resolveAuthorityInitial(remoteAuthority) {
        const MAX_ATTEMPTS = 5;
        for (let attempt = 1;; attempt++) {
            try {
                return this._resolveAuthorityWithLogging(remoteAuthority);
            }
            catch (err) {
                if (RemoteAuthorityResolverError.isNoResolverFound(err)) {
                    throw err;
                }
                if (RemoteAuthorityResolverError.isNotAvailable(err)) {
                    throw err;
                }
                if (attempt >= MAX_ATTEMPTS) {
                    throw err;
                }
            }
        }
    }
    async _resolveAuthorityAgain() {
        const remoteAuthority = this._environmentService.remoteAuthority;
        if (!remoteAuthority) {
            return;
        }
        this._remoteAuthorityResolverService._clearResolvedAuthority(remoteAuthority);
        try {
            const result = await this._resolveAuthorityWithLogging(remoteAuthority);
            this._remoteAuthorityResolverService._setResolvedAuthority(result.authority, result.options);
        }
        catch (err) {
            this._remoteAuthorityResolverService._setResolvedAuthorityError(remoteAuthority, err);
        }
    }
    async _resolveAuthorityWithLogging(remoteAuthority) {
        const authorityPrefix = getRemoteAuthorityPrefix(remoteAuthority);
        const sw = StopWatch.create(false);
        this._logService.info(`Invoking resolveAuthority(${authorityPrefix})...`);
        try {
            performance.mark(`code/willResolveAuthority/${authorityPrefix}`);
            const result = await this._resolveAuthority(remoteAuthority);
            performance.mark(`code/didResolveAuthorityOK/${authorityPrefix}`);
            this._logService.info(`resolveAuthority(${authorityPrefix}) returned '${result.authority.connectTo}' after ${sw.elapsed()} ms`);
            return result;
        }
        catch (err) {
            performance.mark(`code/didResolveAuthorityError/${authorityPrefix}`);
            this._logService.error(`resolveAuthority(${authorityPrefix}) returned an error after ${sw.elapsed()} ms`, err);
            throw err;
        }
    }
    async _resolveAuthorityOnExtensionHosts(kind, remoteAuthority) {
        const extensionHosts = this._getExtensionHostManagers(kind);
        if (extensionHosts.length === 0) {
            throw new Error(`Cannot resolve authority`);
        }
        this._resolveAuthorityAttempt++;
        const results = await Promise.all(( (extensionHosts.map(
            extHost => extHost.resolveAuthority(remoteAuthority, this._resolveAuthorityAttempt)
        ))));
        let bestErrorResult = null;
        for (const result of results) {
            if (result.type === 'ok') {
                return result.value;
            }
            if (!bestErrorResult) {
                bestErrorResult = result;
                continue;
            }
            const bestErrorIsUnknown = (bestErrorResult.error.code === RemoteAuthorityResolverErrorCode.Unknown);
            const errorIsUnknown = (result.error.code === RemoteAuthorityResolverErrorCode.Unknown);
            if (bestErrorIsUnknown && !errorIsUnknown) {
                bestErrorResult = result;
            }
        }
        throw new RemoteAuthorityResolverError(bestErrorResult.error.message, bestErrorResult.error.code, bestErrorResult.error.detail);
    }
    stopExtensionHosts(reason) {
        return this._doStopExtensionHostsWithVeto(reason);
    }
    _doStopExtensionHosts() {
        const previouslyActivatedExtensionIds = [];
        for (const extensionStatus of ( (this._extensionStatus.values()))) {
            if (extensionStatus.activationStarted) {
                previouslyActivatedExtensionIds.push(extensionStatus.id);
            }
        }
        for (let i = this._extensionHostManagers.length - 1; i >= 0; i--) {
            this._extensionHostManagers[i].dispose();
        }
        this._extensionHostManagers = [];
        for (const extensionStatus of ( (this._extensionStatus.values()))) {
            extensionStatus.clearRuntimeStatus();
        }
        if (previouslyActivatedExtensionIds.length > 0) {
            this._onDidChangeExtensionsStatus.fire(previouslyActivatedExtensionIds);
        }
    }
    async _doStopExtensionHostsWithVeto(reason) {
        const vetos = [];
        const vetoReasons = ( (new Set()));
        this._onWillStop.fire({
            reason,
            veto(value, reason) {
                vetos.push(value);
                if (typeof value === 'boolean') {
                    if (value === true) {
                        vetoReasons.add(reason);
                    }
                }
                else {
                    value.then(value => {
                        if (value) {
                            vetoReasons.add(reason);
                        }
                    }).catch(error => {
                        vetoReasons.add(( (nls.localize(
                            'extensionStopVetoError',
                            "{0} (Error: {1})",
                            reason,
                            toErrorMessage(error)
                        ))));
                    });
                }
            }
        });
        const veto = await handleVetos(vetos, error => this._logService.error(error));
        if (!veto) {
            this._doStopExtensionHosts();
        }
        else {
            const vetoReasonsArray = Array.from(vetoReasons);
            this._logService.warn(`Extension host was not stopped because of veto (stop reason: ${reason}, veto reason: ${vetoReasonsArray.join(', ')})`);
            await this._dialogService.warn(( (nls.localize(
                'extensionStopVetoMessage',
                "The following operation was blocked: {0}",
                reason
            ))), vetoReasonsArray.length === 1 ?
                ( (nls.localize(
                'extensionStopVetoDetailsOne',
                "The reason for blocking the operation: {0}",
                vetoReasonsArray[0]
            ))) :
                ( (nls.localize(
                'extensionStopVetoDetailsMany',
                "The reasons for blocking the operation:\n- {0}",
                vetoReasonsArray.join('\n -')
            ))));
        }
        return !veto;
    }
    _startExtensionHostsIfNecessary(isInitialStart, initialActivationEvents) {
        const locations = [];
        for (let affinity = 0; affinity <= this._runningLocations.maxLocalProcessAffinity; affinity++) {
            locations.push(( (new LocalProcessRunningLocation(affinity))));
        }
        for (let affinity = 0; affinity <= this._runningLocations.maxLocalWebWorkerAffinity; affinity++) {
            locations.push(( (new LocalWebWorkerRunningLocation(affinity))));
        }
        locations.push(( (new RemoteRunningLocation())));
        for (const location of locations) {
            if (this._getExtensionHostManagerByRunningLocation(location)) {
                continue;
            }
            const extHostManager = this._createExtensionHostManager(location, isInitialStart, initialActivationEvents);
            if (extHostManager) {
                this._extensionHostManagers.push(extHostManager);
            }
        }
    }
    _createExtensionHostManager(runningLocation, isInitialStart, initialActivationEvents) {
        const extensionHost = this._extensionHostFactory.createExtensionHost(this._runningLocations, runningLocation, isInitialStart);
        if (!extensionHost) {
            return null;
        }
        const processManager = this._doCreateExtensionHostManager(extensionHost, initialActivationEvents);
        processManager.onDidExit(([code, signal]) => this._onExtensionHostCrashOrExit(processManager, code, signal));
        processManager.onDidChangeResponsiveState((responsiveState) => {
            this._onDidChangeResponsiveChange.fire({
                extensionHostKind: processManager.kind,
                isResponsive: responsiveState === 0 ,
                getInspectPort: (tryEnableInspector) => {
                    return processManager.getInspectPort(tryEnableInspector);
                }
            });
        });
        return processManager;
    }
    _doCreateExtensionHostManager(extensionHost, initialActivationEvents) {
        return createExtensionHostManager(this._instantiationService, extensionHost, initialActivationEvents, this._acquireInternalAPI(extensionHost));
    }
    _onExtensionHostCrashOrExit(extensionHost, code, signal) {
        const isExtensionDevHost = parseExtensionDevOptions(this._environmentService).isExtensionDevHost;
        if (!isExtensionDevHost) {
            this._onExtensionHostCrashed(extensionHost, code, signal);
            return;
        }
        this._onExtensionHostExit(code);
    }
    _onExtensionHostCrashed(extensionHost, code, signal) {
        console.error(`Extension host (${extensionHostKindToString(extensionHost.kind)}) terminated unexpectedly. Code: ${code}, Signal: ${signal}`);
        if (extensionHost.kind === 1 ) {
            this._doStopExtensionHosts();
        }
        else if (extensionHost.kind === 3 ) {
            if (signal) {
                this._onRemoteExtensionHostCrashed(extensionHost, signal);
            }
            for (let i = 0; i < this._extensionHostManagers.length; i++) {
                if (this._extensionHostManagers[i] === extensionHost) {
                    this._extensionHostManagers[i].dispose();
                    this._extensionHostManagers.splice(i, 1);
                    break;
                }
            }
        }
    }
    _getExtensionHostExitInfoWithTimeout(reconnectionToken) {
        return (
             (new Promise((resolve, reject) => {
                const timeoutHandle = setTimeout(() => {
                    reject(( (new Error('getExtensionHostExitInfo timed out'))));
                }, 2000);
                this._remoteAgentService.getExtensionHostExitInfo(reconnectionToken).then((r) => {
                    clearTimeout(timeoutHandle);
                    resolve(r);
                }, reject);
            }))
        );
    }
    async _onRemoteExtensionHostCrashed(extensionHost, reconnectionToken) {
        try {
            const info = await this._getExtensionHostExitInfoWithTimeout(reconnectionToken);
            if (info) {
                this._logService.error(`Extension host (${extensionHostKindToString(extensionHost.kind)}) terminated unexpectedly with code ${info.code}.`);
            }
            this._logExtensionHostCrash(extensionHost);
            this._remoteCrashTracker.registerCrash();
            if (this._remoteCrashTracker.shouldAutomaticallyRestart()) {
                this._logService.info(`Automatically restarting the remote extension host.`);
                this._notificationService.status(( (nls.localize(
                    'extensionService.autoRestart',
                    "The remote extension host terminated unexpectedly. Restarting..."
                ))), { hideAfter: 5000 });
                this._startExtensionHostsIfNecessary(false, Array.from(( (this._allRequestedActivateEvents.keys()))));
            }
            else {
                this._notificationService.prompt(Severity.Error, ( (nls.localize(
                    'extensionService.crash',
                    "Remote Extension host terminated unexpectedly 3 times within the last 5 minutes."
                ))), [{
                        label: ( (nls.localize('restart', "Restart Remote Extension Host"))),
                        run: () => {
                            this._startExtensionHostsIfNecessary(false, Array.from(( (this._allRequestedActivateEvents.keys()))));
                        }
                    }]);
            }
        }
        catch (err) {
        }
    }
    _logExtensionHostCrash(extensionHost) {
        const activatedExtensions = [];
        for (const extensionStatus of ( (this._extensionStatus.values()))) {
            if (extensionStatus.activationStarted && extensionHost.containsExtension(extensionStatus.id)) {
                activatedExtensions.push(extensionStatus.id);
            }
        }
        if (activatedExtensions.length > 0) {
            this._logService.error(`Extension host (${extensionHostKindToString(extensionHost.kind)}) terminated unexpectedly. The following extensions were running: ${( ( activatedExtensions.map(id => id.value))).join(', ')}`);
        }
        else {
            this._logService.error(`Extension host (${extensionHostKindToString(extensionHost.kind)}) terminated unexpectedly. No extensions were activated.`);
        }
    }
    async startExtensionHosts() {
        this._doStopExtensionHosts();
        const lock = await this._registry.acquireLock('startExtensionHosts');
        try {
            this._startExtensionHostsIfNecessary(false, Array.from(( (this._allRequestedActivateEvents.keys()))));
            const localProcessExtensionHosts = this._getExtensionHostManagers(1 );
            await Promise.all(( (localProcessExtensionHosts.map(extHost => extHost.ready()))));
        }
        finally {
            lock.dispose();
        }
    }
    activateByEvent(activationEvent, activationKind = 0 ) {
        if (this._installedExtensionsReady.isOpen()) {
            this._allRequestedActivateEvents.add(activationEvent);
            if (!this._registry.containsActivationEvent(activationEvent)) {
                return NO_OP_VOID_PROMISE;
            }
            return this._activateByEvent(activationEvent, activationKind);
        }
        else {
            this._allRequestedActivateEvents.add(activationEvent);
            if (activationKind === 1 ) {
                return this._activateByEvent(activationEvent, activationKind);
            }
            return this._installedExtensionsReady.wait().then(() => this._activateByEvent(activationEvent, activationKind));
        }
    }
    _activateByEvent(activationEvent, activationKind) {
        const result = Promise.all(( (this._extensionHostManagers.map(
            extHostManager => extHostManager.activateByEvent(activationEvent, activationKind)
        )))).then(() => { });
        this._onWillActivateByEvent.fire({
            event: activationEvent,
            activation: result
        });
        return result;
    }
    activationEventIsDone(activationEvent) {
        if (!this._installedExtensionsReady.isOpen()) {
            return false;
        }
        if (!this._registry.containsActivationEvent(activationEvent)) {
            return true;
        }
        return this._extensionHostManagers.every(manager => manager.activationEventIsDone(activationEvent));
    }
    whenInstalledExtensionsRegistered() {
        return this._installedExtensionsReady.wait();
    }
    get extensions() {
        return this._registry.getAllExtensionDescriptions();
    }
    _getExtensions() {
        return this._installedExtensionsReady.wait().then(() => this.extensions);
    }
    getExtension(id) {
        return this._installedExtensionsReady.wait().then(() => {
            return this._registry.getExtensionDescription(id);
        });
    }
    readExtensionPointContributions(extPoint) {
        return this._installedExtensionsReady.wait().then(() => {
            const availableExtensions = this._registry.getAllExtensionDescriptions();
            const result = [];
            for (const desc of availableExtensions) {
                if (desc.contributes && hasOwnProperty.call(desc.contributes, extPoint.name)) {
                    result.push(( (new ExtensionPointContribution(desc, desc.contributes[extPoint.name]))));
                }
            }
            return result;
        });
    }
    getExtensionsStatus() {
        const result = Object.create(null);
        if (this._registry) {
            const extensions = this._registry.getAllExtensionDescriptions();
            for (const extension of extensions) {
                const extensionStatus = this._extensionStatus.get(extension.identifier);
                result[extension.identifier.value] = {
                    id: extension.identifier,
                    messages: extensionStatus?.messages ?? [],
                    activationStarted: extensionStatus?.activationStarted ?? false,
                    activationTimes: extensionStatus?.activationTimes ?? undefined,
                    runtimeErrors: extensionStatus?.runtimeErrors ?? [],
                    runningLocation: this._runningLocations.getRunningLocation(extension.identifier),
                };
            }
        }
        return result;
    }
    async getInspectPorts(extensionHostKind, tryEnableInspector) {
        const result = await Promise.all(( (this._getExtensionHostManagers(extensionHostKind).map(extHost => extHost.getInspectPort(tryEnableInspector)))));
        return result.filter(element => Boolean(element));
    }
    async setRemoteEnvironment(env) {
        await ( (this._extensionHostManagers
            .map(manager => manager.setRemoteEnvironment(env))));
    }
    _safeInvokeIsEnabled(extension) {
        try {
            return this._extensionEnablementService.isEnabled(extension);
        }
        catch (err) {
            return false;
        }
    }
    _doHandleExtensionPoints(affectedExtensions) {
        const affectedExtensionPoints = Object.create(null);
        for (const extensionDescription of affectedExtensions) {
            if (extensionDescription.contributes) {
                for (const extPointName in extensionDescription.contributes) {
                    if (hasOwnProperty.call(extensionDescription.contributes, extPointName)) {
                        affectedExtensionPoints[extPointName] = true;
                    }
                }
            }
        }
        const messageHandler = (msg) => this._handleExtensionPointMessage(msg);
        const availableExtensions = this._registry.getAllExtensionDescriptions();
        const extensionPoints = ExtensionsRegistry.getExtensionPoints();
        performance.mark('code/willHandleExtensionPoints');
        for (const extensionPoint of extensionPoints) {
            if (affectedExtensionPoints[extensionPoint.name]) {
                performance.mark(`code/willHandleExtensionPoint/${extensionPoint.name}`);
                AbstractExtensionService._handleExtensionPoint(extensionPoint, availableExtensions, messageHandler);
                performance.mark(`code/didHandleExtensionPoint/${extensionPoint.name}`);
            }
        }
        performance.mark('code/didHandleExtensionPoints');
    }
    _getOrCreateExtensionStatus(extensionId) {
        if (!( (this._extensionStatus.has(extensionId)))) {
            this._extensionStatus.set(extensionId, ( (new ExtensionStatus(extensionId))));
        }
        return this._extensionStatus.get(extensionId);
    }
    _handleExtensionPointMessage(msg) {
        const extensionStatus = this._getOrCreateExtensionStatus(msg.extensionId);
        extensionStatus.addMessage(msg);
        const extension = this._registry.getExtensionDescription(msg.extensionId);
        const strMsg = `[${msg.extensionId.value}]: ${msg.message}`;
        if (msg.type === Severity.Error) {
            if (extension && extension.isUnderDevelopment) {
                this._notificationService.notify({ severity: Severity.Error, message: strMsg });
            }
            this._logService.error(strMsg);
        }
        else if (msg.type === Severity.Warning) {
            if (extension && extension.isUnderDevelopment) {
                this._notificationService.notify({ severity: Severity.Warning, message: strMsg });
            }
            this._logService.warn(strMsg);
        }
        else {
            this._logService.info(strMsg);
        }
        if (msg.extensionId && this._environmentService.isBuilt && !this._environmentService.isExtensionDevelopment) {
            const { type, extensionId, extensionPointId, message } = msg;
            this._telemetryService.publicLog2('extensionsMessage', {
                type, extensionId: extensionId.value, extensionPointId, message
            });
        }
    }
    static _handleExtensionPoint(extensionPoint, availableExtensions, messageHandler) {
        const users = [];
        for (const desc of availableExtensions) {
            if (desc.contributes && hasOwnProperty.call(desc.contributes, extensionPoint.name)) {
                users.push({
                    description: desc,
                    value: desc.contributes[extensionPoint.name],
                    collector: ( (new ExtensionMessageCollector(messageHandler, desc, extensionPoint.name)))
                });
            }
        }
        extensionPoint.acceptUsers(users);
    }
    _acquireInternalAPI(extensionHost) {
        return {
            _activateById: (extensionId, reason) => {
                return this._activateById(extensionId, reason);
            },
            _onWillActivateExtension: (extensionId) => {
                return this._onWillActivateExtension(extensionId, extensionHost.runningLocation);
            },
            _onDidActivateExtension: (extensionId, codeLoadingTime, activateCallTime, activateResolvedTime, activationReason) => {
                return this._onDidActivateExtension(extensionId, codeLoadingTime, activateCallTime, activateResolvedTime, activationReason);
            },
            _onDidActivateExtensionError: (extensionId, error) => {
                return this._onDidActivateExtensionError(extensionId, error);
            },
            _onExtensionRuntimeError: (extensionId, err) => {
                return this._onExtensionRuntimeError(extensionId, err);
            }
        };
    }
    async _activateById(extensionId, reason) {
        const results = await Promise.all(( (this._extensionHostManagers.map(manager => manager.activate(extensionId, reason)))));
        const activated = ( (results.some(e => e)));
        if (!activated) {
            throw new Error(`Unknown extension ${extensionId.value}`);
        }
    }
    _onWillActivateExtension(extensionId, runningLocation) {
        this._runningLocations.set(extensionId, runningLocation);
        const extensionStatus = this._getOrCreateExtensionStatus(extensionId);
        extensionStatus.onWillActivate();
    }
    _onDidActivateExtension(extensionId, codeLoadingTime, activateCallTime, activateResolvedTime, activationReason) {
        const extensionStatus = this._getOrCreateExtensionStatus(extensionId);
        extensionStatus.setActivationTimes(( (new ActivationTimes(codeLoadingTime, activateCallTime, activateResolvedTime, activationReason))));
        this._onDidChangeExtensionsStatus.fire([extensionId]);
    }
    _onDidActivateExtensionError(extensionId, error) {
        this._telemetryService.publicLog2('extensionActivationError', {
            extensionId: extensionId.value,
            error: error.message
        });
    }
    _onExtensionRuntimeError(extensionId, err) {
        const extensionStatus = this._getOrCreateExtensionStatus(extensionId);
        extensionStatus.addRuntimeError(err);
        this._onDidChangeExtensionsStatus.fire([extensionId]);
    }
};
AbstractExtensionService = ( (__decorate([
    ( (__param(3, IInstantiationService))),
    ( (__param(4, INotificationService))),
    ( (__param(5, IWorkbenchEnvironmentService))),
    ( (__param(6, ITelemetryService))),
    ( (__param(7, IWorkbenchExtensionEnablementService))),
    ( (__param(8, IFileService))),
    ( (__param(9, IProductService))),
    ( (__param(10, IWorkbenchExtensionManagementService))),
    ( (__param(11, IWorkspaceContextService))),
    ( (__param(12, IConfigurationService))),
    ( (__param(13, IExtensionManifestPropertiesService))),
    ( (__param(14, ILogService))),
    ( (__param(15, IRemoteAgentService))),
    ( (__param(16, IRemoteExtensionsScannerService))),
    ( (__param(17, ILifecycleService))),
    ( (__param(18, IRemoteAuthorityResolverService))),
    ( (__param(19, IDialogService)))
], AbstractExtensionService)));
class ResolvedExtensions {
    constructor(local, remote, hasLocalProcess, allowRemoteExtensionsInLocalWebWorker) {
        this.local = local;
        this.remote = remote;
        this.hasLocalProcess = hasLocalProcess;
        this.allowRemoteExtensionsInLocalWebWorker = allowRemoteExtensionsInLocalWebWorker;
    }
}
class DeltaExtensionsQueueItem {
    constructor(toAdd, toRemove) {
        this.toAdd = toAdd;
        this.toRemove = toRemove;
    }
}
function checkEnabledAndProposedAPI(extensionEnablementService, extensionsProposedApi, extensions, ignoreWorkspaceTrust) {
    return filterEnabledExtensions(extensionEnablementService, extensions, ignoreWorkspaceTrust);
}
function filterEnabledExtensions(extensionEnablementService, extensions, ignoreWorkspaceTrust) {
    const enabledExtensions = [], extensionsToCheck = [], mappedExtensions = [];
    for (const extension of extensions) {
        if (extension.isUnderDevelopment) {
            enabledExtensions.push(extension);
        }
        else {
            extensionsToCheck.push(extension);
            mappedExtensions.push(toExtension(extension));
        }
    }
    const enablementStates = extensionEnablementService.getEnablementStates(mappedExtensions, ignoreWorkspaceTrust ? { trusted: true } : undefined);
    for (let index = 0; index < enablementStates.length; index++) {
        if (extensionEnablementService.isEnabledEnablementState(enablementStates[index])) {
            enabledExtensions.push(extensionsToCheck[index]);
        }
    }
    return enabledExtensions;
}
function includes(extensions, identifier) {
    for (const extension of extensions) {
        if (ExtensionIdentifier.equals(extension.identifier, identifier)) {
            return true;
        }
    }
    return false;
}
class ExtensionStatus {
    get messages() {
        return this._messages;
    }
    get activationTimes() {
        return this._activationTimes;
    }
    get runtimeErrors() {
        return this._runtimeErrors;
    }
    get activationStarted() {
        return this._activationStarted;
    }
    constructor(id) {
        this.id = id;
        this._messages = [];
        this._activationTimes = null;
        this._runtimeErrors = [];
        this._activationStarted = false;
    }
    clearRuntimeStatus() {
        this._activationStarted = false;
        this._activationTimes = null;
        this._runtimeErrors = [];
    }
    addMessage(msg) {
        this._messages.push(msg);
    }
    setActivationTimes(activationTimes) {
        this._activationTimes = activationTimes;
    }
    addRuntimeError(err) {
        this._runtimeErrors.push(err);
    }
    onWillActivate() {
        this._activationStarted = true;
    }
}
class ExtensionHostCrashTracker {
    constructor() {
        this._recentCrashes = [];
    }
    static { this._TIME_LIMIT = 5 * 60 * 1000; }
    static { this._CRASH_LIMIT = 3; }
    _removeOldCrashes() {
        const limit = Date.now() - ExtensionHostCrashTracker._TIME_LIMIT;
        while (this._recentCrashes.length > 0 && this._recentCrashes[0].timestamp < limit) {
            this._recentCrashes.shift();
        }
    }
    registerCrash() {
        this._removeOldCrashes();
        this._recentCrashes.push({ timestamp: Date.now() });
    }
    shouldAutomaticallyRestart() {
        this._removeOldCrashes();
        return (this._recentCrashes.length < ExtensionHostCrashTracker._CRASH_LIMIT);
    }
}
class ImplicitActivationAwareReader {
    readActivationEvents(extensionDescription) {
        return ImplicitActivationEvents.readActivationEvents(extensionDescription);
    }
}
export { AbstractExtensionService, DeltaExtensionsQueueItem, ExtensionHostCrashTracker, ExtensionStatus, ResolvedExtensions, checkEnabledAndProposedAPI, filterEnabledExtensions };
