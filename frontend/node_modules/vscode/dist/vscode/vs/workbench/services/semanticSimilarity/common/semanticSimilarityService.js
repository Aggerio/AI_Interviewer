import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import { createDecorator } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { timeout, createCancelablePromise, raceCancellablePromises } from 'monaco-editor/esm/vs/base/common/async.js';
import { StopWatch } from 'monaco-editor/esm/vs/base/common/stopwatch.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
const ISemanticSimilarityService = ( createDecorator('ISemanticSimilarityService'));
let SemanticSimilarityService = class SemanticSimilarityService {
    static { this.DEFAULT_TIMEOUT = 1000 * 10; }
    constructor(logService) {
        this.logService = logService;
        this._providers = [];
    }
    isEnabled() {
        return this._providers.length > 0;
    }
    registerSemanticSimilarityProvider(provider) {
        this._providers.push(provider);
        return {
            dispose: () => {
                const index = this._providers.indexOf(provider);
                if (index >= 0) {
                    this._providers.splice(index, 1);
                }
            }
        };
    }
    async getSimilarityScore(string1, comparisons, token) {
        if (this._providers.length === 0) {
            throw new Error('No semantic similarity providers registered');
        }
        const stopwatch = StopWatch.create();
        const cancellablePromises = [];
        const timer = timeout(SemanticSimilarityService.DEFAULT_TIMEOUT);
        const disposable = token.onCancellationRequested(() => {
            disposable.dispose();
            timer.cancel();
        });
        for (const provider of this._providers) {
            cancellablePromises.push(createCancelablePromise(async (t) => {
                try {
                    return await provider.provideSimilarityScore(string1, comparisons, t);
                }
                catch (e) {
                }
                await timer;
                throw new Error('Semantic similarity provider timed out');
            }));
        }
        cancellablePromises.push(createCancelablePromise(async (t) => {
            const disposable = t.onCancellationRequested(() => {
                timer.cancel();
                disposable.dispose();
            });
            await timer;
            throw new Error('Semantic similarity provider timed out');
        }));
        try {
            const result = await raceCancellablePromises(cancellablePromises);
            return result;
        }
        finally {
            stopwatch.stop();
            this.logService.trace(`[SemanticSimilarityService]: getSimilarityScore took ${stopwatch.elapsed()}ms`);
        }
    }
};
SemanticSimilarityService = ( __decorate([
    ( __param(0, ILogService))
], SemanticSimilarityService));
export { ISemanticSimilarityService, SemanticSimilarityService };
