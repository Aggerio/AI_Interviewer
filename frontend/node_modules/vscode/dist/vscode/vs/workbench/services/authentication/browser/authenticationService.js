import { isString } from 'monaco-editor/esm/vs/base/common/types.js';
import * as nls from 'monaco-editor/esm/vs/nls.js';
import { MenuRegistry, MenuId } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { CommandsRegistry } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { ContextKeyExpr } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import '../../../../../../override/vs/platform/dialogs/common/dialogs.js';
import { IBrowserWorkbenchEnvironmentService } from '../../environment/browser/environmentService.js';
function getAuthenticationProviderActivationEvent(id) { return `onAuthenticationRequest:${id}`; }
function readAccountUsages(storageService, providerId, accountName) {
    const accountKey = `${providerId}-${accountName}-usages`;
    const storedUsages = storageService.get(accountKey, -1 );
    let usages = [];
    if (storedUsages) {
        try {
            usages = JSON.parse(storedUsages);
        }
        catch (e) {
        }
    }
    return usages;
}
function removeAccountUsage(storageService, providerId, accountName) {
    const accountKey = `${providerId}-${accountName}-usages`;
    storageService.remove(accountKey, -1 );
}
function addAccountUsage(storageService, providerId, accountName, extensionId, extensionName) {
    const accountKey = `${providerId}-${accountName}-usages`;
    const usages = readAccountUsages(storageService, providerId, accountName);
    const existingUsageIndex = usages.findIndex(usage => usage.extensionId === extensionId);
    if (existingUsageIndex > -1) {
        usages.splice(existingUsageIndex, 1, {
            extensionId,
            extensionName,
            lastUsed: Date.now()
        });
    }
    else {
        usages.push({
            extensionId,
            extensionName,
            lastUsed: Date.now()
        });
    }
    storageService.store(accountKey, JSON.stringify(usages), -1 , 1 );
}
async function getCurrentAuthenticationSessionInfo(
credentialsService, secretStorageService, productService) {
    const authenticationSessionValue = (await secretStorageService.get(`${productService.urlProtocol}.loginAccount`))
        ?? (await credentialsService.getPassword(`${productService.urlProtocol}.login`, 'account'));
    if (authenticationSessionValue) {
        try {
            const authenticationSessionInfo = JSON.parse(authenticationSessionValue);
            if (authenticationSessionInfo
                && isString(authenticationSessionInfo.id)
                && isString(authenticationSessionInfo.accessToken)
                && isString(authenticationSessionInfo.providerId)) {
                return authenticationSessionInfo;
            }
        }
        catch (e) {
            console.error(`Failed parsing current auth session value: ${e}`);
        }
    }
    return undefined;
}
function readAllowedExtensions(storageService, providerId, accountName) {
    let trustedExtensions = [];
    try {
        const trustedExtensionSrc = storageService.get(`${providerId}-${accountName}`, -1 );
        if (trustedExtensionSrc) {
            trustedExtensions = JSON.parse(trustedExtensionSrc);
        }
    }
    catch (err) { }
    return trustedExtensions;
}
CommandsRegistry.registerCommand('workbench.getCodeExchangeProxyEndpoints', function (accessor, _) {
    const environmentService = accessor.get(IBrowserWorkbenchEnvironmentService);
    return environmentService.options?.codeExchangeProxyEndpoints;
});
MenuRegistry.appendMenuItem(MenuId.AccountsContext, {
    command: {
        id: 'noAuthenticationProviders',
        title: ( nls.localize('authentication.Placeholder', "No accounts requested yet...")),
        precondition: ContextKeyExpr.false()
    },
});
export { addAccountUsage, getAuthenticationProviderActivationEvent, getCurrentAuthenticationSessionInfo, readAccountUsages, readAllowedExtensions, removeAccountUsage };
