import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { Severity, NoOpNotification, NeverShowAgainScope, NotificationsFilter } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { NotificationsModel, ChoiceAction } from '../../../common/notifications.js';
import { Disposable, DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { Emitter, Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { Action } from 'monaco-editor/esm/vs/base/common/actions.js';
import { IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
let NotificationService = class NotificationService extends Disposable {
    constructor(storageService) {
        super();
        this.storageService = storageService;
        this.model = this._register(( new NotificationsModel()));
        this._onDidAddNotification = this._register(( new Emitter()));
        this.onDidAddNotification = this._onDidAddNotification.event;
        this._onDidRemoveNotification = this._register(( new Emitter()));
        this.onDidRemoveNotification = this._onDidRemoveNotification.event;
        this._onDidChangeDoNotDisturbMode = this._register(( new Emitter()));
        this.onDidChangeDoNotDisturbMode = this._onDidChangeDoNotDisturbMode.event;
        this._doNotDisturbMode = this.storageService.getBoolean(NotificationService.DND_SETTINGS_KEY, -1 , false);
        this.updateDoNotDisturbFilters();
        this.registerListeners();
    }
    registerListeners() {
        this._register(this.model.onDidChangeNotification(e => {
            switch (e.kind) {
                case 0 :
                case 3 : {
                    const notification = {
                        message: e.item.message.original,
                        severity: e.item.severity,
                        source: typeof e.item.sourceId === 'string' && typeof e.item.source === 'string' ? { id: e.item.sourceId, label: e.item.source } : e.item.source,
                        priority: e.item.priority
                    };
                    if (e.kind === 0 ) {
                        this._onDidAddNotification.fire(notification);
                    }
                    if (e.kind === 3 ) {
                        this._onDidRemoveNotification.fire(notification);
                    }
                    break;
                }
            }
        }));
    }
    static { this.DND_SETTINGS_KEY = 'notifications.doNotDisturbMode'; }
    get doNotDisturbMode() {
        return this._doNotDisturbMode;
    }
    set doNotDisturbMode(enabled) {
        if (this._doNotDisturbMode === enabled) {
            return;
        }
        this.storageService.store(NotificationService.DND_SETTINGS_KEY, enabled, -1 , 1 );
        this._doNotDisturbMode = enabled;
        this.updateDoNotDisturbFilters();
        this._onDidChangeDoNotDisturbMode.fire();
    }
    updateDoNotDisturbFilters() {
        let filter;
        if (this._doNotDisturbMode) {
            filter = NotificationsFilter.ERROR;
        }
        else {
            filter = NotificationsFilter.OFF;
        }
        this.model.setFilter(filter);
    }
    info(message) {
        if (Array.isArray(message)) {
            message.forEach(m => this.info(m));
            return;
        }
        this.model.addNotification({ severity: Severity.Info, message });
    }
    warn(message) {
        if (Array.isArray(message)) {
            message.forEach(m => this.warn(m));
            return;
        }
        this.model.addNotification({ severity: Severity.Warning, message });
    }
    error(message) {
        if (Array.isArray(message)) {
            message.forEach(m => this.error(m));
            return;
        }
        this.model.addNotification({ severity: Severity.Error, message });
    }
    notify(notification) {
        const toDispose = ( new DisposableStore());
        if (notification.neverShowAgain) {
            const scope = this.toStorageScope(notification.neverShowAgain);
            const id = notification.neverShowAgain.id;
            if (this.storageService.getBoolean(id, scope)) {
                return ( new NoOpNotification());
            }
            const neverShowAgainAction = toDispose.add(( new Action('workbench.notification.neverShowAgain', ( localize('neverShowAgain', "Don't Show Again")), undefined, true, async () => {
                handle.close();
                this.storageService.store(id, true, scope, 0 );
            })));
            const actions = {
                primary: notification.actions?.primary || [],
                secondary: notification.actions?.secondary || []
            };
            if (!notification.neverShowAgain.isSecondary) {
                actions.primary = [neverShowAgainAction, ...actions.primary];
            }
            else {
                actions.secondary = [...actions.secondary, neverShowAgainAction];
            }
            notification.actions = actions;
        }
        const handle = this.model.addNotification(notification);
        Event.once(handle.onDidClose)(() => toDispose.dispose());
        return handle;
    }
    toStorageScope(options) {
        switch (options.scope) {
            case NeverShowAgainScope.APPLICATION:
                return -1 ;
            case NeverShowAgainScope.PROFILE:
                return 0 ;
            case NeverShowAgainScope.WORKSPACE:
                return 1 ;
            default:
                return -1 ;
        }
    }
    prompt(severity, message, choices, options) {
        const toDispose = ( new DisposableStore());
        if (options?.neverShowAgain) {
            const scope = this.toStorageScope(options.neverShowAgain);
            const id = options.neverShowAgain.id;
            if (this.storageService.getBoolean(id, scope)) {
                return ( new NoOpNotification());
            }
            const neverShowAgainChoice = {
                label: ( localize('neverShowAgain', "Don't Show Again")),
                run: () => this.storageService.store(id, true, scope, 0 ),
                isSecondary: options.neverShowAgain.isSecondary
            };
            if (!options.neverShowAgain.isSecondary) {
                choices = [neverShowAgainChoice, ...choices];
            }
            else {
                choices = [...choices, neverShowAgainChoice];
            }
        }
        let choiceClicked = false;
        const primaryActions = [];
        const secondaryActions = [];
        choices.forEach((choice, index) => {
            const action = ( new ChoiceAction(`workbench.dialog.choice.${index}`, choice));
            if (!choice.isSecondary) {
                primaryActions.push(action);
            }
            else {
                secondaryActions.push(action);
            }
            toDispose.add(action.onDidRun(() => {
                choiceClicked = true;
                if (!choice.keepOpen) {
                    handle.close();
                }
            }));
            toDispose.add(action);
        });
        const actions = { primary: primaryActions, secondary: secondaryActions };
        const handle = this.notify({ severity, message, actions, sticky: options?.sticky, priority: options?.priority });
        Event.once(handle.onDidClose)(() => {
            toDispose.dispose();
            if (options && typeof options.onCancel === 'function' && !choiceClicked) {
                options.onCancel();
            }
        });
        return handle;
    }
    status(message, options) {
        return this.model.showStatusMessage(message, options);
    }
};
NotificationService = ( __decorate([
    ( __param(0, IStorageService))
], NotificationService));
export { NotificationService };
