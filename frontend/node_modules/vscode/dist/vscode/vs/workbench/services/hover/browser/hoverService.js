import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import './media/hover.css.js';
import { registerThemingParticipant } from 'monaco-editor/esm/vs/platform/theme/common/themeService.js';
import { editorHoverBorder } from 'monaco-editor/esm/vs/platform/theme/common/colorRegistry.js';
import { IContextViewService, IContextMenuService } from 'monaco-editor/esm/vs/platform/contextview/browser/contextView.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { HoverWidget } from './hoverWidget.js';
import { toDisposable, DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { addDisposableListener, EventType } from 'monaco-editor/esm/vs/base/browser/dom.js';
import { IKeybindingService } from 'monaco-editor/esm/vs/platform/keybinding/common/keybinding.js';
import { StandardKeyboardEvent } from 'monaco-editor/esm/vs/base/browser/keyboardEvent.js';
import { IAccessibilityService } from 'monaco-editor/esm/vs/platform/accessibility/common/accessibility.js';
let HoverService = class HoverService {
    constructor(_instantiationService, _contextViewService, contextMenuService, _keybindingService, _accessibilityService) {
        this._instantiationService = _instantiationService;
        this._contextViewService = _contextViewService;
        this._keybindingService = _keybindingService;
        this._accessibilityService = _accessibilityService;
        contextMenuService.onDidShowContextMenu(() => this.hideHover());
    }
    showHover(options, focus, skipLastFocusedUpdate) {
        if (getHoverOptionsIdentity(this._currentHoverOptions) === getHoverOptionsIdentity(options)) {
            return undefined;
        }
        this._currentHoverOptions = options;
        this._lastHoverOptions = options;
        const trapFocus = options.trapFocus || this._accessibilityService.isScreenReaderOptimized();
        if (!skipLastFocusedUpdate) {
            if (trapFocus && document.activeElement) {
                this._lastFocusedElementBeforeOpen = document.activeElement;
            }
            else {
                this._lastFocusedElementBeforeOpen = undefined;
            }
        }
        const hoverDisposables = ( (new DisposableStore()));
        const hover = this._instantiationService.createInstance(HoverWidget, options);
        hover.onDispose(() => {
            this._lastFocusedElementBeforeOpen?.focus();
            if (this._currentHoverOptions === options) {
                this._currentHoverOptions = undefined;
            }
            hoverDisposables.dispose();
        });
        const provider = this._contextViewService;
        provider.showContextView(( (new HoverContextViewDelegate(hover, focus))), options.container);
        hover.onRequestLayout(() => provider.layout());
        if ('targetElements' in options.target) {
            for (const element of options.target.targetElements) {
                hoverDisposables.add(addDisposableListener(element, EventType.CLICK, () => this.hideHover()));
            }
        }
        else {
            hoverDisposables.add(addDisposableListener(options.target, EventType.CLICK, () => this.hideHover()));
        }
        const focusedElement = document.activeElement;
        if (focusedElement) {
            hoverDisposables.add(addDisposableListener(focusedElement, EventType.KEY_DOWN, e => this._keyDown(e, hover, !!options.hideOnKeyDown)));
            hoverDisposables.add(addDisposableListener(document, EventType.KEY_DOWN, e => this._keyDown(e, hover, !!options.hideOnKeyDown)));
            hoverDisposables.add(addDisposableListener(focusedElement, EventType.KEY_UP, e => this._keyUp(e, hover)));
            hoverDisposables.add(addDisposableListener(document, EventType.KEY_UP, e => this._keyUp(e, hover)));
        }
        if ('IntersectionObserver' in window) {
            const observer = ( (new IntersectionObserver(e => this._intersectionChange(e, hover), { threshold: 0 })));
            const firstTargetElement = 'targetElements' in options.target ? options.target.targetElements[0] : options.target;
            observer.observe(firstTargetElement);
            hoverDisposables.add(toDisposable(() => observer.disconnect()));
        }
        this._currentHover = hover;
        return hover;
    }
    hideHover() {
        if (this._currentHover?.isLocked || !this._currentHoverOptions) {
            return;
        }
        this._currentHover = undefined;
        this._currentHoverOptions = undefined;
        this._contextViewService.hideContextView();
    }
    _intersectionChange(entries, hover) {
        const entry = entries[entries.length - 1];
        if (!entry.isIntersecting) {
            hover.dispose();
        }
    }
    showAndFocusLastHover() {
        if (!this._lastHoverOptions) {
            return;
        }
        this.showHover(this._lastHoverOptions, true, true);
    }
    _keyDown(e, hover, hideOnKeyDown) {
        if (e.key === 'Alt') {
            hover.isLocked = true;
            return;
        }
        const event = ( (new StandardKeyboardEvent(e)));
        const keybinding = this._keybindingService.resolveKeyboardEvent(event);
        if (( (keybinding.getSingleModifierDispatchChords().some(value => !!value))) || this._keybindingService.softDispatch(event, event.target).kind !== 0 ) {
            return;
        }
        if (hideOnKeyDown && (!this._currentHoverOptions?.trapFocus || e.key !== 'Tab')) {
            this.hideHover();
            this._lastFocusedElementBeforeOpen?.focus();
        }
    }
    _keyUp(e, hover) {
        if (e.key === 'Alt') {
            hover.isLocked = false;
            if (!hover.isMouseIn) {
                this.hideHover();
                this._lastFocusedElementBeforeOpen?.focus();
            }
        }
    }
};
HoverService = ( (__decorate([
    ( (__param(0, IInstantiationService))),
    ( (__param(1, IContextViewService))),
    ( (__param(2, IContextMenuService))),
    ( (__param(3, IKeybindingService))),
    ( (__param(4, IAccessibilityService)))
], HoverService)));
function getHoverOptionsIdentity(options) {
    if (options === undefined) {
        return undefined;
    }
    return options?.id ?? options;
}
class HoverContextViewDelegate {
    get anchorPosition() {
        return this._hover.anchor;
    }
    constructor(_hover, _focus = false) {
        this._hover = _hover;
        this._focus = _focus;
    }
    render(container) {
        this._hover.render(container);
        if (this._focus) {
            this._hover.focus();
        }
        return this._hover;
    }
    getAnchor() {
        return {
            x: this._hover.x,
            y: this._hover.y
        };
    }
    layout() {
        this._hover.layout();
    }
}
registerThemingParticipant((theme, collector) => {
    const hoverBorder = theme.getColor(editorHoverBorder);
    if (hoverBorder) {
        collector.addRule(`.monaco-workbench .workbench-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${( ( hoverBorder.transparent(0.5)))}; }`);
        collector.addRule(`.monaco-workbench .workbench-hover hr { border-top: 1px solid ${( ( hoverBorder.transparent(0.5)))}; }`);
    }
});
export { HoverService };
