import { __decorate, __param } from '../../../../../../node_modules/tslib/tslib.es6.js';
import { Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { LanguageDetectionStatsId } from '../common/languageDetectionWorkerService.js';
import { FileAccess, Schemas, nodeModulesPath, nodeModulesAsarPath } from 'monaco-editor/esm/vs/base/common/network.js';
import { IWorkbenchEnvironmentService } from '../../environment/common/environmentService.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { ILanguageService } from 'monaco-editor/esm/vs/editor/common/languages/language.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { isWeb } from 'monaco-editor/esm/vs/base/common/platform.js';
import { IModelService } from 'monaco-editor/esm/vs/editor/common/services/model.js';
import { SimpleWorkerClient } from 'monaco-editor/esm/vs/base/common/worker/simpleWorker.js';
import { ITelemetryService } from 'monaco-editor/esm/vs/platform/telemetry/common/telemetry.js';
import { EditorWorkerClient, EditorWorkerHost } from 'monaco-editor/esm/vs/editor/browser/services/editorWorkerService.js';
import { ILanguageConfigurationService } from 'monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js';
import { IDiagnosticsService } from '../../../../platform/diagnostics/common/diagnostics.js';
import { IWorkspaceContextService } from 'monaco-editor/esm/vs/platform/workspace/common/workspace.js';
import { IEditorService } from '../../editor/common/editorService.js';
import { IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
import { LRUCache } from 'monaco-editor/esm/vs/base/common/map.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
const TOP_LANG_COUNTS = 12;
const regexpModuleLocation = `${nodeModulesPath}/vscode-regexp-languagedetection`;
const regexpModuleLocationAsar = `${nodeModulesAsarPath}/vscode-regexp-languagedetection`;
const moduleLocation = `${nodeModulesPath}/@vscode/vscode-languagedetection`;
const moduleLocationAsar = `${nodeModulesAsarPath}/@vscode/vscode-languagedetection`;
let LanguageDetectionService = class LanguageDetectionService extends Disposable {
    static { this.enablementSettingKey = 'workbench.editor.languageDetection'; }
    static { this.historyBasedEnablementConfig = 'workbench.editor.historyBasedLanguageDetection'; }
    static { this.preferHistoryConfig = 'workbench.editor.preferHistoryBasedLanguageDetection'; }
    static { this.workspaceOpenedLanguagesStorageKey = 'workbench.editor.languageDetectionOpenedLanguages.workspace'; }
    static { this.globalOpenedLanguagesStorageKey = 'workbench.editor.languageDetectionOpenedLanguages.global'; }
    constructor(_environmentService, languageService, _configurationService, _diagnosticsService, _workspaceContextService, modelService, _editorService, telemetryService, storageService, _logService, languageConfigurationService) {
        super();
        this._environmentService = _environmentService;
        this._configurationService = _configurationService;
        this._diagnosticsService = _diagnosticsService;
        this._workspaceContextService = _workspaceContextService;
        this._editorService = _editorService;
        this._logService = _logService;
        this.hasResolvedWorkspaceLanguageIds = false;
        this.workspaceLanguageIds = ( new Set());
        this.sessionOpenedLanguageIds = ( new Set());
        this.historicalGlobalOpenedLanguageIds = ( new LRUCache(TOP_LANG_COUNTS));
        this.historicalWorkspaceOpenedLanguageIds = ( new LRUCache(TOP_LANG_COUNTS));
        this.dirtyBiases = true;
        this.langBiases = {};
        this._languageDetectionWorkerClient = ( new LanguageDetectionWorkerClient(
            modelService,
            languageService,
            telemetryService,
            this._environmentService.isBuilt && !isWeb
                ? ( ( FileAccess.asBrowserUri(`${moduleLocationAsar}/dist/lib/index.js`)).toString(true))
                : ( ( FileAccess.asBrowserUri(`${moduleLocation}/dist/lib/index.js`)).toString(true)),
            this._environmentService.isBuilt && !isWeb
                ? ( ( FileAccess.asBrowserUri(`${moduleLocationAsar}/model/model.json`)).toString(true))
                : ( ( FileAccess.asBrowserUri(`${moduleLocation}/model/model.json`)).toString(true)),
            this._environmentService.isBuilt && !isWeb
                ? ( ( FileAccess.asBrowserUri(`${moduleLocationAsar}/model/group1-shard1of1.bin`)).toString(true))
                : ( ( FileAccess.asBrowserUri(`${moduleLocation}/model/group1-shard1of1.bin`)).toString(true)),
            this._environmentService.isBuilt && !isWeb
                ? ( ( FileAccess.asBrowserUri(`${regexpModuleLocationAsar}/dist/index.js`)).toString(true))
                : ( ( FileAccess.asBrowserUri(`${regexpModuleLocation}/dist/index.js`)).toString(true)),
            languageConfigurationService
        ));
        this.initEditorOpenedListeners(storageService);
    }
    async resolveWorkspaceLanguageIds() {
        if (this.hasResolvedWorkspaceLanguageIds) {
            return;
        }
        this.hasResolvedWorkspaceLanguageIds = true;
        const fileExtensions = await this._diagnosticsService.getWorkspaceFileExtensions(this._workspaceContextService.getWorkspace());
        let count = 0;
        for (const ext of fileExtensions.extensions) {
            const langId = this._languageDetectionWorkerClient.getLanguageId(ext);
            if (langId && count < TOP_LANG_COUNTS) {
                this.workspaceLanguageIds.add(langId);
                count++;
                if (count > TOP_LANG_COUNTS) {
                    break;
                }
            }
        }
        this.dirtyBiases = true;
    }
    isEnabledForLanguage(languageId) {
        return !!languageId && this._configurationService.getValue(LanguageDetectionService.enablementSettingKey, { overrideIdentifier: languageId });
    }
    getLanguageBiases() {
        if (!this.dirtyBiases) {
            return this.langBiases;
        }
        const biases = {};
        this.sessionOpenedLanguageIds.forEach(lang => biases[lang] = (biases[lang] ?? 0) + 7);
        this.workspaceLanguageIds.forEach(lang => biases[lang] = (biases[lang] ?? 0) + 5);
        [...( this.historicalWorkspaceOpenedLanguageIds.keys())].forEach(lang => biases[lang] = (biases[lang] ?? 0) + 3);
        [...( this.historicalGlobalOpenedLanguageIds.keys())].forEach(lang => biases[lang] = (biases[lang] ?? 0) + 1);
        this._logService.trace('Session Languages:', JSON.stringify([...this.sessionOpenedLanguageIds]));
        this._logService.trace('Workspace Languages:', JSON.stringify([...this.workspaceLanguageIds]));
        this._logService.trace('Historical Workspace Opened Languages:', JSON.stringify([...( this.historicalWorkspaceOpenedLanguageIds.keys())]));
        this._logService.trace('Historical Globally Opened Languages:', JSON.stringify([...( this.historicalGlobalOpenedLanguageIds.keys())]));
        this._logService.trace('Computed Language Detection Biases:', JSON.stringify(biases));
        this.dirtyBiases = false;
        this.langBiases = biases;
        return biases;
    }
    async detectLanguage(resource, supportedLangs) {
        const useHistory = this._configurationService.getValue(LanguageDetectionService.historyBasedEnablementConfig);
        const preferHistory = this._configurationService.getValue(LanguageDetectionService.preferHistoryConfig);
        if (useHistory) {
            await this.resolveWorkspaceLanguageIds();
        }
        const biases = useHistory ? this.getLanguageBiases() : undefined;
        return this._languageDetectionWorkerClient.detectLanguage(resource, biases, preferHistory, supportedLangs);
    }
    initEditorOpenedListeners(storageService) {
        try {
            const globalLangHistoryData = JSON.parse(storageService.get(LanguageDetectionService.globalOpenedLanguagesStorageKey, 0 , '[]'));
            this.historicalGlobalOpenedLanguageIds.fromJSON(globalLangHistoryData);
        }
        catch (e) {
            console.error(e);
        }
        try {
            const workspaceLangHistoryData = JSON.parse(storageService.get(LanguageDetectionService.workspaceOpenedLanguagesStorageKey, 1 , '[]'));
            this.historicalWorkspaceOpenedLanguageIds.fromJSON(workspaceLangHistoryData);
        }
        catch (e) {
            console.error(e);
        }
        this._register(this._editorService.onDidActiveEditorChange(() => {
            const activeLanguage = this._editorService.activeTextEditorLanguageId;
            if (activeLanguage && this._editorService.activeEditor?.resource?.scheme !== Schemas.untitled) {
                this.sessionOpenedLanguageIds.add(activeLanguage);
                this.historicalGlobalOpenedLanguageIds.set(activeLanguage, true);
                this.historicalWorkspaceOpenedLanguageIds.set(activeLanguage, true);
                storageService.store(LanguageDetectionService.globalOpenedLanguagesStorageKey, JSON.stringify(this.historicalGlobalOpenedLanguageIds.toJSON()), 0 , 1 );
                storageService.store(LanguageDetectionService.workspaceOpenedLanguagesStorageKey, JSON.stringify(this.historicalWorkspaceOpenedLanguageIds.toJSON()), 1 , 1 );
                this.dirtyBiases = true;
            }
        }));
    }
};
LanguageDetectionService = ( __decorate([
    ( __param(0, IWorkbenchEnvironmentService)),
    ( __param(1, ILanguageService)),
    ( __param(2, IConfigurationService)),
    ( __param(3, IDiagnosticsService)),
    ( __param(4, IWorkspaceContextService)),
    ( __param(5, IModelService)),
    ( __param(6, IEditorService)),
    ( __param(7, ITelemetryService)),
    ( __param(8, IStorageService)),
    ( __param(9, ILogService)),
    ( __param(10, ILanguageConfigurationService))
], LanguageDetectionService));
class LanguageDetectionWorkerClient extends EditorWorkerClient {
    constructor(modelService, _languageService, _telemetryService, _indexJsUri, _modelJsonUri, _weightsUri, _regexpModelUri, languageConfigurationService) {
        super(modelService, true, 'languageDetectionWorkerService', languageConfigurationService);
        this._languageService = _languageService;
        this._telemetryService = _telemetryService;
        this._indexJsUri = _indexJsUri;
        this._modelJsonUri = _modelJsonUri;
        this._weightsUri = _weightsUri;
        this._regexpModelUri = _regexpModelUri;
    }
    _getOrCreateLanguageDetectionWorker() {
        if (this.workerPromise) {
            return this.workerPromise;
        }
        this.workerPromise = ( new Promise((resolve, reject) => {
            resolve(this._register(( new SimpleWorkerClient(
                this._workerFactory,
                'vs/workbench/services/languageDetection/browser/languageDetectionSimpleWorker',
                ( new EditorWorkerHost(this))
            ))));
        }));
        return this.workerPromise;
    }
    _guessLanguageIdByUri(uri) {
        const guess = this._languageService.guessLanguageIdByFilepathOrFirstLine(uri);
        if (guess && guess !== 'unknown') {
            return guess;
        }
        return undefined;
    }
    async _getProxy() {
        return (await this._getOrCreateLanguageDetectionWorker()).getProxyObject();
    }
    async fhr(method, args) {
        switch (method) {
            case 'getIndexJsUri':
                return this.getIndexJsUri();
            case 'getModelJsonUri':
                return this.getModelJsonUri();
            case 'getWeightsUri':
                return this.getWeightsUri();
            case 'getRegexpModelUri':
                return this.getRegexpModelUri();
            case 'getLanguageId':
                return this.getLanguageId(args[0]);
            case 'sendTelemetryEvent':
                return this.sendTelemetryEvent(args[0], args[1], args[2]);
            default:
                return super.fhr(method, args);
        }
    }
    async getIndexJsUri() {
        return this._indexJsUri;
    }
    getLanguageId(languageIdOrExt) {
        if (!languageIdOrExt) {
            return undefined;
        }
        if (this._languageService.isRegisteredLanguageId(languageIdOrExt)) {
            return languageIdOrExt;
        }
        const guessed = this._guessLanguageIdByUri(URI.file(`file.${languageIdOrExt}`));
        if (!guessed || guessed === 'unknown') {
            return undefined;
        }
        return guessed;
    }
    async getModelJsonUri() {
        return this._modelJsonUri;
    }
    async getWeightsUri() {
        return this._weightsUri;
    }
    async getRegexpModelUri() {
        return this._regexpModelUri;
    }
    async sendTelemetryEvent(languages, confidences, timeSpent) {
        this._telemetryService.publicLog2(LanguageDetectionStatsId, {
            languages: languages.join(','),
            confidences: confidences.join(','),
            timeSpent
        });
    }
    async detectLanguage(resource, langBiases, preferHistory, supportedLangs) {
        const startTime = Date.now();
        const quickGuess = this._guessLanguageIdByUri(resource);
        if (quickGuess) {
            return quickGuess;
        }
        await this._withSyncedResources([resource]);
        const modelId = await (await this._getProxy()).detectLanguage(( resource.toString()), langBiases, preferHistory, supportedLangs);
        const languageId = this.getLanguageId(modelId);
        const LanguageDetectionStatsId = 'automaticlanguagedetection.perf';
        this._telemetryService.publicLog2(LanguageDetectionStatsId, {
            timeSpent: Date.now() - startTime,
            detection: languageId || 'unknown',
        });
        return languageId;
    }
}
export { LanguageDetectionService, LanguageDetectionWorkerClient };
