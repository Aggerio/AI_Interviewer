import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { ILifecycleService } from '../services/lifecycle/common/lifecycle.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { DeferredPromise, runWhenIdle } from 'monaco-editor/esm/vs/base/common/async.js';
import { mark } from 'monaco-editor/esm/vs/base/common/performance.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { IEnvironmentService } from 'monaco-editor/esm/vs/platform/environment/common/environment.js';
var Extensions;
( (function(Extensions) {
    Extensions.Workbench = 'workbench.contributions.kind';
})(Extensions || (Extensions = {})));
class WorkbenchContributionsRegistry {
    constructor() {
        this.contributions = ( new Map());
        this.pendingRestoredContributions = ( new DeferredPromise());
    }
    registerWorkbenchContribution(contribution, phase = 1 ) {
        if (this.instantiationService && this.lifecycleService && this.logService && this.environmentService && this.lifecycleService.phase >= phase) {
            this.safeCreateContribution(this.instantiationService, this.logService, this.environmentService, contribution, phase);
        }
        else {
            let contributions = this.contributions.get(phase);
            if (!contributions) {
                contributions = [];
                this.contributions.set(phase, contributions);
            }
            contributions.push(contribution);
        }
    }
    start(accessor) {
        const instantiationService = this.instantiationService = accessor.get(IInstantiationService);
        const lifecycleService = this.lifecycleService = accessor.get(ILifecycleService);
        const logService = this.logService = accessor.get(ILogService);
        const environmentService = this.environmentService = accessor.get(IEnvironmentService);
        for (const phase of [1 , 2 , 3 , 4 ]) {
            this.instantiateByPhase(instantiationService, lifecycleService, logService, environmentService, phase);
        }
    }
    instantiateByPhase(instantiationService, lifecycleService, logService, environmentService, phase) {
        if (lifecycleService.phase >= phase) {
            this.doInstantiateByPhase(instantiationService, logService, environmentService, phase);
        }
        else {
            lifecycleService.when(phase).then(() => this.doInstantiateByPhase(instantiationService, logService, environmentService, phase));
        }
    }
    async doInstantiateByPhase(instantiationService, logService, environmentService, phase) {
        const contributions = this.contributions.get(phase);
        if (contributions) {
            this.contributions.delete(phase);
            switch (phase) {
                case 1 :
                case 2 : {
                    mark(`code/willCreateWorkbenchContributions/${phase}`);
                    for (const contribution of contributions) {
                        this.safeCreateContribution(instantiationService, logService, environmentService, contribution, phase);
                    }
                    mark(`code/didCreateWorkbenchContributions/${phase}`);
                    break;
                }
                case 3 :
                case 4 : {
                    if (phase === 4 ) {
                        await this.pendingRestoredContributions.p;
                    }
                    this.doInstantiateWhenIdle(contributions, instantiationService, logService, environmentService, phase);
                    break;
                }
            }
        }
    }
    doInstantiateWhenIdle(contributions, instantiationService, logService, environmentService, phase) {
        mark(`code/willCreateWorkbenchContributions/${phase}`);
        let i = 0;
        const forcedTimeout = phase === 4  ? 3000 : 500;
        const instantiateSome = (idle) => {
            while (i < contributions.length) {
                const contribution = contributions[i++];
                this.safeCreateContribution(instantiationService, logService, environmentService, contribution, phase);
                if (idle.timeRemaining() < 1) {
                    runWhenIdle(instantiateSome, forcedTimeout);
                    break;
                }
            }
            if (i === contributions.length) {
                mark(`code/didCreateWorkbenchContributions/${phase}`);
                if (phase === 3 ) {
                    this.pendingRestoredContributions.complete();
                }
            }
        };
        runWhenIdle(instantiateSome, forcedTimeout);
    }
    safeCreateContribution(instantiationService, logService, environmentService, contribution, phase) {
        const now = phase < 3  ? Date.now() : undefined;
        try {
            instantiationService.createInstance(contribution);
        }
        catch (error) {
            logService.error(`Unable to create workbench contribution ${contribution.name}.`, error);
        }
        if (typeof now === 'number' && !environmentService.isBuilt ) {
            const time = Date.now() - now;
            if (time > 20) {
                logService.warn(`Workbench contribution ${contribution.name} blocked restore phase by ${time}ms.`);
            }
        }
    }
}
Registry.add(Extensions.Workbench, ( new WorkbenchContributionsRegistry()));
export { Extensions };
