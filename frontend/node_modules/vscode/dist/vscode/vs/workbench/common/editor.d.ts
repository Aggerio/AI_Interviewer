import { Event } from '../../base/common/event.js';
import { URI } from '../../base/common/uri.js';
import { Disposable } from '../../base/common/lifecycle.js';
import { IDiffEditor } from '../../editor/common/editorCommon.js';
import { IEditorOptions, IBaseTextResourceEditorInput, IBaseUntypedEditorInput, IResourceEditorInput, ITextResourceEditorInput } from '../../platform/editor/common/editor.js';
import { EditorInput } from './editor/editorInput.js';
import { IInstantiationService } from '../../platform/instantiation/common/instantiation.js';
import { IContextKeyService } from '../../platform/contextkey/common/contextkey.js';
import { IEncodingSupport, ILanguageSupport } from '../services/textfile/common/textfiles.js';
import { IEditorGroup } from '../services/editor/common/editorGroupsService.js';
import { IComposite, ICompositeControl } from './composite.js';

interface IEditorDescriptor<T extends IEditorPane> {
    /**
     * The unique type identifier of the editor. All instances
     * of the same `IEditorPane` should have the same type
     * identifier.
     */
    readonly typeId: string;
    /**
     * The display name of the editor.
     */
    readonly name: string;
    /**
     * Instantiates the editor pane using the provided services.
     */
    instantiate(instantiationService: IInstantiationService): T;
    /**
     * Whether the descriptor is for the provided editor pane.
     */
    describes(editorPane: T): boolean;
}
/**
 * The editor pane is the container for workbench editors.
 */
interface IEditorPane extends IComposite {
    /**
     * An event to notify when the `IEditorControl` in this
     * editor pane changes.
     *
     * This can be used for editor panes that are a compound
     * of multiple editor controls to signal that the active
     * editor control has changed when the user clicks around.
     */
    readonly onDidChangeControl: Event<void>;
    /**
     * An optional event to notify when the selection inside the editor
     * pane changed in case the editor has a selection concept.
     *
     * For example, in a text editor pane, the selection changes whenever
     * the cursor is set to a new location.
     */
    readonly onDidChangeSelection?: Event<IEditorPaneSelectionChangeEvent>;
    /**
     * The assigned input of this editor.
     */
    readonly input: EditorInput | undefined;
    /**
     * The assigned options of the editor.
     */
    readonly options: IEditorOptions | undefined;
    /**
     * The assigned group this editor is showing in.
     */
    readonly group: IEditorGroup | undefined;
    /**
     * The minimum width of this editor.
     */
    readonly minimumWidth: number;
    /**
     * The maximum width of this editor.
     */
    readonly maximumWidth: number;
    /**
     * The minimum height of this editor.
     */
    readonly minimumHeight: number;
    /**
     * The maximum height of this editor.
     */
    readonly maximumHeight: number;
    /**
     * An event to notify whenever minimum/maximum width/height changes.
     */
    readonly onDidChangeSizeConstraints: Event<{
        width: number;
        height: number;
    } | undefined>;
    /**
     * The context key service for this editor. Should be overridden by
     * editors that have their own ScopedContextKeyService
     */
    readonly scopedContextKeyService: IContextKeyService | undefined;
    /**
     * Returns the underlying control of this editor. Callers need to cast
     * the control to a specific instance as needed, e.g. by using the
     * `isCodeEditor` helper method to access the text code editor.
     *
     * Use the `onDidChangeControl` event to track whenever the control
     * changes.
     */
    getControl(): IEditorControl | undefined;
    /**
     * Returns the current view state of the editor if any.
     *
     * This method is optional to override for the editor pane
     * and should only be overridden when the pane can deal with
     * `IEditorOptions.viewState` to be applied when opening.
     */
    getViewState(): object | undefined;
    /**
     * An optional method to return the current selection in
     * the editor pane in case the editor pane has a selection
     * concept.
     *
     * Clients of this method will typically react to the
     * `onDidChangeSelection` event to receive the current
     * selection as needed.
     */
    getSelection?(): IEditorPaneSelection | undefined;
    /**
     * Finds out if this editor is visible or not.
     */
    isVisible(): boolean;
}
interface IEditorPaneSelectionChangeEvent {
    /**
     * More details for how the selection was made.
     */
    reason: EditorPaneSelectionChangeReason;
}
declare const enum EditorPaneSelectionChangeReason {
    /**
     * The selection was changed as a result of a programmatic
     * method invocation.
     *
     * For a text editor pane, this for example can be a selection
     * being restored from previous view state automatically.
     */
    PROGRAMMATIC = 1,
    /**
     * The selection was changed by the user.
     *
     * This typically means the user changed the selection
     * with mouse or keyboard.
     */
    USER = 2,
    /**
     * The selection was changed as a result of editing in
     * the editor pane.
     *
     * For a text editor pane, this for example can be typing
     * in the text of the editor pane.
     */
    EDIT = 3,
    /**
     * The selection was changed as a result of a navigation
     * action.
     *
     * For a text editor pane, this for example can be a result
     * of selecting an entry from a text outline view.
     */
    NAVIGATION = 4,
    /**
     * The selection was changed as a result of a jump action
     * from within the editor pane.
     *
     * For a text editor pane, this for example can be a result
     * of invoking "Go to definition" from a symbol.
     */
    JUMP = 5
}
interface IEditorPaneSelection {
    /**
     * Asks to compare this selection to another selection.
     */
    compare(otherSelection: IEditorPaneSelection): EditorPaneSelectionCompareResult;
    /**
     * Asks to massage the provided `options` in a way
     * that the selection can be restored when the editor
     * is opened again.
     *
     * For a text editor this means to apply the selected
     * line and column as text editor options.
     */
    restore(options: IEditorOptions): IEditorOptions;
    /**
     * Only used for logging to print more info about the selection.
     */
    log?(): string;
}
declare const enum EditorPaneSelectionCompareResult {
    /**
     * The selections are identical.
     */
    IDENTICAL = 1,
    /**
     * The selections are similar.
     *
     * For a text editor this can mean that the one
     * selection is in close proximity to the other
     * selection.
     *
     * Upstream clients may decide in this case to
     * not treat the selection different from the
     * previous one because it is not distinct enough.
     */
    SIMILAR = 2,
    /**
     * The selections are entirely different.
     */
    DIFFERENT = 3
}
/**
 * Overrides `IEditorPane` where `input` and `group` are known to be set.
 */
interface IVisibleEditorPane extends IEditorPane {
    readonly input: EditorInput;
    readonly group: IEditorGroup;
}
/**
 * The text editor pane is the container for workbench text diff editors.
 */
interface ITextDiffEditorPane extends IEditorPane {
    /**
     * Returns the underlying text diff editor widget of this editor.
     */
    getControl(): IDiffEditor | undefined;
}
/**
 * Marker interface for the control inside an editor pane. Callers
 * have to cast the control to work with it, e.g. via methods
 * such as `isCodeEditor(control)`.
 */
interface IEditorControl extends ICompositeControl {
}
interface IUntitledTextResourceEditorInput extends IBaseTextResourceEditorInput {
    /**
     * Optional resource for the untitled editor. Depending on the value, the editor:
     * - should get a unique name if `undefined` (for example `Untitled-1`)
     * - should use the resource directly if the scheme is `untitled:`
     * - should change the scheme to `untitled:` otherwise and assume an associated path
     *
     * Untitled editors with associated path behave slightly different from other untitled
     * editors:
     * - they are dirty right when opening
     * - they will not ask for a file path when saving but use the associated path
     */
    readonly resource: URI | undefined;
}
/**
 * A resource side by side editor input shows 2 editors side by side but
 * without highlighting any differences.
 *
 * Note: both sides will be resolved as editor individually. As such, it is
 * possible to show 2 different editors side by side.
 *
 * @see {@link IResourceDiffEditorInput} for a variant that compares 2 editors.
 */
interface IResourceSideBySideEditorInput extends IBaseUntypedEditorInput {
    /**
     * The right hand side editor to open inside a side-by-side editor.
     */
    readonly primary: IResourceEditorInput | ITextResourceEditorInput | IUntitledTextResourceEditorInput;
    /**
     * The left hand side editor to open inside a side-by-side editor.
     */
    readonly secondary: IResourceEditorInput | ITextResourceEditorInput | IUntitledTextResourceEditorInput;
}
/**
 * A resource diff editor input compares 2 editors side by side
 * highlighting the differences.
 *
 * Note: both sides must be resolvable to the same editor, or
 * a text based presentation will be used as fallback.
 */
interface IResourceDiffEditorInput extends IBaseUntypedEditorInput {
    /**
     * The left hand side editor to open inside a diff editor.
     */
    readonly original: IResourceEditorInput | ITextResourceEditorInput | IUntitledTextResourceEditorInput;
    /**
     * The right hand side editor to open inside a diff editor.
     */
    readonly modified: IResourceEditorInput | ITextResourceEditorInput | IUntitledTextResourceEditorInput;
}
type IResourceMergeEditorInputSide = (IResourceEditorInput | ITextResourceEditorInput) & {
    detail?: string;
};
/**
 * A resource merge editor input compares multiple editors
 * highlighting the differences for merging.
 *
 * Note: all sides must be resolvable to the same editor, or
 * a text based presentation will be used as fallback.
 */
interface IResourceMergeEditorInput extends IBaseUntypedEditorInput {
    /**
     * The one changed version of the file.
     */
    readonly input1: IResourceMergeEditorInputSide;
    /**
     * The second changed version of the file.
     */
    readonly input2: IResourceMergeEditorInputSide;
    /**
     * The base common ancestor of the file to merge.
     */
    readonly base: IResourceEditorInput | ITextResourceEditorInput;
    /**
     * The resulting output of the merge.
     */
    readonly result: IResourceEditorInput | ITextResourceEditorInput;
}
declare const enum Verbosity {
    SHORT = 0,
    MEDIUM = 1,
    LONG = 2
}
declare const enum SaveReason {
    /**
     * Explicit user gesture.
     */
    EXPLICIT = 1,
    /**
     * Auto save after a timeout.
     */
    AUTO = 2,
    /**
     * Auto save after editor focus change.
     */
    FOCUS_CHANGE = 3,
    /**
     * Auto save after window change.
     */
    WINDOW_CHANGE = 4
}
type SaveSource = string;
interface ISaveOptions {
    /**
     * An indicator how the save operation was triggered.
     */
    reason?: SaveReason;
    /**
     * An indicator about the source of the save operation.
     *
     * Must use `SaveSourceRegistry.registerSource()` to obtain.
     */
    readonly source?: SaveSource;
    /**
     * Forces to save the contents of the working copy
     * again even if the working copy is not dirty.
     */
    readonly force?: boolean;
    /**
     * Instructs the save operation to skip any save participants.
     */
    readonly skipSaveParticipants?: boolean;
    /**
     * A hint as to which file systems should be available for saving.
     */
    readonly availableFileSystems?: string[];
}
interface IRevertOptions {
    /**
     * Forces to load the contents of the working copy
     * again even if the working copy is not dirty.
     */
    readonly force?: boolean;
    /**
     * A soft revert will clear dirty state of a working copy
     * but will not attempt to load it from its persisted state.
     *
     * This option may be used in scenarios where an editor is
     * closed and where we do not require to load the contents.
     */
    readonly soft?: boolean;
}
interface IMoveResult {
    editor: EditorInput | IUntypedEditorInput;
    options?: IEditorOptions;
}
declare const enum EditorInputCapabilities {
    /**
     * Signals no specific capability for the input.
     */
    None = 0,
    /**
     * Signals that the input is readonly.
     */
    Readonly = 2,
    /**
     * Signals that the input is untitled.
     */
    Untitled = 4,
    /**
     * Signals that the input can only be shown in one group
     * and not be split into multiple groups.
     */
    Singleton = 8,
    /**
     * Signals that the input requires workspace trust.
     */
    RequiresTrust = 16,
    /**
     * Signals that the editor can split into 2 in the same
     * editor group.
     */
    CanSplitInGroup = 32,
    /**
     * Signals that the editor wants its description to be
     * visible when presented to the user. By default, a UI
     * component may decide to hide the description portion
     * for brevity.
     */
    ForceDescription = 64,
    /**
     * Signals that the editor supports dropping into the
     * editor by holding shift.
     */
    CanDropIntoEditor = 128,
    /**
     * Signals that the editor is composed of multiple editors
     * within.
     */
    MultipleEditors = 256,
    /**
     * Signals that the editor cannot be in a dirty state
     * and may still have unsaved changes
     */
    Scratchpad = 512
}
type IUntypedEditorInput = IResourceEditorInput | ITextResourceEditorInput | IUntitledTextResourceEditorInput | IResourceDiffEditorInput | IResourceSideBySideEditorInput | IResourceMergeEditorInput;
declare abstract class AbstractEditorInput extends Disposable {
}
interface EditorInputWithPreferredResource {
    /**
     * An editor may provide an additional preferred resource alongside
     * the `resource` property. While the `resource` property serves as
     * unique identifier of the editor that should be used whenever we
     * compare to other editors, the `preferredResource` should be used
     * in places where e.g. the resource is shown to the user.
     *
     * For example: on Windows and macOS, the same URI with different
     * casing may point to the same file. The editor may chose to
     * "normalize" the URIs so that only one editor opens for different
     * URIs. But when displaying the editor label to the user, the
     * preferred URI should be used.
     *
     * Not all editors have a `preferredResource`. The `EditorResourceAccessor`
     * utility can be used to always get the right resource without having
     * to do instanceof checks.
     */
    readonly preferredResource: URI;
}
interface IUntypedFileEditorInput extends ITextResourceEditorInput {
    /**
     * A marker to create a `IFileEditorInput` from this untyped input.
     */
    forceFile: true;
}
/**
 * This is a tagging interface to declare an editor input being capable of dealing with files. It is only used in the editor registry
 * to register this kind of input to the platform.
 */
interface IFileEditorInput extends EditorInput, IEncodingSupport, ILanguageSupport, EditorInputWithPreferredResource {
    /**
     * Gets the resource this file input is about. This will always be the
     * canonical form of the resource, so it may differ from the original
     * resource that was provided to create the input. Use `preferredResource`
     * for the form as it was created.
     */
    readonly resource: URI;
    /**
     * Sets the preferred resource to use for this file input.
     */
    setPreferredResource(preferredResource: URI): void;
    /**
     * Sets the preferred name to use for this file input.
     *
     * Note: for certain file schemes the input may decide to ignore this
     * name and use our standard naming. Specifically for schemes we own,
     * we do not let others override the name.
     */
    setPreferredName(name: string): void;
    /**
     * Sets the preferred description to use for this file input.
     *
     * Note: for certain file schemes the input may decide to ignore this
     * description and use our standard naming. Specifically for schemes we own,
     * we do not let others override the description.
     */
    setPreferredDescription(description: string): void;
    /**
     * Sets the preferred encoding to use for this file input.
     */
    setPreferredEncoding(encoding: string): void;
    /**
     * Sets the preferred language id to use for this file input.
     */
    setPreferredLanguageId(languageId: string): void;
    /**
     * Sets the preferred contents to use for this file input.
     */
    setPreferredContents(contents: string): void;
    /**
     * Forces this file input to open as binary instead of text.
     */
    setForceOpenAsBinary(): void;
    /**
     * Figure out if the file input has been resolved or not.
     */
    isResolved(): boolean;
}
interface EditorInputWithOptions {
    editor: EditorInput;
    options?: IEditorOptions;
}
interface EditorInputWithOptionsAndGroup extends EditorInputWithOptions {
    group: IEditorGroup;
}
interface IEditorIdentifier {
    groupId: GroupIdentifier;
    editor: EditorInput;
}
/**
 * More information around why an editor was closed in the model.
 */
declare enum EditorCloseContext {
    /**
     * No specific context for closing (e.g. explicit user gesture).
     */
    UNKNOWN = 0,
    /**
     * The editor closed because it was replaced with another editor.
     * This can either happen via explicit replace call or when an
     * editor is in preview mode and another editor opens.
     */
    REPLACE = 1,
    /**
     * The editor closed as a result of moving it to another group.
     */
    MOVE = 2,
    /**
     * The editor closed because another editor turned into preview
     * and this used to be the preview editor before.
     */
    UNPIN = 3
}
interface IEditorCloseEvent extends IEditorIdentifier {
    /**
     * More information around why the editor was closed.
     */
    readonly context: EditorCloseContext;
    /**
     * The index of the editor before closing.
     */
    readonly index: number;
    /**
     * Whether the editor was sticky or not.
     */
    readonly sticky: boolean;
}
interface IActiveEditorChangeEvent {
    /**
     * The new active editor or `undefined` if the group is empty.
     */
    editor: EditorInput | undefined;
}
interface IEditorWillMoveEvent extends IEditorIdentifier {
    /**
     * The target group of the move operation.
     */
    readonly target: GroupIdentifier;
}
interface IEditorWillOpenEvent extends IEditorIdentifier {
}
type GroupIdentifier = number;
declare const enum GroupModelChangeKind {
    GROUP_ACTIVE = 0,
    GROUP_INDEX = 1,
    GROUP_LOCKED = 2,
    EDITOR_OPEN = 3,
    EDITOR_CLOSE = 4,
    EDITOR_MOVE = 5,
    EDITOR_ACTIVE = 6,
    EDITOR_LABEL = 7,
    EDITOR_CAPABILITIES = 8,
    EDITOR_PIN = 9,
    EDITOR_STICKY = 10,
    EDITOR_DIRTY = 11,
    EDITOR_WILL_DISPOSE = 12
}
interface IEditorPartConfiguration {
    showTabs?: boolean;
    wrapTabs?: boolean;
    scrollToSwitchTabs?: boolean;
    highlightModifiedTabs?: boolean;
    tabCloseButton?: 'left' | 'right' | 'off';
    tabSizing?: 'fit' | 'shrink' | 'fixed';
    tabSizingFixedMinWidth?: number;
    tabSizingFixedMaxWidth?: number;
    pinnedTabSizing?: 'normal' | 'compact' | 'shrink';
    titleScrollbarSizing?: 'default' | 'large';
    focusRecentEditorAfterClose?: boolean;
    showIcons?: boolean;
    enablePreview?: boolean;
    enablePreviewFromQuickOpen?: boolean;
    enablePreviewFromCodeNavigation?: boolean;
    closeOnFileDelete?: boolean;
    openPositioning?: 'left' | 'right' | 'first' | 'last';
    openSideBySideDirection?: 'right' | 'down';
    closeEmptyGroups?: boolean;
    autoLockGroups?: Set<string>;
    revealIfOpen?: boolean;
    mouseBackForwardToNavigate?: boolean;
    labelFormat?: 'default' | 'short' | 'medium' | 'long';
    restoreViewState?: boolean;
    splitInGroupLayout?: 'vertical' | 'horizontal';
    splitSizing?: 'auto' | 'split' | 'distribute';
    splitOnDragAndDrop?: boolean;
    centeredLayoutFixedWidth?: boolean;
    doubleClickTabToToggleEditorGroupSizes?: boolean;
    limit?: {
        enabled?: boolean;
        excludeDirty?: boolean;
        value?: number;
        perEditorGroup?: boolean;
    };
    decorations?: {
        badges?: boolean;
        colors?: boolean;
    };
}
interface IEditorPartOptions extends IEditorPartConfiguration {
    hasIcons?: boolean;
}
interface IEditorPartOptionsChangeEvent {
    oldPartOptions: IEditorPartOptions;
    newPartOptions: IEditorPartOptions;
}
declare enum SideBySideEditor {
    PRIMARY = 1,
    SECONDARY = 2,
    BOTH = 3,
    ANY = 4
}
interface IFindEditorOptions {
    /**
     * Whether to consider any or both side by side editor as matching.
     * By default, side by side editors will not be considered
     * as matching, even if the editor is opened in one of the sides.
     */
    supportSideBySide?: SideBySideEditor.PRIMARY | SideBySideEditor.SECONDARY | SideBySideEditor.ANY;
}
interface IMatchEditorOptions {
    /**
     * Whether to consider a side by side editor as matching.
     * By default, side by side editors will not be considered
     * as matching, even if the editor is opened in one of the sides.
     */
    supportSideBySide?: SideBySideEditor.ANY | SideBySideEditor.BOTH;
    /**
     * Only consider an editor to match when the
     * `candidate === editor` but not when
     * `candidate.matches(editor)`.
     */
    strictEquals?: boolean;
}
declare const enum CloseDirection {
    LEFT = 0,
    RIGHT = 1
}
declare const enum EditorsOrder {
    /**
     * Editors sorted by most recent activity (most recent active first)
     */
    MOST_RECENTLY_ACTIVE = 0,
    /**
     * Editors sorted by sequential order
     */
    SEQUENTIAL = 1
}

export { AbstractEditorInput, CloseDirection, EditorCloseContext, EditorInputCapabilities, EditorInputWithOptions, EditorInputWithOptionsAndGroup, EditorInputWithPreferredResource, EditorPaneSelectionChangeReason, EditorPaneSelectionCompareResult, EditorsOrder, GroupIdentifier, GroupModelChangeKind, IActiveEditorChangeEvent, IEditorCloseEvent, IEditorControl, IEditorDescriptor, IEditorIdentifier, IEditorPane, IEditorPaneSelection, IEditorPaneSelectionChangeEvent, IEditorPartOptions, IEditorPartOptionsChangeEvent, IEditorWillMoveEvent, IEditorWillOpenEvent, IFileEditorInput, IFindEditorOptions, IMatchEditorOptions, IMoveResult, IResourceDiffEditorInput, IResourceMergeEditorInput, IResourceMergeEditorInputSide, IResourceSideBySideEditorInput, IRevertOptions, ISaveOptions, ITextDiffEditorPane, IUntitledTextResourceEditorInput, IUntypedEditorInput, IUntypedFileEditorInput, IVisibleEditorPane, SaveReason, SaveSource, SideBySideEditor, Verbosity };
