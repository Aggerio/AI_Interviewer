import { __decorate, __param } from '../../../../node_modules/tslib/tslib.es6.js';
import { DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { RawContextKey, IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { isEqual, basename, dirname, extname } from 'monaco-editor/esm/vs/base/common/resources.js';
import { ILanguageService } from 'monaco-editor/esm/vs/editor/common/languages/language.js';
import { IFileService } from 'monaco-editor/esm/vs/platform/files/common/files.js';
import { IModelService } from 'monaco-editor/esm/vs/editor/common/services/model.js';
import { Schemas } from 'monaco-editor/esm/vs/base/common/network.js';
import { DEFAULT_EDITOR_ASSOCIATION } from './editor.js';
const WorkbenchStateContext = ( new RawContextKey('workbenchState', undefined, { type: 'string', description: ( localize(
    'workbenchState',
    "The kind of workspace opened in the window, either 'empty' (no workspace), 'folder' (single folder) or 'workspace' (multi-root workspace)"
)) }));
const WorkspaceFolderCountContext = ( new RawContextKey('workspaceFolderCount', 0, ( localize('workspaceFolderCount', "The number of root folders in the workspace"))));
const OpenFolderWorkspaceSupportContext = ( new RawContextKey('openFolderWorkspaceSupport', true, true));
const EnterMultiRootWorkspaceSupportContext = ( new RawContextKey('enterMultiRootWorkspaceSupport', true, true));
const EmptyWorkspaceSupportContext = ( new RawContextKey('emptyWorkspaceSupport', true, true));
const DirtyWorkingCopiesContext = ( new RawContextKey('dirtyWorkingCopies', false, ( localize(
    'dirtyWorkingCopies',
    "Whether there are any working copies with unsaved changes"
))));
const RemoteNameContext = ( new RawContextKey('remoteName', '', ( localize(
    'remoteName',
    "The name of the remote the window is connected to or an empty string if not connected to any remote"
))));
const VirtualWorkspaceContext = ( new RawContextKey('virtualWorkspace', '', ( localize(
    'virtualWorkspace',
    "The scheme of the current workspace is from a virtual file system or an empty string."
))));
const IsFullscreenContext = ( new RawContextKey('isFullscreen', false, ( localize('isFullscreen', "Whether the window is in fullscreen mode"))));
const HasWebFileSystemAccess = ( new RawContextKey('hasWebFileSystemAccess', false, true));
const ActiveEditorDirtyContext = ( new RawContextKey('activeEditorIsDirty', false, ( localize('activeEditorIsDirty', "Whether the active editor has unsaved changes"))));
const ActiveEditorPinnedContext = ( new RawContextKey('activeEditorIsNotPreview', false, ( localize(
    'activeEditorIsNotPreview',
    "Whether the active editor is not in preview mode"
))));
const ActiveEditorFirstInGroupContext = ( new RawContextKey('activeEditorIsFirstInGroup', false, ( localize(
    'activeEditorIsFirstInGroup',
    "Whether the active editor is the first one in its group"
))));
const ActiveEditorLastInGroupContext = ( new RawContextKey('activeEditorIsLastInGroup', false, ( localize(
    'activeEditorIsLastInGroup',
    "Whether the active editor is the last one in its group"
))));
const ActiveEditorStickyContext = ( new RawContextKey('activeEditorIsPinned', false, ( localize('activeEditorIsPinned', "Whether the active editor is pinned"))));
const ActiveEditorCanToggleReadonlyContext = ( new RawContextKey('activeEditorCanToggleReadonly', true, ( localize(
    'activeEditorCanToggleReadonly',
    "Whether the active editor can toggle between being read-only or writeable"
))));
const ActiveEditorCanSplitInGroupContext = ( new RawContextKey('activeEditorCanSplitInGroup', true));
const ActiveEditorContext = ( new RawContextKey('activeEditor', null, { type: 'string', description: ( localize('activeEditor', "The identifier of the active editor")) }));
const ActiveEditorAvailableEditorIdsContext = ( new RawContextKey('activeEditorAvailableEditorIds', '', ( localize(
    'activeEditorAvailableEditorIds',
    "The available editor identifiers that are usable for the active editor"
))));
const TextCompareEditorVisibleContext = ( new RawContextKey('textCompareEditorVisible', false, ( localize('textCompareEditorVisible', "Whether a text compare editor is visible"))));
const TextCompareEditorActiveContext = ( new RawContextKey('textCompareEditorActive', false, ( localize('textCompareEditorActive', "Whether a text compare editor is active"))));
const SideBySideEditorActiveContext = ( new RawContextKey('sideBySideEditorActive', false, ( localize('sideBySideEditorActive', "Whether a side by side editor is active"))));
const EditorGroupEditorsCountContext = ( new RawContextKey('groupEditorsCount', 0, ( localize('groupEditorsCount', "The number of opened editor groups"))));
const ActiveEditorGroupEmptyContext = ( new RawContextKey('activeEditorGroupEmpty', false, ( localize('activeEditorGroupEmpty', "Whether the active editor group is empty"))));
const ActiveEditorGroupLockedContext = ( new RawContextKey('activeEditorGroupLocked', false, ( localize('activeEditorGroupLocked', "Whether the active editor group is locked"))));
const MultipleEditorGroupsContext = ( new RawContextKey('multipleEditorGroups', false, ( localize('multipleEditorGroups', "Whether there are multiple editor groups opened"))));
const InEditorZenModeContext = ( new RawContextKey('inZenMode', false, ( localize('inZenMode', "Whether Zen mode is enabled"))));
const IsCenteredLayoutContext = ( new RawContextKey('isCenteredLayout', false, ( localize('isCenteredLayout', "Whether centered layout is enabled"))));
const EditorTabsVisibleContext = ( new RawContextKey('editorTabsVisible', true, ( localize('editorTabsVisible', "Whether editor tabs are visible"))));
const SideBarVisibleContext = ( new RawContextKey('sideBarVisible', false, ( localize('sideBarVisible', "Whether the sidebar is visible"))));
const SidebarFocusContext = ( new RawContextKey('sideBarFocus', false, ( localize('sideBarFocus', "Whether the sidebar has keyboard focus"))));
const ActiveViewletContext = ( new RawContextKey('activeViewlet', '', ( localize('activeViewlet', "The identifier of the active viewlet"))));
const StatusBarFocused = ( new RawContextKey('statusBarFocused', false, ( localize('statusBarFocused', "Whether the status bar has keyboard focus"))));
const NotificationFocusedContext = ( new RawContextKey('notificationFocus', true, ( localize('notificationFocus', "Whether a notification has keyboard focus"))));
const NotificationsCenterVisibleContext = ( new RawContextKey('notificationCenterVisible', false, ( localize('notificationCenterVisible', "Whether the notifications center is visible"))));
const NotificationsToastsVisibleContext = ( new RawContextKey('notificationToastsVisible', false, ( localize('notificationToastsVisible', "Whether a notification toast is visible"))));
const ActiveAuxiliaryContext = ( new RawContextKey('activeAuxiliary', '', ( localize('activeAuxiliary', "The identifier of the active auxiliary panel"))));
const AuxiliaryBarFocusContext = ( new RawContextKey('auxiliaryBarFocus', false, ( localize('auxiliaryBarFocus', "Whether the auxiliary bar has keyboard focus"))));
const AuxiliaryBarVisibleContext = ( new RawContextKey('auxiliaryBarVisible', false, ( localize('auxiliaryBarVisible', "Whether the auxiliary bar is visible"))));
const ActivePanelContext = ( new RawContextKey('activePanel', '', ( localize('activePanel', "The identifier of the active panel"))));
const PanelFocusContext = ( new RawContextKey('panelFocus', false, ( localize('panelFocus', "Whether the panel has keyboard focus"))));
const PanelPositionContext = ( new RawContextKey('panelPosition', 'bottom', ( localize('panelPosition', "The position of the panel, always 'bottom'"))));
const PanelAlignmentContext = ( new RawContextKey('panelAlignment', 'center', ( localize(
    'panelAlignment',
    "The alignment of the panel, either 'center', 'left', 'right' or 'justify'"
))));
const PanelVisibleContext = ( new RawContextKey('panelVisible', false, ( localize('panelVisible', "Whether the panel is visible"))));
const FocusedViewContext = ( new RawContextKey('focusedView', '', ( localize('focusedView', "The identifier of the view that has keyboard focus"))));
function getVisbileViewContextKey(viewId) { return `view.${viewId}.visible`; }
function getEnabledViewContainerContextKey(viewContainerId) { return `viewContainer.${viewContainerId}.enabled`; }
let ResourceContextKey = class ResourceContextKey {
    static { this.Scheme = ( new RawContextKey('resourceScheme', undefined, { type: 'string', description: ( localize('resourceScheme', "The scheme of the resource")) })); }
    static { this.Filename = ( new RawContextKey(
        'resourceFilename',
        undefined,
        { type: 'string', description: ( localize('resourceFilename', "The file name of the resource")) }
    )); }
    static { this.Dirname = ( new RawContextKey(
        'resourceDirname',
        undefined,
        { type: 'string', description: ( localize('resourceDirname', "The folder name the resource is contained in")) }
    )); }
    static { this.Path = ( new RawContextKey('resourcePath', undefined, { type: 'string', description: ( localize('resourcePath', "The full path of the resource")) })); }
    static { this.LangId = ( new RawContextKey('resourceLangId', undefined, { type: 'string', description: ( localize('resourceLangId', "The language identifier of the resource")) })); }
    static { this.Resource = ( new RawContextKey('resource', undefined, { type: 'URI', description: ( localize('resource', "The full value of the resource including scheme and path")) })); }
    static { this.Extension = ( new RawContextKey(
        'resourceExtname',
        undefined,
        { type: 'string', description: ( localize('resourceExtname', "The extension name of the resource")) }
    )); }
    static { this.HasResource = ( new RawContextKey('resourceSet', undefined, { type: 'boolean', description: ( localize('resourceSet', "Whether a resource is present or not")) })); }
    static { this.IsFileSystemResource = ( new RawContextKey(
        'isFileSystemResource',
        undefined,
        { type: 'boolean', description: ( localize(
            'isFileSystemResource',
            "Whether the resource is backed by a file system provider"
        )) }
    )); }
    constructor(_contextKeyService, _fileService, _languageService, _modelService) {
        this._contextKeyService = _contextKeyService;
        this._fileService = _fileService;
        this._languageService = _languageService;
        this._modelService = _modelService;
        this._disposables = ( new DisposableStore());
        this._schemeKey = ResourceContextKey.Scheme.bindTo(this._contextKeyService);
        this._filenameKey = ResourceContextKey.Filename.bindTo(this._contextKeyService);
        this._dirnameKey = ResourceContextKey.Dirname.bindTo(this._contextKeyService);
        this._pathKey = ResourceContextKey.Path.bindTo(this._contextKeyService);
        this._langIdKey = ResourceContextKey.LangId.bindTo(this._contextKeyService);
        this._resourceKey = ResourceContextKey.Resource.bindTo(this._contextKeyService);
        this._extensionKey = ResourceContextKey.Extension.bindTo(this._contextKeyService);
        this._hasResource = ResourceContextKey.HasResource.bindTo(this._contextKeyService);
        this._isFileSystemResource = ResourceContextKey.IsFileSystemResource.bindTo(this._contextKeyService);
        this._disposables.add(_fileService.onDidChangeFileSystemProviderRegistrations(() => {
            const resource = this.get();
            this._isFileSystemResource.set(Boolean(resource && _fileService.hasProvider(resource)));
        }));
        this._disposables.add(_modelService.onModelAdded(model => {
            if (isEqual(model.uri, this.get())) {
                this._setLangId();
            }
        }));
        this._disposables.add(_modelService.onModelLanguageChanged(e => {
            if (isEqual(e.model.uri, this.get())) {
                this._setLangId();
            }
        }));
    }
    dispose() {
        this._disposables.dispose();
    }
    _setLangId() {
        const value = this.get();
        if (!value) {
            this._langIdKey.set(null);
            return;
        }
        const langId = this._modelService.getModel(value)?.getLanguageId() ?? this._languageService.guessLanguageIdByFilepathOrFirstLine(value);
        this._langIdKey.set(langId);
    }
    set(value) {
        value = value ?? undefined;
        if (isEqual(this._value, value)) {
            return;
        }
        this._value = value;
        this._contextKeyService.bufferChangeEvents(() => {
            this._resourceKey.set(value ? ( value.toString()) : null);
            this._schemeKey.set(value ? value.scheme : null);
            this._filenameKey.set(value ? basename(value) : null);
            this._dirnameKey.set(value ? this.uriToPath(dirname(value)) : null);
            this._pathKey.set(value ? this.uriToPath(value) : null);
            this._setLangId();
            this._extensionKey.set(value ? extname(value) : null);
            this._hasResource.set(Boolean(value));
            this._isFileSystemResource.set(value ? this._fileService.hasProvider(value) : false);
        });
    }
    uriToPath(uri) {
        if (uri.scheme === Schemas.file) {
            return uri.fsPath;
        }
        return uri.path;
    }
    reset() {
        this._value = undefined;
        this._contextKeyService.bufferChangeEvents(() => {
            this._resourceKey.reset();
            this._schemeKey.reset();
            this._filenameKey.reset();
            this._dirnameKey.reset();
            this._pathKey.reset();
            this._langIdKey.reset();
            this._extensionKey.reset();
            this._hasResource.reset();
            this._isFileSystemResource.reset();
        });
    }
    get() {
        return this._value;
    }
};
ResourceContextKey = ( __decorate([
    ( __param(0, IContextKeyService)),
    ( __param(1, IFileService)),
    ( __param(2, ILanguageService)),
    ( __param(3, IModelService))
], ResourceContextKey));
function applyAvailableEditorIds(contextKey, editor, editorResolverService) {
    if (!editor) {
        contextKey.set('');
        return;
    }
    const editorResource = editor.resource;
    const editors = editorResource ? ( editorResolverService.getEditors(editorResource).map(editor => editor.id)) : [];
    if (editorResource?.scheme === Schemas.untitled && editor.editorId !== DEFAULT_EDITOR_ASSOCIATION.id) {
        contextKey.set('');
    }
    else {
        contextKey.set(editors.join(','));
    }
}
export { ActiveAuxiliaryContext, ActiveEditorAvailableEditorIdsContext, ActiveEditorCanSplitInGroupContext, ActiveEditorCanToggleReadonlyContext, ActiveEditorContext, ActiveEditorDirtyContext, ActiveEditorFirstInGroupContext, ActiveEditorGroupEmptyContext, ActiveEditorGroupLockedContext, ActiveEditorLastInGroupContext, ActiveEditorPinnedContext, ActiveEditorStickyContext, ActivePanelContext, ActiveViewletContext, AuxiliaryBarFocusContext, AuxiliaryBarVisibleContext, DirtyWorkingCopiesContext, EditorGroupEditorsCountContext, EditorTabsVisibleContext, EmptyWorkspaceSupportContext, EnterMultiRootWorkspaceSupportContext, FocusedViewContext, HasWebFileSystemAccess, InEditorZenModeContext, IsCenteredLayoutContext, IsFullscreenContext, MultipleEditorGroupsContext, NotificationFocusedContext, NotificationsCenterVisibleContext, NotificationsToastsVisibleContext, OpenFolderWorkspaceSupportContext, PanelAlignmentContext, PanelFocusContext, PanelPositionContext, PanelVisibleContext, RemoteNameContext, ResourceContextKey, SideBarVisibleContext, SideBySideEditorActiveContext, SidebarFocusContext, StatusBarFocused, TextCompareEditorActiveContext, TextCompareEditorVisibleContext, VirtualWorkspaceContext, WorkbenchStateContext, WorkspaceFolderCountContext, applyAvailableEditorIds, getEnabledViewContainerContextKey, getVisbileViewContextKey };
