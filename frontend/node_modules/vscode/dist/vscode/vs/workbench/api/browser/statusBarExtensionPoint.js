import { __decorate, __param } from '../../../../../node_modules/tslib/tslib.es6.js';
import { toDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { createDecorator } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IStatusbarService } from '../../services/statusbar/browser/statusbar.js';
import { getCodiconAriaLabel } from 'monaco-editor/esm/vs/base/common/iconLabels.js';
import { hash } from 'monaco-editor/esm/vs/base/common/hash.js';
import { Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { registerSingleton } from 'monaco-editor/esm/vs/platform/instantiation/common/extensions.js';
const IExtensionStatusBarItemService = ( createDecorator('IExtensionStatusBarItemService'));
let ExtensionStatusBarItemService = class ExtensionStatusBarItemService {
    constructor(_statusbarService) {
        this._statusbarService = _statusbarService;
        this._entries = ( new Map());
        this._onDidChange = ( new Emitter());
        this.onDidChange = this._onDidChange.event;
    }
    dispose() {
        this._entries.forEach(entry => entry.accessor.dispose());
        this._entries.clear();
        this._onDidChange.dispose();
    }
    setOrUpdateEntry(entryId, id, extensionId, name, text, tooltip, command, color, backgroundColor, alignLeft, priority, accessibilityInformation) {
        let ariaLabel;
        let role = undefined;
        if (accessibilityInformation) {
            ariaLabel = accessibilityInformation.label;
            role = accessibilityInformation.role;
        }
        else {
            ariaLabel = getCodiconAriaLabel(text);
            if (tooltip) {
                const tooltipString = typeof tooltip === 'string' ? tooltip : tooltip.value;
                ariaLabel += `, ${tooltipString}`;
            }
        }
        const entry = { name, text, tooltip, command, color, backgroundColor, ariaLabel, role };
        if (typeof priority === 'undefined') {
            priority = 0;
        }
        let alignment = alignLeft ? 0  : 1 ;
        const existingEntry = this._entries.get(entryId);
        if (existingEntry) {
            alignment = existingEntry.alignment;
            priority = existingEntry.priority;
        }
        if (!existingEntry) {
            let entryPriority;
            if (typeof extensionId === 'string') {
                entryPriority = { primary: priority, secondary: hash(extensionId) };
            }
            else {
                entryPriority = priority;
            }
            const accessor = this._statusbarService.addEntry(entry, id, alignment, entryPriority);
            this._entries.set(entryId, {
                accessor,
                entry,
                alignment,
                priority,
                disposable: toDisposable(() => {
                    accessor.dispose();
                    this._entries.delete(entryId);
                    this._onDidChange.fire({ removed: entryId });
                })
            });
            this._onDidChange.fire({ added: [entryId, { entry, alignment, priority }] });
            return 0 ;
        }
        else {
            existingEntry.accessor.update(entry);
            existingEntry.entry = entry;
            return 1 ;
        }
    }
    unsetEntry(entryId) {
        this._entries.get(entryId)?.disposable.dispose();
        this._entries.delete(entryId);
    }
    getEntries() {
        return this._entries.entries();
    }
};
ExtensionStatusBarItemService = ( __decorate([
    ( __param(0, IStatusbarService))
], ExtensionStatusBarItemService));
registerSingleton(IExtensionStatusBarItemService, ExtensionStatusBarItemService, 1 );
export { ExtensionStatusBarItemService, IExtensionStatusBarItemService };
