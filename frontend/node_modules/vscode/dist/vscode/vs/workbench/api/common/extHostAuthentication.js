import { Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { MainContext } from './extHost.protocol.js';
import { Disposable } from './extHostTypes.js';
import { ExtensionIdentifier } from 'monaco-editor/esm/vs/platform/extensions/common/extensions.js';
class ExtHostAuthentication {
    constructor(mainContext) {
        this._authenticationProviders = ( new Map());
        this._providers = [];
        this._onDidChangeSessions = ( new Emitter());
        this.onDidChangeSessions = this._onDidChangeSessions.event;
        this._getSessionTaskSingler = ( new TaskSingler());
        this._getSessionsTaskSingler = ( new TaskSingler());
        this._proxy = ( mainContext.getProxy(MainContext.MainThreadAuthentication));
    }
    $setProviders(providers) {
        this._providers = providers;
        return Promise.resolve();
    }
    async getSession(requestingExtension, providerId, scopes, options = {}) {
        const extensionId = ExtensionIdentifier.toKey(requestingExtension.identifier);
        const sortedScopes = [...scopes].sort().join(' ');
        return await this._getSessionTaskSingler.getOrCreate(`${extensionId} ${providerId} ${sortedScopes}`, async () => {
            await this._proxy.$ensureProvider(providerId);
            const extensionName = requestingExtension.displayName || requestingExtension.name;
            return this._proxy.$getSession(providerId, scopes, extensionId, extensionName, options);
        });
    }
    async getSessions(requestingExtension, providerId, scopes) {
        const extensionId = ExtensionIdentifier.toKey(requestingExtension.identifier);
        const sortedScopes = [...scopes].sort().join(' ');
        return await this._getSessionsTaskSingler.getOrCreate(`${extensionId} ${sortedScopes}`, async () => {
            await this._proxy.$ensureProvider(providerId);
            const extensionName = requestingExtension.displayName || requestingExtension.name;
            return this._proxy.$getSessions(providerId, scopes, extensionId, extensionName);
        });
    }
    async removeSession(providerId, sessionId) {
        const providerData = this._authenticationProviders.get(providerId);
        if (!providerData) {
            return this._proxy.$removeSession(providerId, sessionId);
        }
        return providerData.provider.removeSession(sessionId);
    }
    registerAuthenticationProvider(id, label, provider, options) {
        if (this._authenticationProviders.get(id)) {
            throw new Error(`An authentication provider with id '${id}' is already registered.`);
        }
        this._authenticationProviders.set(id, { label, provider, options: options ?? { supportsMultipleAccounts: false } });
        if (!this._providers.find(p => p.id === id)) {
            this._providers.push({
                id: id,
                label: label
            });
        }
        const listener = provider.onDidChangeSessions(e => {
            this._proxy.$sendDidChangeSessions(id, {
                added: e.added ?? [],
                changed: e.changed ?? [],
                removed: e.removed ?? []
            });
        });
        this._proxy.$registerAuthenticationProvider(id, label, options?.supportsMultipleAccounts ?? false);
        return ( new Disposable(() => {
            listener.dispose();
            this._authenticationProviders.delete(id);
            const i = this._providers.findIndex(p => p.id === id);
            if (i > -1) {
                this._providers.splice(i);
            }
            this._proxy.$unregisterAuthenticationProvider(id);
        }));
    }
    $createSession(providerId, scopes, options) {
        const providerData = this._authenticationProviders.get(providerId);
        if (providerData) {
            return Promise.resolve(providerData.provider.createSession(scopes, options));
        }
        throw new Error(`Unable to find authentication provider with handle: ${providerId}`);
    }
    $removeSession(providerId, sessionId) {
        const providerData = this._authenticationProviders.get(providerId);
        if (providerData) {
            return Promise.resolve(providerData.provider.removeSession(sessionId));
        }
        throw new Error(`Unable to find authentication provider with handle: ${providerId}`);
    }
    $getSessions(providerId, scopes) {
        const providerData = this._authenticationProviders.get(providerId);
        if (providerData) {
            return Promise.resolve(providerData.provider.getSessions(scopes));
        }
        throw new Error(`Unable to find authentication provider with handle: ${providerId}`);
    }
    $onDidChangeAuthenticationSessions(id, label) {
        this._onDidChangeSessions.fire({ provider: { id, label } });
        return Promise.resolve();
    }
}
class TaskSingler {
    constructor() {
        this._inFlightPromises = ( new Map());
    }
    getOrCreate(key, promiseFactory) {
        const inFlight = this._inFlightPromises.get(key);
        if (inFlight) {
            return inFlight;
        }
        const promise = promiseFactory().finally(() => this._inFlightPromises.delete(key));
        this._inFlightPromises.set(key, promise);
        return promise;
    }
}
export { ExtHostAuthentication };
