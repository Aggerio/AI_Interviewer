import { __decorate, __param } from '../../../../../node_modules/tslib/tslib.es6.js';
import { asPromise } from 'monaco-editor/esm/vs/base/common/async.js';
import { Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { withNullAsUndefined } from 'monaco-editor/esm/vs/base/common/types.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { createDecorator } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { MainContext } from './extHost.protocol.js';
import { IExtHostEditorTabs } from './extHostEditorTabs.js';
import { IExtHostExtensionService } from './extHostExtensionService.js';
import { IExtHostRpcService } from './extHostRpcService.js';
import { SourceBreakpoint, DebugConsoleMode, Disposable, setBreakpointId, FunctionBreakpoint, Location, Position, DebugAdapterExecutable, DebugAdapterServer, DebugAdapterNamedPipeServer, DebugAdapterInlineImplementation, DataBreakpoint, ThreadFocus, StackFrameFocus } from './extHostTypes.js';
import { IExtHostWorkspace } from './extHostWorkspace.js';
import { AbstractDebugAdapter } from '../../contrib/debug/common/abstractDebugAdapter.js';
import { convertToVSCPaths, convertToDAPaths, isDebuggerMainContribution } from '../../contrib/debug/common/debugUtils.js';
import { IExtHostConfiguration } from './extHostConfiguration.js';
import { IExtHostVariableResolverProvider } from './extHostVariableResolverService.js';
const IExtHostDebugService = ( createDecorator('IExtHostDebugService'));
let ExtHostDebugServiceBase = class ExtHostDebugServiceBase {
    get onDidStartDebugSession() { return this._onDidStartDebugSession.event; }
    get onDidTerminateDebugSession() { return this._onDidTerminateDebugSession.event; }
    get onDidChangeActiveDebugSession() { return this._onDidChangeActiveDebugSession.event; }
    get activeDebugSession() { return this._activeDebugSession; }
    get onDidReceiveDebugSessionCustomEvent() { return this._onDidReceiveDebugSessionCustomEvent.event; }
    get activeDebugConsole() { return this._activeDebugConsole.value; }
    constructor(extHostRpcService, _workspaceService, _extensionService, _configurationService, _editorTabs, _variableResolver) {
        this._workspaceService = _workspaceService;
        this._extensionService = _extensionService;
        this._configurationService = _configurationService;
        this._editorTabs = _editorTabs;
        this._variableResolver = _variableResolver;
        this._debugSessions = ( new Map());
        this._configProviderHandleCounter = 0;
        this._configProviders = [];
        this._adapterFactoryHandleCounter = 0;
        this._adapterFactories = [];
        this._trackerFactoryHandleCounter = 0;
        this._trackerFactories = [];
        this._debugAdapters = ( new Map());
        this._debugAdaptersTrackers = ( new Map());
        this._onDidStartDebugSession = ( new Emitter());
        this._onDidTerminateDebugSession = ( new Emitter());
        this._onDidChangeActiveDebugSession = ( new Emitter());
        this._onDidReceiveDebugSessionCustomEvent = ( new Emitter());
        this._debugServiceProxy = ( extHostRpcService.getProxy(MainContext.MainThreadDebugService));
        this._onDidChangeBreakpoints = ( new Emitter());
        this._onDidChangeStackFrameFocus = ( new Emitter());
        this._activeDebugConsole = ( new ExtHostDebugConsole(this._debugServiceProxy));
        this._breakpoints = ( new Map());
        this._extensionService.getExtensionRegistry().then((extensionRegistry) => {
            extensionRegistry.onDidChange(_ => {
                this.registerAllDebugTypes(extensionRegistry);
            });
            this.registerAllDebugTypes(extensionRegistry);
        });
    }
    asDebugSourceUri(src, session) {
        const source = src;
        if (typeof source.sourceReference === 'number' && source.sourceReference > 0) {
            let debug = `debug:${encodeURIComponent(source.path || '')}`;
            let sep = '?';
            if (session) {
                debug += `${sep}session=${encodeURIComponent(session.id)}`;
                sep = '&';
            }
            debug += `${sep}ref=${source.sourceReference}`;
            return ( URI.parse(debug));
        }
        else if (source.path) {
            return URI.file(source.path);
        }
        else {
            throw new Error(`cannot create uri from DAP 'source' object; properties 'path' and 'sourceReference' are both missing.`);
        }
    }
    registerAllDebugTypes(extensionRegistry) {
        const debugTypes = [];
        for (const ed of extensionRegistry.getAllExtensionDescriptions()) {
            if (ed.contributes) {
                const debuggers = ed.contributes['debuggers'];
                if (debuggers && debuggers.length > 0) {
                    for (const dbg of debuggers) {
                        if (isDebuggerMainContribution(dbg)) {
                            debugTypes.push(dbg.type);
                        }
                    }
                }
            }
        }
        this._debugServiceProxy.$registerDebugTypes(debugTypes);
    }
    get stackFrameFocus() {
        return this._stackFrameFocus;
    }
    get onDidChangeStackFrameFocus() {
        return this._onDidChangeStackFrameFocus.event;
    }
    get onDidChangeBreakpoints() {
        return this._onDidChangeBreakpoints.event;
    }
    get breakpoints() {
        const result = [];
        this._breakpoints.forEach(bp => result.push(bp));
        return result;
    }
    addBreakpoints(breakpoints0) {
        const breakpoints = breakpoints0.filter(bp => {
            const id = bp.id;
            if (!( this._breakpoints.has(id))) {
                this._breakpoints.set(id, bp);
                return true;
            }
            return false;
        });
        this.fireBreakpointChanges(breakpoints, [], []);
        const dtos = [];
        const map = ( new Map());
        for (const bp of breakpoints) {
            if (bp instanceof SourceBreakpoint) {
                let dto = map.get(( bp.location.uri.toString()));
                if (!dto) {
                    dto = {
                        type: 'sourceMulti',
                        uri: bp.location.uri,
                        lines: []
                    };
                    map.set(( bp.location.uri.toString()), dto);
                    dtos.push(dto);
                }
                dto.lines.push({
                    id: bp.id,
                    enabled: bp.enabled,
                    condition: bp.condition,
                    hitCondition: bp.hitCondition,
                    logMessage: bp.logMessage,
                    line: bp.location.range.start.line,
                    character: bp.location.range.start.character
                });
            }
            else if (bp instanceof FunctionBreakpoint) {
                dtos.push({
                    type: 'function',
                    id: bp.id,
                    enabled: bp.enabled,
                    hitCondition: bp.hitCondition,
                    logMessage: bp.logMessage,
                    condition: bp.condition,
                    functionName: bp.functionName
                });
            }
        }
        return this._debugServiceProxy.$registerBreakpoints(dtos);
    }
    removeBreakpoints(breakpoints0) {
        const breakpoints = breakpoints0.filter(b => this._breakpoints.delete(b.id));
        this.fireBreakpointChanges([], breakpoints, []);
        const ids = ( breakpoints.filter(bp => bp instanceof SourceBreakpoint).map(bp => bp.id));
        const fids = ( breakpoints.filter(bp => bp instanceof FunctionBreakpoint).map(bp => bp.id));
        const dids = ( breakpoints.filter(bp => bp instanceof DataBreakpoint).map(bp => bp.id));
        return this._debugServiceProxy.$unregisterBreakpoints(ids, fids, dids);
    }
    startDebugging(folder, nameOrConfig, options) {
        return this._debugServiceProxy.$startDebugging(folder ? folder.uri : undefined, nameOrConfig, {
            parentSessionID: options.parentSession ? options.parentSession.id : undefined,
            lifecycleManagedByParent: options.lifecycleManagedByParent,
            repl: options.consoleMode === DebugConsoleMode.MergeWithParent ? 'mergeWithParent' : 'separate',
            noDebug: options.noDebug,
            compact: options.compact,
            suppressSaveBeforeStart: options.suppressSaveBeforeStart,
            suppressDebugStatusbar: options.suppressDebugStatusbar ?? options.debugUI?.simple,
            suppressDebugToolbar: options.suppressDebugToolbar ?? options.debugUI?.simple,
            suppressDebugView: options.suppressDebugView ?? options.debugUI?.simple,
        });
    }
    stopDebugging(session) {
        return this._debugServiceProxy.$stopDebugging(session ? session.id : undefined);
    }
    registerDebugConfigurationProvider(type, provider, trigger) {
        if (!provider) {
            return ( new Disposable(() => { }));
        }
        const handle = this._configProviderHandleCounter++;
        this._configProviders.push({ type, handle, provider });
        this._debugServiceProxy.$registerDebugConfigurationProvider(type, trigger, !!provider.provideDebugConfigurations, !!provider.resolveDebugConfiguration, !!provider.resolveDebugConfigurationWithSubstitutedVariables, handle);
        return ( new Disposable(() => {
            this._configProviders = this._configProviders.filter(p => p.provider !== provider);
            this._debugServiceProxy.$unregisterDebugConfigurationProvider(handle);
        }));
    }
    registerDebugAdapterDescriptorFactory(extension, type, factory) {
        if (!factory) {
            return ( new Disposable(() => { }));
        }
        if (!this.definesDebugType(extension, type)) {
            throw new Error(`a DebugAdapterDescriptorFactory can only be registered from the extension that defines the '${type}' debugger.`);
        }
        if (this.getAdapterDescriptorFactoryByType(type)) {
            throw new Error(`a DebugAdapterDescriptorFactory can only be registered once per a type.`);
        }
        const handle = this._adapterFactoryHandleCounter++;
        this._adapterFactories.push({ type, handle, factory });
        this._debugServiceProxy.$registerDebugAdapterDescriptorFactory(type, handle);
        return ( new Disposable(() => {
            this._adapterFactories = this._adapterFactories.filter(p => p.factory !== factory);
            this._debugServiceProxy.$unregisterDebugAdapterDescriptorFactory(handle);
        }));
    }
    registerDebugAdapterTrackerFactory(type, factory) {
        if (!factory) {
            return ( new Disposable(() => { }));
        }
        const handle = this._trackerFactoryHandleCounter++;
        this._trackerFactories.push({ type, handle, factory });
        return ( new Disposable(() => {
            this._trackerFactories = this._trackerFactories.filter(p => p.factory !== factory);
        }));
    }
    async $runInTerminal(args, sessionId) {
        return Promise.resolve(undefined);
    }
    async $substituteVariables(folderUri, config) {
        let ws;
        const folder = await this.getFolder(folderUri);
        if (folder) {
            ws = {
                uri: folder.uri,
                name: folder.name,
                index: folder.index,
                toResource: () => {
                    throw new Error('Not implemented');
                }
            };
        }
        const variableResolver = await this._variableResolver.getResolver();
        return variableResolver.resolveAnyAsync(ws, config);
    }
    createDebugAdapter(adapter, session) {
        if (adapter.type === 'implementation') {
            return ( new DirectDebugAdapter(adapter.implementation));
        }
        return undefined;
    }
    createSignService() {
        return undefined;
    }
    async $startDASession(debugAdapterHandle, sessionDto) {
        const mythis = this;
        const session = await this.getSession(sessionDto);
        return this.getAdapterDescriptor(this.getAdapterDescriptorFactoryByType(session.type), session).then(daDescriptor => {
            if (!daDescriptor) {
                throw new Error(`Couldn't find a debug adapter descriptor for debug type '${session.type}' (extension might have failed to activate)`);
            }
            const adapterDescriptor = this.convertToDto(daDescriptor);
            const da = this.createDebugAdapter(adapterDescriptor, session);
            if (!da) {
                throw new Error(`Couldn't create a debug adapter for type '${session.type}'.`);
            }
            const debugAdapter = da;
            this._debugAdapters.set(debugAdapterHandle, debugAdapter);
            return this.getDebugAdapterTrackers(session).then(tracker => {
                if (tracker) {
                    this._debugAdaptersTrackers.set(debugAdapterHandle, tracker);
                }
                debugAdapter.onMessage(async (message) => {
                    if (message.type === 'request' && message.command === 'handshake') {
                        const request = message;
                        const response = {
                            type: 'response',
                            seq: 0,
                            command: request.command,
                            request_seq: request.seq,
                            success: true
                        };
                        if (!this._signService) {
                            this._signService = this.createSignService();
                        }
                        try {
                            if (this._signService) {
                                const signature = await this._signService.sign(request.arguments.value);
                                response.body = {
                                    signature: signature
                                };
                                debugAdapter.sendResponse(response);
                            }
                            else {
                                throw new Error('no signer');
                            }
                        }
                        catch (e) {
                            response.success = false;
                            response.message = e.message;
                            debugAdapter.sendResponse(response);
                        }
                    }
                    else {
                        if (tracker && tracker.onDidSendMessage) {
                            tracker.onDidSendMessage(message);
                        }
                        message = convertToVSCPaths(message, true);
                        mythis._debugServiceProxy.$acceptDAMessage(debugAdapterHandle, message);
                    }
                });
                debugAdapter.onError(err => {
                    if (tracker && tracker.onError) {
                        tracker.onError(err);
                    }
                    this._debugServiceProxy.$acceptDAError(debugAdapterHandle, err.name, err.message, err.stack);
                });
                debugAdapter.onExit((code) => {
                    if (tracker && tracker.onExit) {
                        tracker.onExit(withNullAsUndefined(code), undefined);
                    }
                    this._debugServiceProxy.$acceptDAExit(debugAdapterHandle, withNullAsUndefined(code), undefined);
                });
                if (tracker && tracker.onWillStartSession) {
                    tracker.onWillStartSession();
                }
                return debugAdapter.startSession();
            });
        });
    }
    $sendDAMessage(debugAdapterHandle, message) {
        message = convertToDAPaths(message, false);
        const tracker = this._debugAdaptersTrackers.get(debugAdapterHandle);
        if (tracker && tracker.onWillReceiveMessage) {
            tracker.onWillReceiveMessage(message);
        }
        const da = this._debugAdapters.get(debugAdapterHandle);
        da?.sendMessage(message);
    }
    $stopDASession(debugAdapterHandle) {
        const tracker = this._debugAdaptersTrackers.get(debugAdapterHandle);
        this._debugAdaptersTrackers.delete(debugAdapterHandle);
        if (tracker && tracker.onWillStopSession) {
            tracker.onWillStopSession();
        }
        const da = this._debugAdapters.get(debugAdapterHandle);
        this._debugAdapters.delete(debugAdapterHandle);
        if (da) {
            return da.stopSession();
        }
        else {
            return Promise.resolve(void 0);
        }
    }
    $acceptBreakpointsDelta(delta) {
        const a = [];
        const r = [];
        const c = [];
        if (delta.added) {
            for (const bpd of delta.added) {
                const id = bpd.id;
                if (id && !( this._breakpoints.has(id))) {
                    let bp;
                    if (bpd.type === 'function') {
                        bp = ( new FunctionBreakpoint(
                            bpd.functionName,
                            bpd.enabled,
                            bpd.condition,
                            bpd.hitCondition,
                            bpd.logMessage
                        ));
                    }
                    else if (bpd.type === 'data') {
                        bp = ( new DataBreakpoint(
                            bpd.label,
                            bpd.dataId,
                            bpd.canPersist,
                            bpd.enabled,
                            bpd.hitCondition,
                            bpd.condition,
                            bpd.logMessage
                        ));
                    }
                    else {
                        const uri = URI.revive(bpd.uri);
                        bp = ( new SourceBreakpoint(( new Location(uri, ( new Position(bpd.line, bpd.character)))), bpd.enabled, bpd.condition, bpd.hitCondition, bpd.logMessage));
                    }
                    setBreakpointId(bp, id);
                    this._breakpoints.set(id, bp);
                    a.push(bp);
                }
            }
        }
        if (delta.removed) {
            for (const id of delta.removed) {
                const bp = this._breakpoints.get(id);
                if (bp) {
                    this._breakpoints.delete(id);
                    r.push(bp);
                }
            }
        }
        if (delta.changed) {
            for (const bpd of delta.changed) {
                if (bpd.id) {
                    const bp = this._breakpoints.get(bpd.id);
                    if (bp) {
                        if (bp instanceof FunctionBreakpoint && bpd.type === 'function') {
                            const fbp = bp;
                            fbp.enabled = bpd.enabled;
                            fbp.condition = bpd.condition;
                            fbp.hitCondition = bpd.hitCondition;
                            fbp.logMessage = bpd.logMessage;
                            fbp.functionName = bpd.functionName;
                        }
                        else if (bp instanceof SourceBreakpoint && bpd.type === 'source') {
                            const sbp = bp;
                            sbp.enabled = bpd.enabled;
                            sbp.condition = bpd.condition;
                            sbp.hitCondition = bpd.hitCondition;
                            sbp.logMessage = bpd.logMessage;
                            sbp.location = ( new Location(URI.revive(bpd.uri), ( new Position(bpd.line, bpd.character))));
                        }
                        c.push(bp);
                    }
                }
            }
        }
        this.fireBreakpointChanges(a, r, c);
    }
    async $acceptStackFrameFocus(focusDto) {
        let focus;
        const session = focusDto.sessionId ? await this.getSession(focusDto.sessionId) : undefined;
        if (!session) {
            throw new Error('no DebugSession found for debug focus context');
        }
        if (focusDto.kind === 'thread') {
            focus = ( new ThreadFocus(session, focusDto.threadId));
        }
        else {
            focus = ( new StackFrameFocus(session, focusDto.threadId, focusDto.frameId));
        }
        this._stackFrameFocus = focus;
        this._onDidChangeStackFrameFocus.fire(this._stackFrameFocus);
    }
    $provideDebugConfigurations(configProviderHandle, folderUri, token) {
        return asPromise(async () => {
            const provider = this.getConfigProviderByHandle(configProviderHandle);
            if (!provider) {
                throw new Error('no DebugConfigurationProvider found');
            }
            if (!provider.provideDebugConfigurations) {
                throw new Error('DebugConfigurationProvider has no method provideDebugConfigurations');
            }
            const folder = await this.getFolder(folderUri);
            return provider.provideDebugConfigurations(folder, token);
        }).then(debugConfigurations => {
            if (!debugConfigurations) {
                throw new Error('nothing returned from DebugConfigurationProvider.provideDebugConfigurations');
            }
            return debugConfigurations;
        });
    }
    $resolveDebugConfiguration(configProviderHandle, folderUri, debugConfiguration, token) {
        return asPromise(async () => {
            const provider = this.getConfigProviderByHandle(configProviderHandle);
            if (!provider) {
                throw new Error('no DebugConfigurationProvider found');
            }
            if (!provider.resolveDebugConfiguration) {
                throw new Error('DebugConfigurationProvider has no method resolveDebugConfiguration');
            }
            const folder = await this.getFolder(folderUri);
            return provider.resolveDebugConfiguration(folder, debugConfiguration, token);
        });
    }
    $resolveDebugConfigurationWithSubstitutedVariables(configProviderHandle, folderUri, debugConfiguration, token) {
        return asPromise(async () => {
            const provider = this.getConfigProviderByHandle(configProviderHandle);
            if (!provider) {
                throw new Error('no DebugConfigurationProvider found');
            }
            if (!provider.resolveDebugConfigurationWithSubstitutedVariables) {
                throw new Error('DebugConfigurationProvider has no method resolveDebugConfigurationWithSubstitutedVariables');
            }
            const folder = await this.getFolder(folderUri);
            return provider.resolveDebugConfigurationWithSubstitutedVariables(folder, debugConfiguration, token);
        });
    }
    async $provideDebugAdapter(adapterFactoryHandle, sessionDto) {
        const adapterDescriptorFactory = this.getAdapterDescriptorFactoryByHandle(adapterFactoryHandle);
        if (!adapterDescriptorFactory) {
            return Promise.reject(( new Error('no adapter descriptor factory found for handle')));
        }
        const session = await this.getSession(sessionDto);
        return this.getAdapterDescriptor(adapterDescriptorFactory, session).then(adapterDescriptor => {
            if (!adapterDescriptor) {
                throw new Error(`Couldn't find a debug adapter descriptor for debug type '${session.type}'`);
            }
            return this.convertToDto(adapterDescriptor);
        });
    }
    async $acceptDebugSessionStarted(sessionDto) {
        const session = await this.getSession(sessionDto);
        this._onDidStartDebugSession.fire(session);
    }
    async $acceptDebugSessionTerminated(sessionDto) {
        const session = await this.getSession(sessionDto);
        if (session) {
            this._onDidTerminateDebugSession.fire(session);
            this._debugSessions.delete(session.id);
        }
    }
    async $acceptDebugSessionActiveChanged(sessionDto) {
        this._activeDebugSession = sessionDto ? await this.getSession(sessionDto) : undefined;
        this._onDidChangeActiveDebugSession.fire(this._activeDebugSession);
    }
    async $acceptDebugSessionNameChanged(sessionDto, name) {
        const session = await this.getSession(sessionDto);
        session?._acceptNameChanged(name);
    }
    async $acceptDebugSessionCustomEvent(sessionDto, event) {
        const session = await this.getSession(sessionDto);
        const ee = {
            session: session,
            event: event.event,
            body: event.body
        };
        this._onDidReceiveDebugSessionCustomEvent.fire(ee);
    }
    convertToDto(x) {
        if (x instanceof DebugAdapterExecutable) {
            return {
                type: 'executable',
                command: x.command,
                args: x.args,
                options: x.options
            };
        }
        else if (x instanceof DebugAdapterServer) {
            return {
                type: 'server',
                port: x.port,
                host: x.host
            };
        }
        else if (x instanceof DebugAdapterNamedPipeServer) {
            return {
                type: 'pipeServer',
                path: x.path
            };
        }
        else if (x instanceof DebugAdapterInlineImplementation) {
            return {
                type: 'implementation',
                implementation: x.implementation
            };
        }
        else {
            throw new Error('convertToDto unexpected type');
        }
    }
    getAdapterDescriptorFactoryByType(type) {
        const results = this._adapterFactories.filter(p => p.type === type);
        if (results.length > 0) {
            return results[0].factory;
        }
        return undefined;
    }
    getAdapterDescriptorFactoryByHandle(handle) {
        const results = this._adapterFactories.filter(p => p.handle === handle);
        if (results.length > 0) {
            return results[0].factory;
        }
        return undefined;
    }
    getConfigProviderByHandle(handle) {
        const results = this._configProviders.filter(p => p.handle === handle);
        if (results.length > 0) {
            return results[0].provider;
        }
        return undefined;
    }
    definesDebugType(ed, type) {
        if (ed.contributes) {
            const debuggers = ed.contributes['debuggers'];
            if (debuggers && debuggers.length > 0) {
                for (const dbg of debuggers) {
                    if (dbg.label && dbg.type) {
                        if (dbg.type === type) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
    getDebugAdapterTrackers(session) {
        const config = session.configuration;
        const type = config.type;
        const promises = ( this._trackerFactories
            .filter(tuple => tuple.type === type || tuple.type === '*')
            .map(
            tuple => asPromise(() => tuple.factory.createDebugAdapterTracker(session)).then(p => p, err => null)
        ));
        return Promise.race([
            Promise.all(promises).then(result => {
                const trackers = result.filter(t => !!t);
                if (trackers.length > 0) {
                    return ( new MultiTracker(trackers));
                }
                return undefined;
            }),
            ( new Promise(resolve => setTimeout(() => resolve(undefined), 1000))),
        ]).catch(err => {
            return undefined;
        });
    }
    async getAdapterDescriptor(adapterDescriptorFactory, session) {
        const serverPort = session.configuration.debugServer;
        if (typeof serverPort === 'number') {
            return Promise.resolve(( new DebugAdapterServer(serverPort)));
        }
        if (adapterDescriptorFactory) {
            const extensionRegistry = await this._extensionService.getExtensionRegistry();
            return asPromise(() => adapterDescriptorFactory.createDebugAdapterDescriptor(session, this.daExecutableFromPackage(session, extensionRegistry))).then(daDescriptor => {
                if (daDescriptor) {
                    return daDescriptor;
                }
                return undefined;
            });
        }
        const extensionRegistry = await this._extensionService.getExtensionRegistry();
        return Promise.resolve(this.daExecutableFromPackage(session, extensionRegistry));
    }
    daExecutableFromPackage(session, extensionRegistry) {
        return undefined;
    }
    fireBreakpointChanges(added, removed, changed) {
        if (added.length > 0 || removed.length > 0 || changed.length > 0) {
            this._onDidChangeBreakpoints.fire(( Object.freeze({
                added,
                removed,
                changed,
            })));
        }
    }
    async getSession(dto) {
        if (dto) {
            if (typeof dto === 'string') {
                const ds = this._debugSessions.get(dto);
                if (ds) {
                    return ds;
                }
            }
            else {
                let ds = this._debugSessions.get(dto.id);
                if (!ds) {
                    const folder = await this.getFolder(dto.folderUri);
                    const parent = dto.parent ? this._debugSessions.get(dto.parent) : undefined;
                    ds = ( new ExtHostDebugSession(
                        this._debugServiceProxy,
                        dto.id,
                        dto.type,
                        dto.name,
                        folder,
                        dto.configuration,
                        parent
                    ));
                    this._debugSessions.set(ds.id, ds);
                    this._debugServiceProxy.$sessionCached(ds.id);
                }
                return ds;
            }
        }
        throw new Error('cannot find session');
    }
    getFolder(_folderUri) {
        if (_folderUri) {
            const folderURI = URI.revive(_folderUri);
            return this._workspaceService.resolveWorkspaceFolder(folderURI);
        }
        return Promise.resolve(undefined);
    }
};
ExtHostDebugServiceBase = ( __decorate([
    ( __param(0, IExtHostRpcService)),
    ( __param(1, IExtHostWorkspace)),
    ( __param(2, IExtHostExtensionService)),
    ( __param(3, IExtHostConfiguration)),
    ( __param(4, IExtHostEditorTabs)),
    ( __param(5, IExtHostVariableResolverProvider))
], ExtHostDebugServiceBase));
class ExtHostDebugSession {
    constructor(_debugServiceProxy, _id, _type, _name, _workspaceFolder, _configuration, _parentSession) {
        this._debugServiceProxy = _debugServiceProxy;
        this._id = _id;
        this._type = _type;
        this._name = _name;
        this._workspaceFolder = _workspaceFolder;
        this._configuration = _configuration;
        this._parentSession = _parentSession;
    }
    get id() {
        return this._id;
    }
    get type() {
        return this._type;
    }
    get name() {
        return this._name;
    }
    set name(name) {
        this._name = name;
        this._debugServiceProxy.$setDebugSessionName(this._id, name);
    }
    get parentSession() {
        return this._parentSession;
    }
    _acceptNameChanged(name) {
        this._name = name;
    }
    get workspaceFolder() {
        return this._workspaceFolder;
    }
    get configuration() {
        return this._configuration;
    }
    customRequest(command, args) {
        return this._debugServiceProxy.$customDebugAdapterRequest(this._id, command, args);
    }
    getDebugProtocolBreakpoint(breakpoint) {
        return this._debugServiceProxy.$getDebugProtocolBreakpoint(this._id, breakpoint.id);
    }
}
class ExtHostDebugConsole {
    constructor(proxy) {
        this.value = ( Object.freeze({
            append(value) {
                proxy.$appendDebugConsole(value);
            },
            appendLine(value) {
                this.append(value + '\n');
            }
        }));
    }
}
class MultiTracker {
    constructor(trackers) {
        this.trackers = trackers;
    }
    onWillStartSession() {
        this.trackers.forEach(t => t.onWillStartSession ? t.onWillStartSession() : undefined);
    }
    onWillReceiveMessage(message) {
        this.trackers.forEach(t => t.onWillReceiveMessage ? t.onWillReceiveMessage(message) : undefined);
    }
    onDidSendMessage(message) {
        this.trackers.forEach(t => t.onDidSendMessage ? t.onDidSendMessage(message) : undefined);
    }
    onWillStopSession() {
        this.trackers.forEach(t => t.onWillStopSession ? t.onWillStopSession() : undefined);
    }
    onError(error) {
        this.trackers.forEach(t => t.onError ? t.onError(error) : undefined);
    }
    onExit(code, signal) {
        this.trackers.forEach(t => t.onExit ? t.onExit(code, signal) : undefined);
    }
}
class DirectDebugAdapter extends AbstractDebugAdapter {
    constructor(implementation) {
        super();
        this.implementation = implementation;
        implementation.onDidSendMessage((message) => {
            this.acceptMessage(message);
        });
    }
    startSession() {
        return Promise.resolve(undefined);
    }
    sendMessage(message) {
        this.implementation.handleMessage(message);
    }
    stopSession() {
        this.implementation.dispose();
        return Promise.resolve(undefined);
    }
}
let WorkerExtHostDebugService = class WorkerExtHostDebugService extends ExtHostDebugServiceBase {
    constructor(extHostRpcService, workspaceService, extensionService, configurationService, editorTabs, variableResolver) {
        super(extHostRpcService, workspaceService, extensionService, configurationService, editorTabs, variableResolver);
    }
};
WorkerExtHostDebugService = ( __decorate([
    ( __param(0, IExtHostRpcService)),
    ( __param(1, IExtHostWorkspace)),
    ( __param(2, IExtHostExtensionService)),
    ( __param(3, IExtHostConfiguration)),
    ( __param(4, IExtHostEditorTabs)),
    ( __param(5, IExtHostVariableResolverProvider))
], WorkerExtHostDebugService));
export { ExtHostDebugConsole, ExtHostDebugServiceBase, ExtHostDebugSession, IExtHostDebugService, WorkerExtHostDebugService };
