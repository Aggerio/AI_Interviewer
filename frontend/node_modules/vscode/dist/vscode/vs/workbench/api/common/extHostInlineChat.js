import { toDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { MainContext } from './extHost.protocol.js';
import { Range, Position, Selection, MarkdownString, WorkspaceEdit as WorkspaceEdit$1, TextEdit } from './extHostTypeConverters.js';
import { WorkspaceEdit, InteractiveEditorResponseFeedbackKind } from './extHostTypes.js';
import { ApiCommand, ApiCommandArgument, ApiCommandResult } from './extHostCommands.js';
class ProviderWrapper {
    static { this._pool = 0; }
    constructor(extension, provider) {
        this.extension = extension;
        this.provider = provider;
        this.handle = ProviderWrapper._pool++;
    }
}
class SessionWrapper {
    constructor(session) {
        this.session = session;
        this.responses = [];
    }
}
class ExtHostInteractiveEditor {
    static { this._nextId = 0; }
    constructor(mainContext, extHostCommands, _documents, _logService) {
        this._documents = _documents;
        this._logService = _logService;
        this._inputProvider = ( new Map());
        this._inputSessions = ( new Map());
        this._proxy = ( mainContext.getProxy(MainContext.MainThreadInlineChat));
        extHostCommands.registerApiCommand(( new ApiCommand(
            'vscode.editorChat.start',
            'inlineChat.start',
            'Invoke a new editor chat session',
            [( new ApiCommandArgument('Run arguments', '', _v => true, v => {
                    if (!v) {
                        return undefined;
                    }
                    return {
                        initialRange: v.initialRange ? Range.from(v.initialRange) : undefined,
                        message: v.message,
                        autoSend: v.autoSend,
                        position: v.position ? Position.from(v.position) : undefined,
                    };
                }))],
            ApiCommandResult.Void
        )));
    }
    registerProvider(extension, provider) {
        const wrapper = ( new ProviderWrapper(extension, provider));
        this._inputProvider.set(wrapper.handle, wrapper);
        this._proxy.$registerInteractiveEditorProvider(wrapper.handle, extension.identifier.value, typeof provider.handleInteractiveEditorResponseFeedback === 'function');
        return toDisposable(() => {
            this._proxy.$unregisterInteractiveEditorProvider(wrapper.handle);
            this._inputProvider.delete(wrapper.handle);
        });
    }
    async $prepareSession(handle, uri, range, token) {
        const entry = this._inputProvider.get(handle);
        if (!entry) {
            this._logService.warn('CANNOT prepare session because the PROVIDER IS GONE');
            return undefined;
        }
        const document = this._documents.getDocument(URI.revive(uri));
        const selection = Selection.to(range);
        const session = await entry.provider.prepareInteractiveEditorSession({ document, selection }, token);
        if (!session) {
            return undefined;
        }
        if (session.wholeRange && !session.wholeRange.contains(selection)) {
            throw new Error(`InteractiveEditorSessionProvider returned a wholeRange that does not contain the selection.`);
        }
        const id = ExtHostInteractiveEditor._nextId++;
        this._inputSessions.set(id, ( new SessionWrapper(session)));
        return {
            id,
            placeholder: session.placeholder,
            slashCommands: session.slashCommands?.map(c => ({ command: c.command, detail: c.detail, refer: c.refer, executeImmediately: c.executeImmediately })),
            wholeRange: Range.from(session.wholeRange),
            message: session.message
        };
    }
    async $provideResponse(handle, item, request, token) {
        const entry = this._inputProvider.get(handle);
        if (!entry) {
            return undefined;
        }
        const sessionData = this._inputSessions.get(item.id);
        if (!sessionData) {
            return;
        }
        const apiRequest = {
            session: sessionData.session,
            prompt: request.prompt,
            selection: Selection.to(request.selection),
            wholeRange: Range.to(request.wholeRange),
            attempt: request.attempt,
            live: request.live,
        };
        let done = false;
        const progress = {
            report: value => {
                if (!request.live) {
                    throw new Error('Progress reporting is only supported for live sessions');
                }
                if (done || token.isCancellationRequested) {
                    return;
                }
                if (!value.message && !value.edits) {
                    return;
                }
                this._proxy.$handleProgressChunk(request.requestId, {
                    message: value.message,
                    edits: value.edits?.map(TextEdit.from)
                });
            }
        };
        const task = typeof entry.provider.provideInteractiveEditorResponse2 === 'function'
            ? entry.provider.provideInteractiveEditorResponse2(apiRequest, progress, token)
            : entry.provider.provideInteractiveEditorResponse(apiRequest, token);
        Promise.resolve(task).finally(() => done = true);
        const res = await task;
        if (res) {
            const id = sessionData.responses.push(res) - 1;
            const stub = {
                wholeRange: Range.from(res.wholeRange),
                placeholder: res.placeholder,
            };
            if (ExtHostInteractiveEditor._isMessageResponse(res)) {
                return {
                    ...stub,
                    id,
                    type: "message" ,
                    message: MarkdownString.from(res.contents),
                };
            }
            const { edits } = res;
            if (edits instanceof WorkspaceEdit) {
                return {
                    ...stub,
                    id,
                    type: "bulkEdit" ,
                    edits: WorkspaceEdit$1.from(edits),
                };
            }
            else if (Array.isArray(edits)) {
                return {
                    ...stub,
                    id,
                    type: "editorEdit" ,
                    edits: ( edits.map(TextEdit.from)),
                };
            }
        }
        return undefined;
    }
    $handleFeedback(handle, sessionId, responseId, kind) {
        const entry = this._inputProvider.get(handle);
        const sessionData = this._inputSessions.get(sessionId);
        const response = sessionData?.responses[responseId];
        if (entry && response) {
            let apiKind;
            switch (kind) {
                case 1 :
                    apiKind = InteractiveEditorResponseFeedbackKind.Helpful;
                    break;
                case 0 :
                    apiKind = InteractiveEditorResponseFeedbackKind.Unhelpful;
                    break;
                case 2 :
                    apiKind = InteractiveEditorResponseFeedbackKind.Undone;
                    break;
                case 3 :
                    apiKind = InteractiveEditorResponseFeedbackKind.Accepted;
                    break;
            }
            entry.provider.handleInteractiveEditorResponseFeedback?.(sessionData.session, response, apiKind);
        }
    }
    $releaseSession(handle, sessionId) {
        const sessionData = this._inputSessions.get(sessionId);
        const entry = this._inputProvider.get(handle);
        if (sessionData && entry) {
            entry.provider.releaseInteractiveEditorSession?.(sessionData.session);
        }
        this._inputSessions.delete(sessionId);
    }
    static _isMessageResponse(thing) {
        return typeof thing === 'object' && typeof thing.contents === 'object';
    }
}
export { ExtHostInteractiveEditor };
