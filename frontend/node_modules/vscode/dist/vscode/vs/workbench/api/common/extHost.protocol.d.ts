import { Dto } from '../../services/extensions/common/proxyIdentifier.js';
import { VSBuffer } from '../../../base/common/buffer.js';
import { CancellationToken } from '../../../base/common/cancellation.js';
import { UriComponents, URI } from '../../../base/common/uri.js';
import { TerminalCommandMatchResult, TerminalQuickFixCommand, TerminalQuickFixOpener } from 'vscode';
import { SerializedError } from '../../../base/common/errors.js';
import { IDisposable } from '../../../base/common/lifecycle.js';
import { PerformanceMark } from '../../../base/common/performance.js';
import { IExtensionDescription, ExtensionIdentifier } from '../../../platform/extensions/common/extensions.js';
import { IConfigurationData, ConfigurationTarget, IConfigurationOverrides, IConfigurationChange } from '../../../platform/configuration/common/configuration.js';
import { ConfigurationScope } from '../../../platform/configuration/common/configurationRegistry.js';
import { IRemoteConnectionData } from '../../../platform/remote/common/remoteAuthorityResolver.js';
import { ClassifiedEvent, OmitMetadata, IGDPRProperty, StrictPropertyCheck } from '../../../platform/telemetry/common/gdprTypings.js';
import { ISerializableEnvironmentVariableCollection } from '../../../platform/terminal/common/environmentVariable.js';
import { TerminalExitReason, IShellLaunchConfigDto, ITerminalLaunchError, ITerminalProfile, ICreateContributedTerminalProfileOptions } from '../../../platform/terminal/common/terminal.js';
import { TunnelOptions, TunnelCreationOptions, ProvidedPortAttributes, TunnelPrivacyId } from '../../../platform/tunnel/common/tunnel.js';
import { EditSessionIdentityMatch } from '../../../platform/workspace/common/editSessions.js';
import { WorkspaceTrustRequestOptions } from '../../../platform/workspace/common/workspaceTrust.js';
import { ExtensionActivationReason, MissingExtensionDependency, ActivationKind } from '../../services/extensions/common/extensions.js';
import { IPatternInfo, IRawFileMatch2 } from '../../services/search/common/search.js';
import { IExtensionDescriptionDelta, IStaticWorkspaceData } from '../../services/extensions/common/extensionHostProtocol.js';
import { IResolveAuthorityResult } from '../../services/extensions/common/extensionHostProxy.js';
import { CandidatePort } from '../../services/remote/common/remoteExplorerService.js';
import { ITextQueryBuilderOptions } from '../../services/search/common/queryBuilder.js';

type TerminalQuickFix = TerminalQuickFixCommand | TerminalQuickFixOpener;
interface IWorkspaceData extends IStaticWorkspaceData {
    folders: {
        uri: UriComponents;
        name: string;
        index: number;
    }[];
}
interface IConfigurationInitData extends IConfigurationData {
    configurationScopes: [string, ConfigurationScope | undefined][];
}
interface MainThreadConfigurationShape extends IDisposable {
    $updateConfigurationOption(target: ConfigurationTarget | null, key: string, value: any, overrides: IConfigurationOverrides | undefined, scopeToLanguage: boolean | undefined): Promise<void>;
    $removeConfigurationOption(target: ConfigurationTarget | null, key: string, overrides: IConfigurationOverrides | undefined, scopeToLanguage: boolean | undefined): Promise<void>;
}
/**
 * A terminal that is created on the extension host side is temporarily assigned
 * a UUID by the extension host that created it. Once the renderer side has assigned
 * a real numeric id, the numeric id will be used.
 *
 * All other terminals (that are not created on the extension host side) always
 * use the numeric id.
 */
type ExtHostTerminalIdentifier = number | string;
interface MainThreadTelemetryShape extends IDisposable {
    $publicLog(eventName: string, data?: any): void;
    $publicLog2<E extends ClassifiedEvent<OmitMetadata<T>> = never, T extends IGDPRProperty = never>(eventName: string, data?: StrictPropertyCheck<T, E>): void;
}
interface ExtHostManagedSocketsShape {
    $openRemoteSocket(socketFactoryId: number): Promise<number>;
    $remoteSocketWrite(socketId: number, buffer: VSBuffer): void;
    $remoteSocketEnd(socketId: number): void;
    $remoteSocketDrain(socketId: number): Promise<void>;
}
interface ITextSearchComplete {
    limitHit?: boolean;
}
interface MainThreadWorkspaceShape extends IDisposable {
    $startFileSearch(includePattern: string | null, includeFolder: UriComponents | null, excludePatternOrDisregardExcludes: string | false | null, maxResults: number | null, token: CancellationToken): Promise<UriComponents[] | null>;
    $startTextSearch(query: IPatternInfo, folder: UriComponents | null, options: ITextQueryBuilderOptions, requestId: number, token: CancellationToken): Promise<ITextSearchComplete | null>;
    $checkExists(folders: readonly UriComponents[], includes: string[], token: CancellationToken): Promise<boolean>;
    $save(uri: UriComponents, options: {
        saveAs: boolean;
    }): Promise<UriComponents | undefined>;
    $saveAll(includeUntitled?: boolean): Promise<boolean>;
    $updateWorkspaceFolders(extensionName: string, index: number, deleteCount: number, workspaceFoldersToAdd: {
        uri: UriComponents;
        name?: string;
    }[]): Promise<void>;
    $resolveProxy(url: string): Promise<string | undefined>;
    $requestWorkspaceTrust(options?: WorkspaceTrustRequestOptions): Promise<boolean | undefined>;
    $registerEditSessionIdentityProvider(handle: number, scheme: string): void;
    $unregisterEditSessionIdentityProvider(handle: number): void;
    $registerCanonicalUriProvider(handle: number, scheme: string): void;
    $unregisterCanonicalUriProvider(handle: number): void;
}
interface MainThreadExtensionServiceShape extends IDisposable {
    $getExtension(extensionId: string): Promise<Dto<IExtensionDescription> | undefined>;
    $activateExtension(extensionId: ExtensionIdentifier, reason: ExtensionActivationReason): Promise<void>;
    $onWillActivateExtension(extensionId: ExtensionIdentifier): Promise<void>;
    $onDidActivateExtension(extensionId: ExtensionIdentifier, codeLoadingTime: number, activateCallTime: number, activateResolvedTime: number, activationReason: ExtensionActivationReason): void;
    $onExtensionActivationError(extensionId: ExtensionIdentifier, error: SerializedError, missingExtensionDependency: MissingExtensionDependency | null): Promise<void>;
    $onExtensionRuntimeError(extensionId: ExtensionIdentifier, error: SerializedError): void;
    $setPerformanceMarks(marks: PerformanceMark[]): Promise<void>;
    $asBrowserUri(uri: UriComponents): Promise<UriComponents>;
    $getAllStaticBrowserUris(): Promise<[UriComponents, UriComponents][]>;
}
interface PortAttributesSelector {
    portRange?: [number, number] | number;
    commandPattern?: RegExp;
}
interface ExtHostConfigurationShape {
    $initializeConfiguration(data: IConfigurationInitData): void;
    $acceptConfigurationChanged(data: IConfigurationInitData, change: IConfigurationChange): void;
}
interface ExtHostWorkspaceShape {
    $initializeWorkspace(workspace: IWorkspaceData | null, trusted: boolean): void;
    $acceptWorkspaceData(workspace: IWorkspaceData | null): void;
    $handleTextSearchResult(result: IRawFileMatch2, requestId: number): void;
    $onDidGrantWorkspaceTrust(): void;
    $getEditSessionIdentifier(folder: UriComponents, token: CancellationToken): Promise<string | undefined>;
    $provideEditSessionIdentityMatch(folder: UriComponents, identity1: string, identity2: string, token: CancellationToken): Promise<EditSessionIdentityMatch | undefined>;
    $onWillCreateEditSessionIdentity(folder: UriComponents, token: CancellationToken, timeout: number): Promise<void>;
    $provideCanonicalUri(uri: UriComponents, targetScheme: string, token: CancellationToken): Promise<UriComponents | undefined>;
}
interface ExtHostFileSystemInfoShape {
    $acceptProviderInfos(uri: UriComponents, capabilities: number | null): void;
}
interface ExtHostExtensionServiceShape {
    $resolveAuthority(remoteAuthority: string, resolveAttempt: number): Promise<Dto<IResolveAuthorityResult>>;
    /**
     * Returns `null` if no resolver for `remoteAuthority` is found.
     */
    $getCanonicalURI(remoteAuthority: string, uri: UriComponents): Promise<UriComponents | null>;
    $startExtensionHost(extensionsDelta: IExtensionDescriptionDelta): Promise<void>;
    $extensionTestsExecute(): Promise<number>;
    $activateByEvent(activationEvent: string, activationKind: ActivationKind): Promise<void>;
    $activate(extensionId: ExtensionIdentifier, reason: ExtensionActivationReason): Promise<boolean>;
    $setRemoteEnvironment(env: {
        [key: string]: string | null;
    }): Promise<void>;
    $updateRemoteConnectionData(connectionData: IRemoteConnectionData): Promise<void>;
    $deltaExtensions(extensionsDelta: IExtensionDescriptionDelta): Promise<void>;
    $test_latency(n: number): Promise<number>;
    $test_up(b: VSBuffer): Promise<number>;
    $test_down(size: number): Promise<VSBuffer>;
}
interface ITerminalLinkDto {
    /** The ID of the link to enable activation and disposal. */
    id: number;
    /** The startIndex of the link in the line. */
    startIndex: number;
    /** The length of the link in the line. */
    length: number;
    /** The descriptive label for what the link does when activated. */
    label?: string;
}
interface ITerminalDimensionsDto {
    columns: number;
    rows: number;
}
interface ExtHostTerminalServiceShape {
    $acceptTerminalClosed(id: number, exitCode: number | undefined, exitReason: TerminalExitReason): void;
    $acceptTerminalOpened(id: number, extHostTerminalId: string | undefined, name: string, shellLaunchConfig: IShellLaunchConfigDto): void;
    $acceptActiveTerminalChanged(id: number | null): void;
    $acceptTerminalProcessId(id: number, processId: number): void;
    $acceptTerminalProcessData(id: number, data: string): void;
    $acceptTerminalTitleChange(id: number, name: string): void;
    $acceptTerminalDimensions(id: number, cols: number, rows: number): void;
    $acceptTerminalMaximumDimensions(id: number, cols: number, rows: number): void;
    $acceptTerminalInteraction(id: number): void;
    $acceptTerminalSelection(id: number, selection: string | undefined): void;
    $startExtensionTerminal(id: number, initialDimensions: ITerminalDimensionsDto | undefined): Promise<ITerminalLaunchError | undefined>;
    $acceptProcessAckDataEvent(id: number, charCount: number): void;
    $acceptProcessInput(id: number, data: string): void;
    $acceptProcessResize(id: number, cols: number, rows: number): void;
    $acceptProcessShutdown(id: number, immediate: boolean): void;
    $acceptProcessRequestInitialCwd(id: number): void;
    $acceptProcessRequestCwd(id: number): void;
    $acceptProcessRequestLatency(id: number): Promise<number>;
    $provideLinks(id: number, line: string): Promise<ITerminalLinkDto[]>;
    $activateLink(id: number, linkId: number): void;
    $initEnvironmentVariableCollections(collections: [string, ISerializableEnvironmentVariableCollection][]): void;
    $acceptDefaultProfile(profile: ITerminalProfile, automationProfile: ITerminalProfile): void;
    $createContributedProfileTerminal(id: string, options: ICreateContributedTerminalProfileOptions): Promise<void>;
    $provideTerminalQuickFixes(id: string, matchResult: TerminalCommandMatchResult, token: CancellationToken): Promise<TerminalQuickFix[] | TerminalQuickFix | undefined>;
}
interface TunnelDto {
    remoteAddress: {
        port: number;
        host: string;
    };
    localAddress: {
        port: number;
        host: string;
    } | string;
    public: boolean;
    privacy: TunnelPrivacyId | string;
    protocol: string | undefined;
}
interface ExtHostTunnelServiceShape {
    $forwardPort(tunnelOptions: TunnelOptions, tunnelCreationOptions: TunnelCreationOptions): Promise<TunnelDto | undefined>;
    $closeTunnel(remote: {
        host: string;
        port: number;
    }, silent?: boolean): Promise<void>;
    $onDidTunnelsChange(): Promise<void>;
    $registerCandidateFinder(enable: boolean): Promise<void>;
    $applyCandidateFilter(candidates: CandidatePort[]): Promise<CandidatePort[]>;
    $providePortAttributes(handles: number[], ports: number[], pid: number | undefined, commandline: string | undefined, cancellationToken: CancellationToken): Promise<ProvidedPortAttributes[]>;
}
interface ExtHostLocalizationShape {
    getMessage(extensionId: string, details: IStringDetails): string;
    getBundle(extensionId: string): {
        [key: string]: string;
    } | undefined;
    getBundleUri(extensionId: string): URI | undefined;
    initializeLocalizedMessages(extension: IExtensionDescription): Promise<void>;
}
interface IStringDetails {
    message: string;
    args?: Record<string | number, any>;
    comment?: string | string[];
}

export { ExtHostConfigurationShape, ExtHostExtensionServiceShape, ExtHostFileSystemInfoShape, ExtHostLocalizationShape, ExtHostManagedSocketsShape, ExtHostTerminalIdentifier, ExtHostTerminalServiceShape, ExtHostTunnelServiceShape, ExtHostWorkspaceShape, IConfigurationInitData, IStringDetails, ITerminalDimensionsDto, ITerminalLinkDto, ITextSearchComplete, IWorkspaceData, MainThreadConfigurationShape, MainThreadExtensionServiceShape, MainThreadTelemetryShape, MainThreadWorkspaceShape, PortAttributesSelector, TerminalQuickFix, TunnelDto };
