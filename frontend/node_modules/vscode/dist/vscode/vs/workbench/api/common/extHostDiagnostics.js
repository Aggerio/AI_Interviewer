import { __decorate, __param } from '../../../../../node_modules/tslib/tslib.es6.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { MarkerSeverity } from 'monaco-editor/esm/vs/platform/markers/common/markers.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { MainContext } from './extHost.protocol.js';
import { DiagnosticSeverity } from './extHostTypes.js';
import { Diagnostic } from './extHostTypeConverters.js';
import { DebounceEmitter, Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { ResourceMap } from 'monaco-editor/esm/vs/base/common/map.js';
import { IExtHostFileSystemInfo } from './extHostFileSystemInfo.js';
class DiagnosticCollection {
    #proxy;
    #onDidChangeDiagnostics;
    #data;
    constructor(_name, _owner, _maxDiagnosticsTotal, _maxDiagnosticsPerFile, _modelVersionIdProvider, extUri, proxy, onDidChangeDiagnostics) {
        this._name = _name;
        this._owner = _owner;
        this._maxDiagnosticsTotal = _maxDiagnosticsTotal;
        this._maxDiagnosticsPerFile = _maxDiagnosticsPerFile;
        this._modelVersionIdProvider = _modelVersionIdProvider;
        this._isDisposed = false;
        this._maxDiagnosticsTotal = Math.max(_maxDiagnosticsPerFile, _maxDiagnosticsTotal);
        this.#data = ( new ResourceMap(uri => extUri.getComparisonKey(uri)));
        this.#proxy = proxy;
        this.#onDidChangeDiagnostics = onDidChangeDiagnostics;
    }
    dispose() {
        if (!this._isDisposed) {
            this.#onDidChangeDiagnostics.fire([...( this.#data.keys())]);
            this.#proxy?.$clear(this._owner);
            this.#data.clear();
            this._isDisposed = true;
        }
    }
    get name() {
        this._checkDisposed();
        return this._name;
    }
    set(first, diagnostics) {
        if (!first) {
            this.clear();
            return;
        }
        this._checkDisposed();
        let toSync = [];
        if (URI.isUri(first)) {
            if (!diagnostics) {
                this.delete(first);
                return;
            }
            this.#data.set(first, diagnostics.slice());
            toSync = [first];
        }
        else if (Array.isArray(first)) {
            toSync = [];
            let lastUri;
            first = [...first].sort(DiagnosticCollection._compareIndexedTuplesByUri);
            for (const tuple of first) {
                const [uri, diagnostics] = tuple;
                if (!lastUri || ( uri.toString()) !== ( lastUri.toString())) {
                    if (lastUri && this.#data.get(lastUri).length === 0) {
                        this.#data.delete(lastUri);
                    }
                    lastUri = uri;
                    toSync.push(uri);
                    this.#data.set(uri, []);
                }
                if (!diagnostics) {
                    const currentDiagnostics = this.#data.get(uri);
                    if (currentDiagnostics) {
                        currentDiagnostics.length = 0;
                    }
                }
                else {
                    const currentDiagnostics = this.#data.get(uri);
                    currentDiagnostics?.push(...diagnostics);
                }
            }
        }
        this.#onDidChangeDiagnostics.fire(toSync);
        if (!this.#proxy) {
            return;
        }
        const entries = [];
        let totalMarkerCount = 0;
        for (const uri of toSync) {
            let marker = [];
            const diagnostics = this.#data.get(uri);
            if (diagnostics) {
                if (diagnostics.length > this._maxDiagnosticsPerFile) {
                    marker = [];
                    const order = [DiagnosticSeverity.Error, DiagnosticSeverity.Warning, DiagnosticSeverity.Information, DiagnosticSeverity.Hint];
                    orderLoop: for (let i = 0; i < 4; i++) {
                        for (const diagnostic of diagnostics) {
                            if (diagnostic.severity === order[i]) {
                                const len = marker.push({ ...Diagnostic.from(diagnostic), modelVersionId: this._modelVersionIdProvider(uri) });
                                if (len === this._maxDiagnosticsPerFile) {
                                    break orderLoop;
                                }
                            }
                        }
                    }
                    marker.push({
                        severity: MarkerSeverity.Info,
                        message: ( localize(
                            { key: 'limitHit', comment: ['amount of errors/warning skipped due to limits'] },
                            "Not showing {0} further errors and warnings.",
                            diagnostics.length - this._maxDiagnosticsPerFile
                        )),
                        startLineNumber: marker[marker.length - 1].startLineNumber,
                        startColumn: marker[marker.length - 1].startColumn,
                        endLineNumber: marker[marker.length - 1].endLineNumber,
                        endColumn: marker[marker.length - 1].endColumn
                    });
                }
                else {
                    marker = ( diagnostics.map(
                        diag => ({ ...Diagnostic.from(diag), modelVersionId: this._modelVersionIdProvider(uri) })
                    ));
                }
            }
            entries.push([uri, marker]);
            totalMarkerCount += marker.length;
            if (totalMarkerCount > this._maxDiagnosticsTotal) {
                break;
            }
        }
        this.#proxy.$changeMany(this._owner, entries);
    }
    delete(uri) {
        this._checkDisposed();
        this.#onDidChangeDiagnostics.fire([uri]);
        this.#data.delete(uri);
        this.#proxy?.$changeMany(this._owner, [[uri, undefined]]);
    }
    clear() {
        this._checkDisposed();
        this.#onDidChangeDiagnostics.fire([...( this.#data.keys())]);
        this.#data.clear();
        this.#proxy?.$clear(this._owner);
    }
    forEach(callback, thisArg) {
        this._checkDisposed();
        for (const [uri, values] of this) {
            callback.call(thisArg, uri, values, this);
        }
    }
    *[Symbol.iterator]() {
        this._checkDisposed();
        for (const uri of ( this.#data.keys())) {
            yield [uri, this.get(uri)];
        }
    }
    get(uri) {
        this._checkDisposed();
        const result = this.#data.get(uri);
        if (Array.isArray(result)) {
            return ( Object.freeze(result.slice(0)));
        }
        return [];
    }
    has(uri) {
        this._checkDisposed();
        return Array.isArray(this.#data.get(uri));
    }
    _checkDisposed() {
        if (this._isDisposed) {
            throw new Error('illegal state - object is disposed');
        }
    }
    static _compareIndexedTuplesByUri(a, b) {
        if (( a[0].toString()) < ( b[0].toString())) {
            return -1;
        }
        else if (( a[0].toString()) > ( b[0].toString())) {
            return 1;
        }
        else {
            return 0;
        }
    }
}
let ExtHostDiagnostics = class ExtHostDiagnostics {
    static { this._idPool = 0; }
    static { this._maxDiagnosticsPerFile = 1000; }
    static { this._maxDiagnosticsTotal = 1.1 * ExtHostDiagnostics._maxDiagnosticsPerFile; }
    static _mapper(last) {
        const map = ( new ResourceMap());
        for (const uri of last) {
            map.set(uri, uri);
        }
        return { uris: ( Object.freeze(Array.from(( map.values())))) };
    }
    constructor(mainContext, _logService, _fileSystemInfoService, _extHostDocumentsAndEditors) {
        this._logService = _logService;
        this._fileSystemInfoService = _fileSystemInfoService;
        this._extHostDocumentsAndEditors = _extHostDocumentsAndEditors;
        this._collections = ( new Map());
        this._onDidChangeDiagnostics = ( new DebounceEmitter({ merge: all => all.flat(), delay: 50 }));
        this.onDidChangeDiagnostics = ( Event.map(this._onDidChangeDiagnostics.event, ExtHostDiagnostics._mapper));
        this._proxy = ( mainContext.getProxy(MainContext.MainThreadDiagnostics));
    }
    createDiagnosticCollection(extensionId, name) {
        const { _collections, _proxy, _onDidChangeDiagnostics, _logService, _fileSystemInfoService, _extHostDocumentsAndEditors } = this;
        const loggingProxy = new (class {
            $changeMany(owner, entries) {
                _proxy.$changeMany(owner, entries);
                _logService.trace('[DiagnosticCollection] change many (extension, owner, uris)', extensionId.value, owner, entries.length === 0 ? 'CLEARING' : entries);
            }
            $clear(owner) {
                _proxy.$clear(owner);
                _logService.trace('[DiagnosticCollection] remove all (extension, owner)', extensionId.value, owner);
            }
            dispose() {
                _proxy.dispose();
            }
        });
        let owner;
        if (!name) {
            name = '_generated_diagnostic_collection_name_#' + ExtHostDiagnostics._idPool++;
            owner = name;
        }
        else if (!( _collections.has(name))) {
            owner = name;
        }
        else {
            this._logService.warn(`DiagnosticCollection with name '${name}' does already exist.`);
            do {
                owner = name + ExtHostDiagnostics._idPool++;
            } while (( _collections.has(owner)));
        }
        const result = new (class extends DiagnosticCollection {
            constructor() {
                super(name, owner, ExtHostDiagnostics._maxDiagnosticsTotal, ExtHostDiagnostics._maxDiagnosticsPerFile, uri => _extHostDocumentsAndEditors.getDocument(uri)?.version, _fileSystemInfoService.extUri, loggingProxy, _onDidChangeDiagnostics);
                _collections.set(owner, this);
            }
            dispose() {
                super.dispose();
                _collections.delete(owner);
            }
        });
        return result;
    }
    getDiagnostics(resource) {
        if (resource) {
            return this._getDiagnostics(resource);
        }
        else {
            const index = ( new Map());
            const res = [];
            for (const collection of ( this._collections.values())) {
                collection.forEach((uri, diagnostics) => {
                    let idx = index.get(( uri.toString()));
                    if (typeof idx === 'undefined') {
                        idx = res.length;
                        index.set(( uri.toString()), idx);
                        res.push([uri, []]);
                    }
                    res[idx][1] = res[idx][1].concat(...diagnostics);
                });
            }
            return res;
        }
    }
    _getDiagnostics(resource) {
        let res = [];
        for (const collection of ( this._collections.values())) {
            if (( collection.has(resource))) {
                res = res.concat(collection.get(resource));
            }
        }
        return res;
    }
    $acceptMarkersChange(data) {
        if (!this._mirrorCollection) {
            const name = '_generated_mirror';
            const collection = ( new DiagnosticCollection(
                name,
                name,
                Number.MAX_SAFE_INTEGER,
                Number.MAX_SAFE_INTEGER,
                _uri => undefined,
                this._fileSystemInfoService.extUri,
                undefined,
                this._onDidChangeDiagnostics
            ));
            this._collections.set(name, collection);
            this._mirrorCollection = collection;
        }
        for (const [uri, markers] of data) {
            this._mirrorCollection.set(URI.revive(uri), ( markers.map(Diagnostic.to)));
        }
    }
};
ExtHostDiagnostics = ( __decorate([
    ( __param(1, ILogService)),
    ( __param(2, IExtHostFileSystemInfo))
], ExtHostDiagnostics));
export { DiagnosticCollection, ExtHostDiagnostics };
