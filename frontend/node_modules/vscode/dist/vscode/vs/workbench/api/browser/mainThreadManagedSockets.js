import { __decorate, __param } from '../../../../../node_modules/tslib/tslib.es6.js';
import { ExtHostContext, MainContext } from '../common/extHost.protocol.js';
import { extHostNamedCustomer } from '../../services/extensions/common/extHostCustomers.js';
import { Disposable, DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { VSBuffer } from 'monaco-editor/esm/vs/base/common/buffer.js';
import { IRemoteSocketFactoryService } from '../../../platform/remote/common/remoteSocketFactoryService.js';
import { SocketDiagnostics } from '../../../base/parts/ipc/common/ipc.net.js';
import { PauseableEmitter, Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { makeRawSocketHeaders, socketRawEndHeaderSequence } from '../../../platform/remote/common/managedSocket.js';
let MainThreadManagedSockets = class MainThreadManagedSockets extends Disposable {
    constructor(extHostContext, _remoteSocketFactoryService) {
        super();
        this._remoteSocketFactoryService = _remoteSocketFactoryService;
        this._registrations = ( new Map());
        this._remoteSockets = ( new Map());
        this._proxy = ( extHostContext.getProxy(ExtHostContext.ExtHostManagedSockets));
    }
    async $registerSocketFactory(socketFactoryId) {
        const that = this;
        const socketFactory = new (class {
            supports(connectTo) {
                return (connectTo.id === socketFactoryId);
            }
            connect(connectTo, path, query, debugLabel) {
                return ( new Promise((resolve, reject) => {
                    if (connectTo.id !== socketFactoryId) {
                        return reject(( new Error('Invalid connectTo')));
                    }
                    const factoryId = connectTo.id;
                    that._proxy.$openRemoteSocket(factoryId).then(socketId => {
                        const half = {
                            onClose: ( new Emitter()),
                            onData: ( new Emitter()),
                            onEnd: ( new Emitter()),
                        };
                        that._remoteSockets.set(socketId, half);
                        ManagedSocket.connect(socketId, that._proxy, path, query, debugLabel, half)
                            .then(socket => {
                            socket.onDidDispose(() => that._remoteSockets.delete(socketId));
                            resolve(socket);
                        }, err => {
                            that._remoteSockets.delete(socketId);
                            reject(err);
                        });
                    }).catch(reject);
                }));
            }
        });
        this._registrations.set(socketFactoryId, this._remoteSocketFactoryService.register(1 , socketFactory));
    }
    async $unregisterSocketFactory(socketFactoryId) {
        this._registrations.get(socketFactoryId)?.dispose();
    }
    $onDidManagedSocketHaveData(socketId, data) {
        this._remoteSockets.get(socketId)?.onData.fire(data);
    }
    $onDidManagedSocketClose(socketId, error) {
        this._remoteSockets.get(socketId)?.onClose.fire({
            type: 0 ,
            error: error ? ( new Error(error)) : undefined,
            hadError: !!error
        });
        this._remoteSockets.delete(socketId);
    }
    $onDidManagedSocketEnd(socketId) {
        this._remoteSockets.get(socketId)?.onEnd.fire();
    }
};
MainThreadManagedSockets = __decorate([
    extHostNamedCustomer(MainContext.MainThreadManagedSockets),
    ( __param(1, IRemoteSocketFactoryService))
], MainThreadManagedSockets);
class ManagedSocket extends Disposable {
    static connect(socketId, proxy, path, query, debugLabel, half) {
        const socket = ( new ManagedSocket(socketId, proxy, debugLabel, half.onClose, half.onData, half.onEnd));
        socket.write(VSBuffer.fromString(makeRawSocketHeaders(path, query)));
        const d = ( new DisposableStore());
        return ( new Promise((resolve, reject) => {
            let dataSoFar;
            d.add(socket.onData(d => {
                if (!dataSoFar) {
                    dataSoFar = d;
                }
                else {
                    dataSoFar = VSBuffer.concat([dataSoFar, d], dataSoFar.byteLength + d.byteLength);
                }
                const index = dataSoFar.indexOf(socketRawEndHeaderSequence);
                if (index === -1) {
                    return;
                }
                resolve(socket);
                socket.pauseData();
                const rest = dataSoFar.slice(index + socketRawEndHeaderSequence.byteLength);
                if (rest.byteLength) {
                    half.onData.fire(rest);
                }
            }));
            d.add(socket.onClose(err => reject(err ?? ( new Error('socket closed')))));
            d.add(socket.onEnd(() => reject(( new Error('socket ended')))));
        })).finally(() => d.dispose());
    }
    constructor(socketId, proxy, debugLabel, onCloseEmitter, onDataEmitter, onEndEmitter) {
        super();
        this.socketId = socketId;
        this.proxy = proxy;
        this.debugLabel = debugLabel;
        this.pausableDataEmitter = this._register(( new PauseableEmitter()));
        this.onData = (...args) => {
            if (this.pausableDataEmitter.isPaused) {
                queueMicrotask(() => this.pausableDataEmitter.resume());
            }
            return this.pausableDataEmitter.event(...args);
        };
        this.didDisposeEmitter = this._register(( new Emitter()));
        this.onDidDispose = this.didDisposeEmitter.event;
        this.ended = false;
        this._register(onDataEmitter);
        this._register(onDataEmitter.event(data => this.pausableDataEmitter.fire(data)));
        this.onClose = this._register(onCloseEmitter).event;
        this.onEnd = this._register(onEndEmitter).event;
    }
    pauseData() {
        this.pausableDataEmitter.pause();
    }
    write(buffer) {
        this.proxy.$remoteSocketWrite(this.socketId, buffer);
    }
    end() {
        this.ended = true;
        this.proxy.$remoteSocketEnd(this.socketId);
    }
    drain() {
        return this.proxy.$remoteSocketDrain(this.socketId);
    }
    traceSocketEvent(type, data) {
        SocketDiagnostics.traceSocketEvent(this, this.debugLabel, type, data);
    }
    dispose() {
        if (!this.ended) {
            this.proxy.$remoteSocketEnd(this.socketId);
        }
        this.didDisposeEmitter.fire();
        super.dispose();
    }
}
export { MainThreadManagedSockets, ManagedSocket };
