import { IExtensionService } from './vscode/vs/workbench/services/extensions/common/extensions.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { getExtensionId } from './vscode/vs/platform/extensionManagement/common/extensionManagementUtil.js';
import { DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { localizeManifest } from './vscode/vs/platform/extensionManagement/common/extensionNls.js';
import { joinPath } from 'monaco-editor/esm/vs/base/common/resources.js';
import { FileAccess } from 'monaco-editor/esm/vs/base/common/network.js';
import { Barrier } from 'monaco-editor/esm/vs/base/common/async.js';
export { ExtensionHostKind } from './vscode/vs/workbench/services/extensions/common/extensionHostKind.js';
import { getLocalExtHostExtensionService } from './service-override/extensions.js';
import { registerExtensionFile } from './service-override/files.js';
import { setDefaultApi } from './api.js';
import { getService } from './services.js';
const defaultApiInitializeBarrier = new Barrier();
async function initialize() {
    await getLocalExtHostExtensionService().then(async (extHostExtensionService) => {
        setDefaultApi(await extHostExtensionService.getApi());
        defaultApiInitializeBarrier.open();
    });
}
function registerExtensionFileUrl(extensionLocation, filePath, url, mimeType) {
    const fileDisposable = new DisposableStore();
    fileDisposable.add(FileAccess.registerStaticBrowserUri(joinPath(extensionLocation, filePath), ( URI.parse(url))));
    fileDisposable.add(registerExtensionFile(extensionLocation, filePath, async () => {
        const response = await fetch(url, {
            headers: mimeType != null
                ? {
                    Accept: mimeType
                }
                : {}
        });
        if (response.status !== 200) {
            throw new Error(response.statusText);
        }
        return new Uint8Array(await response.arrayBuffer());
    }));
    return fileDisposable;
}
let _toAdd = [];
let _toRemove = [];
let lastPromise;
async function deltaExtensions(toAdd, toRemove) {
    _toAdd.push(...toAdd);
    _toRemove.push(...toRemove);
    if (lastPromise == null) {
        const extensionService = await getService(IExtensionService);
        lastPromise = new Promise(resolve => setTimeout(resolve)).then(async () => {
            await extensionService.deltaExtensions(_toAdd, _toRemove);
            _toAdd = [];
            _toRemove = [];
            lastPromise = undefined;
        });
    }
    await lastPromise;
}
function registerExtension(manifest, extHostKind, defaultNLS, builtin = manifest.publisher === 'vscode') {
    const disposableStore = new DisposableStore();
    const localizedManifest = defaultNLS != null ? localizeManifest(manifest, defaultNLS) : manifest;
    const id = getExtensionId(localizedManifest.publisher, localizedManifest.name);
    const location = ( URI.from({ scheme: 'extension', authority: id, path: '/' }));
    const extension = {
        manifest: localizedManifest,
        type: builtin ? 0  : 1 ,
        isBuiltin: builtin,
        identifier: { id },
        location,
        targetPlatform: "web" ,
        isValid: true,
        validations: [],
        extHostKind
    };
    const addExtensionPromise = deltaExtensions([extension], []);
    const api = {
        id: extension.identifier.id,
        registerFileUrl: (path, url, mimeType) => {
            return registerExtensionFileUrl(extension.location, path, url, mimeType);
        },
        async dispose() {
            await deltaExtensions([], [extension]);
            disposableStore.dispose();
        }
    };
    if (extHostKind === 1 ) {
        async function getApi() {
            await addExtensionPromise;
            return (await getLocalExtHostExtensionService()).getApi(id);
        }
        return {
            ...api,
            getApi,
            async setAsDefaultApi() {
                setDefaultApi(await getApi());
            }
        };
    }
    return api;
}
function onExtHostInitialized(fct) {
    void defaultApiInitializeBarrier.wait().then(fct);
}
export { initialize, onExtHostInitialized, registerExtension };
