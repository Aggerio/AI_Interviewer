import { createFilter } from '@rollup/pluginutils';
import * as yauzl from 'yauzl';
import { p as parseJson, e as extractResourcesFromExtensionManifest, l as localizeManifest } from './extension-tools.js';
import * as path from 'path';

function read(stream) {
    const bufs = [];
    return new Promise((resolve) => {
        stream.on('data', function (d) {
            bufs.push(d);
        });
        stream.on('end', function () {
            resolve(Buffer.concat(bufs));
        });
    });
}
async function readVsix(file) {
    return new Promise((resolve) => {
        const files = {};
        yauzl.open(file, { lazyEntries: true }, (err, zipfile) => {
            if (err != null)
                throw err;
            zipfile.readEntry();
            zipfile.on('entry', function (entry) {
                if (/\/$/.test(entry.fileName) || !entry.fileName.startsWith('extension/')) {
                    zipfile.readEntry();
                }
                else {
                    zipfile.openReadStream(entry, async function (err, readStream) {
                        if (err != null)
                            throw err;
                        readStream.on('end', function () {
                            zipfile.readEntry();
                        });
                        files[entry.fileName.slice('extension/'.length)] = await read(readStream);
                    });
                }
            });
            zipfile.on('end', function () {
                resolve(files);
            });
        });
    });
}
function getVsixPath(file) {
    return path.relative('/', path.resolve('/', file));
}
function plugin({ include = '**/*.vsix', exclude, transformManifest = manifest => manifest, getAdditionalResources = () => Promise.resolve([]) } = {}) {
    const filter = createFilter(include, exclude);
    return {
        name: 'vsix-loader',
        resolveId(source) {
            if (filter(source)) {
                return source;
            }
            if (source.startsWith('vsix:')) {
                return source;
            }
            return undefined;
        },
        async load(id) {
            if (!filter(id))
                return null;
            const files = await readVsix(id);
            const manifest = transformManifest(parseJson(id, files['package.json'].toString('utf8')));
            const extensionResources = (await extractResourcesFromExtensionManifest(manifest, async (path) => {
                return files[getVsixPath(path)];
            })).filter(resource => getVsixPath(resource.path) in files);
            const vsixFile = Object.fromEntries(Object.entries(files).map(([key, value]) => [getVsixPath(key), value]));
            const resources = [
                ...extensionResources,
                ...await getAdditionalResources(manifest)
            ];
            const pathMapping = await Promise.all(resources.map(async (resource) => {
                const assetPath = getVsixPath(resource.path);
                let url;
                if (process.env.NODE_ENV === 'development') {
                    url = `'data:text/javascript;base64,${vsixFile[assetPath].toString('base64')}'`;
                }
                else {
                    url = 'import.meta.ROLLUP_FILE_URL_' + this.emitFile({
                        type: 'asset',
                        name: `${path.basename(id)}/${path.basename(assetPath)}`,
                        source: vsixFile[assetPath]
                    });
                }
                return ({
                    pathInExtension: assetPath,
                    url,
                    mimeType: resource.mimeType
                });
            }));
            let packageJson = parseJson(id, vsixFile['package.json'].toString('utf8'));
            if ('package.nls.json' in vsixFile) {
                packageJson = localizeManifest(packageJson, parseJson(id, vsixFile['package.nls.json'].toString()));
            }
            return `
import { registerExtension } from 'vscode/extensions'

const manifest = ${JSON.stringify(transformManifest(packageJson))}

const { registerFileUrl } = registerExtension(manifest)

${pathMapping.map(({ pathInExtension, url, mimeType }) => (`
registerFileUrl('${pathInExtension}', ${url}${mimeType != null ? `, '${mimeType}'` : ''})`)).join('\n')}
`;
        }
    };
}

export { plugin as default };
