diff -urN -x '*.map' a/vs/base/browser/browser.js b/vs/base/browser/browser.js
--- a/vs/base/browser/browser.js	2023-09-05 08:43:04.206807940 +0000
+++ b/vs/base/browser/browser.js	2023-09-05 08:45:14.293196291 +0000
@@ -6,12 +6,40 @@
 import { Disposable, markAsSingleton } from '../common/lifecycle.js';
 class WindowManager {
     constructor() {
+        // --- Zoom Level
+        this._zoomLevel = 0;
         // --- Zoom Factor
         this._zoomFactor = 1;
+        // --- Fullscreen
+        this._fullscreen = false;
+        this._onDidChangeFullscreen = new Emitter();
+        this.onDidChangeFullscreen = this._onDidChangeFullscreen.event;
+    }
+    getZoomLevel() {
+        return this._zoomLevel;
+    }
+    setZoomLevel(zoomLevel) {
+        if (this._zoomLevel === zoomLevel) {
+            return;
+        }
+        this._zoomLevel = zoomLevel;
     }
     getZoomFactor() {
         return this._zoomFactor;
     }
+    setZoomFactor(zoomFactor) {
+        this._zoomFactor = zoomFactor;
+    }
+    setFullscreen(fullscreen) {
+        if (this._fullscreen === fullscreen) {
+            return;
+        }
+        this._fullscreen = fullscreen;
+        this._onDidChangeFullscreen.fire();
+    }
+    isFullscreen() {
+        return this._fullscreen;
+    }
 }
 WindowManager.INSTANCE = new WindowManager();
 /**
@@ -99,10 +127,27 @@
  * and any measurements need to be discarded for example when a window is moved from a monitor to another.
  */
 export const PixelRatio = new PixelRatioFacade();
+/** A zoom index, e.g. 1, 2, 3 */
+export function setZoomLevel(zoomLevel) {
+    WindowManager.INSTANCE.setZoomLevel(zoomLevel);
+}
+export function getZoomLevel() {
+    return WindowManager.INSTANCE.getZoomLevel();
+}
 /** The zoom scale for an index, e.g. 1, 1.2, 1.4 */
 export function getZoomFactor() {
     return WindowManager.INSTANCE.getZoomFactor();
 }
+export function setZoomFactor(zoomFactor) {
+    WindowManager.INSTANCE.setZoomFactor(zoomFactor);
+}
+export function setFullscreen(fullscreen) {
+    WindowManager.INSTANCE.setFullscreen(fullscreen);
+}
+export function isFullscreen() {
+    return WindowManager.INSTANCE.isFullscreen();
+}
+export const onDidChangeFullscreen = WindowManager.INSTANCE.onDidChangeFullscreen;
 const userAgent = navigator.userAgent;
 export const isFirefox = (userAgent.indexOf('Firefox') >= 0);
 export const isWebKit = (userAgent.indexOf('AppleWebKit') >= 0);
@@ -129,3 +174,10 @@
 export function isStandalone() {
     return standalone;
 }
+// Visible means that the feature is enabled, not necessarily being rendered
+// e.g. visible is true even in fullscreen mode where the controls are hidden
+// See docs at https://developer.mozilla.org/en-US/docs/Web/API/WindowControlsOverlay/visible
+export function isWCOEnabled() {
+    var _a;
+    return (_a = navigator === null || navigator === void 0 ? void 0 : navigator.windowControlsOverlay) === null || _a === void 0 ? void 0 : _a.visible;
+}
diff -urN -x '*.map' a/vs/base/browser/defaultWorkerFactory.js b/vs/base/browser/defaultWorkerFactory.js
--- a/vs/base/browser/defaultWorkerFactory.js	2023-09-05 08:43:04.206807940 +0000
+++ b/vs/base/browser/defaultWorkerFactory.js	2023-09-05 08:45:14.293196291 +0000
@@ -3,8 +3,17 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import { createTrustedTypesPolicy } from './trustedTypes.js';
+// ESM-comment-begin
+// import { COI } from '../common/network';
+// ESM-comment-end
 import { logOnceWebWorkerWarning } from '../common/worker/simpleWorker.js';
 const ttPolicy = createTrustedTypesPolicy('defaultWorkerFactory', { createScriptURL: value => value });
+export function createBlobWorker(blobUrl, options) {
+    if (!blobUrl.startsWith('blob:')) {
+        throw new URIError('Not a blob-url: ' + blobUrl);
+    }
+    return new Worker(ttPolicy ? ttPolicy.createScriptURL(blobUrl) : blobUrl, options);
+}
 function getWorker(label) {
     const monacoEnvironment = globalThis.MonacoEnvironment;
     if (monacoEnvironment) {
diff -urN -x '*.map' a/vs/base/browser/dnd.js b/vs/base/browser/dnd.js
--- a/vs/base/browser/dnd.js	2023-09-05 08:43:04.206807940 +0000
+++ b/vs/base/browser/dnd.js	2023-09-05 08:45:14.293196291 +0000
@@ -1,4 +1,43 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { addDisposableListener } from './dom.js';
+import { Disposable } from '../common/lifecycle.js';
 import { Mimes } from '../common/mime.js';
+/**
+ * A helper that will execute a provided function when the provided HTMLElement receives
+ *  dragover event for 800ms. If the drag is aborted before, the callback will not be triggered.
+ */
+export class DelayedDragHandler extends Disposable {
+    constructor(container, callback) {
+        super();
+        this._register(addDisposableListener(container, 'dragover', e => {
+            e.preventDefault(); // needed so that the drop event fires (https://stackoverflow.com/questions/21339924/drop-event-not-firing-in-chrome)
+            if (!this.timeout) {
+                this.timeout = setTimeout(() => {
+                    callback();
+                    this.timeout = null;
+                }, 800);
+            }
+        }));
+        ['dragleave', 'drop', 'dragend'].forEach(type => {
+            this._register(addDisposableListener(container, type, () => {
+                this.clearDragTimeout();
+            }));
+        });
+    }
+    clearDragTimeout() {
+        if (this.timeout) {
+            clearTimeout(this.timeout);
+            this.timeout = null;
+        }
+    }
+    dispose() {
+        super.dispose();
+        this.clearDragTimeout();
+    }
+}
 // Common data transfers
 export const DataTransfers = {
     /**
@@ -24,3 +63,20 @@
      */
     INTERNAL_URI_LIST: 'application/vnd.code.uri-list',
 };
+export function applyDragImage(event, label, clazz, backgroundColor, foregroundColor) {
+    const dragImage = document.createElement('div');
+    dragImage.className = clazz;
+    dragImage.textContent = label;
+    if (foregroundColor) {
+        dragImage.style.color = foregroundColor;
+    }
+    if (backgroundColor) {
+        dragImage.style.background = backgroundColor;
+    }
+    if (event.dataTransfer) {
+        document.body.appendChild(dragImage);
+        event.dataTransfer.setDragImage(dragImage, -10, -10);
+        // Removes the element when the DND operation is done
+        setTimeout(() => document.body.removeChild(dragImage), 0);
+    }
+}
diff -urN -x '*.map' a/vs/base/browser/dom.js b/vs/base/browser/dom.js
--- a/vs/base/browser/dom.js	2023-09-05 08:43:04.206807940 +0000
+++ b/vs/base/browser/dom.js	2023-09-05 08:45:14.293196291 +0000
@@ -6,12 +6,15 @@
 import { BrowserFeatures } from './canIUse.js';
 import { StandardKeyboardEvent } from './keyboardEvent.js';
 import { StandardMouseEvent } from './mouseEvent.js';
+import { TimeoutTimer } from '../common/async.js';
 import { onUnexpectedError } from '../common/errors.js';
 import * as event from '../common/event.js';
 import * as dompurify from './dompurify/dompurify.js';
 import { Disposable, DisposableStore, toDisposable } from '../common/lifecycle.js';
-import { FileAccess, RemoteAuthorities } from '../common/network.js';
+import { FileAccess, RemoteAuthorities, Schemas } from '../common/network.js';
 import * as platform from '../common/platform.js';
+import { withNullAsUndefined } from '../common/types.js';
+import { URI } from '../common/uri.js';
 export function clearNode(node) {
     while (node.firstChild) {
         node.firstChild.remove();
@@ -77,6 +80,9 @@
 export function addDisposableGenericMouseDownListener(node, handler, useCapture) {
     return addDisposableListener(node, platform.isIOS && BrowserFeatures.pointerEvents ? EventType.POINTER_DOWN : EventType.MOUSE_DOWN, handler, useCapture);
 }
+export function addDisposableGenericMouseMoveListener(node, handler, useCapture) {
+    return addDisposableListener(node, platform.isIOS && BrowserFeatures.pointerEvents ? EventType.POINTER_MOVE : EventType.MOUSE_MOVE, handler, useCapture);
+}
 export function addDisposableGenericMouseUpListener(node, handler, useCapture) {
     return addDisposableListener(node, platform.isIOS && BrowserFeatures.pointerEvents ? EventType.POINTER_UP : EventType.MOUSE_UP, handler, useCapture);
 }
@@ -168,6 +174,43 @@
         }
     };
 })();
+export function measure(callback) {
+    return scheduleAtNextAnimationFrame(callback, 10000 /* must be early */);
+}
+export function modify(callback) {
+    return scheduleAtNextAnimationFrame(callback, -10000 /* must be late */);
+}
+const MINIMUM_TIME_MS = 8;
+const DEFAULT_EVENT_MERGER = function (lastEvent, currentEvent) {
+    return currentEvent;
+};
+class TimeoutThrottledDomListener extends Disposable {
+    constructor(node, type, handler, eventMerger = DEFAULT_EVENT_MERGER, minimumTimeMs = MINIMUM_TIME_MS) {
+        super();
+        let lastEvent = null;
+        let lastHandlerTime = 0;
+        const timeout = this._register(new TimeoutTimer());
+        const invokeHandler = () => {
+            lastHandlerTime = (new Date()).getTime();
+            handler(lastEvent);
+            lastEvent = null;
+        };
+        this._register(addDisposableListener(node, type, (e) => {
+            lastEvent = eventMerger(lastEvent, e);
+            const elapsedTime = (new Date()).getTime() - lastHandlerTime;
+            if (elapsedTime >= minimumTimeMs) {
+                timeout.cancel();
+                invokeHandler();
+            }
+            else {
+                timeout.setIfNotSet(invokeHandler, minimumTimeMs - elapsedTime);
+            }
+        }));
+    }
+}
+export function addDisposableThrottledListener(node, type, handler, eventMerger, minimumTimeMs) {
+    return new TimeoutThrottledDomListener(node, type, handler, eventMerger, minimumTimeMs);
+}
 export function getComputedStyle(el) {
     return document.defaultView.getComputedStyle(el, null);
 }
@@ -312,6 +355,21 @@
         element.style.height = `${height}px`;
     }
 }
+export function position(element, top, right, bottom, left, position = 'absolute') {
+    if (typeof top === 'number') {
+        element.style.top = `${top}px`;
+    }
+    if (typeof right === 'number') {
+        element.style.right = `${right}px`;
+    }
+    if (typeof bottom === 'number') {
+        element.style.bottom = `${bottom}px`;
+    }
+    if (typeof left === 'number') {
+        element.style.left = `${left}px`;
+    }
+    element.style.position = position;
+}
 /**
  * Returns the position of a dom node relative to the entire page.
  */
@@ -350,6 +408,10 @@
     const padding = SizeUtils.getPaddingLeft(element) + SizeUtils.getPaddingRight(element);
     return element.offsetWidth - border - padding;
 }
+export function getTotalScrollWidth(element) {
+    const margin = SizeUtils.getMarginLeft(element) + SizeUtils.getMarginRight(element);
+    return element.scrollWidth + margin;
+}
 // Adapted from WinJS
 // Gets the height of the content of the specified element. The content height does not include borders or padding.
 export function getContentHeight(element) {
@@ -363,6 +425,22 @@
     const margin = SizeUtils.getMarginTop(element) + SizeUtils.getMarginBottom(element);
     return element.offsetHeight + margin;
 }
+// Gets the left coordinate of the specified element relative to the specified parent.
+function getRelativeLeft(element, parent) {
+    if (element === null) {
+        return 0;
+    }
+    const elementPosition = getTopLeftOffset(element);
+    const parentPosition = getTopLeftOffset(parent);
+    return elementPosition.left - parentPosition.left;
+}
+export function getLargestChildWidth(parent, children) {
+    const childWidths = children.map((child) => {
+        return Math.max(getTotalScrollWidth(child), getTotalWidth(child)) + getRelativeLeft(child, parent) || 0;
+    });
+    const maxWidth = Math.max(...childWidths);
+    return maxWidth;
+}
 // ----------------------------------------------------------------------------------------
 export function isAncestor(testChild, testAncestor) {
     while (testChild) {
@@ -373,6 +451,42 @@
     }
     return false;
 }
+const parentFlowToDataKey = 'parentFlowToElementId';
+/**
+ * Set an explicit parent to use for nodes that are not part of the
+ * regular dom structure.
+ */
+export function setParentFlowTo(fromChildElement, toParentElement) {
+    fromChildElement.dataset[parentFlowToDataKey] = toParentElement.id;
+}
+function getParentFlowToElement(node) {
+    const flowToParentId = node.dataset[parentFlowToDataKey];
+    if (typeof flowToParentId === 'string') {
+        return document.getElementById(flowToParentId);
+    }
+    return null;
+}
+/**
+ * Check if `testAncestor` is an ancestor of `testChild`, observing the explicit
+ * parents set by `setParentFlowTo`.
+ */
+export function isAncestorUsingFlowTo(testChild, testAncestor) {
+    let node = testChild;
+    while (node) {
+        if (node === testAncestor) {
+            return true;
+        }
+        if (node instanceof HTMLElement) {
+            const flowToParentElement = getParentFlowToElement(node);
+            if (flowToParentElement) {
+                node = flowToParentElement;
+                continue;
+            }
+        }
+        node = node.parentNode;
+    }
+    return false;
+}
 export function findParentWithClass(node, clazz, stopAtClazzOrNode) {
     while (node && node.nodeType === node.ELEMENT_NODE) {
         if (node.classList.contains(clazz)) {
@@ -428,6 +542,11 @@
     container.appendChild(style);
     return style;
 }
+export function createMetaElement(container = document.getElementsByTagName('head')[0]) {
+    const meta = document.createElement('meta');
+    container.appendChild(meta);
+    return meta;
+}
 let _sharedStyleSheet = null;
 function getSharedStyleSheet() {
     if (!_sharedStyleSheet) {
@@ -613,6 +732,9 @@
         this._register(addDisposableListener(element, EventType.FOCUS_IN, () => this._refreshStateHandler()));
         this._register(addDisposableListener(element, EventType.FOCUS_OUT, () => this._refreshStateHandler()));
     }
+    refreshState() {
+        this._refreshStateHandler();
+    }
 }
 /**
  * Creates a new `IFocusTracker` instance that tracks focus changes on the given `element` and its descendants.
@@ -623,6 +745,10 @@
 export function trackFocus(element) {
     return new FocusTracker(element);
 }
+export function after(sibling, child) {
+    sibling.after(child);
+    return child;
+}
 export function append(parent, ...children) {
     parent.append(...children);
     if (children.length === 1 && typeof children[0] !== 'string') {
@@ -692,6 +818,21 @@
 $.SVG = function (description, attrs, ...children) {
     return _$(Namespace.SVG, description, attrs, ...children);
 };
+export function join(nodes, separator) {
+    const result = [];
+    nodes.forEach((node, index) => {
+        if (index > 0) {
+            if (separator instanceof Node) {
+                result.push(separator.cloneNode());
+            }
+            else {
+                result.push(document.createTextNode(separator));
+            }
+        }
+        result.push(node);
+    });
+    return result;
+}
 export function setVisibility(visible, ...elements) {
     if (visible) {
         show(...elements);
@@ -712,6 +853,47 @@
         element.setAttribute('aria-hidden', 'true');
     }
 }
+function findParentWithAttribute(node, attribute) {
+    while (node && node.nodeType === node.ELEMENT_NODE) {
+        if (node instanceof HTMLElement && node.hasAttribute(attribute)) {
+            return node;
+        }
+        node = node.parentNode;
+    }
+    return null;
+}
+export function removeTabIndexAndUpdateFocus(node) {
+    if (!node || !node.hasAttribute('tabIndex')) {
+        return;
+    }
+    // If we are the currently focused element and tabIndex is removed,
+    // standard DOM behavior is to move focus to the <body> element. We
+    // typically never want that, rather put focus to the closest element
+    // in the hierarchy of the parent DOM nodes.
+    if (document.activeElement === node) {
+        const parentFocusable = findParentWithAttribute(node.parentElement, 'tabIndex');
+        parentFocusable === null || parentFocusable === void 0 ? void 0 : parentFocusable.focus();
+    }
+    node.removeAttribute('tabindex');
+}
+export function finalHandler(fn) {
+    return e => {
+        e.preventDefault();
+        e.stopPropagation();
+        fn(e);
+    };
+}
+export function domContentLoaded() {
+    return new Promise(resolve => {
+        const readyState = document.readyState;
+        if (readyState === 'complete' || (document && document.body !== null)) {
+            resolve(undefined);
+        }
+        else {
+            window.addEventListener('DOMContentLoaded', resolve, false);
+        }
+    });
+}
 /**
  * Find a value usable for a dom node size such that the likelihood that it would be
  * displayed with constant screen pixels size is as high as possible.
@@ -744,6 +926,50 @@
     // the creation of the window.
     window.open(url, '_blank', 'noopener');
 }
+/**
+ * Open a new window in a popup. This is the best way to do so, but you cannot tell
+ * if the window was opened or if it was blocked by the browser's popup blocker.
+ * If you want to tell if the browser blocked the new window, use {@link windowOpenWithSuccess}.
+ *
+ * Note: this does not set {@link window.opener} to null. This is to allow the opened popup to
+ * be able to use {@link window.close} to close itself. Because of this, you should only use
+ * this function on urls that you trust.
+ *
+ * In otherwords, you should almost always use {@link windowOpenNoOpener} instead of this function.
+ */
+const popupWidth = 780, popupHeight = 640;
+export function windowOpenPopup(url) {
+    const left = Math.floor(window.screenLeft + window.innerWidth / 2 - popupWidth / 2);
+    const top = Math.floor(window.screenTop + window.innerHeight / 2 - popupHeight / 2);
+    window.open(url, '_blank', `width=${popupWidth},height=${popupHeight},top=${top},left=${left}`);
+}
+/**
+ * Attempts to open a window and returns whether it succeeded. This technique is
+ * not appropriate in certain contexts, like for example when the JS context is
+ * executing inside a sandboxed iframe. If it is not necessary to know if the
+ * browser blocked the new window, use {@link windowOpenNoOpener}.
+ *
+ * See https://github.com/microsoft/monaco-editor/issues/601
+ * See https://github.com/microsoft/monaco-editor/issues/2474
+ * See https://mathiasbynens.github.io/rel-noopener/
+ *
+ * @param url the url to open
+ * @param noOpener whether or not to set the {@link window.opener} to null. You should leave the default
+ * (true) unless you trust the url that is being opened.
+ * @returns boolean indicating if the {@link window.open} call succeeded
+ */
+export function windowOpenWithSuccess(url, noOpener = true) {
+    const newTab = window.open();
+    if (newTab) {
+        if (noOpener) {
+            // see `windowOpenNoOpener` for details on why this is important
+            newTab.opener = null;
+        }
+        newTab.location.href = url;
+        return true;
+    }
+    return false;
+}
 export function animate(fn) {
     const step = () => {
         fn();
@@ -779,6 +1005,90 @@
     }
     return dflt;
 }
+export function triggerDownload(dataOrUri, name) {
+    // If the data is provided as Buffer, we create a
+    // blob URL out of it to produce a valid link
+    let url;
+    if (URI.isUri(dataOrUri)) {
+        url = dataOrUri.toString(true);
+    }
+    else {
+        const blob = new Blob([dataOrUri]);
+        url = URL.createObjectURL(blob);
+        // Ensure to free the data from DOM eventually
+        setTimeout(() => URL.revokeObjectURL(url));
+    }
+    // In order to download from the browser, the only way seems
+    // to be creating a <a> element with download attribute that
+    // points to the file to download.
+    // See also https://developers.google.com/web/updates/2011/08/Downloading-resources-in-HTML5-a-download
+    const anchor = document.createElement('a');
+    document.body.appendChild(anchor);
+    anchor.download = name;
+    anchor.href = url;
+    anchor.click();
+    // Ensure to remove the element from DOM eventually
+    setTimeout(() => document.body.removeChild(anchor));
+}
+export function triggerUpload() {
+    return new Promise(resolve => {
+        // In order to upload to the browser, create a
+        // input element of type `file` and click it
+        // to gather the selected files
+        const input = document.createElement('input');
+        document.body.appendChild(input);
+        input.type = 'file';
+        input.multiple = true;
+        // Resolve once the input event has fired once
+        event.Event.once(event.Event.fromDOMEventEmitter(input, 'input'))(() => {
+            resolve(withNullAsUndefined(input.files));
+        });
+        input.click();
+        // Ensure to remove the element from DOM eventually
+        setTimeout(() => document.body.removeChild(input));
+    });
+}
+export var DetectedFullscreenMode;
+(function (DetectedFullscreenMode) {
+    /**
+     * The document is fullscreen, e.g. because an element
+     * in the document requested to be fullscreen.
+     */
+    DetectedFullscreenMode[DetectedFullscreenMode["DOCUMENT"] = 1] = "DOCUMENT";
+    /**
+     * The browser is fullscreen, e.g. because the user enabled
+     * native window fullscreen for it.
+     */
+    DetectedFullscreenMode[DetectedFullscreenMode["BROWSER"] = 2] = "BROWSER";
+})(DetectedFullscreenMode || (DetectedFullscreenMode = {}));
+export function detectFullscreen() {
+    // Browser fullscreen: use DOM APIs to detect
+    if (document.fullscreenElement || document.webkitFullscreenElement || document.webkitIsFullScreen) {
+        return { mode: DetectedFullscreenMode.DOCUMENT, guess: false };
+    }
+    // There is no standard way to figure out if the browser
+    // is using native fullscreen. Via checking on screen
+    // height and comparing that to window height, we can guess
+    // it though.
+    if (window.innerHeight === screen.height) {
+        // if the height of the window matches the screen height, we can
+        // safely assume that the browser is fullscreen because no browser
+        // chrome is taking height away (e.g. like toolbars).
+        return { mode: DetectedFullscreenMode.BROWSER, guess: false };
+    }
+    if (platform.isMacintosh || platform.isLinux) {
+        // macOS and Linux do not properly report `innerHeight`, only Windows does
+        if (window.outerHeight === screen.height && window.outerWidth === screen.width) {
+            // if the height of the browser matches the screen height, we can
+            // only guess that we are in fullscreen. It is also possible that
+            // the user has turned off taskbars in the OS and the browser is
+            // simply able to span the entire size of the screen.
+            return { mode: DetectedFullscreenMode.BROWSER, guess: true };
+        }
+    }
+    // Not in fullscreen
+    return null;
+}
 // -- sanitize and trusted html
 /**
  * Hooks dompurify using `afterSanitizeAttributes` to check that all `href` and `src`
@@ -811,6 +1121,11 @@
         dompurify.removeHook('afterSanitizeAttributes');
     });
 }
+const defaultSafeProtocols = [
+    Schemas.http,
+    Schemas.https,
+    Schemas.command,
+];
 /**
  * List of safe, non-input html tags.
  */
@@ -889,6 +1204,43 @@
     RETURN_DOM_FRAGMENT: false,
     RETURN_TRUSTED_TYPE: true
 });
+/**
+ * Sanitizes the given `value` and reset the given `node` with it.
+ */
+export function safeInnerHtml(node, value) {
+    const hook = hookDomPurifyHrefAndSrcSanitizer(defaultSafeProtocols);
+    try {
+        const html = dompurify.sanitize(value, defaultDomPurifyConfig);
+        node.innerHTML = html;
+    }
+    finally {
+        hook.dispose();
+    }
+}
+/**
+ * Convert a Unicode string to a string in which each 16-bit unit occupies only one byte
+ *
+ * From https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/btoa
+ */
+function toBinary(str) {
+    const codeUnits = new Uint16Array(str.length);
+    for (let i = 0; i < codeUnits.length; i++) {
+        codeUnits[i] = str.charCodeAt(i);
+    }
+    let binary = '';
+    const uint8array = new Uint8Array(codeUnits.buffer);
+    for (let i = 0; i < uint8array.length; i++) {
+        binary += String.fromCharCode(uint8array[i]);
+    }
+    return binary;
+}
+/**
+ * Version of the global `btoa` function that handles multi-byte characters instead
+ * of throwing an exception.
+ */
+export function multibyteAwareBtoa(str) {
+    return btoa(toBinary(str));
+}
 export class ModifierKeyEmitter extends event.Emitter {
     constructor() {
         super();
@@ -985,6 +1337,9 @@
     get keyStatus() {
         return this._keyStatus;
     }
+    get isModifierPressed() {
+        return this._keyStatus.altKey || this._keyStatus.ctrlKey || this._keyStatus.metaKey || this._keyStatus.shiftKey;
+    }
     /**
      * Allows to explicitly reset the key status based on more knowledge (#109062)
      */
@@ -1011,6 +1366,10 @@
         this._subscriptions.dispose();
     }
 }
+export function getCookieValue(name) {
+    const match = document.cookie.match('(^|[^;]+)\\s*' + name + '\\s*=\\s*([^;]+)'); // See https://stackoverflow.com/a/25490531
+    return match ? match.pop() : undefined;
+}
 export class DragAndDropObserver extends Disposable {
     constructor(element, callbacks) {
         super();
diff -urN -x '*.map' a/vs/base/browser/fastDomNode.js b/vs/base/browser/fastDomNode.js
--- a/vs/base/browser/fastDomNode.js	2023-09-05 08:43:04.210808041 +0000
+++ b/vs/base/browser/fastDomNode.js	2023-09-05 08:45:14.293196291 +0000
@@ -12,7 +12,10 @@
         this._left = '';
         this._bottom = '';
         this._right = '';
+        this._paddingTop = '';
         this._paddingLeft = '';
+        this._paddingBottom = '';
+        this._paddingRight = '';
         this._fontFamily = '';
         this._fontWeight = '';
         this._fontSize = '';
@@ -88,6 +91,14 @@
         this._right = right;
         this.domNode.style.right = this._right;
     }
+    setPaddingTop(_paddingTop) {
+        const paddingTop = numberAsPixels(_paddingTop);
+        if (this._paddingTop === paddingTop) {
+            return;
+        }
+        this._paddingTop = paddingTop;
+        this.domNode.style.paddingTop = this._paddingTop;
+    }
     setPaddingLeft(_paddingLeft) {
         const paddingLeft = numberAsPixels(_paddingLeft);
         if (this._paddingLeft === paddingLeft) {
@@ -96,6 +107,22 @@
         this._paddingLeft = paddingLeft;
         this.domNode.style.paddingLeft = this._paddingLeft;
     }
+    setPaddingBottom(_paddingBottom) {
+        const paddingBottom = numberAsPixels(_paddingBottom);
+        if (this._paddingBottom === paddingBottom) {
+            return;
+        }
+        this._paddingBottom = paddingBottom;
+        this.domNode.style.paddingBottom = this._paddingBottom;
+    }
+    setPaddingRight(_paddingRight) {
+        const paddingRight = numberAsPixels(_paddingRight);
+        if (this._paddingRight === paddingRight) {
+            return;
+        }
+        this._paddingRight = paddingRight;
+        this.domNode.style.paddingRight = this._paddingRight;
+    }
     setFontFamily(fontFamily) {
         if (this._fontFamily === fontFamily) {
             return;
diff -urN -x '*.map' a/vs/base/browser/iframe.js b/vs/base/browser/iframe.js
--- a/vs/base/browser/iframe.js	2023-09-05 08:43:04.210808041 +0000
+++ b/vs/base/browser/iframe.js	2023-09-05 08:45:14.293196291 +0000
@@ -54,6 +54,16 @@
         return sameOriginWindowChainCache.slice(0);
     }
     /**
+     * Returns true if the current execution environment is chained in a list of iframes which at one point ends in a window with a different origin.
+     * Returns false if the current execution environment is not running inside an iframe or if the entire chain of iframes have the same origin.
+     */
+    static hasDifferentOriginAncestor() {
+        if (!sameOriginWindowChainCache) {
+            this.getSameOriginWindowChain();
+        }
+        return hasDifferentOriginAncestorFlag;
+    }
+    /**
      * Returns the position of `childWindow` relative to `ancestorWindow`
      */
     static getPositionOfChildWindowRelativeToAncestorWindow(childWindow, ancestorWindow) {
diff -urN -x '*.map' a/vs/base/browser/indexedDB.js b/vs/base/browser/indexedDB.js
--- a/vs/base/browser/indexedDB.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/base/browser/indexedDB.js	2023-09-05 08:45:14.293196291 +0000
@@ -0,0 +1,175 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+import { toErrorMessage } from '../common/errorMessage.js';
+import { getErrorMessage } from '../common/errors.js';
+import { mark } from '../common/performance.js';
+class MissingStoresError extends Error {
+    constructor(db) {
+        super('Missing stores');
+        this.db = db;
+    }
+}
+export class DBClosedError extends Error {
+    constructor(dbName) {
+        super(`IndexedDB database '${dbName}' is closed.`);
+        this.code = 'DBClosed';
+    }
+}
+export class IndexedDB {
+    static create(name, version, stores) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const database = yield IndexedDB.openDatabase(name, version, stores);
+            return new IndexedDB(database, name);
+        });
+    }
+    static openDatabase(name, version, stores) {
+        return __awaiter(this, void 0, void 0, function* () {
+            mark(`code/willOpenDatabase/${name}`);
+            try {
+                return yield IndexedDB.doOpenDatabase(name, version, stores);
+            }
+            catch (err) {
+                if (err instanceof MissingStoresError) {
+                    console.info(`Attempting to recreate the IndexedDB once.`, name);
+                    try {
+                        // Try to delete the db
+                        yield IndexedDB.deleteDatabase(err.db);
+                    }
+                    catch (error) {
+                        console.error(`Error while deleting the IndexedDB`, getErrorMessage(error));
+                        throw error;
+                    }
+                    return yield IndexedDB.doOpenDatabase(name, version, stores);
+                }
+                throw err;
+            }
+            finally {
+                mark(`code/didOpenDatabase/${name}`);
+            }
+        });
+    }
+    static doOpenDatabase(name, version, stores) {
+        return new Promise((c, e) => {
+            const request = window.indexedDB.open(name, version);
+            request.onerror = () => e(request.error);
+            request.onsuccess = () => {
+                const db = request.result;
+                for (const store of stores) {
+                    if (!db.objectStoreNames.contains(store)) {
+                        console.error(`Error while opening IndexedDB. Could not find '${store}'' object store`);
+                        e(new MissingStoresError(db));
+                        return;
+                    }
+                }
+                c(db);
+            };
+            request.onupgradeneeded = () => {
+                const db = request.result;
+                for (const store of stores) {
+                    if (!db.objectStoreNames.contains(store)) {
+                        db.createObjectStore(store);
+                    }
+                }
+            };
+        });
+    }
+    static deleteDatabase(indexedDB) {
+        return new Promise((c, e) => {
+            // Close any opened connections
+            indexedDB.close();
+            // Delete the db
+            const deleteRequest = window.indexedDB.deleteDatabase(indexedDB.name);
+            deleteRequest.onerror = (err) => e(deleteRequest.error);
+            deleteRequest.onsuccess = () => c();
+        });
+    }
+    constructor(database, name) {
+        this.name = name;
+        this.database = null;
+        this.pendingTransactions = [];
+        this.database = database;
+    }
+    hasPendingTransactions() {
+        return this.pendingTransactions.length > 0;
+    }
+    close() {
+        var _a;
+        if (this.pendingTransactions.length) {
+            this.pendingTransactions.splice(0, this.pendingTransactions.length).forEach(transaction => transaction.abort());
+        }
+        (_a = this.database) === null || _a === void 0 ? void 0 : _a.close();
+        this.database = null;
+    }
+    runInTransaction(store, transactionMode, dbRequestFn) {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (!this.database) {
+                throw new DBClosedError(this.name);
+            }
+            const transaction = this.database.transaction(store, transactionMode);
+            this.pendingTransactions.push(transaction);
+            return new Promise((c, e) => {
+                transaction.oncomplete = () => {
+                    if (Array.isArray(request)) {
+                        c(request.map(r => r.result));
+                    }
+                    else {
+                        c(request.result);
+                    }
+                };
+                transaction.onerror = () => e(transaction.error);
+                transaction.onabort = () => e(transaction.error);
+                const request = dbRequestFn(transaction.objectStore(store));
+            }).finally(() => this.pendingTransactions.splice(this.pendingTransactions.indexOf(transaction), 1));
+        });
+    }
+    getKeyValues(store, isValid) {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (!this.database) {
+                throw new DBClosedError(this.name);
+            }
+            const transaction = this.database.transaction(store, 'readonly');
+            this.pendingTransactions.push(transaction);
+            return new Promise(resolve => {
+                const items = new Map();
+                const objectStore = transaction.objectStore(store);
+                // Open a IndexedDB Cursor to iterate over key/values
+                const cursor = objectStore.openCursor();
+                if (!cursor) {
+                    return resolve(items); // this means the `ItemTable` was empty
+                }
+                // Iterate over rows of `ItemTable` until the end
+                cursor.onsuccess = () => {
+                    if (cursor.result) {
+                        // Keep cursor key/value in our map
+                        if (isValid(cursor.result.value)) {
+                            items.set(cursor.result.key.toString(), cursor.result.value);
+                        }
+                        // Advance cursor to next row
+                        cursor.result.continue();
+                    }
+                    else {
+                        resolve(items); // reached end of table
+                    }
+                };
+                // Error handlers
+                const onError = (error) => {
+                    console.error(`IndexedDB getKeyValues(): ${toErrorMessage(error, true)}`);
+                    resolve(items);
+                };
+                cursor.onerror = () => onError(cursor.error);
+                transaction.onerror = () => onError(transaction.error);
+            }).finally(() => this.pendingTransactions.splice(this.pendingTransactions.indexOf(transaction), 1));
+        });
+    }
+}
diff -urN -x '*.map' a/vs/base/browser/keyboardEvent.js b/vs/base/browser/keyboardEvent.js
--- a/vs/base/browser/keyboardEvent.js	2023-09-05 08:43:04.210808041 +0000
+++ b/vs/base/browser/keyboardEvent.js	2023-09-05 08:45:14.293196291 +0000
@@ -53,6 +53,38 @@
 const altKeyMod = 512 /* KeyMod.Alt */;
 const shiftKeyMod = 1024 /* KeyMod.Shift */;
 const metaKeyMod = (platform.isMacintosh ? 2048 /* KeyMod.CtrlCmd */ : 256 /* KeyMod.WinCtrl */);
+export function printKeyboardEvent(e) {
+    const modifiers = [];
+    if (e.ctrlKey) {
+        modifiers.push(`ctrl`);
+    }
+    if (e.shiftKey) {
+        modifiers.push(`shift`);
+    }
+    if (e.altKey) {
+        modifiers.push(`alt`);
+    }
+    if (e.metaKey) {
+        modifiers.push(`meta`);
+    }
+    return `modifiers: [${modifiers.join(',')}], code: ${e.code}, keyCode: ${e.keyCode}, key: ${e.key}`;
+}
+export function printStandardKeyboardEvent(e) {
+    const modifiers = [];
+    if (e.ctrlKey) {
+        modifiers.push(`ctrl`);
+    }
+    if (e.shiftKey) {
+        modifiers.push(`shift`);
+    }
+    if (e.altKey) {
+        modifiers.push(`alt`);
+    }
+    if (e.metaKey) {
+        modifiers.push(`meta`);
+    }
+    return `modifiers: [${modifiers.join(',')}], code: ${e.code}, keyCode: ${e.keyCode} ('${KeyCodeUtils.toString(e.keyCode)}')`;
+}
 export class StandardKeyboardEvent {
     constructor(source) {
         this._standardKeyboardEventBrand = true;
diff -urN -x '*.map' a/vs/base/browser/mouseEvent.js b/vs/base/browser/mouseEvent.js
--- a/vs/base/browser/mouseEvent.js	2023-09-05 08:43:04.210808041 +0000
+++ b/vs/base/browser/mouseEvent.js	2023-09-05 08:45:14.293196291 +0000
@@ -43,6 +43,12 @@
         this.browserEvent.stopPropagation();
     }
 }
+export class DragMouseEvent extends StandardMouseEvent {
+    constructor(e) {
+        super(e);
+        this.dataTransfer = e.dataTransfer;
+    }
+}
 export class StandardWheelEvent {
     constructor(e, deltaX = 0, deltaY = 0) {
         this.browserEvent = e || null;
diff -urN -x '*.map' a/vs/base/browser/ui/actionbar/actionViewItems.js b/vs/base/browser/ui/actionbar/actionViewItems.js
--- a/vs/base/browser/ui/actionbar/actionViewItems.js	2023-09-05 08:43:04.178807231 +0000
+++ b/vs/base/browser/ui/actionbar/actionViewItems.js	2023-09-05 08:45:14.285196176 +0000
@@ -130,6 +130,10 @@
             this.element.classList.add('focused');
         }
     }
+    isFocused() {
+        var _a;
+        return !!((_a = this.element) === null || _a === void 0 ? void 0 : _a.classList.contains('focused'));
+    }
     blur() {
         if (this.element) {
             this.element.blur();
@@ -243,6 +247,10 @@
             this.label.focus();
         }
     }
+    isFocused() {
+        var _a;
+        return !!this.label && ((_a = this.label) === null || _a === void 0 ? void 0 : _a.tabIndex) === 0;
+    }
     blur() {
         if (this.label) {
             this.label.tabIndex = -1;
@@ -337,6 +345,9 @@
         this._register(this.selectBox);
         this.registerListeners();
     }
+    setOptions(options, selected) {
+        this.selectBox.setOptions(options, selected);
+    }
     select(index) {
         this.selectBox.select(index);
     }
diff -urN -x '*.map' a/vs/base/browser/ui/actionbar/actionbar.js b/vs/base/browser/ui/actionbar/actionbar.js
--- a/vs/base/browser/ui/actionbar/actionbar.js	2023-09-05 08:43:04.178807231 +0000
+++ b/vs/base/browser/ui/actionbar/actionbar.js	2023-09-05 08:45:14.285196176 +0000
@@ -155,6 +155,14 @@
             this.actionsList.setAttribute('role', 'presentation');
         }
     }
+    setAriaLabel(label) {
+        if (label) {
+            this.actionsList.setAttribute('aria-label', label);
+        }
+        else {
+            this.actionsList.removeAttribute('aria-label');
+        }
+    }
     // Some action bars should not be focusable at times
     // When an action bar is not focusable make sure to make all the elements inside it not focusable
     // When an action bar is focusable again, make sure the first item can be focused
@@ -212,6 +220,9 @@
     getContainer() {
         return this.domNode;
     }
+    hasAction(action) {
+        return this.viewItems.findIndex(candidate => candidate.action.id === action.id) !== -1;
+    }
     getAction(indexOrElement) {
         var _a;
         // by index
@@ -278,6 +289,32 @@
         }
         this.refreshRole();
     }
+    getWidth(index) {
+        if (index >= 0 && index < this.actionsList.children.length) {
+            const item = this.actionsList.children.item(index);
+            if (item) {
+                return item.clientWidth;
+            }
+        }
+        return 0;
+    }
+    getHeight(index) {
+        if (index >= 0 && index < this.actionsList.children.length) {
+            const item = this.actionsList.children.item(index);
+            if (item) {
+                return item.clientHeight;
+            }
+        }
+        return 0;
+    }
+    pull(index) {
+        if (index >= 0 && index < this.viewItems.length) {
+            this.actionsList.removeChild(this.actionsList.childNodes[index]);
+            this.viewItemDisposables.deleteAndDispose(this.viewItems[index]);
+            dispose(this.viewItems.splice(index, 1));
+            this.refreshRole();
+        }
+    }
     clear() {
         if (this.isEmpty()) {
             return;
@@ -422,3 +459,46 @@
         super.dispose();
     }
 }
+export function prepareActions(actions) {
+    if (!actions.length) {
+        return actions;
+    }
+    // Clean up leading separators
+    let firstIndexOfAction = -1;
+    for (let i = 0; i < actions.length; i++) {
+        if (actions[i].id === Separator.ID) {
+            continue;
+        }
+        firstIndexOfAction = i;
+        break;
+    }
+    if (firstIndexOfAction === -1) {
+        return [];
+    }
+    actions = actions.slice(firstIndexOfAction);
+    // Clean up trailing separators
+    for (let h = actions.length - 1; h >= 0; h--) {
+        const isSeparator = actions[h].id === Separator.ID;
+        if (isSeparator) {
+            actions.splice(h, 1);
+        }
+        else {
+            break;
+        }
+    }
+    // Clean up separator duplicates
+    let foundAction = false;
+    for (let k = actions.length - 1; k >= 0; k--) {
+        const isSeparator = actions[k].id === Separator.ID;
+        if (isSeparator && !foundAction) {
+            actions.splice(k, 1);
+        }
+        else if (!isSeparator) {
+            foundAction = true;
+        }
+        else if (isSeparator) {
+            foundAction = false;
+        }
+    }
+    return actions;
+}
diff -urN -x '*.map' a/vs/base/browser/ui/breadcrumbs/breadcrumbsWidget.js b/vs/base/browser/ui/breadcrumbs/breadcrumbsWidget.js
--- a/vs/base/browser/ui/breadcrumbs/breadcrumbsWidget.js	2023-09-05 08:43:04.178807231 +0000
+++ b/vs/base/browser/ui/breadcrumbs/breadcrumbsWidget.js	2023-09-05 08:45:14.289196233 +0000
@@ -1 +1,301 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import * as dom from '../../dom.js';
+import { DomScrollableElement } from '../scrollbar/scrollableElement.js';
+import { commonPrefixLength } from '../../../common/arrays.js';
+import { ThemeIcon } from '../../../common/themables.js';
+import { Emitter } from '../../../common/event.js';
+import { DisposableStore, dispose } from '../../../common/lifecycle.js';
 import './breadcrumbsWidget.css';
+export class BreadcrumbsItem {
+    dispose() { }
+}
+export class BreadcrumbsWidget {
+    constructor(container, horizontalScrollbarSize, separatorIcon, styles) {
+        this._disposables = new DisposableStore();
+        this._onDidSelectItem = new Emitter();
+        this._onDidFocusItem = new Emitter();
+        this._onDidChangeFocus = new Emitter();
+        this.onDidSelectItem = this._onDidSelectItem.event;
+        this.onDidFocusItem = this._onDidFocusItem.event;
+        this.onDidChangeFocus = this._onDidChangeFocus.event;
+        this._items = new Array();
+        this._nodes = new Array();
+        this._freeNodes = new Array();
+        this._enabled = true;
+        this._focusedItemIdx = -1;
+        this._selectedItemIdx = -1;
+        this._domNode = document.createElement('div');
+        this._domNode.className = 'monaco-breadcrumbs';
+        this._domNode.tabIndex = 0;
+        this._domNode.setAttribute('role', 'list');
+        this._scrollable = new DomScrollableElement(this._domNode, {
+            vertical: 2 /* ScrollbarVisibility.Hidden */,
+            horizontal: 1 /* ScrollbarVisibility.Auto */,
+            horizontalScrollbarSize,
+            useShadows: false,
+            scrollYToX: true
+        });
+        this._separatorIcon = separatorIcon;
+        this._disposables.add(this._scrollable);
+        this._disposables.add(dom.addStandardDisposableListener(this._domNode, 'click', e => this._onClick(e)));
+        container.appendChild(this._scrollable.getDomNode());
+        const styleElement = dom.createStyleSheet(this._domNode);
+        this._style(styleElement, styles);
+        const focusTracker = dom.trackFocus(this._domNode);
+        this._disposables.add(focusTracker);
+        this._disposables.add(focusTracker.onDidBlur(_ => this._onDidChangeFocus.fire(false)));
+        this._disposables.add(focusTracker.onDidFocus(_ => this._onDidChangeFocus.fire(true)));
+    }
+    setHorizontalScrollbarSize(size) {
+        this._scrollable.updateOptions({
+            horizontalScrollbarSize: size
+        });
+    }
+    dispose() {
+        var _a;
+        this._disposables.dispose();
+        (_a = this._pendingLayout) === null || _a === void 0 ? void 0 : _a.dispose();
+        this._onDidSelectItem.dispose();
+        this._onDidFocusItem.dispose();
+        this._onDidChangeFocus.dispose();
+        this._domNode.remove();
+        this._nodes.length = 0;
+        this._freeNodes.length = 0;
+    }
+    layout(dim) {
+        var _a;
+        if (dim && dom.Dimension.equals(dim, this._dimension)) {
+            return;
+        }
+        (_a = this._pendingLayout) === null || _a === void 0 ? void 0 : _a.dispose();
+        if (dim) {
+            // only measure
+            this._pendingLayout = this._updateDimensions(dim);
+        }
+        else {
+            this._pendingLayout = this._updateScrollbar();
+        }
+    }
+    _updateDimensions(dim) {
+        const disposables = new DisposableStore();
+        disposables.add(dom.modify(() => {
+            this._dimension = dim;
+            this._domNode.style.width = `${dim.width}px`;
+            this._domNode.style.height = `${dim.height}px`;
+            disposables.add(this._updateScrollbar());
+        }));
+        return disposables;
+    }
+    _updateScrollbar() {
+        return dom.measure(() => {
+            dom.measure(() => {
+                this._scrollable.setRevealOnScroll(false);
+                this._scrollable.scanDomNode();
+                this._scrollable.setRevealOnScroll(true);
+            });
+        });
+    }
+    _style(styleElement, style) {
+        let content = '';
+        if (style.breadcrumbsBackground) {
+            content += `.monaco-breadcrumbs { background-color: ${style.breadcrumbsBackground}}`;
+        }
+        if (style.breadcrumbsForeground) {
+            content += `.monaco-breadcrumbs .monaco-breadcrumb-item { color: ${style.breadcrumbsForeground}}\n`;
+        }
+        if (style.breadcrumbsFocusForeground) {
+            content += `.monaco-breadcrumbs .monaco-breadcrumb-item.focused { color: ${style.breadcrumbsFocusForeground}}\n`;
+        }
+        if (style.breadcrumbsFocusAndSelectionForeground) {
+            content += `.monaco-breadcrumbs .monaco-breadcrumb-item.focused.selected { color: ${style.breadcrumbsFocusAndSelectionForeground}}\n`;
+        }
+        if (style.breadcrumbsHoverForeground) {
+            content += `.monaco-breadcrumbs:not(.disabled	) .monaco-breadcrumb-item:hover:not(.focused):not(.selected) { color: ${style.breadcrumbsHoverForeground}}\n`;
+        }
+        styleElement.innerText = content;
+    }
+    setEnabled(value) {
+        this._enabled = value;
+        this._domNode.classList.toggle('disabled', !this._enabled);
+    }
+    domFocus() {
+        const idx = this._focusedItemIdx >= 0 ? this._focusedItemIdx : this._items.length - 1;
+        if (idx >= 0 && idx < this._items.length) {
+            this._focus(idx, undefined);
+        }
+        else {
+            this._domNode.focus();
+        }
+    }
+    isDOMFocused() {
+        let candidate = document.activeElement;
+        while (candidate) {
+            if (this._domNode === candidate) {
+                return true;
+            }
+            candidate = candidate.parentElement;
+        }
+        return false;
+    }
+    getFocused() {
+        return this._items[this._focusedItemIdx];
+    }
+    setFocused(item, payload) {
+        this._focus(this._items.indexOf(item), payload);
+    }
+    focusPrev(payload) {
+        if (this._focusedItemIdx > 0) {
+            this._focus(this._focusedItemIdx - 1, payload);
+        }
+    }
+    focusNext(payload) {
+        if (this._focusedItemIdx + 1 < this._nodes.length) {
+            this._focus(this._focusedItemIdx + 1, payload);
+        }
+    }
+    _focus(nth, payload) {
+        this._focusedItemIdx = -1;
+        for (let i = 0; i < this._nodes.length; i++) {
+            const node = this._nodes[i];
+            if (i !== nth) {
+                node.classList.remove('focused');
+            }
+            else {
+                this._focusedItemIdx = i;
+                node.classList.add('focused');
+                node.focus();
+            }
+        }
+        this._reveal(this._focusedItemIdx, true);
+        this._onDidFocusItem.fire({ type: 'focus', item: this._items[this._focusedItemIdx], node: this._nodes[this._focusedItemIdx], payload });
+    }
+    reveal(item) {
+        const idx = this._items.indexOf(item);
+        if (idx >= 0) {
+            this._reveal(idx, false);
+        }
+    }
+    revealLast() {
+        this._reveal(this._items.length - 1, false);
+    }
+    _reveal(nth, minimal) {
+        if (nth < 0 || nth >= this._nodes.length) {
+            return;
+        }
+        const node = this._nodes[nth];
+        if (!node) {
+            return;
+        }
+        const { width } = this._scrollable.getScrollDimensions();
+        const { scrollLeft } = this._scrollable.getScrollPosition();
+        if (!minimal || node.offsetLeft > scrollLeft + width || node.offsetLeft < scrollLeft) {
+            this._scrollable.setRevealOnScroll(false);
+            this._scrollable.setScrollPosition({ scrollLeft: node.offsetLeft });
+            this._scrollable.setRevealOnScroll(true);
+        }
+    }
+    getSelection() {
+        return this._items[this._selectedItemIdx];
+    }
+    setSelection(item, payload) {
+        this._select(this._items.indexOf(item), payload);
+    }
+    _select(nth, payload) {
+        this._selectedItemIdx = -1;
+        for (let i = 0; i < this._nodes.length; i++) {
+            const node = this._nodes[i];
+            if (i !== nth) {
+                node.classList.remove('selected');
+            }
+            else {
+                this._selectedItemIdx = i;
+                node.classList.add('selected');
+            }
+        }
+        this._onDidSelectItem.fire({ type: 'select', item: this._items[this._selectedItemIdx], node: this._nodes[this._selectedItemIdx], payload });
+    }
+    getItems() {
+        return this._items;
+    }
+    setItems(items) {
+        let prefix;
+        let removed = [];
+        try {
+            prefix = commonPrefixLength(this._items, items, (a, b) => a.equals(b));
+            removed = this._items.splice(prefix, this._items.length - prefix, ...items.slice(prefix));
+            this._render(prefix);
+            dispose(removed);
+            this._focus(-1, undefined);
+        }
+        catch (e) {
+            const newError = new Error(`BreadcrumbsItem#setItems: newItems: ${items.length}, prefix: ${prefix}, removed: ${removed.length}`);
+            newError.name = e.name;
+            newError.stack = e.stack;
+            throw newError;
+        }
+    }
+    _render(start) {
+        let didChange = false;
+        for (; start < this._items.length && start < this._nodes.length; start++) {
+            const item = this._items[start];
+            const node = this._nodes[start];
+            this._renderItem(item, node);
+            didChange = true;
+        }
+        // case a: more nodes -> remove them
+        while (start < this._nodes.length) {
+            const free = this._nodes.pop();
+            if (free) {
+                this._freeNodes.push(free);
+                free.remove();
+                didChange = true;
+            }
+        }
+        // case b: more items -> render them
+        for (; start < this._items.length; start++) {
+            const item = this._items[start];
+            const node = this._freeNodes.length > 0 ? this._freeNodes.pop() : document.createElement('div');
+            if (node) {
+                this._renderItem(item, node);
+                this._domNode.appendChild(node);
+                this._nodes.push(node);
+                didChange = true;
+            }
+        }
+        if (didChange) {
+            this.layout(undefined);
+        }
+    }
+    _renderItem(item, container) {
+        dom.clearNode(container);
+        container.className = '';
+        try {
+            item.render(container);
+        }
+        catch (err) {
+            container.innerText = '<<RENDER ERROR>>';
+            console.error(err);
+        }
+        container.tabIndex = -1;
+        container.setAttribute('role', 'listitem');
+        container.classList.add('monaco-breadcrumb-item');
+        const iconContainer = dom.$(ThemeIcon.asCSSSelector(this._separatorIcon));
+        container.appendChild(iconContainer);
+    }
+    _onClick(event) {
+        if (!this._enabled) {
+            return;
+        }
+        for (let el = event.target; el; el = el.parentElement) {
+            const idx = this._nodes.indexOf(el);
+            if (idx >= 0) {
+                this._focus(idx, event);
+                this._select(idx, event);
+                break;
+            }
+        }
+    }
+}
diff -urN -x '*.map' a/vs/base/browser/ui/button/button.js b/vs/base/browser/ui/button/button.js
--- a/vs/base/browser/ui/button/button.js	2023-09-05 08:43:04.178807231 +0000
+++ b/vs/base/browser/ui/button/button.js	2023-09-05 08:45:14.289196233 +0000
@@ -1,14 +1,31 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
 import { addDisposableListener, EventHelper, EventType, reset, trackFocus } from '../../dom.js';
 import { sanitize } from '../../dompurify/dompurify.js';
 import { StandardKeyboardEvent } from '../../keyboardEvent.js';
 import { renderMarkdown, renderStringAsPlaintext } from '../../markdownRenderer.js';
 import { Gesture, EventType as TouchEventType } from '../../touch.js';
 import { renderLabelWithIcons } from '../iconLabel/iconLabels.js';
+import { Action } from '../../../common/actions.js';
+import { Codicon } from '../../../common/codicons.js';
 import { Color } from '../../../common/color.js';
 import { Emitter } from '../../../common/event.js';
 import { isMarkdownString, markdownStringEqual } from '../../../common/htmlContent.js';
-import { Disposable } from '../../../common/lifecycle.js';
+import { Disposable, DisposableStore } from '../../../common/lifecycle.js';
+import { ThemeIcon } from '../../../common/themables.js';
 import './button.css';
+import { localize } from '../../../../nls.js';
 export const unthemedButtonStyles = {
     buttonBackground: '#0E639C',
     buttonHoverBackground: '#006BB3',
@@ -169,6 +186,20 @@
     get label() {
         return this._label;
     }
+    set labelShort(value) {
+        if (!this.options.supportShortLabel || !this._labelShortElement) {
+            return;
+        }
+        if (this.options.supportIcons) {
+            reset(this._labelShortElement, ...this.getContentElements(value));
+        }
+        else {
+            this._labelShortElement.textContent = value;
+        }
+    }
+    set icon(icon) {
+        this._element.classList.add(...ThemeIcon.asClassNameArray(icon));
+    }
     set enabled(value) {
         if (value) {
             this._element.classList.remove('disabled');
@@ -183,4 +214,180 @@
     get enabled() {
         return !this._element.classList.contains('disabled');
     }
+    focus() {
+        this._element.focus();
+    }
+    hasFocus() {
+        return this._element === document.activeElement;
+    }
+}
+export class ButtonWithDropdown extends Disposable {
+    constructor(container, options) {
+        var _a;
+        super();
+        this._onDidClick = this._register(new Emitter());
+        this.onDidClick = this._onDidClick.event;
+        this.element = document.createElement('div');
+        this.element.classList.add('monaco-button-dropdown');
+        container.appendChild(this.element);
+        this.button = this._register(new Button(this.element, options));
+        this._register(this.button.onDidClick(e => this._onDidClick.fire(e)));
+        this.action = this._register(new Action('primaryAction', renderStringAsPlaintext(this.button.label), undefined, true, () => __awaiter(this, void 0, void 0, function* () { return this._onDidClick.fire(undefined); })));
+        this.separatorContainer = document.createElement('div');
+        this.separatorContainer.classList.add('monaco-button-dropdown-separator');
+        this.separator = document.createElement('div');
+        this.separatorContainer.appendChild(this.separator);
+        this.element.appendChild(this.separatorContainer);
+        // Separator styles
+        const border = options.buttonBorder;
+        if (border) {
+            this.separatorContainer.style.borderTop = '1px solid ' + border;
+            this.separatorContainer.style.borderBottom = '1px solid ' + border;
+        }
+        const buttonBackground = options.secondary ? options.buttonSecondaryBackground : options.buttonBackground;
+        this.separatorContainer.style.backgroundColor = buttonBackground !== null && buttonBackground !== void 0 ? buttonBackground : '';
+        this.separator.style.backgroundColor = (_a = options.buttonSeparator) !== null && _a !== void 0 ? _a : '';
+        this.dropdownButton = this._register(new Button(this.element, Object.assign(Object.assign({}, options), { title: false, supportIcons: true })));
+        this.dropdownButton.element.title = localize("button dropdown more actions", 'More Actions...');
+        this.dropdownButton.element.setAttribute('aria-haspopup', 'true');
+        this.dropdownButton.element.setAttribute('aria-expanded', 'false');
+        this.dropdownButton.element.classList.add('monaco-dropdown-button');
+        this.dropdownButton.icon = Codicon.dropDownButton;
+        this._register(this.dropdownButton.onDidClick(e => {
+            options.contextMenuProvider.showContextMenu({
+                getAnchor: () => this.dropdownButton.element,
+                getActions: () => options.addPrimaryActionToDropdown === false ? [...options.actions] : [this.action, ...options.actions],
+                actionRunner: options.actionRunner,
+                onHide: () => this.dropdownButton.element.setAttribute('aria-expanded', 'false')
+            });
+            this.dropdownButton.element.setAttribute('aria-expanded', 'true');
+        }));
+    }
+    dispose() {
+        super.dispose();
+        this.element.remove();
+    }
+    set label(value) {
+        this.button.label = value;
+        this.action.label = value;
+    }
+    set icon(icon) {
+        this.button.icon = icon;
+    }
+    set enabled(enabled) {
+        this.button.enabled = enabled;
+        this.dropdownButton.enabled = enabled;
+        this.element.classList.toggle('disabled', !enabled);
+    }
+    get enabled() {
+        return this.button.enabled;
+    }
+    focus() {
+        this.button.focus();
+    }
+    hasFocus() {
+        return this.button.hasFocus() || this.dropdownButton.hasFocus();
+    }
+}
+export class ButtonWithDescription {
+    constructor(container, options) {
+        this.options = options;
+        this._element = document.createElement('div');
+        this._element.classList.add('monaco-description-button');
+        this._button = new Button(this._element, options);
+        this._descriptionElement = document.createElement('div');
+        this._descriptionElement.classList.add('monaco-button-description');
+        this._element.appendChild(this._descriptionElement);
+        container.appendChild(this._element);
+    }
+    get onDidClick() {
+        return this._button.onDidClick;
+    }
+    get element() {
+        return this._element;
+    }
+    set label(value) {
+        this._button.label = value;
+    }
+    set icon(icon) {
+        this._button.icon = icon;
+    }
+    get enabled() {
+        return this._button.enabled;
+    }
+    set enabled(enabled) {
+        this._button.enabled = enabled;
+    }
+    focus() {
+        this._button.focus();
+    }
+    hasFocus() {
+        return this._button.hasFocus();
+    }
+    dispose() {
+        this._button.dispose();
+    }
+    set description(value) {
+        if (this.options.supportIcons) {
+            reset(this._descriptionElement, ...renderLabelWithIcons(value));
+        }
+        else {
+            this._descriptionElement.textContent = value;
+        }
+    }
+}
+export class ButtonBar {
+    constructor(container) {
+        this.container = container;
+        this._buttons = [];
+        this._buttonStore = new DisposableStore();
+    }
+    dispose() {
+        this._buttonStore.dispose();
+    }
+    get buttons() {
+        return this._buttons;
+    }
+    clear() {
+        this._buttonStore.clear();
+        this._buttons.length = 0;
+    }
+    addButton(options) {
+        const button = this._buttonStore.add(new Button(this.container, options));
+        this.pushButton(button);
+        return button;
+    }
+    addButtonWithDescription(options) {
+        const button = this._buttonStore.add(new ButtonWithDescription(this.container, options));
+        this.pushButton(button);
+        return button;
+    }
+    addButtonWithDropdown(options) {
+        const button = this._buttonStore.add(new ButtonWithDropdown(this.container, options));
+        this.pushButton(button);
+        return button;
+    }
+    pushButton(button) {
+        this._buttons.push(button);
+        const index = this._buttons.length - 1;
+        this._buttonStore.add(addDisposableListener(button.element, EventType.KEY_DOWN, e => {
+            const event = new StandardKeyboardEvent(e);
+            let eventHandled = true;
+            // Next / Previous Button
+            let buttonIndexToFocus;
+            if (event.equals(15 /* KeyCode.LeftArrow */)) {
+                buttonIndexToFocus = index > 0 ? index - 1 : this._buttons.length - 1;
+            }
+            else if (event.equals(17 /* KeyCode.RightArrow */)) {
+                buttonIndexToFocus = index === this._buttons.length - 1 ? 0 : index + 1;
+            }
+            else {
+                eventHandled = false;
+            }
+            if (eventHandled && typeof buttonIndexToFocus === 'number') {
+                this._buttons[buttonIndexToFocus].focus();
+                EventHelper.stop(e, true);
+            }
+        }));
+    }
 }
diff -urN -x '*.map' a/vs/base/browser/ui/countBadge/countBadge.js b/vs/base/browser/ui/countBadge/countBadge.js
--- a/vs/base/browser/ui/countBadge/countBadge.js	2023-09-05 08:43:04.182807333 +0000
+++ b/vs/base/browser/ui/countBadge/countBadge.js	2023-09-05 08:45:14.293196291 +0000
@@ -5,6 +5,11 @@
 import { $, append } from '../../dom.js';
 import { format } from '../../../common/strings.js';
 import './countBadge.css';
+export const unthemedCountStyles = {
+    badgeBackground: '#4D4D4D',
+    badgeForeground: '#FFFFFF',
+    badgeBorder: undefined
+};
 export class CountBadge {
     constructor(container, options, styles) {
         this.options = options;
@@ -19,6 +24,10 @@
         this.count = count;
         this.render();
     }
+    setCountFormat(countFormat) {
+        this.countFormat = countFormat;
+        this.render();
+    }
     setTitleFormat(titleFormat) {
         this.titleFormat = titleFormat;
         this.render();
diff -urN -x '*.map' a/vs/base/browser/ui/dialog/dialog.js b/vs/base/browser/ui/dialog/dialog.js
--- a/vs/base/browser/ui/dialog/dialog.js	2023-09-05 08:43:04.182807333 +0000
+++ b/vs/base/browser/ui/dialog/dialog.js	2023-09-05 08:45:14.289196233 +0000
@@ -1 +1,401 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+import { $, addDisposableListener, clearNode, EventHelper, EventType, hide, isAncestor, show } from '../../dom.js';
+import { StandardKeyboardEvent } from '../../keyboardEvent.js';
+import { ActionBar } from '../actionbar/actionbar.js';
+import { ButtonBar, ButtonWithDescription } from '../button/button.js';
+import { Checkbox } from '../toggle/toggle.js';
+import { InputBox } from '../inputbox/inputBox.js';
+import { Action } from '../../../common/actions.js';
+import { Codicon } from '../../../common/codicons.js';
+import { ThemeIcon } from '../../../common/themables.js';
+import { mnemonicButtonLabel } from '../../../common/labels.js';
+import { Disposable } from '../../../common/lifecycle.js';
+import { isLinux, isMacintosh, isWindows } from '../../../common/platform.js';
 import './dialog.css';
+import * as nls from '../../../../nls.js';
+export class Dialog extends Disposable {
+    constructor(container, message, buttons, options) {
+        super();
+        this.container = container;
+        this.message = message;
+        this.options = options;
+        this.modalElement = this.container.appendChild($(`.monaco-dialog-modal-block.dimmed`));
+        this.shadowElement = this.modalElement.appendChild($('.dialog-shadow'));
+        this.element = this.shadowElement.appendChild($('.monaco-dialog-box'));
+        this.element.setAttribute('role', 'dialog');
+        this.element.tabIndex = -1;
+        hide(this.element);
+        this.buttonStyles = options.buttonStyles;
+        if (Array.isArray(buttons) && buttons.length > 0) {
+            this.buttons = buttons;
+        }
+        else if (!this.options.disableDefaultAction) {
+            this.buttons = [nls.localize('ok', "OK")];
+        }
+        else {
+            this.buttons = [];
+        }
+        const buttonsRowElement = this.element.appendChild($('.dialog-buttons-row'));
+        this.buttonsContainer = buttonsRowElement.appendChild($('.dialog-buttons'));
+        const messageRowElement = this.element.appendChild($('.dialog-message-row'));
+        this.iconElement = messageRowElement.appendChild($('#monaco-dialog-icon.dialog-icon'));
+        this.iconElement.setAttribute('aria-label', this.getIconAriaLabel());
+        this.messageContainer = messageRowElement.appendChild($('.dialog-message-container'));
+        if (this.options.detail || this.options.renderBody) {
+            const messageElement = this.messageContainer.appendChild($('.dialog-message'));
+            const messageTextElement = messageElement.appendChild($('#monaco-dialog-message-text.dialog-message-text'));
+            messageTextElement.innerText = this.message;
+        }
+        this.messageDetailElement = this.messageContainer.appendChild($('#monaco-dialog-message-detail.dialog-message-detail'));
+        if (this.options.detail || !this.options.renderBody) {
+            this.messageDetailElement.innerText = this.options.detail ? this.options.detail : message;
+        }
+        else {
+            this.messageDetailElement.style.display = 'none';
+        }
+        if (this.options.renderBody) {
+            const customBody = this.messageContainer.appendChild($('#monaco-dialog-message-body.dialog-message-body'));
+            this.options.renderBody(customBody);
+            for (const el of this.messageContainer.querySelectorAll('a')) {
+                el.tabIndex = 0;
+            }
+        }
+        if (this.options.inputs) {
+            this.inputs = this.options.inputs.map(input => {
+                var _a;
+                const inputRowElement = this.messageContainer.appendChild($('.dialog-message-input'));
+                const inputBox = this._register(new InputBox(inputRowElement, undefined, {
+                    placeholder: input.placeholder,
+                    type: (_a = input.type) !== null && _a !== void 0 ? _a : 'text',
+                    inputBoxStyles: options.inputBoxStyles
+                }));
+                if (input.value) {
+                    inputBox.value = input.value;
+                }
+                return inputBox;
+            });
+        }
+        else {
+            this.inputs = [];
+        }
+        if (this.options.checkboxLabel) {
+            const checkboxRowElement = this.messageContainer.appendChild($('.dialog-checkbox-row'));
+            const checkbox = this.checkbox = this._register(new Checkbox(this.options.checkboxLabel, !!this.options.checkboxChecked, options.checkboxStyles));
+            checkboxRowElement.appendChild(checkbox.domNode);
+            const checkboxMessageElement = checkboxRowElement.appendChild($('.dialog-checkbox-message'));
+            checkboxMessageElement.innerText = this.options.checkboxLabel;
+            this._register(addDisposableListener(checkboxMessageElement, EventType.CLICK, () => checkbox.checked = !checkbox.checked));
+        }
+        const toolbarRowElement = this.element.appendChild($('.dialog-toolbar-row'));
+        this.toolbarContainer = toolbarRowElement.appendChild($('.dialog-toolbar'));
+        this.applyStyles();
+    }
+    getIconAriaLabel() {
+        let typeLabel = nls.localize('dialogInfoMessage', 'Info');
+        switch (this.options.type) {
+            case 'error':
+                typeLabel = nls.localize('dialogErrorMessage', 'Error');
+                break;
+            case 'warning':
+                typeLabel = nls.localize('dialogWarningMessage', 'Warning');
+                break;
+            case 'pending':
+                typeLabel = nls.localize('dialogPendingMessage', 'In Progress');
+                break;
+            case 'none':
+            case 'info':
+            case 'question':
+            default:
+                break;
+        }
+        return typeLabel;
+    }
+    updateMessage(message) {
+        this.messageDetailElement.innerText = message;
+    }
+    show() {
+        return __awaiter(this, void 0, void 0, function* () {
+            this.focusToReturn = document.activeElement;
+            return new Promise((resolve) => {
+                clearNode(this.buttonsContainer);
+                const buttonBar = this.buttonBar = this._register(new ButtonBar(this.buttonsContainer));
+                const buttonMap = this.rearrangeButtons(this.buttons, this.options.cancelId);
+                // Handle button clicks
+                buttonMap.forEach((entry, index) => {
+                    const primary = buttonMap[index].index === 0;
+                    const button = this.options.buttonDetails ? this._register(buttonBar.addButtonWithDescription(Object.assign({ title: true, secondary: !primary }, this.buttonStyles))) : this._register(buttonBar.addButton(Object.assign({ title: true, secondary: !primary }, this.buttonStyles)));
+                    button.label = mnemonicButtonLabel(buttonMap[index].label, true);
+                    if (button instanceof ButtonWithDescription) {
+                        button.description = this.options.buttonDetails[buttonMap[index].index];
+                    }
+                    this._register(button.onDidClick(e => {
+                        if (e) {
+                            EventHelper.stop(e);
+                        }
+                        resolve({
+                            button: buttonMap[index].index,
+                            checkboxChecked: this.checkbox ? this.checkbox.checked : undefined,
+                            values: this.inputs.length > 0 ? this.inputs.map(input => input.value) : undefined
+                        });
+                    }));
+                });
+                // Handle keyboard events globally: Tab, Arrow-Left/Right
+                this._register(addDisposableListener(window, 'keydown', e => {
+                    var _a, _b;
+                    const evt = new StandardKeyboardEvent(e);
+                    if (evt.equals(512 /* KeyMod.Alt */)) {
+                        evt.preventDefault();
+                    }
+                    if (evt.equals(3 /* KeyCode.Enter */)) {
+                        // Enter in input field should OK the dialog
+                        if (this.inputs.some(input => input.hasFocus())) {
+                            EventHelper.stop(e);
+                            resolve({
+                                button: (_b = (_a = buttonMap.find(button => button.index !== this.options.cancelId)) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : 0,
+                                checkboxChecked: this.checkbox ? this.checkbox.checked : undefined,
+                                values: this.inputs.length > 0 ? this.inputs.map(input => input.value) : undefined
+                            });
+                        }
+                        return; // leave default handling
+                    }
+                    if (evt.equals(10 /* KeyCode.Space */)) {
+                        return; // leave default handling
+                    }
+                    let eventHandled = false;
+                    // Focus: Next / Previous
+                    if (evt.equals(2 /* KeyCode.Tab */) || evt.equals(17 /* KeyCode.RightArrow */) || evt.equals(1024 /* KeyMod.Shift */ | 2 /* KeyCode.Tab */) || evt.equals(15 /* KeyCode.LeftArrow */)) {
+                        // Build a list of focusable elements in their visual order
+                        const focusableElements = [];
+                        let focusedIndex = -1;
+                        if (this.messageContainer) {
+                            const links = this.messageContainer.querySelectorAll('a');
+                            for (const link of links) {
+                                focusableElements.push(link);
+                                if (link === document.activeElement) {
+                                    focusedIndex = focusableElements.length - 1;
+                                }
+                            }
+                        }
+                        for (const input of this.inputs) {
+                            focusableElements.push(input);
+                            if (input.hasFocus()) {
+                                focusedIndex = focusableElements.length - 1;
+                            }
+                        }
+                        if (this.checkbox) {
+                            focusableElements.push(this.checkbox);
+                            if (this.checkbox.hasFocus()) {
+                                focusedIndex = focusableElements.length - 1;
+                            }
+                        }
+                        if (this.buttonBar) {
+                            for (const button of this.buttonBar.buttons) {
+                                focusableElements.push(button);
+                                if (button.hasFocus()) {
+                                    focusedIndex = focusableElements.length - 1;
+                                }
+                            }
+                        }
+                        // Focus next element (with wrapping)
+                        if (evt.equals(2 /* KeyCode.Tab */) || evt.equals(17 /* KeyCode.RightArrow */)) {
+                            if (focusedIndex === -1) {
+                                focusedIndex = 0; // default to focus first element if none have focus
+                            }
+                            const newFocusedIndex = (focusedIndex + 1) % focusableElements.length;
+                            focusableElements[newFocusedIndex].focus();
+                        }
+                        // Focus previous element (with wrapping)
+                        else {
+                            if (focusedIndex === -1) {
+                                focusedIndex = focusableElements.length; // default to focus last element if none have focus
+                            }
+                            let newFocusedIndex = focusedIndex - 1;
+                            if (newFocusedIndex === -1) {
+                                newFocusedIndex = focusableElements.length - 1;
+                            }
+                            focusableElements[newFocusedIndex].focus();
+                        }
+                        eventHandled = true;
+                    }
+                    if (eventHandled) {
+                        EventHelper.stop(e, true);
+                    }
+                    else if (this.options.keyEventProcessor) {
+                        this.options.keyEventProcessor(evt);
+                    }
+                }, true));
+                this._register(addDisposableListener(window, 'keyup', e => {
+                    EventHelper.stop(e, true);
+                    const evt = new StandardKeyboardEvent(e);
+                    if (!this.options.disableCloseAction && evt.equals(9 /* KeyCode.Escape */)) {
+                        resolve({
+                            button: this.options.cancelId || 0,
+                            checkboxChecked: this.checkbox ? this.checkbox.checked : undefined
+                        });
+                    }
+                }, true));
+                // Detect focus out
+                this._register(addDisposableListener(this.element, 'focusout', e => {
+                    if (!!e.relatedTarget && !!this.element) {
+                        if (!isAncestor(e.relatedTarget, this.element)) {
+                            this.focusToReturn = e.relatedTarget;
+                            if (e.target) {
+                                e.target.focus();
+                                EventHelper.stop(e, true);
+                            }
+                        }
+                    }
+                }, false));
+                const spinModifierClassName = 'codicon-modifier-spin';
+                this.iconElement.classList.remove(...ThemeIcon.asClassNameArray(Codicon.dialogError), ...ThemeIcon.asClassNameArray(Codicon.dialogWarning), ...ThemeIcon.asClassNameArray(Codicon.dialogInfo), ...ThemeIcon.asClassNameArray(Codicon.loading), spinModifierClassName);
+                if (this.options.icon) {
+                    this.iconElement.classList.add(...ThemeIcon.asClassNameArray(this.options.icon));
+                }
+                else {
+                    switch (this.options.type) {
+                        case 'error':
+                            this.iconElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.dialogError));
+                            break;
+                        case 'warning':
+                            this.iconElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.dialogWarning));
+                            break;
+                        case 'pending':
+                            this.iconElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.loading), spinModifierClassName);
+                            break;
+                        case 'none':
+                            this.iconElement.classList.add('no-codicon');
+                            break;
+                        case 'info':
+                        case 'question':
+                        default:
+                            this.iconElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.dialogInfo));
+                            break;
+                    }
+                }
+                if (!this.options.disableCloseAction) {
+                    const actionBar = this._register(new ActionBar(this.toolbarContainer, {}));
+                    const action = this._register(new Action('dialog.close', nls.localize('dialogClose', "Close Dialog"), ThemeIcon.asClassName(Codicon.dialogClose), true, () => __awaiter(this, void 0, void 0, function* () {
+                        resolve({
+                            button: this.options.cancelId || 0,
+                            checkboxChecked: this.checkbox ? this.checkbox.checked : undefined
+                        });
+                    })));
+                    actionBar.push(action, { icon: true, label: false });
+                }
+                this.applyStyles();
+                this.element.setAttribute('aria-modal', 'true');
+                this.element.setAttribute('aria-labelledby', 'monaco-dialog-icon monaco-dialog-message-text');
+                this.element.setAttribute('aria-describedby', 'monaco-dialog-icon monaco-dialog-message-text monaco-dialog-message-detail monaco-dialog-message-body');
+                show(this.element);
+                // Focus first element (input or button)
+                if (this.inputs.length > 0) {
+                    this.inputs[0].focus();
+                    this.inputs[0].select();
+                }
+                else {
+                    buttonMap.forEach((value, index) => {
+                        if (value.index === 0) {
+                            buttonBar.buttons[index].focus();
+                        }
+                    });
+                }
+            });
+        });
+    }
+    applyStyles() {
+        const style = this.options.dialogStyles;
+        const fgColor = style.dialogForeground;
+        const bgColor = style.dialogBackground;
+        const shadowColor = style.dialogShadow ? `0 0px 8px ${style.dialogShadow}` : '';
+        const border = style.dialogBorder ? `1px solid ${style.dialogBorder}` : '';
+        const linkFgColor = style.textLinkForeground;
+        this.shadowElement.style.boxShadow = shadowColor;
+        this.element.style.color = fgColor !== null && fgColor !== void 0 ? fgColor : '';
+        this.element.style.backgroundColor = bgColor !== null && bgColor !== void 0 ? bgColor : '';
+        this.element.style.border = border;
+        // TODO fix
+        // if (fgColor && bgColor) {
+        // 	const messageDetailColor = fgColor.transparent(.9);
+        // 	this.messageDetailElement.style.mixBlendMode = messageDetailColor.makeOpaque(bgColor).toString();
+        // }
+        if (linkFgColor) {
+            for (const el of this.messageContainer.getElementsByTagName('a')) {
+                el.style.color = linkFgColor;
+            }
+        }
+        let color;
+        switch (this.options.type) {
+            case 'error':
+                color = style.errorIconForeground;
+                break;
+            case 'warning':
+                color = style.warningIconForeground;
+                break;
+            default:
+                color = style.infoIconForeground;
+                break;
+        }
+        if (color) {
+            this.iconElement.style.color = color;
+        }
+    }
+    dispose() {
+        super.dispose();
+        if (this.modalElement) {
+            this.modalElement.remove();
+            this.modalElement = undefined;
+        }
+        if (this.focusToReturn && isAncestor(this.focusToReturn, document.body)) {
+            this.focusToReturn.focus();
+            this.focusToReturn = undefined;
+        }
+    }
+    rearrangeButtons(buttons, cancelId) {
+        // Maps each button to its current label and old index
+        // so that when we move them around it's not a problem
+        const buttonMap = buttons.map((label, index) => ({ label, index }));
+        if (buttons.length < 2) {
+            return buttonMap; // only need to rearrange if there are 2+ buttons
+        }
+        if (isMacintosh || isLinux) {
+            // Linux: the GNOME HIG (https://developer.gnome.org/hig/patterns/feedback/dialogs.html?highlight=dialog)
+            // recommend the following:
+            // "Always ensure that the cancel button appears first, before the affirmative button. In left-to-right
+            //  locales, this is on the left. This button order ensures that users become aware of, and are reminded
+            //  of, the ability to cancel prior to encountering the affirmative button."
+            // macOS: the HIG (https://developer.apple.com/design/human-interface-guidelines/components/presentation/alerts)
+            // recommend the following:
+            // "Place buttons where people expect. In general, place the button people are most likely to choose on the trailing side in a
+            //  row of buttons or at the top in a stack of buttons. Always place the default button on the trailing side of a row or at the
+            //  top of a stack. Cancel buttons are typically on the leading side of a row or at the bottom of a stack."
+            if (typeof cancelId === 'number' && buttonMap[cancelId]) {
+                const cancelButton = buttonMap.splice(cancelId, 1)[0];
+                buttonMap.splice(1, 0, cancelButton);
+            }
+            buttonMap.reverse();
+        }
+        else if (isWindows) {
+            // Windows: the HIG (https://learn.microsoft.com/en-us/windows/win32/uxguide/win-dialog-box)
+            // recommend the following:
+            // "One of the following sets of concise commands: Yes/No, Yes/No/Cancel, [Do it]/Cancel,
+            //  [Do it]/[Don't do it], [Do it]/[Don't do it]/Cancel."
+            if (typeof cancelId === 'number' && buttonMap[cancelId]) {
+                const cancelButton = buttonMap.splice(cancelId, 1)[0];
+                buttonMap.push(cancelButton);
+            }
+        }
+        return buttonMap;
+    }
+}
diff -urN -x '*.map' a/vs/base/browser/ui/dropdown/dropdown.js b/vs/base/browser/ui/dropdown/dropdown.js
--- a/vs/base/browser/ui/dropdown/dropdown.js	2023-09-05 08:43:04.186807434 +0000
+++ b/vs/base/browser/ui/dropdown/dropdown.js	2023-09-05 08:45:14.293196291 +0000
@@ -61,6 +61,14 @@
     get element() {
         return this._element;
     }
+    get label() {
+        return this._label;
+    }
+    set tooltip(tooltip) {
+        if (this._label) {
+            this._label.title = tooltip;
+        }
+    }
     show() {
         if (!this.visible) {
             this.visible = true;
@@ -73,6 +81,12 @@
             this._onDidChangeVisibility.fire(false);
         }
     }
+    isVisible() {
+        return !!this.visible;
+    }
+    onEvent(_e, activeElement) {
+        this.hide();
+    }
     dispose() {
         super.dispose();
         this.hide();
diff -urN -x '*.map' a/vs/base/browser/ui/dropdown/dropdownActionViewItem.js b/vs/base/browser/ui/dropdown/dropdownActionViewItem.js
--- a/vs/base/browser/ui/dropdown/dropdownActionViewItem.js	2023-09-05 08:43:04.186807434 +0000
+++ b/vs/base/browser/ui/dropdown/dropdownActionViewItem.js	2023-09-05 08:45:14.289196233 +0000
@@ -1,6 +1,15 @@
-import { $, append } from '../../dom.js';
-import { BaseActionViewItem } from '../actionbar/actionViewItems.js';
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import * as nls from '../../../../nls.js';
+import { $, addDisposableListener, append, EventType, h } from '../../dom.js';
+import { StandardKeyboardEvent } from '../../keyboardEvent.js';
+import { ActionViewItem, BaseActionViewItem } from '../actionbar/actionViewItems.js';
 import { DropdownMenu } from './dropdown.js';
+import { Action } from '../../../common/actions.js';
+import { Codicon } from '../../../common/codicons.js';
+import { ThemeIcon } from '../../../common/themables.js';
 import { Emitter } from '../../../common/event.js';
 import './dropdown.css';
 export class DropdownMenuActionViewItem extends BaseActionViewItem {
@@ -101,3 +110,56 @@
         (_b = this.element) === null || _b === void 0 ? void 0 : _b.classList.toggle('disabled', disabled);
     }
 }
+export class ActionWithDropdownActionViewItem extends ActionViewItem {
+    constructor(context, action, options, contextMenuProvider) {
+        super(context, action, options);
+        this.contextMenuProvider = contextMenuProvider;
+    }
+    render(container) {
+        super.render(container);
+        if (this.element) {
+            this.element.classList.add('action-dropdown-item');
+            const menuActionsProvider = {
+                getActions: () => {
+                    const actionsProvider = this.options.menuActionsOrProvider;
+                    return Array.isArray(actionsProvider) ? actionsProvider : actionsProvider.getActions(); // TODO: microsoft/TypeScript#42768
+                }
+            };
+            const menuActionClassNames = this.options.menuActionClassNames || [];
+            const separator = h('div.action-dropdown-item-separator', [h('div', {})]).root;
+            separator.classList.toggle('prominent', menuActionClassNames.includes('prominent'));
+            append(this.element, separator);
+            this.dropdownMenuActionViewItem = new DropdownMenuActionViewItem(this._register(new Action('dropdownAction', nls.localize('moreActions', "More Actions..."))), menuActionsProvider, this.contextMenuProvider, { classNames: ['dropdown', ...ThemeIcon.asClassNameArray(Codicon.dropDownButton), ...menuActionClassNames] });
+            this.dropdownMenuActionViewItem.render(this.element);
+            this._register(addDisposableListener(this.element, EventType.KEY_DOWN, e => {
+                var _a, _b, _c;
+                const event = new StandardKeyboardEvent(e);
+                let handled = false;
+                if (((_a = this.dropdownMenuActionViewItem) === null || _a === void 0 ? void 0 : _a.isFocused()) && event.equals(15 /* KeyCode.LeftArrow */)) {
+                    handled = true;
+                    (_b = this.dropdownMenuActionViewItem) === null || _b === void 0 ? void 0 : _b.blur();
+                    this.focus();
+                }
+                else if (this.isFocused() && event.equals(17 /* KeyCode.RightArrow */)) {
+                    handled = true;
+                    this.blur();
+                    (_c = this.dropdownMenuActionViewItem) === null || _c === void 0 ? void 0 : _c.focus();
+                }
+                if (handled) {
+                    event.preventDefault();
+                    event.stopPropagation();
+                }
+            }));
+        }
+    }
+    blur() {
+        var _a;
+        super.blur();
+        (_a = this.dropdownMenuActionViewItem) === null || _a === void 0 ? void 0 : _a.blur();
+    }
+    setFocusable(focusable) {
+        var _a;
+        super.setFocusable(focusable);
+        (_a = this.dropdownMenuActionViewItem) === null || _a === void 0 ? void 0 : _a.setFocusable(focusable);
+    }
+}
diff -urN -x '*.map' a/vs/base/browser/ui/findinput/findInput.js b/vs/base/browser/ui/findinput/findInput.js
--- a/vs/base/browser/ui/findinput/findInput.js	2023-09-05 08:43:04.186807434 +0000
+++ b/vs/base/browser/ui/findinput/findInput.js	2023-09-05 08:45:14.289196233 +0000
@@ -25,7 +25,9 @@
         this._onMouseDown = this._register(new Emitter());
         this.onMouseDown = this._onMouseDown.event;
         this._onInput = this._register(new Emitter());
+        this.onInput = this._onInput.event;
         this._onKeyUp = this._register(new Emitter());
+        this.onKeyUp = this._onKeyUp.event;
         this._onCaseSensitiveKeyDown = this._register(new Emitter());
         this.onCaseSensitiveKeyDown = this._onCaseSensitiveKeyDown.event;
         this._onRegexKeyDown = this._register(new Emitter());
@@ -147,6 +149,9 @@
         this.oninput(this.inputBox.inputElement, (e) => this._onInput.fire());
         this.onmousedown(this.inputBox.inputElement, (e) => this._onMouseDown.fire(e));
     }
+    get isImeSessionInProgress() {
+        return this.imeSessionInProgress;
+    }
     get onDidChange() {
         return this.inputBox.onDidChange;
     }
@@ -221,6 +226,11 @@
                     + this.additionalToggles.reduce((r, t) => r + t.width(), 0);
         }
     }
+    clear() {
+        this.clearValidation();
+        this.setValue('');
+        this.focus();
+    }
     getValue() {
         return this.inputBox.value;
     }
@@ -229,6 +239,9 @@
             this.inputBox.value = value;
         }
     }
+    onSearchSubmit() {
+        this.inputBox.addToHistory();
+    }
     select() {
         this.inputBox.select();
     }
@@ -267,6 +280,10 @@
         var _a;
         (_a = this.caseSensitive) === null || _a === void 0 ? void 0 : _a.focus();
     }
+    focusOnRegex() {
+        var _a;
+        (_a = this.regex) === null || _a === void 0 ? void 0 : _a.focus();
+    }
     highlightFindOptions() {
         this.domNode.classList.remove('highlight-' + (this._lastHighlightFindOptions));
         this._lastHighlightFindOptions = 1 - this._lastHighlightFindOptions;
@@ -281,4 +298,8 @@
     clearMessage() {
         this.inputBox.hideMessage();
     }
+    clearValidation() {
+        this.inputBox.hideMessage();
+    }
 }
+FindInput.OPTION_CHANGE = 'optionChange';
diff -urN -x '*.map' a/vs/base/browser/ui/findinput/replaceInput.js b/vs/base/browser/ui/findinput/replaceInput.js
--- a/vs/base/browser/ui/findinput/replaceInput.js	2023-09-05 08:43:04.186807434 +0000
+++ b/vs/base/browser/ui/findinput/replaceInput.js	2023-09-05 08:45:14.289196233 +0000
@@ -36,10 +36,14 @@
         this._onKeyDown = this._register(new Emitter());
         this.onKeyDown = this._onKeyDown.event;
         this._onMouseDown = this._register(new Emitter());
+        this.onMouseDown = this._onMouseDown.event;
         this._onInput = this._register(new Emitter());
+        this.onInput = this._onInput.event;
         this._onKeyUp = this._register(new Emitter());
+        this.onKeyUp = this._onKeyUp.event;
         this._onPreserveCaseKeyDown = this._register(new Emitter());
         this.onPreserveCaseKeyDown = this._onPreserveCaseKeyDown.event;
+        this._lastHighlightFindOptions = 0;
         this.contextViewProvider = contextViewProvider;
         this.placeholder = options.placeholder || '';
         this.validation = options.validation;
@@ -131,6 +135,9 @@
         this.inputBox.disable();
         this.preserveCase.disable();
     }
+    setFocusInputOnOptionClick(value) {
+        this.fixFocusOnOptionClickEnabled = value;
+    }
     setEnabled(enabled) {
         if (enabled) {
             this.enable();
@@ -139,6 +146,24 @@
             this.disable();
         }
     }
+    clear() {
+        this.clearValidation();
+        this.setValue('');
+        this.focus();
+    }
+    getValue() {
+        return this.inputBox.value;
+    }
+    setValue(value) {
+        if (this.inputBox.value !== value) {
+            this.inputBox.value = value;
+        }
+    }
+    onSearchSubmit() {
+        this.inputBox.addToHistory();
+    }
+    applyStyles() {
+    }
     select() {
         this.inputBox.select();
     }
@@ -154,10 +179,27 @@
     focusOnPreserve() {
         this.preserveCase.focus();
     }
+    highlightFindOptions() {
+        this.domNode.classList.remove('highlight-' + (this._lastHighlightFindOptions));
+        this._lastHighlightFindOptions = 1 - this._lastHighlightFindOptions;
+        this.domNode.classList.add('highlight-' + (this._lastHighlightFindOptions));
+    }
     validate() {
         var _a;
         (_a = this.inputBox) === null || _a === void 0 ? void 0 : _a.validate();
     }
+    showMessage(message) {
+        var _a;
+        (_a = this.inputBox) === null || _a === void 0 ? void 0 : _a.showMessage(message);
+    }
+    clearMessage() {
+        var _a;
+        (_a = this.inputBox) === null || _a === void 0 ? void 0 : _a.hideMessage();
+    }
+    clearValidation() {
+        var _a;
+        (_a = this.inputBox) === null || _a === void 0 ? void 0 : _a.hideMessage();
+    }
     set width(newWidth) {
         this.inputBox.paddingRight = this.cachedOptionsWidth;
         this.domNode.style.width = newWidth + 'px';
@@ -166,3 +208,4 @@
         super.dispose();
     }
 }
+ReplaceInput.OPTION_CHANGE = 'optionChange';
diff -urN -x '*.map' a/vs/base/browser/ui/inputbox/inputBox.js b/vs/base/browser/ui/inputbox/inputBox.js
--- a/vs/base/browser/ui/inputbox/inputBox.js	2023-09-05 08:43:04.190807535 +0000
+++ b/vs/base/browser/ui/inputbox/inputBox.js	2023-09-05 08:45:14.285196176 +0000
@@ -125,6 +125,21 @@
         this.tooltip = tooltip;
         this.input.title = tooltip;
     }
+    setAriaLabel(label) {
+        this.ariaLabel = label;
+        if (label) {
+            this.input.setAttribute('aria-label', this.ariaLabel);
+        }
+        else {
+            this.input.removeAttribute('aria-label');
+        }
+    }
+    getAriaLabel() {
+        return this.ariaLabel;
+    }
+    get mirrorElement() {
+        return this.mirror;
+    }
     get inputElement() {
         return this.input;
     }
@@ -137,6 +152,12 @@
             this.onValueChange();
         }
     }
+    get step() {
+        return this.input.step;
+    }
+    set step(newValue) {
+        this.input.step = newValue;
+    }
     get height() {
         return typeof this.cachedHeight === 'number' ? this.cachedHeight : dom.getTotalHeight(this.element);
     }
@@ -169,6 +190,35 @@
         this.input.disabled = true;
         this._hideMessage();
     }
+    setEnabled(enabled) {
+        if (enabled) {
+            this.enable();
+        }
+        else {
+            this.disable();
+        }
+    }
+    get width() {
+        return dom.getTotalWidth(this.input);
+    }
+    set width(width) {
+        if (this.options.flexibleHeight && this.options.flexibleWidth) {
+            // textarea with horizontal scrolling
+            let horizontalPadding = 0;
+            if (this.mirror) {
+                const paddingLeft = parseFloat(this.mirror.style.paddingLeft || '') || 0;
+                const paddingRight = parseFloat(this.mirror.style.paddingRight || '') || 0;
+                horizontalPadding = paddingLeft + paddingRight;
+            }
+            this.input.style.width = (width - horizontalPadding) + 'px';
+        }
+        else {
+            this.input.style.width = width + 'px';
+        }
+        if (this.mirror) {
+            this.mirror.style.width = width + 'px';
+        }
+    }
     set paddingRight(paddingRight) {
         // Set width to avoid hint text overlapping buttons
         this.input.style.width = `calc(100% - ${paddingRight}px)`;
@@ -212,6 +262,9 @@
         this._hideMessage();
         this.applyStyles();
     }
+    isInputValid() {
+        return !!this.validation && !this.validation(this.value);
+    }
     validate() {
         let errorMsg = null;
         if (this.validation) {
@@ -439,6 +492,22 @@
             this.history.add(this.value);
         }
     }
+    prependHistory(restoredHistory) {
+        const newHistory = this.getHistory();
+        this.clearHistory();
+        restoredHistory.forEach((item) => {
+            this.history.add(item);
+        });
+        newHistory.forEach(item => {
+            this.history.add(item);
+        });
+    }
+    getHistory() {
+        return this.history.getHistory();
+    }
+    isAtFirstInHistory() {
+        return this.history.isFirst();
+    }
     isAtLastInHistory() {
         return this.history.isLast();
     }
@@ -469,6 +538,9 @@
             aria.status(this.value);
         }
     }
+    clearHistory() {
+        this.history.clear();
+    }
     onBlur() {
         super.onBlur();
         this._onDidBlur.fire();
diff -urN -x '*.map' a/vs/base/browser/ui/list/list.js b/vs/base/browser/ui/list/list.js
--- a/vs/base/browser/ui/list/list.js	2023-09-05 08:43:04.190807535 +0000
+++ b/vs/base/browser/ui/list/list.js	2023-09-05 08:45:14.285196176 +0000
@@ -2,8 +2,26 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
+export const ListDragOverReactions = {
+    reject() { return { accept: false }; },
+    accept() { return { accept: true }; },
+};
 export class ListError extends Error {
     constructor(user, message) {
         super(`ListError [${user}] ${message}`);
     }
 }
+export class CachedListVirtualDelegate {
+    constructor() {
+        this.cache = new WeakMap();
+    }
+    getHeight(element) {
+        var _a;
+        return (_a = this.cache.get(element)) !== null && _a !== void 0 ? _a : this.estimateHeight(element);
+    }
+    setDynamicHeight(element, height) {
+        if (height > 0) {
+            this.cache.set(element, height);
+        }
+    }
+}
diff -urN -x '*.map' a/vs/base/browser/ui/list/listPaging.js b/vs/base/browser/ui/list/listPaging.js
--- a/vs/base/browser/ui/list/listPaging.js	2023-09-05 08:43:04.190807535 +0000
+++ b/vs/base/browser/ui/list/listPaging.js	2023-09-05 08:45:14.285196176 +0000
@@ -76,24 +76,45 @@
     getHTMLElement() {
         return this.list.getHTMLElement();
     }
+    isDOMFocused() {
+        return this.list.getHTMLElement() === document.activeElement;
+    }
+    domFocus() {
+        this.list.domFocus();
+    }
     get onDidFocus() {
         return this.list.onDidFocus;
     }
+    get onDidBlur() {
+        return this.list.onDidBlur;
+    }
     get widget() {
         return this.list;
     }
     get onDidDispose() {
         return this.list.onDidDispose;
     }
+    get onMouseClick() {
+        return Event.map(this.list.onMouseClick, ({ element, index, browserEvent }) => ({ element: element === undefined ? undefined : this._model.get(element), index, browserEvent }));
+    }
     get onMouseDblClick() {
         return Event.map(this.list.onMouseDblClick, ({ element, index, browserEvent }) => ({ element: element === undefined ? undefined : this._model.get(element), index, browserEvent }));
     }
+    get onTap() {
+        return Event.map(this.list.onTap, ({ element, index, browserEvent }) => ({ element: element === undefined ? undefined : this._model.get(element), index, browserEvent }));
+    }
     get onPointer() {
         return Event.map(this.list.onPointer, ({ element, index, browserEvent }) => ({ element: element === undefined ? undefined : this._model.get(element), index, browserEvent }));
     }
+    get onDidChangeFocus() {
+        return Event.map(this.list.onDidChangeFocus, ({ elements, indexes, browserEvent }) => ({ elements: elements.map(e => this._model.get(e)), indexes, browserEvent }));
+    }
     get onDidChangeSelection() {
         return Event.map(this.list.onDidChangeSelection, ({ elements, indexes, browserEvent }) => ({ elements: elements.map(e => this._model.get(e)), indexes, browserEvent }));
     }
+    get onContextMenu() {
+        return Event.map(this.list.onContextMenu, ({ element, index, anchor, browserEvent }) => (typeof element === 'undefined' ? { element, index, anchor, browserEvent } : { element: this._model.get(element), index, anchor, browserEvent }));
+    }
     get model() {
         return this._model;
     }
@@ -101,15 +122,69 @@
         this._model = model;
         this.list.splice(0, this.list.length, range(model.length));
     }
+    get length() {
+        return this.list.length;
+    }
+    get scrollTop() {
+        return this.list.scrollTop;
+    }
+    set scrollTop(scrollTop) {
+        this.list.scrollTop = scrollTop;
+    }
+    get scrollLeft() {
+        return this.list.scrollLeft;
+    }
+    set scrollLeft(scrollLeft) {
+        this.list.scrollLeft = scrollLeft;
+    }
+    setAnchor(index) {
+        this.list.setAnchor(index);
+    }
+    getAnchor() {
+        return this.list.getAnchor();
+    }
+    setFocus(indexes) {
+        this.list.setFocus(indexes);
+    }
+    focusNext(n, loop) {
+        this.list.focusNext(n, loop);
+    }
+    focusPrevious(n, loop) {
+        this.list.focusPrevious(n, loop);
+    }
+    focusNextPage() {
+        return this.list.focusNextPage();
+    }
+    focusPreviousPage() {
+        return this.list.focusPreviousPage();
+    }
+    focusLast() {
+        this.list.focusLast();
+    }
+    focusFirst() {
+        this.list.focusFirst();
+    }
     getFocus() {
         return this.list.getFocus();
     }
+    setSelection(indexes, browserEvent) {
+        this.list.setSelection(indexes, browserEvent);
+    }
     getSelection() {
         return this.list.getSelection();
     }
     getSelectedElements() {
         return this.getSelection().map(i => this.model.get(i));
     }
+    layout(height, width) {
+        this.list.layout(height, width);
+    }
+    triggerTypeNavigation() {
+        this.list.triggerTypeNavigation();
+    }
+    reveal(index, relativeTop) {
+        this.list.reveal(index, relativeTop);
+    }
     style(styles) {
         this.list.style(styles);
     }
diff -urN -x '*.map' a/vs/base/browser/ui/list/listView.js b/vs/base/browser/ui/list/listView.js
--- a/vs/base/browser/ui/list/listView.js	2023-09-05 08:43:04.190807535 +0000
+++ b/vs/base/browser/ui/list/listView.js	2023-09-05 08:45:14.285196176 +0000
@@ -44,6 +44,12 @@
     alwaysConsumeMouseWheel: true,
 };
 export class ElementsDragAndDropData {
+    get context() {
+        return this._context;
+    }
+    set context(value) {
+        this._context = value;
+    }
     constructor(elements) {
         this.elements = elements;
     }
@@ -133,7 +139,11 @@
  */
 export class ListView {
     get contentHeight() { return this.rangeMap.size; }
+    get contentWidth() { var _a; return (_a = this.scrollWidth) !== null && _a !== void 0 ? _a : 0; }
     get onDidScroll() { return this.scrollableElement.onScroll; }
+    get onWillScroll() { return this.scrollableElement.onWillScroll; }
+    get containerDomNode() { return this.rowsContainer; }
+    get scrollableElementDomNode() { return this.scrollableElement.getDomNode(); }
     get horizontalScrolling() { return this._horizontalScrolling; }
     set horizontalScrolling(value) {
         if (value === this._horizontalScrolling) {
@@ -176,6 +186,8 @@
         this.disposables = new DisposableStore();
         this._onDidChangeContentHeight = new Emitter();
         this._onDidChangeContentWidth = new Emitter();
+        this.onDidChangeContentHeight = Event.latch(this._onDidChangeContentHeight.event, undefined, this.disposables);
+        this.onDidChangeContentWidth = Event.latch(this._onDidChangeContentWidth.event, undefined, this.disposables);
         this._horizontalScrolling = false;
         if (options.horizontalScrolling && options.supportDynamicHeights) {
             throw new Error('Horizontal scrolling and dynamic heights not supported simultaneously');
@@ -275,6 +287,53 @@
             }
         }
     }
+    delegateScrollFromMouseWheelEvent(browserEvent) {
+        this.scrollableElement.delegateScrollFromMouseWheelEvent(browserEvent);
+    }
+    delegateVerticalScrollbarPointerDown(browserEvent) {
+        this.scrollableElement.delegateVerticalScrollbarPointerDown(browserEvent);
+    }
+    updateElementHeight(index, size, anchorIndex) {
+        if (index < 0 || index >= this.items.length) {
+            return;
+        }
+        const originalSize = this.items[index].size;
+        if (typeof size === 'undefined') {
+            if (!this.supportDynamicHeights) {
+                console.warn('Dynamic heights not supported');
+                return;
+            }
+            this.items[index].lastDynamicHeightWidth = undefined;
+            size = originalSize + this.probeDynamicHeight(index);
+        }
+        if (originalSize === size) {
+            return;
+        }
+        const lastRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
+        let heightDiff = 0;
+        if (index < lastRenderRange.start) {
+            // do not scroll the viewport if resized element is out of viewport
+            heightDiff = size - originalSize;
+        }
+        else {
+            if (anchorIndex !== null && anchorIndex > index && anchorIndex <= lastRenderRange.end) {
+                // anchor in viewport
+                // resized element in viewport and above the anchor
+                heightDiff = size - originalSize;
+            }
+            else {
+                heightDiff = 0;
+            }
+        }
+        this.rangeMap.splice(index, 1, [{ size: size }]);
+        this.items[index].size = size;
+        this.render(lastRenderRange, Math.max(0, this.lastRenderTop + heightDiff), this.lastRenderHeight, undefined, undefined, true);
+        this.setScrollTop(this.lastRenderTop);
+        this.eventuallyUpdateScrollDimensions();
+        if (this.supportDynamicHeights) {
+            this._rerender(this.lastRenderTop, this.lastRenderHeight);
+        }
+    }
     splice(start, deleteCount, elements = []) {
         if (this.splicing) {
             throw new Error('Can\'t run recursive splices.');
@@ -409,6 +468,18 @@
         this.scrollableElement.setScrollDimensions({ scrollWidth: scrollWidth === 0 ? 0 : (scrollWidth + 10) });
         this._onDidChangeContentWidth.fire(this.scrollWidth);
     }
+    updateWidth(index) {
+        if (!this.horizontalScrolling || typeof this.scrollWidth === 'undefined') {
+            return;
+        }
+        const item = this.items[index];
+        this.measureItemWidth(item);
+        if (typeof item.width !== 'undefined' && item.width > this.scrollWidth) {
+            this.scrollWidth = item.width;
+            this.scrollableElement.setScrollDimensions({ scrollWidth: this.scrollWidth + 10 });
+            this._onDidChangeContentWidth.fire(this.scrollWidth);
+        }
+    }
     rerender() {
         if (!this.supportDynamicHeights) {
             return;
@@ -437,9 +508,16 @@
         }
         return range.start;
     }
+    get lastVisibleIndex() {
+        const range = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
+        return range.end - 1;
+    }
     element(index) {
         return this.items[index].element;
     }
+    indexOf(element) {
+        return this.items.findIndex(item => item.element === element);
+    }
     domElement(index) {
         const row = this.items[index].row;
         return row && row.domNode;
@@ -621,6 +699,18 @@
         }
         this.scrollableElement.setScrollPosition({ scrollTop, reuseAnimation });
     }
+    getScrollLeft() {
+        const scrollPosition = this.scrollableElement.getScrollPosition();
+        return scrollPosition.scrollLeft;
+    }
+    setScrollLeft(scrollLeft) {
+        if (this.scrollableElementUpdateDisposable) {
+            this.scrollableElementUpdateDisposable.dispose();
+            this.scrollableElementUpdateDisposable = null;
+            this.scrollableElement.setScrollDimensions({ scrollWidth: this.scrollWidth });
+        }
+        this.scrollableElement.setScrollPosition({ scrollLeft });
+    }
     get scrollTop() {
         return this.getScrollTop();
     }
@@ -634,8 +724,10 @@
     get onMouseClick() { return Event.map(this.disposables.add(new DomEmitter(this.domNode, 'click')).event, e => this.toMouseEvent(e), this.disposables); }
     get onMouseDblClick() { return Event.map(this.disposables.add(new DomEmitter(this.domNode, 'dblclick')).event, e => this.toMouseEvent(e), this.disposables); }
     get onMouseMiddleClick() { return Event.filter(Event.map(this.disposables.add(new DomEmitter(this.domNode, 'auxclick')).event, e => this.toMouseEvent(e), this.disposables), e => e.browserEvent.button === 1, this.disposables); }
+    get onMouseUp() { return Event.map(this.disposables.add(new DomEmitter(this.domNode, 'mouseup')).event, e => this.toMouseEvent(e), this.disposables); }
     get onMouseDown() { return Event.map(this.disposables.add(new DomEmitter(this.domNode, 'mousedown')).event, e => this.toMouseEvent(e), this.disposables); }
     get onMouseOver() { return Event.map(this.disposables.add(new DomEmitter(this.domNode, 'mouseover')).event, e => this.toMouseEvent(e), this.disposables); }
+    get onMouseMove() { return Event.map(this.disposables.add(new DomEmitter(this.domNode, 'mousemove')).event, e => this.toMouseEvent(e), this.disposables); }
     get onMouseOut() { return Event.map(this.disposables.add(new DomEmitter(this.domNode, 'mouseout')).event, e => this.toMouseEvent(e), this.disposables); }
     get onContextMenu() { return Event.any(Event.map(this.disposables.add(new DomEmitter(this.domNode, 'contextmenu')).event, e => this.toMouseEvent(e), this.disposables), Event.map(this.disposables.add(new DomEmitter(this.domNode, TouchEventType.Contextmenu)).event, e => this.toGestureEvent(e), this.disposables)); }
     get onTouchStart() { return Event.map(this.disposables.add(new DomEmitter(this.domNode, 'touchstart')).event, e => this.toTouchEvent(e), this.disposables); }
@@ -1054,12 +1146,18 @@
 ], ListView.prototype, "onMouseMiddleClick", null);
 __decorate([
     memoize
+], ListView.prototype, "onMouseUp", null);
+__decorate([
+    memoize
 ], ListView.prototype, "onMouseDown", null);
 __decorate([
     memoize
 ], ListView.prototype, "onMouseOver", null);
 __decorate([
     memoize
+], ListView.prototype, "onMouseMove", null);
+__decorate([
+    memoize
 ], ListView.prototype, "onMouseOut", null);
 __decorate([
     memoize
diff -urN -x '*.map' a/vs/base/browser/ui/list/listWidget.js b/vs/base/browser/ui/list/listWidget.js
--- a/vs/base/browser/ui/list/listWidget.js	2023-09-05 08:43:04.190807535 +0000
+++ b/vs/base/browser/ui/list/listWidget.js	2023-09-05 08:45:14.285196176 +0000
@@ -379,6 +379,9 @@
         }
         this.mode = (_b = options.typeNavigationMode) !== null && _b !== void 0 ? _b : TypeNavigationMode.Automatic;
     }
+    trigger() {
+        this.triggered = !this.triggered;
+    }
     enable() {
         if (this.enabled) {
             return;
@@ -1009,8 +1012,10 @@
     get onMouseDblClick() { return this.view.onMouseDblClick; }
     get onMouseMiddleClick() { return this.view.onMouseMiddleClick; }
     get onPointer() { return this.mouseController.onPointer; }
+    get onMouseUp() { return this.view.onMouseUp; }
     get onMouseDown() { return this.view.onMouseDown; }
     get onMouseOver() { return this.view.onMouseOver; }
+    get onMouseMove() { return this.view.onMouseMove; }
     get onMouseOut() { return this.view.onMouseOut; }
     get onTouchStart() { return this.view.onTouchStart; }
     get onTap() { return this.view.onTap; }
@@ -1049,7 +1054,10 @@
         return Event.any(fromKeyDown, fromKeyUp, fromMouse);
     }
     get onKeyDown() { return this.disposables.add(new DomEmitter(this.view.domNode, 'keydown')).event; }
+    get onKeyUp() { return this.disposables.add(new DomEmitter(this.view.domNode, 'keyup')).event; }
+    get onKeyPress() { return this.disposables.add(new DomEmitter(this.view.domNode, 'keypress')).event; }
     get onDidFocus() { return Event.signal(this.disposables.add(new DomEmitter(this.view.domNode, 'focus', true)).event); }
+    get onDidBlur() { return Event.signal(this.disposables.add(new DomEmitter(this.view.domNode, 'blur', true)).event); }
     constructor(user, container, virtualDelegate, renderers, _options = DefaultOptions) {
         var _a, _b, _c, _d;
         this.user = user;
@@ -1149,24 +1157,48 @@
         }
         this.eventBufferer.bufferEvents(() => this.spliceable.splice(start, deleteCount, elements));
     }
+    updateWidth(index) {
+        this.view.updateWidth(index);
+    }
+    updateElementHeight(index, size) {
+        this.view.updateElementHeight(index, size, null);
+    }
     rerender() {
         this.view.rerender();
     }
     element(index) {
         return this.view.element(index);
     }
+    indexOf(element) {
+        return this.view.indexOf(element);
+    }
     get length() {
         return this.view.length;
     }
     get contentHeight() {
         return this.view.contentHeight;
     }
+    get contentWidth() {
+        return this.view.contentWidth;
+    }
+    get onDidChangeContentHeight() {
+        return this.view.onDidChangeContentHeight;
+    }
+    get onDidChangeContentWidth() {
+        return this.view.onDidChangeContentWidth;
+    }
     get scrollTop() {
         return this.view.getScrollTop();
     }
     set scrollTop(scrollTop) {
         this.view.setScrollTop(scrollTop);
     }
+    get scrollLeft() {
+        return this.view.getScrollLeft();
+    }
+    set scrollLeft(scrollLeft) {
+        this.view.setScrollLeft(scrollLeft);
+    }
     get scrollHeight() {
         return this.view.scrollHeight;
     }
@@ -1176,6 +1208,9 @@
     get firstVisibleIndex() {
         return this.view.firstVisibleIndex;
     }
+    get lastVisibleIndex() {
+        return this.view.lastVisibleIndex;
+    }
     get ariaLabel() {
         return this._ariaLabel;
     }
@@ -1189,6 +1224,10 @@
     layout(height, width) {
         this.view.layout(height, width);
     }
+    triggerTypeNavigation() {
+        var _a;
+        (_a = this.typeNavigationController) === null || _a === void 0 ? void 0 : _a.trigger();
+    }
     setSelection(indexes, browserEvent) {
         for (const index of indexes) {
             if (index < 0 || index >= this.length) {
@@ -1390,6 +1429,27 @@
             }
         }
     }
+    /**
+     * Returns the relative position of an element rendered in the list.
+     * Returns `null` if the element isn't *entirely* in the visible viewport.
+     */
+    getRelativeTop(index) {
+        if (index < 0 || index >= this.length) {
+            throw new ListError(this.user, `Invalid index ${index}`);
+        }
+        const scrollTop = this.view.getScrollTop();
+        const elementTop = this.view.elementTop(index);
+        const elementHeight = this.view.elementHeight(index);
+        if (elementTop < scrollTop || elementTop + elementHeight > scrollTop + this.view.renderHeight) {
+            return null;
+        }
+        // y = mx + b
+        const m = elementHeight - this.view.renderHeight;
+        return Math.abs((scrollTop - elementTop) / m);
+    }
+    isDOMFocused() {
+        return this.view.domNode === document.activeElement;
+    }
     getHTMLElement() {
         return this.view.domNode;
     }
@@ -1447,4 +1507,13 @@
 ], List.prototype, "onKeyDown", null);
 __decorate([
     memoize
+], List.prototype, "onKeyUp", null);
+__decorate([
+    memoize
+], List.prototype, "onKeyPress", null);
+__decorate([
+    memoize
 ], List.prototype, "onDidFocus", null);
+__decorate([
+    memoize
+], List.prototype, "onDidBlur", null);
diff -urN -x '*.map' a/vs/base/browser/ui/menu/menu.js b/vs/base/browser/ui/menu/menu.js
--- a/vs/base/browser/ui/menu/menu.js	2023-09-05 08:43:04.206807940 +0000
+++ b/vs/base/browser/ui/menu/menu.js	2023-09-05 08:45:14.293196291 +0000
@@ -26,6 +26,20 @@
     Direction[Direction["Right"] = 0] = "Right";
     Direction[Direction["Left"] = 1] = "Left";
 })(Direction || (Direction = {}));
+export const unthemedMenuStyles = {
+    shadowColor: undefined,
+    borderColor: undefined,
+    foregroundColor: undefined,
+    backgroundColor: undefined,
+    selectionForegroundColor: undefined,
+    selectionBackgroundColor: undefined,
+    selectionBorderColor: undefined,
+    separatorColor: undefined,
+    scrollbarShadow: undefined,
+    scrollbarSliderBackground: undefined,
+    scrollbarSliderHoverBackground: undefined,
+    scrollbarSliderActiveBackground: undefined
+};
 export class Menu extends ActionBar {
     constructor(container, actions, options, menuStyles) {
         container.classList.add('monaco-menu-container');
@@ -212,6 +226,24 @@
     get onScroll() {
         return this.scrollableElement.onScroll;
     }
+    get scrollOffset() {
+        return this.menuElement.scrollTop;
+    }
+    trigger(index) {
+        if (index <= this.viewItems.length && index >= 0) {
+            const item = this.viewItems[index];
+            if (item instanceof SubmenuMenuActionViewItem) {
+                super.focus(index);
+                item.open(true);
+            }
+            else if (item instanceof BaseMenuActionViewItem) {
+                super.run(item._action, item._context);
+            }
+            else {
+                return;
+            }
+        }
+    }
     focusItemByElement(element) {
         const lastFocusedItem = this.focusedItem;
         this.setFocusedItem(element);
@@ -586,6 +618,10 @@
         // native menus do not observe enablement on sumbenus
         // we mimic that behavior
     }
+    open(selectFirst) {
+        this.cleanupExistingSubmenu(false);
+        this.createSubmenu(selectFirst);
+    }
     onClick(e) {
         // stop clicking from trying to run an action
         EventHelper.stop(e, true);
diff -urN -x '*.map' a/vs/base/browser/ui/progressbar/progressbar.js b/vs/base/browser/ui/progressbar/progressbar.js
--- a/vs/base/browser/ui/progressbar/progressbar.js	2023-09-05 08:43:04.194807636 +0000
+++ b/vs/base/browser/ui/progressbar/progressbar.js	2023-09-05 08:45:14.289196233 +0000
@@ -2,15 +2,19 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-import { show } from '../../dom.js';
+import { hide, show } from '../../dom.js';
 import { RunOnceScheduler } from '../../../common/async.js';
 import { Disposable } from '../../../common/lifecycle.js';
+import { isNumber } from '../../../common/types.js';
 import './progressbar.css';
 const CSS_DONE = 'done';
 const CSS_ACTIVE = 'active';
 const CSS_INFINITE = 'infinite';
 const CSS_INFINITE_LONG_RUNNING = 'infinite-long-running';
 const CSS_DISCRETE = 'discrete';
+export const unthemedProgressBarOptions = {
+    progressBarBackground: undefined
+};
 /**
  * A progress bar with support for infinite or discrete progress.
  */
@@ -42,6 +46,12 @@
         this.longRunningScheduler.cancel();
     }
     /**
+     * Indicates to the progress bar that all work is done.
+     */
+    done() {
+        return this.doDone(true);
+    }
+    /**
      * Stops the progressbar from showing any progress instantly without fading out.
      */
     stop() {
@@ -85,9 +95,62 @@
     infiniteLongRunning() {
         this.element.classList.add(CSS_INFINITE_LONG_RUNNING);
     }
+    /**
+     * Tells the progress bar the total number of work. Use in combination with workedVal() to let
+     * the progress bar show the actual progress based on the work that is done.
+     */
+    total(value) {
+        this.workedVal = 0;
+        this.totalWork = value;
+        this.element.setAttribute('aria-valuemax', value.toString());
+        return this;
+    }
+    /**
+     * Finds out if this progress bar is configured with total work
+     */
+    hasTotal() {
+        return isNumber(this.totalWork);
+    }
+    /**
+     * Tells the progress bar that an increment of work has been completed.
+     */
+    worked(value) {
+        value = Math.max(1, Number(value));
+        return this.doSetWorked(this.workedVal + value);
+    }
+    /**
+     * Tells the progress bar the total amount of work that has been completed.
+     */
+    setWorked(value) {
+        value = Math.max(1, Number(value));
+        return this.doSetWorked(value);
+    }
+    doSetWorked(value) {
+        const totalWork = this.totalWork || 100;
+        this.workedVal = value;
+        this.workedVal = Math.min(totalWork, this.workedVal);
+        this.element.classList.remove(CSS_INFINITE, CSS_INFINITE_LONG_RUNNING, CSS_DONE);
+        this.element.classList.add(CSS_ACTIVE, CSS_DISCRETE);
+        this.element.setAttribute('aria-valuenow', value.toString());
+        this.bit.style.width = 100 * (this.workedVal / (totalWork)) + '%';
+        return this;
+    }
     getContainer() {
         return this.element;
     }
+    show(delay) {
+        this.showDelayedScheduler.cancel();
+        if (typeof delay === 'number') {
+            this.showDelayedScheduler.schedule(delay);
+        }
+        else {
+            show(this.element);
+        }
+    }
+    hide() {
+        hide(this.element);
+        this.showDelayedScheduler.cancel();
+    }
 }
 /**
  * After a certain time of showing the progress bar, switch
diff -urN -x '*.map' a/vs/base/browser/ui/sash/sash.js b/vs/base/browser/ui/sash/sash.js
--- a/vs/base/browser/ui/sash/sash.js	2023-09-05 08:43:04.194807636 +0000
+++ b/vs/base/browser/ui/sash/sash.js	2023-09-05 08:45:14.293196291 +0000
@@ -31,8 +31,16 @@
 })(OrthogonalEdge || (OrthogonalEdge = {}));
 let globalSize = 4;
 const onDidChangeGlobalSize = new Emitter();
+export function setGlobalSashSize(size) {
+    globalSize = size;
+    onDidChangeGlobalSize.fire(size);
+}
 let globalHoverDelay = 300;
 const onDidChangeHoverDelay = new Emitter();
+export function setGlobalHoverDelay(size) {
+    globalHoverDelay = size;
+    onDidChangeHoverDelay.fire(size);
+}
 class MouseEventFactory {
     constructor() {
         this.disposables = new DisposableStore();
diff -urN -x '*.map' a/vs/base/browser/ui/scrollbar/scrollableElement.js b/vs/base/browser/ui/scrollbar/scrollableElement.js
--- a/vs/base/browser/ui/scrollbar/scrollableElement.js	2023-09-05 08:43:04.194807636 +0000
+++ b/vs/base/browser/ui/scrollbar/scrollableElement.js	2023-09-05 08:45:14.289196233 +0000
@@ -127,6 +127,7 @@
         this._onScroll = this._register(new Emitter());
         this.onScroll = this._onScroll.event;
         this._onWillScroll = this._register(new Emitter());
+        this.onWillScroll = this._onWillScroll.event;
         element.style.overflow = 'hidden';
         this._options = resolveOptions(options);
         this._scrollable = scrollable;
@@ -255,6 +256,9 @@
             this._render();
         }
     }
+    setRevealOnScroll(value) {
+        this._revealOnScroll = value;
+    }
     delegateScrollFromMouseWheelEvent(browserEvent) {
         this._onMouseWheel(new StandardWheelEvent(browserEvent));
     }
@@ -444,6 +448,9 @@
     setScrollPosition(update) {
         this._scrollable.setScrollPositionNow(update);
     }
+    getScrollPosition() {
+        return this._scrollable.getCurrentScrollPosition();
+    }
 }
 export class SmoothScrollableElement extends AbstractScrollableElement {
     constructor(element, options, scrollable) {
diff -urN -x '*.map' a/vs/base/browser/ui/selectBox/selectBox.js b/vs/base/browser/ui/selectBox/selectBox.js
--- a/vs/base/browser/ui/selectBox/selectBox.js	2023-09-05 08:43:04.198807738 +0000
+++ b/vs/base/browser/ui/selectBox/selectBox.js	2023-09-05 08:45:14.289196233 +0000
@@ -2,11 +2,13 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
+import { unthemedListStyles } from '../list/listWidget.js';
 import { SelectBoxList } from './selectBoxCustom.js';
 import { SelectBoxNative } from './selectBoxNative.js';
 import { Widget } from '../widget.js';
 import { isMacintosh } from '../../../common/platform.js';
 import './selectBox.css';
+export const unthemedSelectBoxStyles = Object.assign(Object.assign({}, unthemedListStyles), { selectBackground: '#3C3C3C', selectForeground: '#F0F0F0', selectBorder: '#3C3C3C', decoratorRightForeground: undefined, selectListBackground: undefined, selectListBorder: undefined, focusBorder: undefined });
 export class SelectBox extends Widget {
     constructor(options, selected, contextViewProvider, styles, selectBoxOptions) {
         super();
@@ -29,6 +31,9 @@
     select(index) {
         this.selectBoxDelegate.select(index);
     }
+    setAriaLabel(label) {
+        this.selectBoxDelegate.setAriaLabel(label);
+    }
     focus() {
         this.selectBoxDelegate.focus();
     }
diff -urN -x '*.map' a/vs/base/browser/ui/selectBox/selectBoxCustom.js b/vs/base/browser/ui/selectBox/selectBoxCustom.js
--- a/vs/base/browser/ui/selectBox/selectBoxCustom.js	2023-09-05 08:43:04.198807738 +0000
+++ b/vs/base/browser/ui/selectBox/selectBoxCustom.js	2023-09-05 08:45:14.289196233 +0000
@@ -223,6 +223,10 @@
             this.selectElement.title = this.options[this.selected].text;
         }
     }
+    setAriaLabel(label) {
+        this.selectBoxOptions.ariaLabel = label;
+        this.selectElement.setAttribute('aria-label', this.selectBoxOptions.ariaLabel);
+    }
     focus() {
         if (this.selectElement) {
             this.selectElement.tabIndex = 0;
diff -urN -x '*.map' a/vs/base/browser/ui/selectBox/selectBoxNative.js b/vs/base/browser/ui/selectBox/selectBoxNative.js
--- a/vs/base/browser/ui/selectBox/selectBoxNative.js	2023-09-05 08:43:04.198807738 +0000
+++ b/vs/base/browser/ui/selectBox/selectBoxNative.js	2023-09-05 08:45:14.289196233 +0000
@@ -100,6 +100,10 @@
             this.selectElement.title = '';
         }
     }
+    setAriaLabel(label) {
+        this.selectBoxOptions.ariaLabel = label;
+        this.selectElement.setAttribute('aria-label', label);
+    }
     focus() {
         if (this.selectElement) {
             this.selectElement.tabIndex = 0;
@@ -121,6 +125,10 @@
         this.setOptions(this.options, this.selected);
         this.applyStyles();
     }
+    style(styles) {
+        this.styles = styles;
+        this.applyStyles();
+    }
     applyStyles() {
         var _a, _b, _c;
         // Style native select
diff -urN -x '*.map' a/vs/base/browser/ui/splitview/splitview.js b/vs/base/browser/ui/splitview/splitview.js
--- a/vs/base/browser/ui/splitview/splitview.js	2023-09-05 08:43:04.198807738 +0000
+++ b/vs/base/browser/ui/splitview/splitview.js	2023-09-05 08:45:14.285196176 +0000
@@ -24,6 +24,7 @@
     get size() {
         return this._size;
     }
+    get cachedVisibleSize() { return this._cachedVisibleSize; }
     get visible() {
         return typeof this._cachedVisibleSize === 'undefined';
     }
@@ -147,6 +148,24 @@
  * - Alt key modifier behavior, macOS style
  */
 export class SplitView extends Disposable {
+    /**
+     * The amount of views in this {@link SplitView}.
+     */
+    get length() {
+        return this.viewItems.length;
+    }
+    /**
+     * The minimum size of this {@link SplitView}.
+     */
+    get minimumSize() {
+        return this.viewItems.reduce((r, item) => r + item.minimumSize, 0);
+    }
+    /**
+     * The maximum size of this {@link SplitView}.
+     */
+    get maximumSize() {
+        return this.length === 0 ? Number.POSITIVE_INFINITY : this.viewItems.reduce((r, item) => r + item.maximumSize, 0);
+    }
     get orthogonalStartSash() { return this._orthogonalStartSash; }
     get orthogonalEndSash() { return this._orthogonalEndSash; }
     get startSnappingEnabled() { return this._startSnappingEnabled; }
@@ -174,6 +193,12 @@
         this._orthogonalEndSash = sash;
     }
     /**
+     * The internal sashes within this {@link SplitView}.
+     */
+    get sashes() {
+        return this.sashItems.map(s => s.sash);
+    }
+    /**
      * Enable/disable snapping at the beginning of this {@link SplitView}.
      */
     set startSnappingEnabled(startSnappingEnabled) {
@@ -292,6 +317,126 @@
         this.doAddView(view, size, index, skipLayout);
     }
     /**
+     * Remove a {@link IView view} from this {@link SplitView}.
+     *
+     * @param index The index where the {@link IView view} is located.
+     * @param sizing Whether to distribute other {@link IView view}'s sizes.
+     */
+    removeView(index, sizing) {
+        if (this.state !== State.Idle) {
+            throw new Error('Cant modify splitview');
+        }
+        this.state = State.Busy;
+        if (index < 0 || index >= this.viewItems.length) {
+            throw new Error('Index out of bounds');
+        }
+        if ((sizing === null || sizing === void 0 ? void 0 : sizing.type) === 'auto') {
+            if (this.areViewsDistributed()) {
+                sizing = { type: 'distribute' };
+            }
+            else {
+                sizing = { type: 'split', index: sizing.index };
+            }
+        }
+        // Save referene view, in case of `split` sizing
+        const referenceViewItem = (sizing === null || sizing === void 0 ? void 0 : sizing.type) === 'split' ? this.viewItems[sizing.index] : undefined;
+        // Remove view
+        const viewItemToRemove = this.viewItems.splice(index, 1)[0];
+        // Resize reference view, in case of `split` sizing
+        if (referenceViewItem) {
+            referenceViewItem.size += viewItemToRemove.size;
+        }
+        // Remove sash
+        if (this.viewItems.length >= 1) {
+            const sashIndex = Math.max(index - 1, 0);
+            const sashItem = this.sashItems.splice(sashIndex, 1)[0];
+            sashItem.disposable.dispose();
+        }
+        this.relayout();
+        this.state = State.Idle;
+        if ((sizing === null || sizing === void 0 ? void 0 : sizing.type) === 'distribute') {
+            this.distributeViewSizes();
+        }
+        const result = viewItemToRemove.view;
+        viewItemToRemove.dispose();
+        return result;
+    }
+    /**
+     * Move a {@link IView view} to a different index.
+     *
+     * @param from The source index.
+     * @param to The target index.
+     */
+    moveView(from, to) {
+        if (this.state !== State.Idle) {
+            throw new Error('Cant modify splitview');
+        }
+        const cachedVisibleSize = this.getViewCachedVisibleSize(from);
+        const sizing = typeof cachedVisibleSize === 'undefined' ? this.getViewSize(from) : Sizing.Invisible(cachedVisibleSize);
+        const view = this.removeView(from);
+        this.addView(view, sizing, to);
+    }
+    /**
+     * Swap two {@link IView views}.
+     *
+     * @param from The source index.
+     * @param to The target index.
+     */
+    swapViews(from, to) {
+        if (this.state !== State.Idle) {
+            throw new Error('Cant modify splitview');
+        }
+        if (from > to) {
+            return this.swapViews(to, from);
+        }
+        const fromSize = this.getViewSize(from);
+        const toSize = this.getViewSize(to);
+        const toView = this.removeView(to);
+        const fromView = this.removeView(from);
+        this.addView(toView, fromSize, from);
+        this.addView(fromView, toSize, to);
+    }
+    /**
+     * Returns whether the {@link IView view} is visible.
+     *
+     * @param index The {@link IView view} index.
+     */
+    isViewVisible(index) {
+        if (index < 0 || index >= this.viewItems.length) {
+            throw new Error('Index out of bounds');
+        }
+        const viewItem = this.viewItems[index];
+        return viewItem.visible;
+    }
+    /**
+     * Set a {@link IView view}'s visibility.
+     *
+     * @param index The {@link IView view} index.
+     * @param visible Whether the {@link IView view} should be visible.
+     */
+    setViewVisible(index, visible) {
+        if (index < 0 || index >= this.viewItems.length) {
+            throw new Error('Index out of bounds');
+        }
+        const viewItem = this.viewItems[index];
+        viewItem.setVisible(visible);
+        this.distributeEmptySpace(index);
+        this.layoutViews();
+        this.saveProportions();
+    }
+    /**
+     * Returns the {@link IView view}'s size previously to being hidden.
+     *
+     * @param index The {@link IView view} index.
+     */
+    getViewCachedVisibleSize(index) {
+        if (index < 0 || index >= this.viewItems.length) {
+            throw new Error('Index out of bounds');
+        }
+        const viewItem = this.viewItems[index];
+        return viewItem.cachedVisibleSize;
+    }
+    /**
      * Layout the {@link SplitView}.
      *
      * @param size The entire size of the {@link SplitView}.
@@ -471,6 +616,20 @@
         this.state = State.Idle;
     }
     /**
+     * Returns whether all other {@link IView views} are at their minimum size.
+     */
+    isViewSizeMaximized(index) {
+        if (index < 0 || index >= this.viewItems.length) {
+            return false;
+        }
+        for (const item of this.viewItems) {
+            if (item !== this.viewItems[index] && item.size > item.minimumSize) {
+                return false;
+            }
+        }
+        return true;
+    }
+    /**
      * Distribute the entire {@link SplitView} size among all {@link IView views}.
      */
     distributeViewSizes() {
diff -urN -x '*.map' a/vs/base/browser/ui/table/table.js b/vs/base/browser/ui/table/table.js
--- a/vs/base/browser/ui/table/table.js	2023-09-05 08:43:04.198807738 +0000
+++ b/vs/base/browser/ui/table/table.js	2023-09-05 08:45:14.289196233 +0000
@@ -2,4 +2,8 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-export {};
+export class TableError extends Error {
+    constructor(user, message) {
+        super(`TableError [${user}] ${message}`);
+    }
+}
diff -urN -x '*.map' a/vs/base/browser/ui/table/tableWidget.js b/vs/base/browser/ui/table/tableWidget.js
--- a/vs/base/browser/ui/table/tableWidget.js	2023-09-05 08:43:04.198807738 +0000
+++ b/vs/base/browser/ui/table/tableWidget.js	2023-09-05 08:45:14.289196233 +0000
@@ -2,7 +2,7 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-import { $, append, clearNode, createStyleSheet } from '../../dom.js';
+import { $, append, clearNode, createStyleSheet, getContentHeight, getContentWidth } from '../../dom.js';
 import { List, unthemedListStyles } from '../list/listWidget.js';
 import { SplitView } from '../splitview/splitview.js';
 import { Emitter, Event } from '../../../common/event.js';
@@ -97,11 +97,24 @@
     get onDidChangeFocus() { return this.list.onDidChangeFocus; }
     get onDidChangeSelection() { return this.list.onDidChangeSelection; }
     get onDidScroll() { return this.list.onDidScroll; }
+    get onMouseClick() { return this.list.onMouseClick; }
     get onMouseDblClick() { return this.list.onMouseDblClick; }
+    get onMouseMiddleClick() { return this.list.onMouseMiddleClick; }
     get onPointer() { return this.list.onPointer; }
+    get onMouseUp() { return this.list.onMouseUp; }
+    get onMouseDown() { return this.list.onMouseDown; }
+    get onMouseOver() { return this.list.onMouseOver; }
+    get onMouseMove() { return this.list.onMouseMove; }
+    get onMouseOut() { return this.list.onMouseOut; }
+    get onTouchStart() { return this.list.onTouchStart; }
+    get onTap() { return this.list.onTap; }
+    get onContextMenu() { return this.list.onContextMenu; }
     get onDidFocus() { return this.list.onDidFocus; }
+    get onDidBlur() { return this.list.onDidBlur; }
     get scrollTop() { return this.list.scrollTop; }
     set scrollTop(scrollTop) { this.list.scrollTop = scrollTop; }
+    get scrollLeft() { return this.list.scrollLeft; }
+    set scrollLeft(scrollLeft) { this.list.scrollLeft = scrollLeft; }
     get scrollHeight() { return this.list.scrollHeight; }
     get renderHeight() { return this.list.renderHeight; }
     get onDidDispose() { return this.list.onDidDispose; }
@@ -142,9 +155,34 @@
     splice(start, deleteCount, elements = []) {
         this.list.splice(start, deleteCount, elements);
     }
+    rerender() {
+        this.list.rerender();
+    }
+    row(index) {
+        return this.list.element(index);
+    }
+    indexOf(element) {
+        return this.list.indexOf(element);
+    }
+    get length() {
+        return this.list.length;
+    }
     getHTMLElement() {
         return this.domNode;
     }
+    layout(height, width) {
+        height = height !== null && height !== void 0 ? height : getContentHeight(this.domNode);
+        width = width !== null && width !== void 0 ? width : getContentWidth(this.domNode);
+        this.cachedWidth = width;
+        this.cachedHeight = height;
+        this.splitview.layout(width);
+        const listHeight = height - this.virtualDelegate.headerRowHeight;
+        this.list.getHTMLElement().style.height = `${listHeight}px`;
+        this.list.layout(listHeight, width);
+    }
+    triggerTypeNavigation() {
+        this.list.triggerTypeNavigation();
+    }
     style(styles) {
         const content = [];
         content.push(`.monaco-table.${this.domId} > .monaco-split-view2 .monaco-sash.vertical::before {
@@ -154,15 +192,57 @@
         this.styleElement.textContent = content.join('\n');
         this.list.style(styles);
     }
+    domFocus() {
+        this.list.domFocus();
+    }
+    setAnchor(index) {
+        this.list.setAnchor(index);
+    }
+    getAnchor() {
+        return this.list.getAnchor();
+    }
     getSelectedElements() {
         return this.list.getSelectedElements();
     }
+    setSelection(indexes, browserEvent) {
+        this.list.setSelection(indexes, browserEvent);
+    }
     getSelection() {
         return this.list.getSelection();
     }
+    setFocus(indexes, browserEvent) {
+        this.list.setFocus(indexes, browserEvent);
+    }
+    focusNext(n = 1, loop = false, browserEvent) {
+        this.list.focusNext(n, loop, browserEvent);
+    }
+    focusPrevious(n = 1, loop = false, browserEvent) {
+        this.list.focusPrevious(n, loop, browserEvent);
+    }
+    focusNextPage(browserEvent) {
+        return this.list.focusNextPage(browserEvent);
+    }
+    focusPreviousPage(browserEvent) {
+        return this.list.focusPreviousPage(browserEvent);
+    }
+    focusFirst(browserEvent) {
+        this.list.focusFirst(browserEvent);
+    }
+    focusLast(browserEvent) {
+        this.list.focusLast(browserEvent);
+    }
     getFocus() {
         return this.list.getFocus();
     }
+    getFocusedElements() {
+        return this.list.getFocusedElements();
+    }
+    getRelativeTop(index) {
+        return this.list.getRelativeTop(index);
+    }
+    reveal(index, relativeTop) {
+        this.list.reveal(index, relativeTop);
+    }
     dispose() {
         this.disposables.dispose();
     }
diff -urN -x '*.map' a/vs/base/browser/ui/toggle/toggle.js b/vs/base/browser/ui/toggle/toggle.js
--- a/vs/base/browser/ui/toggle/toggle.js	2023-09-05 08:43:04.202807839 +0000
+++ b/vs/base/browser/ui/toggle/toggle.js	2023-09-05 08:45:14.289196233 +0000
@@ -2,7 +2,9 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
+import { BaseActionViewItem } from '../actionbar/actionViewItems.js';
 import { Widget } from '../widget.js';
+import { Codicon } from '../../../common/codicons.js';
 import { ThemeIcon } from '../../../common/themables.js';
 import { Emitter } from '../../../common/event.js';
 import './toggle.css';
@@ -11,6 +13,50 @@
     inputActiveOptionForeground: '#FFFFFF',
     inputActiveOptionBackground: '#0E639C50'
 };
+export class ToggleActionViewItem extends BaseActionViewItem {
+    constructor(context, action, options) {
+        var _a, _b, _c;
+        super(context, action, options);
+        this.toggle = this._register(new Toggle({
+            actionClassName: this._action.class,
+            isChecked: !!this._action.checked,
+            title: this.options.keybinding ? `${this._action.label} (${this.options.keybinding})` : this._action.label,
+            notFocusable: true,
+            inputActiveOptionBackground: (_a = options.toggleStyles) === null || _a === void 0 ? void 0 : _a.inputActiveOptionBackground,
+            inputActiveOptionBorder: (_b = options.toggleStyles) === null || _b === void 0 ? void 0 : _b.inputActiveOptionBorder,
+            inputActiveOptionForeground: (_c = options.toggleStyles) === null || _c === void 0 ? void 0 : _c.inputActiveOptionForeground,
+        }));
+        this._register(this.toggle.onChange(() => this._action.checked = !!this.toggle && this.toggle.checked));
+    }
+    render(container) {
+        this.element = container;
+        this.element.appendChild(this.toggle.domNode);
+    }
+    updateEnabled() {
+        if (this.toggle) {
+            if (this.isEnabled()) {
+                this.toggle.enable();
+            }
+            else {
+                this.toggle.disable();
+            }
+        }
+    }
+    updateChecked() {
+        this.toggle.checked = !!this._action.checked;
+    }
+    focus() {
+        this.toggle.domNode.tabIndex = 0;
+        this.toggle.focus();
+    }
+    blur() {
+        this.toggle.domNode.tabIndex = -1;
+        this.toggle.domNode.blur();
+    }
+    setFocusable(focusable) {
+        this.toggle.domNode.tabIndex = focusable ? 0 : -1;
+    }
+}
 export class Toggle extends Widget {
     constructor(opts) {
         super();
@@ -75,6 +121,15 @@
         this.domNode.classList.toggle('checked', this._checked);
         this.applyStyles();
     }
+    setIcon(icon) {
+        if (this._icon) {
+            this.domNode.classList.remove(...ThemeIcon.asClassNameArray(this._icon));
+        }
+        this._icon = icon;
+        if (this._icon) {
+            this.domNode.classList.add(...ThemeIcon.asClassNameArray(this._icon));
+        }
+    }
     width() {
         return 2 /*margin left*/ + 2 /*border*/ + 2 /*padding*/ + 16 /* icon width */;
     }
@@ -91,4 +146,38 @@
     disable() {
         this.domNode.setAttribute('aria-disabled', String(true));
     }
+    setTitle(newTitle) {
+        this.domNode.title = newTitle;
+        this.domNode.setAttribute('aria-label', newTitle);
+    }
+}
+export class Checkbox extends Widget {
+    constructor(title, isChecked, styles) {
+        super();
+        this.title = title;
+        this.isChecked = isChecked;
+        this.checkbox = new Toggle(Object.assign({ title: this.title, isChecked: this.isChecked, icon: Codicon.check, actionClassName: 'monaco-checkbox' }, unthemedToggleStyles));
+        this.domNode = this.checkbox.domNode;
+        this.styles = styles;
+        this.applyStyles();
+        this._register(this.checkbox.onChange(() => this.applyStyles()));
+    }
+    get checked() {
+        return this.checkbox.checked;
+    }
+    set checked(newIsChecked) {
+        this.checkbox.checked = newIsChecked;
+        this.applyStyles();
+    }
+    focus() {
+        this.domNode.focus();
+    }
+    hasFocus() {
+        return this.domNode === document.activeElement;
+    }
+    applyStyles() {
+        this.domNode.style.color = this.styles.checkboxForeground || '';
+        this.domNode.style.backgroundColor = this.styles.checkboxBackground || '';
+        this.domNode.style.borderColor = this.styles.checkboxBorder || '';
+    }
 }
diff -urN -x '*.map' a/vs/base/browser/ui/toolbar/toolbar.js b/vs/base/browser/ui/toolbar/toolbar.js
--- a/vs/base/browser/ui/toolbar/toolbar.js	2023-09-05 08:43:04.202807839 +0000
+++ b/vs/base/browser/ui/toolbar/toolbar.js	2023-09-05 08:45:14.289196233 +0000
@@ -90,12 +90,39 @@
     get actionRunner() {
         return this.actionBar.actionRunner;
     }
+    set context(context) {
+        var _a;
+        this.actionBar.context = context;
+        (_a = this.toggleMenuActionViewItem) === null || _a === void 0 ? void 0 : _a.setActionContext(context);
+        for (const actionViewItem of this.submenuActionViewItems) {
+            actionViewItem.setActionContext(context);
+        }
+    }
     getElement() {
         return this.element;
     }
+    focus() {
+        this.actionBar.focus();
+    }
+    getItemsWidth() {
+        let itemsWidth = 0;
+        for (let i = 0; i < this.actionBar.length(); i++) {
+            itemsWidth += this.actionBar.getWidth(i);
+        }
+        return itemsWidth;
+    }
     getItemAction(indexOrElement) {
         return this.actionBar.getAction(indexOrElement);
     }
+    getItemWidth(index) {
+        return this.actionBar.getWidth(index);
+    }
+    getItemsLength() {
+        return this.actionBar.length();
+    }
+    setAriaLabel(label) {
+        this.actionBar.setAriaLabel(label);
+    }
     setActions(primaryActions, secondaryActions) {
         this.clear();
         const primaryActionsToSet = primaryActions ? primaryActions.slice(0) : [];
@@ -109,6 +136,9 @@
             this.actionBar.push(action, { icon: true, label: false, keybinding: this.getKeybindingLabel(action) });
         });
     }
+    isEmpty() {
+        return this.actionBar.isEmpty();
+    }
     getKeybindingLabel(action) {
         var _a, _b;
         const key = this.lookupKeybindings ? (_b = (_a = this.options).getKeyBinding) === null || _b === void 0 ? void 0 : _b.call(_a, action) : undefined;
diff -urN -x '*.map' a/vs/base/browser/ui/tree/abstractTree.js b/vs/base/browser/ui/tree/abstractTree.js
--- a/vs/base/browser/ui/tree/abstractTree.js	2023-09-05 08:43:04.202807839 +0000
+++ b/vs/base/browser/ui/tree/abstractTree.js	2023-09-05 08:45:14.285196176 +0000
@@ -21,9 +21,9 @@
 import { isButton, isInputElement, isMonacoEditor, List, MouseController } from '../list/listWidget.js';
 import { Toggle, unthemedToggleStyles } from '../toggle/toggle.js';
 import { getVisibleState, isFilterResult } from './indexTreeModel.js';
-import { TreeMouseEventTarget } from './tree.js';
+import { TreeError, TreeMouseEventTarget } from './tree.js';
 import { Action } from '../../../common/actions.js';
-import { distinct, equals, range } from '../../../common/arrays.js';
+import { distinct, equals, firstOrDefault, range } from '../../../common/arrays.js';
 import { disposableTimeout, timeout } from '../../../common/async.js';
 import { Codicon } from '../../../common/codicons.js';
 import { ThemeIcon } from '../../../common/themables.js';
@@ -36,6 +36,12 @@
 import './media/tree.css';
 import { localize } from '../../../../nls.js';
 class TreeElementsDragAndDropData extends ElementsDragAndDropData {
+    set context(context) {
+        this.data.context = context;
+    }
+    get context() {
+        return this.data.context;
+    }
     constructor(data) {
         super(data.elements.map(node => node.element));
         this.data = data;
@@ -174,6 +180,42 @@
         (_b = (_a = this.delegate).setDynamicHeight) === null || _b === void 0 ? void 0 : _b.call(_a, element.element, height);
     }
 }
+export class AbstractTreeViewState {
+    static lift(state) {
+        return state instanceof AbstractTreeViewState ? state : new AbstractTreeViewState(state);
+    }
+    static empty(scrollTop = 0) {
+        return new AbstractTreeViewState({
+            focus: [],
+            selection: [],
+            expanded: Object.create(null),
+            scrollTop,
+        });
+    }
+    constructor(state) {
+        this.focus = new Set(state.focus);
+        this.selection = new Set(state.selection);
+        if (state.expanded instanceof Array) { // old format
+            this.expanded = Object.create(null);
+            for (const id of state.expanded) {
+                this.expanded[id] = 1;
+            }
+        }
+        else {
+            this.expanded = state.expanded;
+        }
+        this.expanded = state.expanded;
+        this.scrollTop = state.scrollTop;
+    }
+    toJSON() {
+        return {
+            focus: Array.from(this.focus),
+            selection: Array.from(this.selection),
+            expanded: this.expanded,
+            scrollTop: this.scrollTop,
+        };
+    }
+}
 export var RenderIndentGuides;
 (function (RenderIndentGuides) {
     RenderIndentGuides["None"] = "none";
@@ -386,6 +428,10 @@
 class FindFilter {
     get totalCount() { return this._totalCount; }
     get matchCount() { return this._matchCount; }
+    set pattern(pattern) {
+        this._pattern = pattern;
+        this._lowercasePattern = pattern.toLowerCase();
+    }
     constructor(tree, keyboardNavigationLabelProvider, _filter) {
         this.tree = tree;
         this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;
@@ -521,6 +567,12 @@
     set matchType(matchType) {
         this.matchTypeToggle.checked = matchType === TreeFindMatchType.Fuzzy;
     }
+    get value() {
+        return this.findInput.inputBox.value;
+    }
+    set value(value) {
+        this.findInput.inputBox.value = value;
+    }
     constructor(container, tree, contextViewProvider, mode, matchType, options) {
         var _a;
         super();
@@ -534,6 +586,7 @@
         this.right = 0;
         this.top = 0;
         this._onDidDisable = new Emitter();
+        this.onDidDisable = this._onDidDisable.event;
         container.appendChild(this.elements.root);
         this._register(toDisposable(() => container.removeChild(this.elements.root)));
         const styles = (_a = options === null || options === void 0 ? void 0 : options.styles) !== null && _a !== void 0 ? _a : unthemedFindWidgetStyles;
@@ -663,6 +716,17 @@
         }));
         this.onDidChangeValue = this.findInput.onDidChange;
     }
+    getHistory() {
+        return this.findInput.inputBox.getHistory();
+    }
+    focus() {
+        this.findInput.focus();
+    }
+    select() {
+        this.findInput.select();
+        // Reposition to last in history
+        this.findInput.inputBox.addToHistory(true);
+    }
     layout(width = this.width) {
         this.width = width;
         this.right = clamp(this.right, 0, Math.max(0, width - 212));
@@ -724,12 +788,14 @@
         this.contextViewProvider = contextViewProvider;
         this.options = options;
         this._pattern = '';
+        this.previousPattern = '';
         this.width = 0;
         this._onDidChangeMode = new Emitter();
         this.onDidChangeMode = this._onDidChangeMode.event;
         this._onDidChangeMatchType = new Emitter();
         this.onDidChangeMatchType = this._onDidChangeMatchType.event;
         this._onDidChangePattern = new Emitter();
+        this.onDidChangePattern = this._onDidChangePattern.event;
         this._onDidChangeOpenState = new Emitter();
         this.onDidChangeOpenState = this._onDidChangeOpenState.event;
         this.enabledDisposables = new DisposableStore();
@@ -746,6 +812,54 @@
             this.matchType = optionsUpdate.defaultFindMatchType;
         }
     }
+    open() {
+        if (this.widget) {
+            this.widget.focus();
+            this.widget.select();
+            return;
+        }
+        this.widget = new FindWidget(this.view.getHTMLElement(), this.tree, this.contextViewProvider, this.mode, this.matchType, Object.assign(Object.assign({}, this.options), { history: this._history }));
+        this.enabledDisposables.add(this.widget);
+        this.widget.onDidChangeValue(this.onDidChangeValue, this, this.enabledDisposables);
+        this.widget.onDidChangeMode(mode => this.mode = mode, undefined, this.enabledDisposables);
+        this.widget.onDidChangeMatchType(matchType => this.matchType = matchType, undefined, this.enabledDisposables);
+        this.widget.onDidDisable(this.close, this, this.enabledDisposables);
+        this.widget.layout(this.width);
+        this.widget.focus();
+        this.widget.value = this.previousPattern;
+        this.widget.select();
+        this._onDidChangeOpenState.fire(true);
+    }
+    close() {
+        if (!this.widget) {
+            return;
+        }
+        this._history = this.widget.getHistory();
+        this.widget = undefined;
+        this.enabledDisposables.dispose();
+        this.enabledDisposables = new DisposableStore();
+        this.previousPattern = this.pattern;
+        this.onDidChangeValue('');
+        this.tree.domFocus();
+        this._onDidChangeOpenState.fire(false);
+    }
+    onDidChangeValue(pattern) {
+        this._pattern = pattern;
+        this._onDidChangePattern.fire(pattern);
+        this.filter.pattern = pattern;
+        this.tree.refilter();
+        if (pattern) {
+            this.tree.focusNext(0, true, undefined, node => !FuzzyScore.isDefault(node.filterData));
+        }
+        const focus = this.tree.getFocus();
+        if (focus.length > 0) {
+            const element = focus[0];
+            if (this.tree.getRelativeTop(element) === null) {
+                this.tree.reveal(element, 0.5);
+            }
+        }
+        this.render();
+    }
     onDidSpliceModel() {
         if (!this.widget || this.pattern.length === 0) {
             return;
@@ -806,6 +920,13 @@
         target
     };
 }
+function asTreeContextMenuEvent(event) {
+    return {
+        element: event.element ? event.element.element : null,
+        browserEvent: event.browserEvent,
+        anchor: event.anchor
+    };
+}
 function dfs(node, fn) {
     fn(node);
     node.children.forEach(child => dfs(child, fn));
@@ -1031,11 +1152,19 @@
     get onDidScroll() { return this.view.onDidScroll; }
     get onDidChangeFocus() { return this.eventBufferer.wrapEvent(this.focus.onDidChange); }
     get onDidChangeSelection() { return this.eventBufferer.wrapEvent(this.selection.onDidChange); }
+    get onMouseClick() { return Event.map(this.view.onMouseClick, asTreeMouseEvent); }
     get onMouseDblClick() { return Event.filter(Event.map(this.view.onMouseDblClick, asTreeMouseEvent), e => e.target !== TreeMouseEventTarget.Filter); }
+    get onContextMenu() { return Event.map(this.view.onContextMenu, asTreeContextMenuEvent); }
+    get onTap() { return Event.map(this.view.onTap, asTreeMouseEvent); }
     get onPointer() { return Event.map(this.view.onPointer, asTreeMouseEvent); }
+    get onKeyDown() { return this.view.onKeyDown; }
+    get onKeyUp() { return this.view.onKeyUp; }
+    get onKeyPress() { return this.view.onKeyPress; }
     get onDidFocus() { return this.view.onDidFocus; }
+    get onDidBlur() { return this.view.onDidBlur; }
     get onDidChangeModel() { return Event.signal(this.model.onDidSplice); }
     get onDidChangeCollapseState() { return this.model.onDidChangeCollapseState; }
+    get onDidChangeRenderNodeCount() { return this.model.onDidChangeRenderNodeCount; }
     get findMode() { var _a, _b; return (_b = (_a = this.findController) === null || _a === void 0 ? void 0 : _a.mode) !== null && _b !== void 0 ? _b : TreeFindMode.Highlight; }
     set findMode(findMode) { if (this.findController) {
         this.findController.mode = findMode;
@@ -1044,6 +1173,7 @@
     set findMatchType(findFuzzy) { if (this.findController) {
         this.findController.matchType = findFuzzy;
     } }
+    get onDidChangeFindPattern() { return this.findController ? this.findController.onDidChangePattern : Event.None; }
     get expandOnDoubleClick() { return typeof this._options.expandOnDoubleClick === 'undefined' ? true : this._options.expandOnDoubleClick; }
     get expandOnlyOnTwistieClick() { return typeof this._options.expandOnlyOnTwistieClick === 'undefined' ? true : this._options.expandOnlyOnTwistieClick; }
     get onDidDispose() { return this.view.onDidDispose; }
@@ -1057,6 +1187,7 @@
         this._onWillRefilter = new Emitter();
         this.onWillRefilter = this._onWillRefilter.event;
         this._onDidUpdateOptions = new Emitter();
+        this.onDidUpdateOptions = this._onDidUpdateOptions.event;
         const treeDelegate = new ComposedTreeDelegate(delegate);
         const onDidChangeCollapseStateRelay = new Relay();
         const onDidChangeActiveNodes = new Relay();
@@ -1140,25 +1271,75 @@
     get options() {
         return this._options;
     }
+    updateWidth(element) {
+        const index = this.model.getListIndex(element);
+        if (index === -1) {
+            return;
+        }
+        this.view.updateWidth(index);
+    }
     // Widget
     getHTMLElement() {
         return this.view.getHTMLElement();
     }
+    get contentHeight() {
+        return this.view.contentHeight;
+    }
+    get contentWidth() {
+        return this.view.contentWidth;
+    }
+    get onDidChangeContentHeight() {
+        return this.view.onDidChangeContentHeight;
+    }
+    get onDidChangeContentWidth() {
+        return this.view.onDidChangeContentWidth;
+    }
     get scrollTop() {
         return this.view.scrollTop;
     }
     set scrollTop(scrollTop) {
         this.view.scrollTop = scrollTop;
     }
+    get scrollLeft() {
+        return this.view.scrollLeft;
+    }
+    set scrollLeft(scrollLeft) {
+        this.view.scrollLeft = scrollLeft;
+    }
     get scrollHeight() {
         return this.view.scrollHeight;
     }
     get renderHeight() {
         return this.view.renderHeight;
     }
+    get firstVisibleElement() {
+        const index = this.view.firstVisibleIndex;
+        if (index < 0 || index >= this.view.length) {
+            return undefined;
+        }
+        const node = this.view.element(index);
+        return node.element;
+    }
+    get lastVisibleElement() {
+        const index = this.view.lastVisibleIndex;
+        const node = this.view.element(index);
+        return node.element;
+    }
+    get ariaLabel() {
+        return this.view.ariaLabel;
+    }
+    set ariaLabel(value) {
+        this.view.ariaLabel = value;
+    }
+    get selectionSize() {
+        return this.selection.getNodes().length;
+    }
     domFocus() {
         this.view.domFocus();
     }
+    isDOMFocused() {
+        return this.getHTMLElement() === document.activeElement;
+    }
     layout(height, width) {
         var _a;
         this.view.layout(height, width);
@@ -1201,6 +1382,12 @@
     toggleCollapsed(location, recursive = false) {
         return this.model.setCollapsed(location, undefined, recursive);
     }
+    expandAll() {
+        this.model.setCollapsed(this.model.rootRef, false, true);
+    }
+    collapseAll() {
+        this.model.setCollapsed(this.model.rootRef, true, true);
+    }
     isCollapsible(location) {
         return this.model.isCollapsible(location);
     }
@@ -1210,10 +1397,35 @@
     isCollapsed(location) {
         return this.model.isCollapsed(location);
     }
+    triggerTypeNavigation() {
+        this.view.triggerTypeNavigation();
+    }
+    openFind() {
+        var _a;
+        (_a = this.findController) === null || _a === void 0 ? void 0 : _a.open();
+    }
+    closeFind() {
+        var _a;
+        (_a = this.findController) === null || _a === void 0 ? void 0 : _a.close();
+    }
     refilter() {
         this._onWillRefilter.fire(undefined);
         this.model.refilter();
     }
+    setAnchor(element) {
+        if (typeof element === 'undefined') {
+            return this.view.setAnchor(undefined);
+        }
+        const node = this.model.getNode(element);
+        this.anchor.set([node]);
+        const index = this.model.getListIndex(element);
+        if (index > -1) {
+            this.view.setAnchor(index, true);
+        }
+    }
+    getAnchor() {
+        return firstOrDefault(this.anchor.get(), undefined);
+    }
     setSelection(elements, browserEvent) {
         const nodes = elements.map(e => this.model.getNode(e));
         this.selection.set(nodes, browserEvent);
@@ -1229,6 +1441,24 @@
         const indexes = elements.map(e => this.model.getListIndex(e)).filter(i => i > -1);
         this.view.setFocus(indexes, browserEvent, true);
     }
+    focusNext(n = 1, loop = false, browserEvent, filter = this.focusNavigationFilter) {
+        this.view.focusNext(n, loop, browserEvent, filter);
+    }
+    focusPrevious(n = 1, loop = false, browserEvent, filter = this.focusNavigationFilter) {
+        this.view.focusPrevious(n, loop, browserEvent, filter);
+    }
+    focusNextPage(browserEvent, filter = this.focusNavigationFilter) {
+        return this.view.focusNextPage(browserEvent, filter);
+    }
+    focusPreviousPage(browserEvent, filter = this.focusNavigationFilter) {
+        return this.view.focusPreviousPage(browserEvent, filter);
+    }
+    focusLast(browserEvent, filter = this.focusNavigationFilter) {
+        this.view.focusLast(browserEvent, filter);
+    }
+    focusFirst(browserEvent, filter = this.focusNavigationFilter) {
+        this.view.focusFirst(browserEvent, filter);
+    }
     getFocus() {
         return this.focus.get();
     }
@@ -1240,6 +1470,40 @@
         }
         this.view.reveal(index, relativeTop);
     }
+    /**
+     * Returns the relative position of an element rendered in the list.
+     * Returns `null` if the element isn't *entirely* in the visible viewport.
+     */
+    getRelativeTop(location) {
+        const index = this.model.getListIndex(location);
+        if (index === -1) {
+            return null;
+        }
+        return this.view.getRelativeTop(index);
+    }
+    getViewState(identityProvider = this.options.identityProvider) {
+        if (!identityProvider) {
+            throw new TreeError(this._user, 'Can\'t get tree view state without an identity provider');
+        }
+        const getId = (element) => identityProvider.getId(element).toString();
+        const state = AbstractTreeViewState.empty(this.scrollTop);
+        for (const focus of this.getFocus()) {
+            state.focus.add(getId(focus));
+        }
+        for (const selection of this.getSelection()) {
+            state.selection.add(getId(selection));
+        }
+        const root = this.model.getNode();
+        const queue = [root];
+        while (queue.length > 0) {
+            const node = queue.shift();
+            if (node !== root && node.collapsible) {
+                state.expanded[getId(node.element)] = node.collapsed ? 0 : 1;
+            }
+            queue.push(...node.children);
+        }
+        return state;
+    }
     // List
     onLeftArrow(e) {
         e.preventDefault();
@@ -1293,8 +1557,45 @@
         const recursive = e.browserEvent.altKey;
         this.model.setCollapsed(location, undefined, recursive);
     }
+    navigate(start) {
+        return new TreeNavigator(this.view, this.model, start);
+    }
     dispose() {
         dispose(this.disposables);
         this.view.dispose();
     }
 }
+class TreeNavigator {
+    constructor(view, model, start) {
+        this.view = view;
+        this.model = model;
+        if (start) {
+            this.index = this.model.getListIndex(start);
+        }
+        else {
+            this.index = -1;
+        }
+    }
+    current() {
+        if (this.index < 0 || this.index >= this.view.length) {
+            return null;
+        }
+        return this.view.element(this.index).element;
+    }
+    previous() {
+        this.index--;
+        return this.current();
+    }
+    next() {
+        this.index++;
+        return this.current();
+    }
+    first() {
+        this.index = 0;
+        return this.current();
+    }
+    last() {
+        this.index = this.view.length - 1;
+        return this.current();
+    }
+}
diff -urN -x '*.map' a/vs/base/browser/ui/tree/asyncDataTree.js b/vs/base/browser/ui/tree/asyncDataTree.js
--- a/vs/base/browser/ui/tree/asyncDataTree.js	2023-09-05 08:43:04.202807839 +0000
+++ b/vs/base/browser/ui/tree/asyncDataTree.js	2023-09-05 08:45:14.285196176 +0000
@@ -104,7 +104,20 @@
         target: e.target
     };
 }
+function asTreeContextMenuEvent(e) {
+    return {
+        browserEvent: e.browserEvent,
+        element: e.element && e.element.element,
+        anchor: e.anchor
+    };
+}
 class AsyncDataTreeElementsDragAndDropData extends ElementsDragAndDropData {
+    set context(context) {
+        this.data.context = context;
+    }
+    get context() {
+        return this.data.context;
+    }
     constructor(data) {
         super(data.elements.map(node => node.element));
         this.data = data;
@@ -199,16 +212,31 @@
     get onDidScroll() { return this.tree.onDidScroll; }
     get onDidChangeFocus() { return Event.map(this.tree.onDidChangeFocus, asTreeEvent); }
     get onDidChangeSelection() { return Event.map(this.tree.onDidChangeSelection, asTreeEvent); }
+    get onKeyDown() { return this.tree.onKeyDown; }
+    get onMouseClick() { return Event.map(this.tree.onMouseClick, asTreeMouseEvent); }
     get onMouseDblClick() { return Event.map(this.tree.onMouseDblClick, asTreeMouseEvent); }
+    get onContextMenu() { return Event.map(this.tree.onContextMenu, asTreeContextMenuEvent); }
+    get onTap() { return Event.map(this.tree.onTap, asTreeMouseEvent); }
     get onPointer() { return Event.map(this.tree.onPointer, asTreeMouseEvent); }
     get onDidFocus() { return this.tree.onDidFocus; }
+    get onDidBlur() { return this.tree.onDidBlur; }
     /**
      * To be used internally only!
      * @deprecated
      */
     get onDidChangeModel() { return this.tree.onDidChangeModel; }
     get onDidChangeCollapseState() { return this.tree.onDidChangeCollapseState; }
+    get onDidUpdateOptions() { return this.tree.onDidUpdateOptions; }
     get onDidChangeFindOpenState() { return this.tree.onDidChangeFindOpenState; }
+    get findMode() { return this.tree.findMode; }
+    set findMode(mode) { this.tree.findMode = mode; }
+    get expandOnlyOnTwistieClick() {
+        if (typeof this.tree.expandOnlyOnTwistieClick === 'boolean') {
+            return this.tree.expandOnlyOnTwistieClick;
+        }
+        const fn = this.tree.expandOnlyOnTwistieClick;
+        return element => fn(this.nodes.get((element === this.root.element ? null : element)) || null);
+    }
     get onDidDispose() { return this.tree.onDidDispose; }
     constructor(user, container, delegate, renderers, dataSource, options = {}) {
         this.user = user;
@@ -246,22 +274,52 @@
     updateOptions(options = {}) {
         this.tree.updateOptions(options);
     }
+    get options() {
+        return this.tree.options;
+    }
     // Widget
     getHTMLElement() {
         return this.tree.getHTMLElement();
     }
+    get contentHeight() {
+        return this.tree.contentHeight;
+    }
+    get contentWidth() {
+        return this.tree.contentWidth;
+    }
+    get onDidChangeContentHeight() {
+        return this.tree.onDidChangeContentHeight;
+    }
+    get onDidChangeContentWidth() {
+        return this.tree.onDidChangeContentWidth;
+    }
     get scrollTop() {
         return this.tree.scrollTop;
     }
     set scrollTop(scrollTop) {
         this.tree.scrollTop = scrollTop;
     }
+    get scrollLeft() {
+        return this.tree.scrollLeft;
+    }
+    set scrollLeft(scrollLeft) {
+        this.tree.scrollLeft = scrollLeft;
+    }
     get scrollHeight() {
         return this.tree.scrollHeight;
     }
     get renderHeight() {
         return this.tree.renderHeight;
     }
+    get lastVisibleElement() {
+        return this.tree.lastVisibleElement.element;
+    }
+    get ariaLabel() {
+        return this.tree.ariaLabel;
+    }
+    set ariaLabel(value) {
+        this.tree.ariaLabel = value;
+    }
     domFocus() {
         this.tree.domFocus();
     }
@@ -291,6 +349,11 @@
             }
         });
     }
+    updateChildren(element = this.root.element, recursive = true, rerender = false, options) {
+        return __awaiter(this, void 0, void 0, function* () {
+            yield this._updateChildren(element, recursive, rerender, undefined, options);
+        });
+    }
     _updateChildren(element = this.root.element, recursive = true, rerender = false, viewStateContext, options) {
         return __awaiter(this, void 0, void 0, function* () {
             if (typeof this.root.element === 'undefined') {
@@ -313,6 +376,12 @@
             }
         });
     }
+    resort(element = this.root.element, recursive = true) {
+        this.tree.resort(this.getDataNode(element), recursive);
+    }
+    hasNode(element) {
+        return element === this.root.element || this.nodes.has(element);
+    }
     // View
     rerender(element) {
         if (element === undefined || element === this.root.element) {
@@ -322,6 +391,10 @@
         const node = this.getDataNode(element);
         this.tree.rerender(node);
     }
+    updateWidth(element) {
+        const node = this.getDataNode(element);
+        this.tree.updateWidth(node);
+    }
     // Tree
     getNode(element = this.root.element) {
         const dataNode = this.getDataNode(element);
@@ -360,6 +433,40 @@
             return result;
         });
     }
+    toggleCollapsed(element, recursive = false) {
+        return this.tree.toggleCollapsed(this.getDataNode(element), recursive);
+    }
+    expandAll() {
+        this.tree.expandAll();
+    }
+    collapseAll() {
+        this.tree.collapseAll();
+    }
+    isCollapsible(element) {
+        return this.tree.isCollapsible(this.getDataNode(element));
+    }
+    isCollapsed(element) {
+        return this.tree.isCollapsed(this.getDataNode(element));
+    }
+    triggerTypeNavigation() {
+        this.tree.triggerTypeNavigation();
+    }
+    openFind() {
+        this.tree.openFind();
+    }
+    closeFind() {
+        this.tree.closeFind();
+    }
+    refilter() {
+        this.tree.refilter();
+    }
+    setAnchor(element) {
+        this.tree.setAnchor(typeof element === 'undefined' ? undefined : this.getDataNode(element));
+    }
+    getAnchor() {
+        const node = this.tree.getAnchor();
+        return node === null || node === void 0 ? void 0 : node.element;
+    }
     setSelection(elements, browserEvent) {
         const nodes = elements.map(e => this.getDataNode(e));
         this.tree.setSelection(nodes, browserEvent);
@@ -372,6 +479,24 @@
         const nodes = elements.map(e => this.getDataNode(e));
         this.tree.setFocus(nodes, browserEvent);
     }
+    focusNext(n = 1, loop = false, browserEvent) {
+        this.tree.focusNext(n, loop, browserEvent);
+    }
+    focusPrevious(n = 1, loop = false, browserEvent) {
+        this.tree.focusPrevious(n, loop, browserEvent);
+    }
+    focusNextPage(browserEvent) {
+        return this.tree.focusNextPage(browserEvent);
+    }
+    focusPreviousPage(browserEvent) {
+        return this.tree.focusPreviousPage(browserEvent);
+    }
+    focusLast(browserEvent) {
+        this.tree.focusLast(browserEvent);
+    }
+    focusFirst(browserEvent) {
+        this.tree.focusFirst(browserEvent);
+    }
     getFocus() {
         const nodes = this.tree.getFocus();
         return nodes.map(n => n.element);
@@ -379,6 +504,9 @@
     reveal(element, relativeTop) {
         this.tree.reveal(this.getDataNode(element), relativeTop);
     }
+    getRelativeTop(element) {
+        return this.tree.getRelativeTop(this.getDataNode(element));
+    }
     // Tree navigation
     getParentElement(element) {
         const node = this.tree.getParentElement(this.getDataNode(element));
@@ -638,6 +766,26 @@
         }
         return children;
     }
+    // view state
+    getViewState() {
+        if (!this.identityProvider) {
+            throw new TreeError(this.user, 'Can\'t get tree view state without an identity provider');
+        }
+        const getId = (element) => this.identityProvider.getId(element).toString();
+        const focus = this.getFocus().map(getId);
+        const selection = this.getSelection().map(getId);
+        const expanded = [];
+        const root = this.tree.getNode();
+        const stack = [root];
+        while (stack.length > 0) {
+            const node = stack.pop();
+            if (node !== root && node.collapsible && !node.collapsed) {
+                expanded.push(getId(node.element.element));
+            }
+            stack.push(...node.children);
+        }
+        return { focus, selection, expanded, scrollTop: this.scrollTop };
+    }
     dispose() {
         this.disposables.dispose();
     }
@@ -732,6 +880,27 @@
     updateOptions(options = {}) {
         this.tree.updateOptions(options);
     }
+    getViewState() {
+        if (!this.identityProvider) {
+            throw new TreeError(this.user, 'Can\'t get tree view state without an identity provider');
+        }
+        const getId = (element) => this.identityProvider.getId(element).toString();
+        const focus = this.getFocus().map(getId);
+        const selection = this.getSelection().map(getId);
+        const expanded = [];
+        const root = this.tree.getCompressedTreeNode();
+        const stack = [root];
+        while (stack.length > 0) {
+            const node = stack.pop();
+            if (node !== root && node.collapsible && !node.collapsed) {
+                for (const asyncNode of node.element.elements) {
+                    expanded.push(getId(asyncNode.element));
+                }
+            }
+            stack.push(...node.children);
+        }
+        return { focus, selection, expanded, scrollTop: this.scrollTop };
+    }
     render(node, viewStateContext) {
         if (!this.identityProvider) {
             return super.render(node, viewStateContext);
diff -urN -x '*.map' a/vs/base/browser/ui/tree/compressedObjectTreeModel.js b/vs/base/browser/ui/tree/compressedObjectTreeModel.js
--- a/vs/base/browser/ui/tree/compressedObjectTreeModel.js	2023-09-05 08:43:04.202807839 +0000
+++ b/vs/base/browser/ui/tree/compressedObjectTreeModel.js	2023-09-05 08:45:14.285196176 +0000
@@ -85,6 +85,7 @@
     get onDidSplice() { return this.model.onDidSplice; }
     get onDidChangeCollapseState() { return this.model.onDidChangeCollapseState; }
     get onDidChangeRenderNodeCount() { return this.model.onDidChangeRenderNodeCount; }
+    get size() { return this.nodes.size; }
     constructor(user, list, options = {}) {
         this.user = user;
         this.rootRef = null;
@@ -128,6 +129,9 @@
             diffDepth: node.depth - parent.depth,
         });
     }
+    isCompressionEnabled() {
+        return this.enabled;
+    }
     setCompressionEnabled(enabled) {
         if (enabled === this.enabled) {
             return;
@@ -200,6 +204,10 @@
         const compressedNode = this.getCompressedNode(location);
         return this.model.getFirstElementChild(compressedNode);
     }
+    getLastElementAncestor(location) {
+        const compressedNode = typeof location === 'undefined' ? undefined : this.getCompressedNode(location);
+        return this.model.getLastElementAncestor(compressedNode);
+    }
     isCollapsible(location) {
         const compressedNode = this.getCompressedNode(location);
         return this.model.isCollapsible(compressedNode);
@@ -224,9 +232,20 @@
         const compressedNode = this.getCompressedNode(location);
         this.model.rerender(compressedNode);
     }
+    updateElementHeight(element, height) {
+        const compressedNode = this.getCompressedNode(element);
+        if (!compressedNode) {
+            return;
+        }
+        this.model.updateElementHeight(compressedNode, height);
+    }
     refilter() {
         this.model.refilter();
     }
+    resort(location = null, recursive = true) {
+        const compressedNode = this.getCompressedNode(location);
+        this.model.resort(compressedNode, recursive);
+    }
     getCompressedNode(element) {
         if (element === null) {
             return null;
@@ -305,6 +324,9 @@
     setChildren(element, children = Iterable.empty(), options = {}) {
         this.model.setChildren(element, children, options);
     }
+    isCompressionEnabled() {
+        return this.model.isCompressionEnabled();
+    }
     setCompressionEnabled(enabled) {
         this.model.setCompressionEnabled(enabled);
     }
@@ -333,6 +355,13 @@
         }
         return this.elementMapper(result.elements);
     }
+    getLastElementAncestor(location) {
+        const result = this.model.getLastElementAncestor(location);
+        if (result === null || typeof result === 'undefined') {
+            return result;
+        }
+        return this.elementMapper(result.elements);
+    }
     isCollapsible(location) {
         return this.model.isCollapsible(location);
     }
@@ -351,9 +380,15 @@
     rerender(location) {
         return this.model.rerender(location);
     }
+    updateElementHeight(element, height) {
+        this.model.updateElementHeight(element, height);
+    }
     refilter() {
         return this.model.refilter();
     }
+    resort(element = null, recursive = true) {
+        return this.model.resort(element, recursive);
+    }
     getCompressedTreeNode(location = null) {
         return this.model.getNode(location);
     }
diff -urN -x '*.map' a/vs/base/browser/ui/tree/dataTree.js b/vs/base/browser/ui/tree/dataTree.js
--- a/vs/base/browser/ui/tree/dataTree.js	2023-09-05 08:43:04.202807839 +0000
+++ b/vs/base/browser/ui/tree/dataTree.js	2023-09-05 08:45:14.285196176 +0000
@@ -4,13 +4,115 @@
  *--------------------------------------------------------------------------------------------*/
 import { AbstractTree } from './abstractTree.js';
 import { ObjectTreeModel } from './objectTreeModel.js';
+import { TreeError } from './tree.js';
+import { Iterable } from '../../../common/iterator.js';
 export class DataTree extends AbstractTree {
     constructor(user, container, delegate, renderers, dataSource, options = {}) {
         super(user, container, delegate, renderers, options);
         this.user = user;
         this.dataSource = dataSource;
+        this.nodesByIdentity = new Map();
         this.identityProvider = options.identityProvider;
     }
+    // Model
+    getInput() {
+        return this.input;
+    }
+    setInput(input, viewState) {
+        if (viewState && !this.identityProvider) {
+            throw new TreeError(this.user, 'Can\'t restore tree view state without an identity provider');
+        }
+        this.input = input;
+        if (!input) {
+            this.nodesByIdentity.clear();
+            this.model.setChildren(null, Iterable.empty());
+            return;
+        }
+        if (!viewState) {
+            this._refresh(input);
+            return;
+        }
+        const focus = [];
+        const selection = [];
+        const isCollapsed = (element) => {
+            const id = this.identityProvider.getId(element).toString();
+            return !viewState.expanded[id];
+        };
+        const onDidCreateNode = (node) => {
+            const id = this.identityProvider.getId(node.element).toString();
+            if (viewState.focus.has(id)) {
+                focus.push(node.element);
+            }
+            if (viewState.selection.has(id)) {
+                selection.push(node.element);
+            }
+        };
+        this._refresh(input, isCollapsed, onDidCreateNode);
+        this.setFocus(focus);
+        this.setSelection(selection);
+        if (viewState && typeof viewState.scrollTop === 'number') {
+            this.scrollTop = viewState.scrollTop;
+        }
+    }
+    updateChildren(element = this.input) {
+        if (typeof this.input === 'undefined') {
+            throw new TreeError(this.user, 'Tree input not set');
+        }
+        let isCollapsed;
+        if (this.identityProvider) {
+            isCollapsed = element => {
+                const id = this.identityProvider.getId(element).toString();
+                const node = this.nodesByIdentity.get(id);
+                if (!node) {
+                    return undefined;
+                }
+                return node.collapsed;
+            };
+        }
+        this._refresh(element, isCollapsed);
+    }
+    resort(element = this.input, recursive = true) {
+        this.model.resort((element === this.input ? null : element), recursive);
+    }
+    // View
+    refresh(element) {
+        if (element === undefined) {
+            this.view.rerender();
+            return;
+        }
+        this.model.rerender(element);
+    }
+    // Implementation
+    _refresh(element, isCollapsed, onDidCreateNode) {
+        let onDidDeleteNode;
+        if (this.identityProvider) {
+            const insertedElements = new Set();
+            const outerOnDidCreateNode = onDidCreateNode;
+            onDidCreateNode = (node) => {
+                const id = this.identityProvider.getId(node.element).toString();
+                insertedElements.add(id);
+                this.nodesByIdentity.set(id, node);
+                outerOnDidCreateNode === null || outerOnDidCreateNode === void 0 ? void 0 : outerOnDidCreateNode(node);
+            };
+            onDidDeleteNode = (node) => {
+                const id = this.identityProvider.getId(node.element).toString();
+                if (!insertedElements.has(id)) {
+                    this.nodesByIdentity.delete(id);
+                }
+            };
+        }
+        this.model.setChildren((element === this.input ? null : element), this.iterate(element, isCollapsed).elements, { onDidCreateNode, onDidDeleteNode });
+    }
+    iterate(element, isCollapsed) {
+        const children = [...this.dataSource.getChildren(element)];
+        const elements = Iterable.map(children, element => {
+            const { elements: children, size } = this.iterate(element, isCollapsed);
+            const collapsible = this.dataSource.hasChildren ? this.dataSource.hasChildren(element) : undefined;
+            const collapsed = size === 0 ? undefined : (isCollapsed && isCollapsed(element));
+            return { element, children, collapsible, collapsed };
+        });
+        return { elements, size: children.length };
+    }
     createModel(user, view, options) {
         return new ObjectTreeModel(user, view, options);
     }
diff -urN -x '*.map' a/vs/base/browser/ui/tree/indexTreeModel.js b/vs/base/browser/ui/tree/indexTreeModel.js
--- a/vs/base/browser/ui/tree/indexTreeModel.js	2023-09-05 08:43:04.202807839 +0000
+++ b/vs/base/browser/ui/tree/indexTreeModel.js	2023-09-05 08:45:14.285196176 +0000
@@ -197,6 +197,13 @@
             this.list.splice(listIndex, 1, [node]);
         }
     }
+    updateElementHeight(location, height) {
+        if (location.length === 0) {
+            throw new TreeError(this.user, 'Invalid tree location');
+        }
+        const { listIndex } = this.getTreeNodeWithListIndex(location);
+        this.list.updateElementHeight(listIndex, height);
+    }
     has(location) {
         return this.hasTreeNode(location);
     }
@@ -536,4 +543,17 @@
         }
         return node.children[0].element;
     }
+    getLastElementAncestor(location = []) {
+        const node = this.getTreeNode(location);
+        if (node.children.length === 0) {
+            return undefined;
+        }
+        return this._getLastElementAncestor(node);
+    }
+    _getLastElementAncestor(node) {
+        if (node.children.length === 0) {
+            return node.element;
+        }
+        return this._getLastElementAncestor(node.children[node.children.length - 1]);
+    }
 }
diff -urN -x '*.map' a/vs/base/browser/ui/tree/objectTree.js b/vs/base/browser/ui/tree/objectTree.js
--- a/vs/base/browser/ui/tree/objectTree.js	2023-09-05 08:43:04.206807940 +0000
+++ b/vs/base/browser/ui/tree/objectTree.js	2023-09-05 08:45:14.285196176 +0000
@@ -29,6 +29,12 @@
         }
         this.model.rerender(element);
     }
+    updateElementHeight(element, height) {
+        this.model.updateElementHeight(element, height);
+    }
+    resort(element, recursive = true) {
+        this.model.resort(element, recursive);
+    }
     hasElement(element) {
         return this.model.has(element);
     }
diff -urN -x '*.map' a/vs/base/browser/ui/tree/objectTreeModel.js b/vs/base/browser/ui/tree/objectTreeModel.js
--- a/vs/base/browser/ui/tree/objectTreeModel.js	2023-09-05 08:43:04.206807940 +0000
+++ b/vs/base/browser/ui/tree/objectTreeModel.js	2023-09-05 08:45:14.285196176 +0000
@@ -6,6 +6,7 @@
 import { ObjectTreeElementCollapseState, TreeError } from './tree.js';
 import { Iterable } from '../../../common/iterator.js';
 export class ObjectTreeModel {
+    get size() { return this.nodes.size; }
     constructor(user, list, options = {}) {
         this.user = user;
         this.rootRef = null;
@@ -113,10 +114,38 @@
         const location = this.getElementLocation(element);
         this.model.rerender(location);
     }
+    updateElementHeight(element, height) {
+        const location = this.getElementLocation(element);
+        this.model.updateElementHeight(location, height);
+    }
+    resort(element = null, recursive = true) {
+        if (!this.sorter) {
+            return;
+        }
+        const location = this.getElementLocation(element);
+        const node = this.model.getNode(location);
+        this._setChildren(location, this.resortChildren(node, recursive), {});
+    }
+    resortChildren(node, recursive, first = true) {
+        let childrenNodes = [...node.children];
+        if (recursive || first) {
+            childrenNodes = childrenNodes.sort(this.sorter.compare.bind(this.sorter));
+        }
+        return Iterable.map(childrenNodes, node => ({
+            element: node.element,
+            collapsible: node.collapsible,
+            collapsed: node.collapsed,
+            children: this.resortChildren(node, recursive, false)
+        }));
+    }
     getFirstElementChild(ref = null) {
         const location = this.getElementLocation(ref);
         return this.model.getFirstElementChild(location);
     }
+    getLastElementAncestor(ref = null) {
+        const location = this.getElementLocation(ref);
+        return this.model.getLastElementAncestor(location);
+    }
     has(element) {
         return this.nodes.has(element);
     }
diff -urN -x '*.map' a/vs/base/browser/ui/tree/tree.js b/vs/base/browser/ui/tree/tree.js
--- a/vs/base/browser/ui/tree/tree.js	2023-09-05 08:43:04.206807940 +0000
+++ b/vs/base/browser/ui/tree/tree.js	2023-09-05 08:45:14.285196176 +0000
@@ -22,6 +22,12 @@
     TreeMouseEventTarget[TreeMouseEventTarget["Element"] = 2] = "Element";
     TreeMouseEventTarget[TreeMouseEventTarget["Filter"] = 3] = "Filter";
 })(TreeMouseEventTarget || (TreeMouseEventTarget = {}));
+export const TreeDragOverReactions = {
+    acceptBubbleUp() { return { accept: true, bubble: 1 /* TreeDragOverBubble.Up */ }; },
+    acceptBubbleDown(autoExpand = false) { return { accept: true, bubble: 0 /* TreeDragOverBubble.Down */, autoExpand }; },
+    acceptCopyBubbleUp() { return { accept: true, bubble: 1 /* TreeDragOverBubble.Up */, effect: 0 /* ListDragOverEffect.Copy */ }; },
+    acceptCopyBubbleDown(autoExpand = false) { return { accept: true, bubble: 0 /* TreeDragOverBubble.Down */, effect: 0 /* ListDragOverEffect.Copy */, autoExpand }; }
+};
 export class TreeError extends Error {
     constructor(user, message) {
         super(`TreeError [${user}] ${message}`);
diff -urN -x '*.map' a/vs/base/browser/ui/widget.js b/vs/base/browser/ui/widget.js
--- a/vs/base/browser/ui/widget.js	2023-09-05 08:43:04.206807940 +0000
+++ b/vs/base/browser/ui/widget.js	2023-09-05 08:45:14.289196233 +0000
@@ -35,6 +35,9 @@
     onfocus(domNode, listener) {
         this._register(dom.addDisposableListener(domNode, dom.EventType.FOCUS, listener));
     }
+    onchange(domNode, listener) {
+        this._register(dom.addDisposableListener(domNode, dom.EventType.CHANGE, listener));
+    }
     ignoreGesture(domNode) {
         return Gesture.ignoreTarget(domNode);
     }
diff -urN -x '*.map' a/vs/base/common/arrays.js b/vs/base/common/arrays.js
--- a/vs/base/common/arrays.js	2023-09-05 08:43:04.214808143 +0000
+++ b/vs/base/common/arrays.js	2023-09-05 08:45:14.297196348 +0000
@@ -1,3 +1,17 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+import { CancellationError } from './errors.js';
 /**
  * Returns the last element of an array.
  * @param array The array.
@@ -153,6 +167,133 @@
     return result;
 }
 /**
+ * Diffs two *sorted* arrays and computes the splices which apply the diff.
+ */
+export function sortedDiff(before, after, compare) {
+    const result = [];
+    function pushSplice(start, deleteCount, toInsert) {
+        if (deleteCount === 0 && toInsert.length === 0) {
+            return;
+        }
+        const latest = result[result.length - 1];
+        if (latest && latest.start + latest.deleteCount === start) {
+            latest.deleteCount += deleteCount;
+            latest.toInsert.push(...toInsert);
+        }
+        else {
+            result.push({ start, deleteCount, toInsert });
+        }
+    }
+    let beforeIdx = 0;
+    let afterIdx = 0;
+    while (true) {
+        if (beforeIdx === before.length) {
+            pushSplice(beforeIdx, 0, after.slice(afterIdx));
+            break;
+        }
+        if (afterIdx === after.length) {
+            pushSplice(beforeIdx, before.length - beforeIdx, []);
+            break;
+        }
+        const beforeElement = before[beforeIdx];
+        const afterElement = after[afterIdx];
+        const n = compare(beforeElement, afterElement);
+        if (n === 0) {
+            // equal
+            beforeIdx += 1;
+            afterIdx += 1;
+        }
+        else if (n < 0) {
+            // beforeElement is smaller -> before element removed
+            pushSplice(beforeIdx, 1, []);
+            beforeIdx += 1;
+        }
+        else if (n > 0) {
+            // beforeElement is greater -> after element added
+            pushSplice(beforeIdx, 0, [afterElement]);
+            afterIdx += 1;
+        }
+    }
+    return result;
+}
+/**
+ * Takes two *sorted* arrays and computes their delta (removed, added elements).
+ * Finishes in `Math.min(before.length, after.length)` steps.
+ */
+export function delta(before, after, compare) {
+    const splices = sortedDiff(before, after, compare);
+    const removed = [];
+    const added = [];
+    for (const splice of splices) {
+        removed.push(...before.slice(splice.start, splice.start + splice.deleteCount));
+        added.push(...splice.toInsert);
+    }
+    return { removed, added };
+}
+/**
+ * Returns the top N elements from the array.
+ *
+ * Faster than sorting the entire array when the array is a lot larger than N.
+ *
+ * @param array The unsorted array.
+ * @param compare A sort function for the elements.
+ * @param n The number of elements to return.
+ * @return The first n elements from array when sorted with compare.
+ */
+export function top(array, compare, n) {
+    if (n === 0) {
+        return [];
+    }
+    const result = array.slice(0, n).sort(compare);
+    topStep(array, compare, result, n, array.length);
+    return result;
+}
+/**
+ * Asynchronous variant of `top()` allowing for splitting up work in batches between which the event loop can run.
+ *
+ * Returns the top N elements from the array.
+ *
+ * Faster than sorting the entire array when the array is a lot larger than N.
+ *
+ * @param array The unsorted array.
+ * @param compare A sort function for the elements.
+ * @param n The number of elements to return.
+ * @param batch The number of elements to examine before yielding to the event loop.
+ * @return The first n elements from array when sorted with compare.
+ */
+export function topAsync(array, compare, n, batch, token) {
+    if (n === 0) {
+        return Promise.resolve([]);
+    }
+    return new Promise((resolve, reject) => {
+        (() => __awaiter(this, void 0, void 0, function* () {
+            const o = array.length;
+            const result = array.slice(0, n).sort(compare);
+            for (let i = n, m = Math.min(n + batch, o); i < o; i = m, m = Math.min(m + batch, o)) {
+                if (i > n) {
+                    yield new Promise(resolve => setTimeout(resolve)); // any other delay function would starve I/O
+                }
+                if (token && token.isCancellationRequested) {
+                    throw new CancellationError();
+                }
+                topStep(array, compare, result, i, m);
+            }
+            return result;
+        }))()
+            .then(resolve, reject);
+    });
+}
+function topStep(array, compare, result, i, m) {
+    for (const n = result.length; i < m; i++) {
+        const element = array[i];
+        if (compare(element, result[n - 1]) < 0) {
+            result.pop();
+            const j = findFirstInSorted(result, e => compare(element, e) < 0);
+            result.splice(j, 0, element);
+        }
+    }
+}
+/**
  * @returns New array with all falsy values removed. The original array IS NOT modified.
  */
 export function coalesce(array) {
@@ -172,6 +313,12 @@
     array.length = to;
 }
 /**
+ * @deprecated Use `Array.copyWithin` instead
+ */
+export function move(array, from, to) {
+    array.splice(to, 0, array.splice(from, 1)[0]);
+}
+/**
  * @returns false if the provided object is an array and not empty.
  */
 export function isFalsyOrEmpty(obj) {
@@ -195,6 +342,17 @@
         return true;
     });
 }
+export function uniqueFilter(keyFn) {
+    const seen = new Set();
+    return element => {
+        const key = keyFn(element);
+        if (seen.has(key)) {
+            return false;
+        }
+        seen.add(key);
+        return true;
+    };
+}
 export function findLast(arr, predicate) {
     const idx = lastIndex(arr, predicate);
     if (idx === -1) {
@@ -214,6 +372,22 @@
 export function firstOrDefault(array, notFoundValue) {
     return array.length > 0 ? array[0] : notFoundValue;
 }
+export function lastOrDefault(array, notFoundValue) {
+    return array.length > 0 ? array[array.length - 1] : notFoundValue;
+}
+export function commonPrefixLength(one, other, equals = (a, b) => a === b) {
+    let result = 0;
+    for (let i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {
+        result++;
+    }
+    return result;
+}
+/**
+ * @deprecated Use `[].flat()`
+ */
+export function flatten(arr) {
+    return [].concat(...arr);
+}
 export function range(arg, to) {
     let from = typeof to === 'number' ? arg : 0;
     if (typeof to === 'number') {
@@ -236,6 +410,35 @@
     }
     return result;
 }
+export function index(array, indexer, mapper) {
+    return array.reduce((r, t) => {
+        r[indexer(t)] = mapper ? mapper(t) : t;
+        return r;
+    }, Object.create(null));
+}
+/**
+ * Inserts an element into an array. Returns a function which, when
+ * called, will remove that element from the array.
+ *
+ * @deprecated In almost all cases, use a `Set<T>` instead.
+ */
+export function insert(array, element) {
+    array.push(element);
+    return () => remove(array, element);
+}
+/**
+ * Removes an element from an array if it can be found.
+ *
+ * @deprecated In almost all cases, use a `Set<T>` instead.
+ */
+export function remove(array, element) {
+    const index = array.indexOf(element);
+    if (index > -1) {
+        array.splice(index, 1);
+        return element;
+    }
+    return undefined;
+}
 /**
  * Insert `insertArr` inside `target` at `insertIndex`.
  * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array
@@ -246,6 +449,30 @@
     return before.concat(insertArr, after);
 }
 /**
+ * Uses Fisher-Yates shuffle to shuffle the given array
+ */
+export function shuffle(array, _seed) {
+    let rand;
+    if (typeof _seed === 'number') {
+        let seed = _seed;
+        // Seeded random number generator in JS. Modified from:
+        // https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript
+        rand = () => {
+            const x = Math.sin(seed++) * 179426549; // throw away most significant digits and reduce any potential bias
+            return x - Math.floor(x);
+        };
+    }
+    else {
+        rand = Math.random;
+    }
+    for (let i = array.length - 1; i > 0; i -= 1) {
+        const j = Math.floor(rand() * (i + 1));
+        const temp = array[i];
+        array[i] = array[j];
+        array[j] = temp;
+    }
+}
+/**
  * Pushes an element to the start of the array, if found.
  */
 export function pushToStart(arr, value) {
@@ -270,9 +497,17 @@
         arr.push(item);
     }
 }
+export function mapArrayOrNot(items, fn) {
+    return Array.isArray(items) ?
+        items.map(fn) :
+        fn(items);
+}
 export function asArray(x) {
     return Array.isArray(x) ? x : [x];
 }
+export function getRandomElement(arr) {
+    return arr[Math.floor(Math.random() * arr.length)];
+}
 /**
  * Returns the first mapped value of the array which is not undefined.
  */
@@ -349,6 +584,17 @@
 export function compareBy(selector, comparator) {
     return (a, b) => comparator(selector(a), selector(b));
 }
+export function tieBreakComparators(...comparators) {
+    return (item1, item2) => {
+        for (const comparator of comparators) {
+            const result = comparator(item1, item2);
+            if (!CompareResult.isNeitherLessOrGreaterThan(result)) {
+                return result;
+            }
+        }
+        return CompareResult.neitherLessOrGreaterThan;
+    };
+}
 /**
  * The natural order on numbers.
 */
@@ -440,11 +686,22 @@
         }
         return this.items[this.firstIdx];
     }
+    peekLast() {
+        if (this.length === 0) {
+            return undefined;
+        }
+        return this.items[this.lastIdx];
+    }
     dequeue() {
         const result = this.items[this.firstIdx];
         this.firstIdx++;
         return result;
     }
+    removeLast() {
+        const result = this.items[this.lastIdx];
+        this.lastIdx--;
+        return result;
+    }
     takeCount(count) {
         const result = this.items.slice(this.firstIdx, this.firstIdx + count);
         this.firstIdx += count;
@@ -463,6 +720,9 @@
     iterate) {
         this.iterate = iterate;
     }
+    forEach(handler) {
+        this.iterate(item => { handler(item); return true; });
+    }
     toArray() {
         const result = [];
         this.iterate(item => { result.push(item); return true; });
@@ -474,6 +734,22 @@
     map(mapFn) {
         return new CallbackIterable(cb => this.iterate(item => cb(mapFn(item))));
     }
+    some(predicate) {
+        let result = false;
+        this.iterate(item => { result = predicate(item); return !result; });
+        return result;
+    }
+    findFirst(predicate) {
+        let result;
+        this.iterate(item => {
+            if (predicate(item)) {
+                result = item;
+                return false;
+            }
+            return true;
+        });
+        return result;
+    }
     findLast(predicate) {
         let result;
         this.iterate(item => {
diff -urN -x '*.map' a/vs/base/common/assert.js b/vs/base/common/assert.js
--- a/vs/base/common/assert.js	2023-09-05 08:43:04.214808143 +0000
+++ b/vs/base/common/assert.js	2023-09-05 08:45:14.297196348 +0000
@@ -25,6 +25,11 @@
 export function assertNever(value, message = 'Unreachable') {
     throw new Error(message);
 }
+export function assert(condition) {
+    if (!condition) {
+        throw new BugIndicatingError('Assertion Failed');
+    }
+}
 /**
  * condition must be side-effect free!
  */
diff -urN -x '*.map' a/vs/base/common/async.js b/vs/base/common/async.js
--- a/vs/base/common/async.js	2023-09-05 08:43:04.214808143 +0000
+++ b/vs/base/common/async.js	2023-09-05 08:45:14.301196405 +0000
@@ -21,7 +21,8 @@
 import { CancellationTokenSource } from './cancellation.js';
 import { CancellationError } from './errors.js';
 import { Emitter, Event } from './event.js';
-import { toDisposable } from './lifecycle.js';
+import { Disposable, MutableDisposable, toDisposable } from './lifecycle.js';
+import { extUri as defaultExtUri } from './resources.js';
 import { setTimeout0 } from './platform.js';
 import { MicrotaskDelay } from './symbols.js';
 export function isThenable(obj) {
@@ -71,6 +72,61 @@
     });
 }
 /**
+ * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.
+ * @see {@link raceCancellation}
+ */
+export function raceCancellationError(promise, token) {
+    return new Promise((resolve, reject) => {
+        const ref = token.onCancellationRequested(() => {
+            ref.dispose();
+            reject(new CancellationError());
+        });
+        promise.then(resolve, reject).finally(() => ref.dispose());
+    });
+}
+/**
+ * Returns as soon as one of the promises resolves or rejects and cancels remaining promises
+ */
+export function raceCancellablePromises(cancellablePromises) {
+    return __awaiter(this, void 0, void 0, function* () {
+        let resolvedPromiseIndex = -1;
+        const promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));
+        try {
+            const result = yield Promise.race(promises);
+            return result;
+        }
+        finally {
+            cancellablePromises.forEach((cancellablePromise, index) => {
+                if (index !== resolvedPromiseIndex) {
+                    cancellablePromise.cancel();
+                }
+            });
+        }
+    });
+}
+export function raceTimeout(promise, timeout, onTimeout) {
+    let promiseResolve = undefined;
+    const timer = setTimeout(() => {
+        promiseResolve === null || promiseResolve === void 0 ? void 0 : promiseResolve(undefined);
+        onTimeout === null || onTimeout === void 0 ? void 0 : onTimeout();
+    }, timeout);
+    return Promise.race([
+        promise.finally(() => clearTimeout(timer)),
+        new Promise(resolve => promiseResolve = resolve)
+    ]);
+}
+export function asPromise(callback) {
+    return new Promise((resolve, reject) => {
+        const item = callback();
+        if (isThenable(item)) {
+            item.then(resolve, reject);
+        }
+        else {
+            resolve(item);
+        }
+    });
+}
+/**
  * A helper to prevent accumulation of sequential async tasks.
  *
  * Imagine a mail man with the sole task of delivering letters. As soon as
@@ -142,6 +198,33 @@
         this.isDisposed = true;
     }
 }
+export class Sequencer {
+    constructor() {
+        this.current = Promise.resolve(null);
+    }
+    queue(promiseTask) {
+        return this.current = this.current.then(() => promiseTask(), () => promiseTask());
+    }
+}
+export class SequencerByKey {
+    constructor() {
+        this.promiseMap = new Map();
+    }
+    queue(key, promiseTask) {
+        var _a;
+        const runningPromise = (_a = this.promiseMap.get(key)) !== null && _a !== void 0 ? _a : Promise.resolve();
+        const newPromise = runningPromise
+            .catch(() => { })
+            .then(promiseTask)
+            .finally(() => {
+            if (this.promiseMap.get(key) === newPromise) {
+                this.promiseMap.delete(key);
+            }
+        });
+        this.promiseMap.set(key, newPromise);
+        return newPromise;
+    }
+}
 const timeoutDeferred = (timeout, fn) => {
     let scheduled = true;
     const handle = setTimeout(() => {
@@ -265,6 +348,9 @@
     trigger(promiseFactory, delay) {
         return this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay);
     }
+    isTriggered() {
+        return this.delayer.isTriggered();
+    }
     cancel() {
         this.delayer.cancel();
     }
@@ -273,6 +359,41 @@
         this.throttler.dispose();
     }
 }
+/**
+ * A barrier that is initially closed and then becomes opened permanently.
+ */
+export class Barrier {
+    constructor() {
+        this._isOpen = false;
+        this._promise = new Promise((c, e) => {
+            this._completePromise = c;
+        });
+    }
+    isOpen() {
+        return this._isOpen;
+    }
+    open() {
+        this._isOpen = true;
+        this._completePromise(true);
+    }
+    wait() {
+        return this._promise;
+    }
+}
+/**
+ * A barrier that is initially closed and then becomes opened permanently after a certain period of
+ * time or when open is called explicitly
+ */
+export class AutoOpenBarrier extends Barrier {
+    constructor(autoOpenTimeMs) {
+        super();
+        this._timeout = setTimeout(() => this.open(), autoOpenTimeMs);
+    }
+    open() {
+        clearTimeout(this._timeout);
+        super.open();
+    }
+}
 export function timeout(millis, token) {
     if (!token) {
         return createCancelablePromise(token => timeout(millis, token));
@@ -293,6 +414,29 @@
     const timer = setTimeout(handler, timeout);
     return toDisposable(() => clearTimeout(timer));
 }
+/**
+ * Runs the provided list of promise factories in sequential order. The returned
+ * promise will complete to an array of results from each promise.
+ */
+export function sequence(promiseFactories) {
+    const results = [];
+    let index = 0;
+    const len = promiseFactories.length;
+    function next() {
+        return index < len ? promiseFactories[index++]() : null;
+    }
+    function thenHandler(result) {
+        if (result !== undefined && result !== null) {
+            results.push(result);
+        }
+        const n = next();
+        if (n) {
+            return n.then(thenHandler);
+        }
+        return Promise.resolve(results);
+    }
+    return Promise.resolve(null).then(thenHandler);
+}
 export function first(promiseFactories, shouldStop = t => !!t, defaultValue = null) {
     let index = 0;
     const len = promiseFactories.length;
@@ -311,6 +455,169 @@
     };
     return loop();
 }
+export function firstParallel(promiseList, shouldStop = t => !!t, defaultValue = null) {
+    if (promiseList.length === 0) {
+        return Promise.resolve(defaultValue);
+    }
+    let todo = promiseList.length;
+    const finish = () => {
+        var _a, _b;
+        todo = -1;
+        for (const promise of promiseList) {
+            (_b = (_a = promise).cancel) === null || _b === void 0 ? void 0 : _b.call(_a);
+        }
+    };
+    return new Promise((resolve, reject) => {
+        for (const promise of promiseList) {
+            promise.then(result => {
+                if (--todo >= 0 && shouldStop(result)) {
+                    finish();
+                    resolve(result);
+                }
+                else if (todo === 0) {
+                    resolve(defaultValue);
+                }
+            })
+                .catch(err => {
+                if (--todo >= 0) {
+                    finish();
+                    reject(err);
+                }
+            });
+        }
+    });
+}
+/**
+ * A helper to queue N promises and run them all with a max degree of parallelism. The helper
+ * ensures that at any time no more than M promises are running at the same time.
+ */
+export class Limiter {
+    constructor(maxDegreeOfParalellism) {
+        this._size = 0;
+        this.maxDegreeOfParalellism = maxDegreeOfParalellism;
+        this.outstandingPromises = [];
+        this.runningPromises = 0;
+        this._onDrained = new Emitter();
+    }
+    /**
+     * An event that fires when every promise in the queue
+     * has started to execute. In other words: no work is
+     * pending to be scheduled.
+     *
+     * This is NOT an event that signals when all promises
+     * have finished though.
+     */
+    get onDrained() {
+        return this._onDrained.event;
+    }
+    get size() {
+        return this._size;
+    }
+    queue(factory) {
+        this._size++;
+        return new Promise((c, e) => {
+            this.outstandingPromises.push({ factory, c, e });
+            this.consume();
+        });
+    }
+    consume() {
+        while (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {
+            const iLimitedTask = this.outstandingPromises.shift();
+            this.runningPromises++;
+            const promise = iLimitedTask.factory();
+            promise.then(iLimitedTask.c, iLimitedTask.e);
+            promise.then(() => this.consumed(), () => this.consumed());
+        }
+    }
+    consumed() {
+        this._size--;
+        this.runningPromises--;
+        if (this.outstandingPromises.length > 0) {
+            this.consume();
+        }
+        else {
+            this._onDrained.fire();
+        }
+    }
+    dispose() {
+        this._onDrained.dispose();
+    }
+}
+/**
+ * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.
+ */
+export class Queue extends Limiter {
+    constructor() {
+        super(1);
+    }
+}
+/**
+ * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource
+ * by disposing them once the queue is empty.
+ */
+export class ResourceQueue {
+    constructor() {
+        this.queues = new Map();
+        this.drainers = new Set();
+    }
+    whenDrained() {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (this.isDrained()) {
+                return;
+            }
+            const promise = new DeferredPromise();
+            this.drainers.add(promise);
+            return promise.p;
+        });
+    }
+    isDrained() {
+        for (const [, queue] of this.queues) {
+            if (queue.size > 0) {
+                return false;
+            }
+        }
+        return true;
+    }
+    queueFor(resource, extUri = defaultExtUri) {
+        const key = extUri.getComparisonKey(resource);
+        let queue = this.queues.get(key);
+        if (!queue) {
+            queue = new Queue();
+            Event.once(queue.onDrained)(() => {
+                queue === null || queue === void 0 ? void 0 : queue.dispose();
+                this.queues.delete(key);
+                this.onDidQueueDrain();
+            });
+            this.queues.set(key, queue);
+        }
+        return queue;
+    }
+    onDidQueueDrain() {
+        if (!this.isDrained()) {
+            return; // not done yet
+        }
+        this.releaseDrainers();
+    }
+    releaseDrainers() {
+        for (const drainer of this.drainers) {
+            drainer.complete();
+        }
+        this.drainers.clear();
+    }
+    dispose() {
+        for (const [, queue] of this.queues) {
+            queue.dispose();
+        }
+        this.queues.clear();
+        // Even though we might still have pending
+        // tasks queued, after the queues have been
+        // disposed, we can no longer track them, so
+        // we release drainers to prevent hanging
+        // promises when the resource queue is being
+        // disposed.
+        this.releaseDrainers();
+    }
+}
 export class TimeoutTimer {
     constructor(runner, timeout) {
         this._token = -1;
@@ -407,6 +714,12 @@
     isScheduled() {
         return this.timeoutToken !== -1;
     }
+    flush() {
+        if (this.isScheduled()) {
+            this.cancel();
+            this.doRun();
+        }
+    }
     onTimeout() {
         this.timeoutToken = -1;
         if (this.runner) {
@@ -419,6 +732,166 @@
     }
 }
 /**
+ * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.
+ * > **NOTE**: Only offers 1s resolution.
+ *
+ * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep
+ * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But
+ * this scheduler will execute 3hrs **after waking the computer from sleep**.
+ */
+export class ProcessTimeRunOnceScheduler {
+    constructor(runner, delay) {
+        if (delay % 1000 !== 0) {
+            console.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);
+        }
+        this.runner = runner;
+        this.timeout = delay;
+        this.counter = 0;
+        this.intervalToken = -1;
+        this.intervalHandler = this.onInterval.bind(this);
+    }
+    dispose() {
+        this.cancel();
+        this.runner = null;
+    }
+    cancel() {
+        if (this.isScheduled()) {
+            clearInterval(this.intervalToken);
+            this.intervalToken = -1;
+        }
+    }
+    /**
+     * Cancel previous runner (if any) & schedule a new runner.
+     */
+    schedule(delay = this.timeout) {
+        if (delay % 1000 !== 0) {
+            console.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);
+        }
+        this.cancel();
+        this.counter = Math.ceil(delay / 1000);
+        this.intervalToken = setInterval(this.intervalHandler, 1000);
+    }
+    /**
+     * Returns true if scheduled.
+     */
+    isScheduled() {
+        return this.intervalToken !== -1;
+    }
+    onInterval() {
+        var _a;
+        this.counter--;
+        if (this.counter > 0) {
+            // still need to wait
+            return;
+        }
+        // time elapsed
+        clearInterval(this.intervalToken);
+        this.intervalToken = -1;
+        (_a = this.runner) === null || _a === void 0 ? void 0 : _a.call(this);
+    }
+}
+export class RunOnceWorker extends RunOnceScheduler {
+    constructor(runner, timeout) {
+        super(runner, timeout);
+        this.units = [];
+    }
+    work(unit) {
+        this.units.push(unit);
+        if (!this.isScheduled()) {
+            this.schedule();
+        }
+    }
+    doRun() {
+        var _a;
+        const units = this.units;
+        this.units = [];
+        (_a = this.runner) === null || _a === void 0 ? void 0 : _a.call(this, units);
+    }
+    dispose() {
+        this.units = [];
+        super.dispose();
+    }
+}
+/**
+ * The `ThrottledWorker` will accept units of work `T`
+ * to handle. The contract is:
+ * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)
+ * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)
+ * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)
+ */
+export class ThrottledWorker extends Disposable {
+    constructor(options, handler) {
+        super();
+        this.options = options;
+        this.handler = handler;
+        this.pendingWork = [];
+        this.throttler = this._register(new MutableDisposable());
+        this.disposed = false;
+    }
+    /**
+     * The number of work units that are pending to be processed.
+     */
+    get pending() { return this.pendingWork.length; }
+    /**
+     * Add units to be worked on. Use `pending` to figure out
+     * how many units are not yet processed after this method
+     * was called.
+     *
+     * @returns whether the work was accepted or not. If the
+     * worker is disposed, it will not accept any more work.
+     * If the number of pending units would become larger
+     * than `maxPendingWork`, more work will also not be accepted.
+     */
+    work(units) {
+        if (this.disposed) {
+            return false; // work not accepted: disposed
+        }
+        // Check for reaching maximum of pending work
+        if (typeof this.options.maxBufferedWork === 'number') {
+            // Throttled: simple check if pending + units exceeds max pending
+            if (this.throttler.value) {
+                if (this.pending + units.length > this.options.maxBufferedWork) {
+                    return false; // work not accepted: too much pending work
+                }
+            }
+            // Unthrottled: same as throttled, but account for max chunk getting
+            // worked on directly without being pending
+            else {
+                if (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {
+                    return false; // work not accepted: too much pending work
+                }
+            }
+        }
+        // Add to pending units first
+        for (const unit of units) {
+            this.pendingWork.push(unit);
+        }
+        // If not throttled, start working directly
+        // Otherwise, when the throttle delay has
+        // past, pending work will be worked again.
+        if (!this.throttler.value) {
+            this.doWork();
+        }
+        return true; // work accepted
+    }
+    doWork() {
+        // Extract chunk to handle and handle it
+        this.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize));
+        // If we have remaining work, schedule it after a delay
+        if (this.pendingWork.length > 0) {
+            this.throttler.value = new RunOnceScheduler(() => {
+                this.throttler.clear();
+                this.doWork();
+            }, this.options.throttleDelay);
+            this.throttler.value.schedule();
+        }
+    }
+    dispose() {
+        super.dispose();
+        this.disposed = true;
+    }
+}
+/**
  * Execute the callback the next time the browser is idle, returning an
  * {@link IDisposable} that will cancel the callback when disposed. This wraps
  * [requestIdleCallback] so it will fallback to [setTimeout] if the environment
@@ -516,6 +989,123 @@
         return this._didRun;
     }
 }
+//#endregion
+export function retry(task, delay, retries) {
+    return __awaiter(this, void 0, void 0, function* () {
+        let lastError;
+        for (let i = 0; i < retries; i++) {
+            try {
+                return yield task();
+            }
+            catch (error) {
+                lastError = error;
+                yield timeout(delay);
+            }
+        }
+        throw lastError;
+    });
+}
+export class TaskSequentializer {
+    hasPending(taskId) {
+        if (!this._pending) {
+            return false;
+        }
+        if (typeof taskId === 'number') {
+            return this._pending.taskId === taskId;
+        }
+        return !!this._pending;
+    }
+    get pending() {
+        var _a;
+        return (_a = this._pending) === null || _a === void 0 ? void 0 : _a.promise;
+    }
+    cancelPending() {
+        var _a;
+        (_a = this._pending) === null || _a === void 0 ? void 0 : _a.cancel();
+    }
+    setPending(taskId, promise, onCancel) {
+        this._pending = { taskId, cancel: () => onCancel === null || onCancel === void 0 ? void 0 : onCancel(), promise };
+        promise.then(() => this.donePending(taskId), () => this.donePending(taskId));
+        return promise;
+    }
+    donePending(taskId) {
+        if (this._pending && taskId === this._pending.taskId) {
+            // only set pending to done if the promise finished that is associated with that taskId
+            this._pending = undefined;
+            // schedule the next task now that we are free if we have any
+            this.triggerNext();
+        }
+    }
+    triggerNext() {
+        if (this._next) {
+            const next = this._next;
+            this._next = undefined;
+            // Run next task and complete on the associated promise
+            next.run().then(next.promiseResolve, next.promiseReject);
+        }
+    }
+    setNext(run) {
+        // this is our first next task, so we create associated promise with it
+        // so that we can return a promise that completes when the task has
+        // completed.
+        if (!this._next) {
+            let promiseResolve;
+            let promiseReject;
+            const promise = new Promise((resolve, reject) => {
+                promiseResolve = resolve;
+                promiseReject = reject;
+            });
+            this._next = {
+                run,
+                promise,
+                promiseResolve: promiseResolve,
+                promiseReject: promiseReject
+            };
+        }
+        // we have a previous next task, just overwrite it
+        else {
+            this._next.run = run;
+        }
+        return this._next.promise;
+    }
+    hasNext() {
+        return !!this._next;
+    }
+    join() {
+        var _a, _b, _c;
+        return __awaiter(this, void 0, void 0, function* () {
+            return (_b = (_a = this._next) === null || _a === void 0 ? void 0 : _a.promise) !== null && _b !== void 0 ? _b : (_c = this._pending) === null || _c === void 0 ? void 0 : _c.promise;
+        });
+    }
+}
+//#endregion
+//#region
+/**
+ * The `IntervalCounter` allows to count the number
+ * of calls to `increment()` over a duration of
+ * `interval`. This utility can be used to conditionally
+ * throttle a frequent task when a certain threshold
+ * is reached.
+ */
+export class IntervalCounter {
+    constructor(interval, nowFn = () => Date.now()) {
+        this.interval = interval;
+        this.nowFn = nowFn;
+        this.lastIncrementTime = 0;
+        this.value = 0;
+    }
+    increment() {
+        const now = this.nowFn();
+        // We are outside of the range of `interval` and as such
+        // start counting from 0 and remember the time
+        if (now - this.lastIncrementTime > this.interval) {
+            this.lastIncrementTime = now;
+            this.value = 0;
+        }
+        this.value++;
+        return this.value;
+    }
+}
 /**
  * Creates a promise whose resolution or rejection can be controlled imperatively.
  */
@@ -524,9 +1114,17 @@
         var _a;
         return ((_a = this.outcome) === null || _a === void 0 ? void 0 : _a.outcome) === 1 /* DeferredOutcome.Rejected */;
     }
+    get isResolved() {
+        var _a;
+        return ((_a = this.outcome) === null || _a === void 0 ? void 0 : _a.outcome) === 0 /* DeferredOutcome.Resolved */;
+    }
     get isSettled() {
         return !!this.outcome;
     }
+    get value() {
+        var _a, _b;
+        return ((_a = this.outcome) === null || _a === void 0 ? void 0 : _a.outcome) === 0 /* DeferredOutcome.Resolved */ ? (_b = this.outcome) === null || _b === void 0 ? void 0 : _b.value : undefined;
+    }
     constructor() {
         this.p = new Promise((c, e) => {
             this.completeCallback = c;
diff -urN -x '*.map' a/vs/base/common/buffer.js b/vs/base/common/buffer.js
--- a/vs/base/common/buffer.js	2023-09-05 08:43:04.214808143 +0000
+++ b/vs/base/common/buffer.js	2023-09-05 08:45:14.301196405 +0000
@@ -2,12 +2,35 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
 import { Lazy } from './lazy.js';
+import * as streams from './stream.js';
 const hasBuffer = (typeof Buffer !== 'undefined');
 const indexOfTable = new Lazy(() => new Uint8Array(256));
+let textEncoder;
 let textDecoder;
 export class VSBuffer {
     /**
+     * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
+     * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
+     */
+    static alloc(byteLength) {
+        if (hasBuffer) {
+            return new VSBuffer(Buffer.allocUnsafe(byteLength));
+        }
+        else {
+            return new VSBuffer(new Uint8Array(byteLength));
+        }
+    }
+    /**
      * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for
      * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,
      * which is not transferrable.
@@ -20,10 +43,66 @@
         }
         return new VSBuffer(actual);
     }
+    /**
+     * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
+     * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
+     */
+    static fromString(source, options) {
+        const dontUseNodeBuffer = (options === null || options === void 0 ? void 0 : options.dontUseNodeBuffer) || false;
+        if (!dontUseNodeBuffer && hasBuffer) {
+            return new VSBuffer(Buffer.from(source));
+        }
+        else {
+            if (!textEncoder) {
+                textEncoder = new TextEncoder();
+            }
+            return new VSBuffer(textEncoder.encode(source));
+        }
+    }
+    /**
+     * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
+     * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
+     */
+    static fromByteArray(source) {
+        const result = VSBuffer.alloc(source.length);
+        for (let i = 0, len = source.length; i < len; i++) {
+            result.buffer[i] = source[i];
+        }
+        return result;
+    }
+    /**
+     * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
+     * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
+     */
+    static concat(buffers, totalLength) {
+        if (typeof totalLength === 'undefined') {
+            totalLength = 0;
+            for (let i = 0, len = buffers.length; i < len; i++) {
+                totalLength += buffers[i].byteLength;
+            }
+        }
+        const ret = VSBuffer.alloc(totalLength);
+        let offset = 0;
+        for (let i = 0, len = buffers.length; i < len; i++) {
+            const element = buffers[i];
+            ret.set(element, offset);
+            offset += element.byteLength;
+        }
+        return ret;
+    }
     constructor(buffer) {
         this.buffer = buffer;
         this.byteLength = this.buffer.byteLength;
     }
+    /**
+     * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
+     * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
+     */
+    clone() {
+        const result = VSBuffer.alloc(this.byteLength);
+        result.set(this);
+        return result;
+    }
     toString() {
         if (hasBuffer) {
             return this.buffer.toString();
@@ -35,6 +114,91 @@
             return textDecoder.decode(this.buffer);
         }
     }
+    slice(start, end) {
+        // IMPORTANT: use subarray instead of slice because TypedArray#slice
+        // creates shallow copy and NodeBuffer#slice doesn't. The use of subarray
+        // ensures the same, performance, behaviour.
+        return new VSBuffer(this.buffer.subarray(start, end));
+    }
+    set(array, offset) {
+        if (array instanceof VSBuffer) {
+            this.buffer.set(array.buffer, offset);
+        }
+        else if (array instanceof Uint8Array) {
+            this.buffer.set(array, offset);
+        }
+        else if (array instanceof ArrayBuffer) {
+            this.buffer.set(new Uint8Array(array), offset);
+        }
+        else if (ArrayBuffer.isView(array)) {
+            this.buffer.set(new Uint8Array(array.buffer, array.byteOffset, array.byteLength), offset);
+        }
+        else {
+            throw new Error(`Unknown argument 'array'`);
+        }
+    }
+    readUInt32BE(offset) {
+        return readUInt32BE(this.buffer, offset);
+    }
+    writeUInt32BE(value, offset) {
+        writeUInt32BE(this.buffer, value, offset);
+    }
+    readUInt32LE(offset) {
+        return readUInt32LE(this.buffer, offset);
+    }
+    writeUInt32LE(value, offset) {
+        writeUInt32LE(this.buffer, value, offset);
+    }
+    readUInt8(offset) {
+        return readUInt8(this.buffer, offset);
+    }
+    writeUInt8(value, offset) {
+        writeUInt8(this.buffer, value, offset);
+    }
+    indexOf(subarray, offset = 0) {
+        return binaryIndexOf(this.buffer, subarray instanceof VSBuffer ? subarray.buffer : subarray, offset);
+    }
+}
+/**
+ * Like String.indexOf, but works on Uint8Arrays.
+ * Uses the boyer-moore-horspool algorithm to be reasonably speedy.
+ */
+export function binaryIndexOf(haystack, needle, offset = 0) {
+    const needleLen = needle.byteLength;
+    const haystackLen = haystack.byteLength;
+    if (needleLen === 0) {
+        return 0;
+    }
+    if (needleLen === 1) {
+        return haystack.indexOf(needle[0]);
+    }
+    if (needleLen > haystackLen - offset) {
+        return -1;
+    }
+    // find index of the subarray using boyer-moore-horspool algorithm
+    const table = indexOfTable.value;
+    table.fill(needle.length);
+    for (let i = 0; i < needle.length; i++) {
+        table[needle[i]] = needle.length - i - 1;
+    }
+    let i = offset + needle.length - 1;
+    let j = i;
+    let result = -1;
+    while (i < haystackLen) {
+        if (haystack[i] === needle[j]) {
+            if (j === 0) {
+                result = i;
+                break;
+            }
+            i--;
+            j--;
+        }
+        else {
+            i += Math.max(needle.length - j, table[haystack[i]]);
+            j = needle.length - 1;
+        }
+    }
+    return result;
 }
 export function readUInt16LE(source, offset) {
     return (((source[offset + 0] << 0) >>> 0) |
@@ -60,9 +224,160 @@
     value = value >>> 8;
     destination[offset] = value;
 }
+export function readUInt32LE(source, offset) {
+    return (((source[offset + 0] << 0) >>> 0) |
+        ((source[offset + 1] << 8) >>> 0) |
+        ((source[offset + 2] << 16) >>> 0) |
+        ((source[offset + 3] << 24) >>> 0));
+}
+export function writeUInt32LE(destination, value, offset) {
+    destination[offset + 0] = (value & 0b11111111);
+    value = value >>> 8;
+    destination[offset + 1] = (value & 0b11111111);
+    value = value >>> 8;
+    destination[offset + 2] = (value & 0b11111111);
+    value = value >>> 8;
+    destination[offset + 3] = (value & 0b11111111);
+}
 export function readUInt8(source, offset) {
     return source[offset];
 }
 export function writeUInt8(destination, value, offset) {
     destination[offset] = value;
 }
+export function readableToBuffer(readable) {
+    return streams.consumeReadable(readable, chunks => VSBuffer.concat(chunks));
+}
+export function bufferToReadable(buffer) {
+    return streams.toReadable(buffer);
+}
+export function streamToBuffer(stream) {
+    return streams.consumeStream(stream, chunks => VSBuffer.concat(chunks));
+}
+export function bufferedStreamToBuffer(bufferedStream) {
+    return __awaiter(this, void 0, void 0, function* () {
+        if (bufferedStream.ended) {
+            return VSBuffer.concat(bufferedStream.buffer);
+        }
+        return VSBuffer.concat([
+            // Include already read chunks...
+            ...bufferedStream.buffer,
+            // ...and all additional chunks
+            yield streamToBuffer(bufferedStream.stream)
+        ]);
+    });
+}
+export function bufferToStream(buffer) {
+    return streams.toStream(buffer, chunks => VSBuffer.concat(chunks));
+}
+export function streamToBufferReadableStream(stream) {
+    return streams.transform(stream, { data: data => typeof data === 'string' ? VSBuffer.fromString(data) : VSBuffer.wrap(data) }, chunks => VSBuffer.concat(chunks));
+}
+export function newWriteableBufferStream(options) {
+    return streams.newWriteableStream(chunks => VSBuffer.concat(chunks), options);
+}
+export function prefixedBufferReadable(prefix, readable) {
+    return streams.prefixedReadable(prefix, readable, chunks => VSBuffer.concat(chunks));
+}
+export function prefixedBufferStream(prefix, stream) {
+    return streams.prefixedStream(prefix, stream, chunks => VSBuffer.concat(chunks));
+}
+/** Decodes base64 to a uint8 array. URL-encoded and unpadded base64 is allowed. */
+export function decodeBase64(encoded) {
+    let building = 0;
+    let remainder = 0;
+    let bufi = 0;
+    // The simpler way to do this is `Uint8Array.from(atob(str), c => c.charCodeAt(0))`,
+    // but that's about 10-20x slower than this function in current Chromium versions.
+    const buffer = new Uint8Array(Math.floor(encoded.length / 4 * 3));
+    const append = (value) => {
+        switch (remainder) {
+            case 3:
+                buffer[bufi++] = building | value;
+                remainder = 0;
+                break;
+            case 2:
+                buffer[bufi++] = building | (value >>> 2);
+                building = value << 6;
+                remainder = 3;
+                break;
+            case 1:
+                buffer[bufi++] = building | (value >>> 4);
+                building = value << 4;
+                remainder = 2;
+                break;
+            default:
+                building = value << 2;
+                remainder = 1;
+        }
+    };
+    for (let i = 0; i < encoded.length; i++) {
+        const code = encoded.charCodeAt(i);
+        // See https://datatracker.ietf.org/doc/html/rfc4648#section-4
+        // This branchy code is about 3x faster than an indexOf on a base64 char string.
+        if (code >= 65 && code <= 90) {
+            append(code - 65); // A-Z starts ranges from char code 65 to 90
+        }
+        else if (code >= 97 && code <= 122) {
+            append(code - 97 + 26); // a-z starts ranges from char code 97 to 122, starting at byte 26
+        }
+        else if (code >= 48 && code <= 57) {
+            append(code - 48 + 52); // 0-9 starts ranges from char code 48 to 58, starting at byte 52
+        }
+        else if (code === 43 || code === 45) {
+            append(62); // "+" or "-" for URLS
+        }
+        else if (code === 47 || code === 95) {
+            append(63); // "/" or "_" for URLS
+        }
+        else if (code === 61) {
+            break; // "="
+        }
+        else {
+            throw new SyntaxError(`Unexpected base64 character ${encoded[i]}`);
+        }
+    }
+    const unpadded = bufi;
+    while (remainder > 0) {
+        append(0);
+    }
+    // slice is needed to account for overestimation due to padding
+    return VSBuffer.wrap(buffer).slice(0, unpadded);
+}
+const base64Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
+const base64UrlSafeAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
+/** Encodes a buffer to a base64 string. */
+export function encodeBase64({ buffer }, padded = true, urlSafe = false) {
+    const dictionary = urlSafe ? base64UrlSafeAlphabet : base64Alphabet;
+    let output = '';
+    const remainder = buffer.byteLength % 3;
+    let i = 0;
+    for (; i < buffer.byteLength - remainder; i += 3) {
+        const a = buffer[i + 0];
+        const b = buffer[i + 1];
+        const c = buffer[i + 2];
+        output += dictionary[a >>> 2];
+        output += dictionary[(a << 4 | b >>> 4) & 0b111111];
+        output += dictionary[(b << 2 | c >>> 6) & 0b111111];
+        output += dictionary[c & 0b111111];
+    }
+    if (remainder === 1) {
+        const a = buffer[i + 0];
+        output += dictionary[a >>> 2];
+        output += dictionary[(a << 4) & 0b111111];
+        if (padded) {
+            output += '==';
+        }
+    }
+    else if (remainder === 2) {
+        const a = buffer[i + 0];
+        const b = buffer[i + 1];
+        output += dictionary[a >>> 2];
+        output += dictionary[(a << 4 | b >>> 4) & 0b111111];
+        output += dictionary[(b << 2) & 0b111111];
+        if (padded) {
+            output += '=';
+        }
+    }
+    return output;
+}
diff -urN -x '*.map' a/vs/base/common/cache.js b/vs/base/common/cache.js
--- a/vs/base/common/cache.js	2023-09-05 08:43:04.214808143 +0000
+++ b/vs/base/common/cache.js	2023-09-05 08:45:14.297196348 +0000
@@ -1,3 +1,30 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { CancellationTokenSource } from './cancellation.js';
+export class Cache {
+    constructor(task) {
+        this.task = task;
+        this.result = null;
+    }
+    get() {
+        if (this.result) {
+            return this.result;
+        }
+        const cts = new CancellationTokenSource();
+        const promise = this.task(cts.token);
+        this.result = {
+            promise,
+            dispose: () => {
+                this.result = null;
+                cts.cancel();
+                cts.dispose();
+            }
+        };
+        return this.result;
+    }
+}
 /**
  * Uses a LRU cache to make a given parametrized function cached.
  * Caches just the last value.
diff -urN -x '*.map' a/vs/base/common/codicons.js b/vs/base/common/codicons.js
--- a/vs/base/common/codicons.js	2023-09-05 08:43:04.214808143 +0000
+++ b/vs/base/common/codicons.js	2023-09-05 08:45:14.297196348 +0000
@@ -18,6 +18,12 @@
     return _codiconFontCharacters;
 }
 /**
+ * Only to be used by the iconRegistry.
+ */
+export function getAllCodicons() {
+    return Object.values(Codicon);
+}
+/**
  * The Codicon library is a set of default icons that are built-in in VS Code.
  *
  * In the product (outside of base) Codicons should only be used as defaults. In order to have all icons in VS Code
diff -urN -x '*.map' a/vs/base/common/collections.js b/vs/base/common/collections.js
--- a/vs/base/common/collections.js	2023-09-05 08:43:04.218808244 +0000
+++ b/vs/base/common/collections.js	2023-09-05 08:45:14.297196348 +0000
@@ -2,6 +2,52 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
+/**
+ * Groups the collection into a dictionary based on the provided
+ * group function.
+ */
+export function groupBy(data, groupFn) {
+    const result = Object.create(null);
+    for (const element of data) {
+        const key = groupFn(element);
+        let target = result[key];
+        if (!target) {
+            target = result[key] = [];
+        }
+        target.push(element);
+    }
+    return result;
+}
+export function diffSets(before, after) {
+    const removed = [];
+    const added = [];
+    for (const element of before) {
+        if (!after.has(element)) {
+            removed.push(element);
+        }
+    }
+    for (const element of after) {
+        if (!before.has(element)) {
+            added.push(element);
+        }
+    }
+    return { removed, added };
+}
+export function diffMaps(before, after) {
+    const removed = [];
+    const added = [];
+    for (const [index, value] of before) {
+        if (!after.has(index)) {
+            removed.push(value);
+        }
+    }
+    for (const [index, value] of after) {
+        if (!before.has(index)) {
+            added.push(value);
+        }
+    }
+    return { removed, added };
+}
 export class SetMap {
     constructor() {
         this.map = new Map();
diff -urN -x '*.map' a/vs/base/common/color.js b/vs/base/common/color.js
--- a/vs/base/common/color.js	2023-09-05 08:43:04.218808244 +0000
+++ b/vs/base/common/color.js	2023-09-05 08:45:14.301196405 +0000
@@ -242,6 +242,23 @@
         return (c <= 0.03928) ? c / 12.92 : Math.pow(((c + 0.055) / 1.055), 2.4);
     }
     /**
+     * http://www.w3.org/TR/WCAG20/#contrast-ratiodef
+     * Returns the contrast ration number in the set [1, 21].
+     */
+    getContrastRatio(another) {
+        const lum1 = this.getRelativeLuminance();
+        const lum2 = another.getRelativeLuminance();
+        return lum1 > lum2 ? (lum1 + 0.05) / (lum2 + 0.05) : (lum2 + 0.05) / (lum1 + 0.05);
+    }
+    /**
+     *	http://24ways.org/2010/calculating-color-contrast
+     *  Return 'true' if darker color otherwise 'false'
+     */
+    isDarker() {
+        const yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1000;
+        return yiq < 128;
+    }
+    /**
      *	http://24ways.org/2010/calculating-color-contrast
      *  Return 'true' if lighter color otherwise 'false'
      */
@@ -278,6 +295,20 @@
     opposite() {
         return new Color(new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
     }
+    blend(c) {
+        const rgba = c.rgba;
+        // Convert to 0..1 opacity
+        const thisA = this.rgba.a;
+        const colorA = rgba.a;
+        const a = thisA + colorA * (1 - thisA);
+        if (a < 1e-6) {
+            return Color.transparent;
+        }
+        const r = this.rgba.r * thisA / a + rgba.r * colorA * (1 - thisA) / a;
+        const g = this.rgba.g * thisA / a + rgba.g * colorA * (1 - thisA) / a;
+        const b = this.rgba.b * thisA / a + rgba.b * colorA * (1 - thisA) / a;
+        return new Color(new RGBA(r, g, b, a));
+    }
     makeOpaque(opaqueBackground) {
         if (this.isOpaque() || opaqueBackground.rgba.a !== 1) {
             // only allow to blend onto a non-opaque color onto a opaque color
@@ -287,6 +318,16 @@
         // https://stackoverflow.com/questions/12228548/finding-equivalent-color-with-opacity
         return new Color(new RGBA(opaqueBackground.rgba.r - a * (opaqueBackground.rgba.r - r), opaqueBackground.rgba.g - a * (opaqueBackground.rgba.g - g), opaqueBackground.rgba.b - a * (opaqueBackground.rgba.b - b), 1));
     }
+    flatten(...backgrounds) {
+        const background = backgrounds.reduceRight((accumulator, color) => {
+            return Color._flatten(color, accumulator);
+        });
+        return Color._flatten(this, background);
+    }
+    static _flatten(foreground, background) {
+        const backgroundAlpha = 1 - foreground.rgba.a;
+        return new Color(new RGBA(backgroundAlpha * background.rgba.r + foreground.rgba.a * foreground.rgba.r, backgroundAlpha * background.rgba.g + foreground.rgba.a * foreground.rgba.g, backgroundAlpha * background.rgba.b + foreground.rgba.a * foreground.rgba.b));
+    }
     toString() {
         if (!this._toString) {
             this._toString = Color.Format.CSS.format(this);
diff -urN -x '*.map' a/vs/base/common/comparers.js b/vs/base/common/comparers.js
--- a/vs/base/common/comparers.js	2023-09-05 08:43:04.218808244 +0000
+++ b/vs/base/common/comparers.js	2023-09-05 08:45:14.301196405 +0000
@@ -3,6 +3,7 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import { Lazy } from './lazy.js';
+import { sep } from './path.js';
 // When comparing large numbers of strings it's better for performance to create an
 // Intl.Collator object and use the function provided by its compare property
 // than it is to use String.prototype.localeCompare()
@@ -39,6 +40,211 @@
     }
     return result;
 }
+/** Compares full filenames without grouping by case. */
+export function compareFileNamesDefault(one, other) {
+    const collatorNumeric = intlFileNameCollatorNumeric.value.collator;
+    one = one || '';
+    other = other || '';
+    return compareAndDisambiguateByLength(collatorNumeric, one, other);
+}
+/** Compares full filenames grouping uppercase names before lowercase. */
+export function compareFileNamesUpper(one, other) {
+    const collatorNumeric = intlFileNameCollatorNumeric.value.collator;
+    one = one || '';
+    other = other || '';
+    return compareCaseUpperFirst(one, other) || compareAndDisambiguateByLength(collatorNumeric, one, other);
+}
+/** Compares full filenames grouping lowercase names before uppercase. */
+export function compareFileNamesLower(one, other) {
+    const collatorNumeric = intlFileNameCollatorNumeric.value.collator;
+    one = one || '';
+    other = other || '';
+    return compareCaseLowerFirst(one, other) || compareAndDisambiguateByLength(collatorNumeric, one, other);
+}
+/** Compares full filenames by unicode value. */
+export function compareFileNamesUnicode(one, other) {
+    one = one || '';
+    other = other || '';
+    if (one === other) {
+        return 0;
+    }
+    return one < other ? -1 : 1;
+}
+/** Compares filenames by extension, then by name. Disambiguates by unicode comparison. */
+export function compareFileExtensions(one, other) {
+    const [oneName, oneExtension] = extractNameAndExtension(one);
+    const [otherName, otherExtension] = extractNameAndExtension(other);
+    let result = intlFileNameCollatorBaseNumeric.value.collator.compare(oneExtension, otherExtension);
+    if (result === 0) {
+        // Using the numeric option will  make compare(`foo1`, `foo01`) === 0. Disambiguate.
+        if (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && oneExtension !== otherExtension) {
+            return oneExtension < otherExtension ? -1 : 1;
+        }
+        // Extensions are equal, compare filenames
+        result = intlFileNameCollatorBaseNumeric.value.collator.compare(oneName, otherName);
+        if (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && result === 0 && oneName !== otherName) {
+            return oneName < otherName ? -1 : 1;
+        }
+    }
+    return result;
+}
+/** Compares filenames by extension, then by full filename. Mixes uppercase and lowercase names together. */
+export function compareFileExtensionsDefault(one, other) {
+    one = one || '';
+    other = other || '';
+    const oneExtension = extractExtension(one);
+    const otherExtension = extractExtension(other);
+    const collatorNumeric = intlFileNameCollatorNumeric.value.collator;
+    const collatorNumericCaseInsensitive = intlFileNameCollatorNumericCaseInsensitive.value.collator;
+    return compareAndDisambiguateByLength(collatorNumericCaseInsensitive, oneExtension, otherExtension) ||
+        compareAndDisambiguateByLength(collatorNumeric, one, other);
+}
+/** Compares filenames by extension, then case, then full filename. Groups uppercase names before lowercase. */
+export function compareFileExtensionsUpper(one, other) {
+    one = one || '';
+    other = other || '';
+    const oneExtension = extractExtension(one);
+    const otherExtension = extractExtension(other);
+    const collatorNumeric = intlFileNameCollatorNumeric.value.collator;
+    const collatorNumericCaseInsensitive = intlFileNameCollatorNumericCaseInsensitive.value.collator;
+    return compareAndDisambiguateByLength(collatorNumericCaseInsensitive, oneExtension, otherExtension) ||
+        compareCaseUpperFirst(one, other) ||
+        compareAndDisambiguateByLength(collatorNumeric, one, other);
+}
+/** Compares filenames by extension, then case, then full filename. Groups lowercase names before uppercase. */
+export function compareFileExtensionsLower(one, other) {
+    one = one || '';
+    other = other || '';
+    const oneExtension = extractExtension(one);
+    const otherExtension = extractExtension(other);
+    const collatorNumeric = intlFileNameCollatorNumeric.value.collator;
+    const collatorNumericCaseInsensitive = intlFileNameCollatorNumericCaseInsensitive.value.collator;
+    return compareAndDisambiguateByLength(collatorNumericCaseInsensitive, oneExtension, otherExtension) ||
+        compareCaseLowerFirst(one, other) ||
+        compareAndDisambiguateByLength(collatorNumeric, one, other);
+}
+/** Compares filenames by case-insensitive extension unicode value, then by full filename unicode value. */
+export function compareFileExtensionsUnicode(one, other) {
+    one = one || '';
+    other = other || '';
+    const oneExtension = extractExtension(one).toLowerCase();
+    const otherExtension = extractExtension(other).toLowerCase();
+    // Check for extension differences
+    if (oneExtension !== otherExtension) {
+        return oneExtension < otherExtension ? -1 : 1;
+    }
+    // Check for full filename differences.
+    if (one !== other) {
+        return one < other ? -1 : 1;
+    }
+    return 0;
+}
+const FileNameMatch = /^(.*?)(\.([^.]*))?$/;
+/** Extracts the name and extension from a full filename, with optional special handling for dotfiles */
+function extractNameAndExtension(str, dotfilesAsNames = false) {
+    const match = str ? FileNameMatch.exec(str) : [];
+    let result = [(match && match[1]) || '', (match && match[3]) || ''];
+    // if the dotfilesAsNames option is selected, treat an empty filename with an extension
+    // or a filename that starts with a dot, as a dotfile name
+    if (dotfilesAsNames && (!result[0] && result[1] || result[0] && result[0].charAt(0) === '.')) {
+        result = [result[0] + '.' + result[1], ''];
+    }
+    return result;
+}
+/** Extracts the extension from a full filename. Treats dotfiles as names, not extensions. */
+function extractExtension(str) {
+    const match = str ? FileNameMatch.exec(str) : [];
+    return (match && match[1] && match[1].charAt(0) !== '.' && match[3]) || '';
+}
+function compareAndDisambiguateByLength(collator, one, other) {
+    // Check for differences
+    const result = collator.compare(one, other);
+    if (result !== 0) {
+        return result;
+    }
+    // In a numeric comparison, `foo1` and `foo01` will compare as equivalent.
+    // Disambiguate by sorting the shorter string first.
+    if (one.length !== other.length) {
+        return one.length < other.length ? -1 : 1;
+    }
+    return 0;
+}
+/** @returns `true` if the string is starts with a lowercase letter. Otherwise, `false`. */
+function startsWithLower(string) {
+    const character = string.charAt(0);
+    return (character.toLocaleUpperCase() !== character) ? true : false;
+}
+/** @returns `true` if the string starts with an uppercase letter. Otherwise, `false`. */
+function startsWithUpper(string) {
+    const character = string.charAt(0);
+    return (character.toLocaleLowerCase() !== character) ? true : false;
+}
+/**
+ * Compares the case of the provided strings - lowercase before uppercase
+ *
+ * @returns
+ * ```text
+ *   -1 if one is lowercase and other is uppercase
+ *    1 if one is uppercase and other is lowercase
+ *    0 otherwise
+ * ```
+ */
+function compareCaseLowerFirst(one, other) {
+    if (startsWithLower(one) && startsWithUpper(other)) {
+        return -1;
+    }
+    return (startsWithUpper(one) && startsWithLower(other)) ? 1 : 0;
+}
+/**
+ * Compares the case of the provided strings - uppercase before lowercase
+ *
+ * @returns
+ * ```text
+ *   -1 if one is uppercase and other is lowercase
+ *    1 if one is lowercase and other is uppercase
+ *    0 otherwise
+ * ```
+ */
+function compareCaseUpperFirst(one, other) {
+    if (startsWithUpper(one) && startsWithLower(other)) {
+        return -1;
+    }
+    return (startsWithLower(one) && startsWithUpper(other)) ? 1 : 0;
+}
+function comparePathComponents(one, other, caseSensitive = false) {
+    if (!caseSensitive) {
+        one = one && one.toLowerCase();
+        other = other && other.toLowerCase();
+    }
+    if (one === other) {
+        return 0;
+    }
+    return one < other ? -1 : 1;
+}
+export function comparePaths(one, other, caseSensitive = false) {
+    const oneParts = one.split(sep);
+    const otherParts = other.split(sep);
+    const lastOne = oneParts.length - 1;
+    const lastOther = otherParts.length - 1;
+    let endOne, endOther;
+    for (let i = 0;; i++) {
+        endOne = lastOne === i;
+        endOther = lastOther === i;
+        if (endOne && endOther) {
+            return compareFileNames(oneParts[i], otherParts[i], caseSensitive);
+        }
+        else if (endOne) {
+            return -1;
+        }
+        else if (endOther) {
+            return 1;
+        }
+        const result = comparePathComponents(oneParts[i], otherParts[i], caseSensitive);
+        if (result !== 0) {
+            return result;
+        }
+    }
+}
 export function compareAnything(one, other, lookFor) {
     const elementAName = one.toLowerCase();
     const elementBName = other.toLowerCase();
diff -urN -x '*.map' a/vs/base/common/decorators.js b/vs/base/common/decorators.js
--- a/vs/base/common/decorators.js	2023-09-05 08:43:04.218808244 +0000
+++ b/vs/base/common/decorators.js	2023-09-05 08:45:14.297196348 +0000
@@ -1,3 +1,25 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+function createDecorator(mapFn) {
+    return (target, key, descriptor) => {
+        let fnKey = null;
+        let fn = null;
+        if (typeof descriptor.value === 'function') {
+            fnKey = 'value';
+            fn = descriptor.value;
+        }
+        else if (typeof descriptor.get === 'function') {
+            fnKey = 'get';
+            fn = descriptor.get;
+        }
+        if (!fn) {
+            throw new Error('not supported');
+        }
+        descriptor[fnKey] = mapFn(fn, key);
+    };
+}
 export function memoize(_target, key, descriptor) {
     let fnKey = null;
     let fn = null;
@@ -28,3 +50,60 @@
         return this[memoizeKey];
     };
 }
+export function debounce(delay, reducer, initialValueProvider) {
+    return createDecorator((fn, key) => {
+        const timerKey = `$debounce$${key}`;
+        const resultKey = `$debounce$result$${key}`;
+        return function (...args) {
+            if (!this[resultKey]) {
+                this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;
+            }
+            clearTimeout(this[timerKey]);
+            if (reducer) {
+                this[resultKey] = reducer(this[resultKey], ...args);
+                args = [this[resultKey]];
+            }
+            this[timerKey] = setTimeout(() => {
+                fn.apply(this, args);
+                this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;
+            }, delay);
+        };
+    });
+}
+export function throttle(delay, reducer, initialValueProvider) {
+    return createDecorator((fn, key) => {
+        const timerKey = `$throttle$timer$${key}`;
+        const resultKey = `$throttle$result$${key}`;
+        const lastRunKey = `$throttle$lastRun$${key}`;
+        const pendingKey = `$throttle$pending$${key}`;
+        return function (...args) {
+            if (!this[resultKey]) {
+                this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;
+            }
+            if (this[lastRunKey] === null || this[lastRunKey] === undefined) {
+                this[lastRunKey] = -Number.MAX_VALUE;
+            }
+            if (reducer) {
+                this[resultKey] = reducer(this[resultKey], ...args);
+            }
+            if (this[pendingKey]) {
+                return;
+            }
+            const nextTime = this[lastRunKey] + delay;
+            if (nextTime <= Date.now()) {
+                this[lastRunKey] = Date.now();
+                fn.apply(this, [this[resultKey]]);
+                this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;
+            }
+            else {
+                this[pendingKey] = true;
+                this[timerKey] = setTimeout(() => {
+                    this[pendingKey] = false;
+                    this[lastRunKey] = Date.now();
+                    fn.apply(this, [this[resultKey]]);
+                    this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;
+                }, nextTime - Date.now());
+            }
+        };
+    });
+}
diff -urN -x '*.map' a/vs/base/common/errorMessage.js b/vs/base/common/errorMessage.js
--- a/vs/base/common/errorMessage.js	2023-09-05 08:43:04.218808244 +0000
+++ b/vs/base/common/errorMessage.js	2023-09-05 08:45:14.297196348 +0000
@@ -66,3 +66,18 @@
     }
     return nls.localize('error.defaultMessage', "An unknown error occurred. Please consult the log for more details.");
 }
+export function isErrorWithActions(obj) {
+    const candidate = obj;
+    return candidate instanceof Error && Array.isArray(candidate.actions);
+}
+export function createErrorWithActions(messageOrError, actions) {
+    let error;
+    if (typeof messageOrError === 'string') {
+        error = new Error(messageOrError);
+    }
+    else {
+        error = messageOrError;
+    }
+    error.actions = actions;
+    return error;
+}
diff -urN -x '*.map' a/vs/base/common/errors.js b/vs/base/common/errors.js
--- a/vs/base/common/errors.js	2023-09-05 08:43:04.218808244 +0000
+++ b/vs/base/common/errors.js	2023-09-05 08:45:14.301196405 +0000
@@ -18,11 +18,26 @@
             }, 0);
         };
     }
+    addListener(listener) {
+        this.listeners.push(listener);
+        return () => {
+            this._removeListener(listener);
+        };
+    }
     emit(e) {
         this.listeners.forEach((listener) => {
             listener(e);
         });
     }
+    _removeListener(listener) {
+        this.listeners.splice(this.listeners.indexOf(listener), 1);
+    }
+    setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
+        this.unexpectedErrorHandler = newUnexpectedErrorHandler;
+    }
+    getUnexpectedErrorHandler() {
+        return this.unexpectedErrorHandler;
+    }
     onUnexpectedError(e) {
         this.unexpectedErrorHandler(e);
         this.emit(e);
@@ -33,6 +48,24 @@
     }
 }
 export const errorHandler = new ErrorHandler();
+/** @skipMangle */
+export function setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
+    errorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);
+}
+/**
+ * Returns if the error is a SIGPIPE error. SIGPIPE errors should generally be
+ * logged at most once, to avoid a loop.
+ *
+ * @see https://github.com/microsoft/vscode-remote-release/issues/6481
+ */
+export function isSigPipeError(e) {
+    var _a;
+    if (!e || typeof e !== 'object') {
+        return false;
+    }
+    const cast = e;
+    return cast.code === 'EPIPE' && ((_a = cast.syscall) === null || _a === void 0 ? void 0 : _a.toUpperCase()) === 'WRITE';
+}
 export function onUnexpectedError(e) {
     // ignore errors from cancelled promises
     if (!isCancellationError(e)) {
@@ -104,6 +137,36 @@
         return new Error('Illegal state');
     }
 }
+export function readonly(name) {
+    return name
+        ? new Error(`readonly property '${name} cannot be changed'`)
+        : new Error('readonly property cannot be changed');
+}
+export function disposed(what) {
+    const result = new Error(`${what} has been disposed`);
+    result.name = 'DISPOSED';
+    return result;
+}
+export function getErrorMessage(err) {
+    if (!err) {
+        return 'Error';
+    }
+    if (err.message) {
+        return err.message;
+    }
+    if (err.stack) {
+        return err.stack.split('\n')[0];
+    }
+    return String(err);
+}
+export class NotImplementedError extends Error {
+    constructor(message) {
+        super('NotImplemented');
+        if (message) {
+            this.message = message;
+        }
+    }
+}
 export class NotSupportedError extends Error {
     constructor(message) {
         super('NotSupported');
@@ -112,6 +175,12 @@
         }
     }
 }
+export class ExpectedError extends Error {
+    constructor() {
+        super(...arguments);
+        this.isExpected = true;
+    }
+}
 /**
  * Error that when thrown won't be logged in telemetry as an unhandled error.
  */
diff -urN -x '*.map' a/vs/base/common/event.js b/vs/base/common/event.js
--- a/vs/base/common/event.js	2023-09-05 08:43:04.218808244 +0000
+++ b/vs/base/common/event.js	2023-09-05 08:45:14.301196405 +0000
@@ -1,3 +1,16 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
 import { onUnexpectedError } from './errors.js';
 import { once as onceFn } from './functional.js';
 import { combinedDisposable, Disposable, DisposableStore, toDisposable } from './lifecycle.js';
@@ -583,6 +596,15 @@
 EventProfiling.all = new Set();
 EventProfiling._idPool = 0;
 let _globalLeakWarningThreshold = -1;
+export function setGlobalLeakWarningThreshold(n) {
+    const oldValue = _globalLeakWarningThreshold;
+    _globalLeakWarningThreshold = n;
+    return {
+        dispose() {
+            _globalLeakWarningThreshold = oldValue;
+        }
+    };
+}
 class LeakageMonitor {
     constructor(threshold, name = Math.random().toString(18).slice(2, 5)) {
         this.threshold = threshold;
@@ -638,9 +660,11 @@
         console.warn(this.value.split('\n').slice(2).join('\n'));
     }
 }
+let id = 0;
 class UniqueContainer {
     constructor(value) {
         this.value = value;
+        this.id = id++;
     }
 }
 const compactionThreshold = 2;
@@ -889,7 +913,53 @@
         this.value = undefined;
     }
 }
+export class AsyncEmitter extends Emitter {
+    fireAsync(data, token, promiseJoin) {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (!this._listeners) {
+                return;
+            }
+            if (!this._asyncDeliveryQueue) {
+                this._asyncDeliveryQueue = new LinkedList();
+            }
+            forEachListener(this._listeners, listener => this._asyncDeliveryQueue.push([listener.value, data]));
+            while (this._asyncDeliveryQueue.size > 0 && !token.isCancellationRequested) {
+                const [listener, data] = this._asyncDeliveryQueue.shift();
+                const thenables = [];
+                const event = Object.assign(Object.assign({}, data), { token, waitUntil: (p) => {
+                        if (Object.isFrozen(thenables)) {
+                            throw new Error('waitUntil can NOT be called asynchronous');
+                        }
+                        if (promiseJoin) {
+                            p = promiseJoin(p, listener);
+                        }
+                        thenables.push(p);
+                    } });
+                try {
+                    listener(event);
+                }
+                catch (e) {
+                    onUnexpectedError(e);
+                    continue;
+                }
+                // freeze thenables-collection to enforce sync-calls to
+                // wait until and then wait for all thenables to resolve
+                Object.freeze(thenables);
+                yield Promise.allSettled(thenables).then(values => {
+                    for (const value of values) {
+                        if (value.status === 'rejected') {
+                            onUnexpectedError(value.reason);
+                        }
+                    }
+                });
+            }
+        });
+    }
+}
 export class PauseableEmitter extends Emitter {
+    get isPaused() {
+        return this._isPaused !== 0;
+    }
     constructor(options) {
         super(options);
         this._isPaused = 0;
diff -urN -x '*.map' a/vs/base/common/extpath.js b/vs/base/common/extpath.js
--- a/vs/base/common/extpath.js	2023-09-05 08:43:04.218808244 +0000
+++ b/vs/base/common/extpath.js	2023-09-05 08:45:14.293196291 +0000
@@ -2,9 +2,10 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-import { posix, sep } from './path.js';
+import { isAbsolute, join, normalize, posix, sep } from './path.js';
 import { isWindows } from './platform.js';
-import { startsWithIgnoreCase } from './strings.js';
+import { equalsIgnoreCase, rtrim, startsWithIgnoreCase } from './strings.js';
+import { isNumber } from './types.js';
 export function isPathSeparator(code) {
     return code === 47 /* CharCode.Slash */ || code === 92 /* CharCode.Backslash */;
 }
@@ -100,6 +101,92 @@
     return '';
 }
 /**
+ * Check if the path follows this pattern: `\\hostname\sharename`.
+ *
+ * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx
+ * @return A boolean indication if the path is a UNC path, on none-windows
+ * always false.
+ */
+export function isUNC(path) {
+    if (!isWindows) {
+        // UNC is a windows concept
+        return false;
+    }
+    if (!path || path.length < 5) {
+        // at least \\a\b
+        return false;
+    }
+    let code = path.charCodeAt(0);
+    if (code !== 92 /* CharCode.Backslash */) {
+        return false;
+    }
+    code = path.charCodeAt(1);
+    if (code !== 92 /* CharCode.Backslash */) {
+        return false;
+    }
+    let pos = 2;
+    const start = pos;
+    for (; pos < path.length; pos++) {
+        code = path.charCodeAt(pos);
+        if (code === 92 /* CharCode.Backslash */) {
+            break;
+        }
+    }
+    if (start === pos) {
+        return false;
+    }
+    code = path.charCodeAt(pos + 1);
+    if (isNaN(code) || code === 92 /* CharCode.Backslash */) {
+        return false;
+    }
+    return true;
+}
+// Reference: https://en.wikipedia.org/wiki/Filename
+const WINDOWS_INVALID_FILE_CHARS = /[\\/:\*\?"<>\|]/g;
+const UNIX_INVALID_FILE_CHARS = /[\\/]/g;
+const WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\$|nul|lpt[0-9]|com[0-9])(\.(.*?))?$/i;
+export function isValidBasename(name, isWindowsOS = isWindows) {
+    const invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;
+    if (!name || name.length === 0 || /^\s+$/.test(name)) {
+        return false; // require a name that is not just whitespace
+    }
+    invalidFileChars.lastIndex = 0; // the holy grail of software development
+    if (invalidFileChars.test(name)) {
+        return false; // check for certain invalid file characters
+    }
+    if (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {
+        return false; // check for certain invalid file names
+    }
+    if (name === '.' || name === '..') {
+        return false; // check for reserved values
+    }
+    if (isWindowsOS && name[name.length - 1] === '.') {
+        return false; // Windows: file cannot end with a "."
+    }
+    if (isWindowsOS && name.length !== name.trim().length) {
+        return false; // Windows: file cannot end with a whitespace
+    }
+    if (name.length > 255) {
+        return false; // most file systems do not allow files > 255 length
+    }
+    return true;
+}
+/**
+ * @deprecated please use `IUriIdentityService.extUri.isEqual` instead. If you are
+ * in a context without services, consider to pass down the `extUri` from the outside
+ * or use `extUriBiasedIgnorePathCase` if you know what you are doing.
+ */
+export function isEqual(pathA, pathB, ignoreCase) {
+    const identityEquals = (pathA === pathB);
+    if (!ignoreCase || identityEquals) {
+        return identityEquals;
+    }
+    if (!pathA || !pathB) {
+        return false;
+    }
+    return equalsIgnoreCase(pathA, pathB);
+}
+/**
  * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If
  * you are in a context without services, consider to pass down the `extUri` from the
  * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.
@@ -136,9 +223,121 @@
 export function isWindowsDriveLetter(char0) {
     return char0 >= 65 /* CharCode.A */ && char0 <= 90 /* CharCode.Z */ || char0 >= 97 /* CharCode.a */ && char0 <= 122 /* CharCode.z */;
 }
+export function sanitizeFilePath(candidate, cwd) {
+    // Special case: allow to open a drive letter without trailing backslash
+    if (isWindows && candidate.endsWith(':')) {
+        candidate += sep;
+    }
+    // Ensure absolute
+    if (!isAbsolute(candidate)) {
+        candidate = join(cwd, candidate);
+    }
+    // Ensure normalized
+    candidate = normalize(candidate);
+    // Ensure no trailing slash/backslash
+    if (isWindows) {
+        candidate = rtrim(candidate, sep);
+        // Special case: allow to open drive root ('C:\')
+        if (candidate.endsWith(':')) {
+            candidate += sep;
+        }
+    }
+    else {
+        candidate = rtrim(candidate, sep);
+        // Special case: allow to open root ('/')
+        if (!candidate) {
+            candidate = sep;
+        }
+    }
+    return candidate;
+}
+export function isRootOrDriveLetter(path) {
+    const pathNormalized = normalize(path);
+    if (isWindows) {
+        if (path.length > 3) {
+            return false;
+        }
+        return hasDriveLetter(pathNormalized) &&
+            (path.length === 2 || pathNormalized.charCodeAt(2) === 92 /* CharCode.Backslash */);
+    }
+    return pathNormalized === posix.sep;
+}
 export function hasDriveLetter(path, isWindowsOS = isWindows) {
     if (isWindowsOS) {
         return isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === 58 /* CharCode.Colon */;
     }
     return false;
 }
+export function getDriveLetter(path, isWindowsOS = isWindows) {
+    return hasDriveLetter(path, isWindowsOS) ? path[0] : undefined;
+}
+export function indexOfPath(path, candidate, ignoreCase) {
+    if (candidate.length > path.length) {
+        return -1;
+    }
+    if (path === candidate) {
+        return 0;
+    }
+    if (ignoreCase) {
+        path = path.toLowerCase();
+        candidate = candidate.toLowerCase();
+    }
+    return path.indexOf(candidate);
+}
+export function parseLineAndColumnAware(rawPath) {
+    const segments = rawPath.split(':'); // C:\file.txt:<line>:<column>
+    let path = undefined;
+    let line = undefined;
+    let column = undefined;
+    for (const segment of segments) {
+        const segmentAsNumber = Number(segment);
+        if (!isNumber(segmentAsNumber)) {
+            path = !!path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\...)
+        }
+        else if (line === undefined) {
+            line = segmentAsNumber;
+        }
+        else if (column === undefined) {
+            column = segmentAsNumber;
+        }
+    }
+    if (!path) {
+        throw new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');
+    }
+    return {
+        path,
+        line: line !== undefined ? line : undefined,
+        column: column !== undefined ? column : line !== undefined ? 1 : undefined // if we have a line, make sure column is also set
+    };
+}
+const pathChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
+const windowsSafePathFirstChars = 'BDEFGHIJKMOQRSTUVWXYZbdefghijkmoqrstuvwxyz0123456789';
+export function randomPath(parent, prefix, randomLength = 8) {
+    let suffix = '';
+    for (let i = 0; i < randomLength; i++) {
+        let pathCharsTouse;
+        if (i === 0 && isWindows && !prefix && (randomLength === 3 || randomLength === 4)) {
+            // Windows has certain reserved file names that cannot be used, such
+            // as AUX, CON, PRN, etc. We want to avoid generating a random name
+            // that matches that pattern, so we use a different set of characters
+            // for the first character of the name that does not include any of
+            // the reserved names first characters.
+            pathCharsTouse = windowsSafePathFirstChars;
+        }
+        else {
+            pathCharsTouse = pathChars;
+        }
+        suffix += pathCharsTouse.charAt(Math.floor(Math.random() * pathCharsTouse.length));
+    }
+    let randomFileName;
+    if (prefix) {
+        randomFileName = `${prefix}-${suffix}`;
+    }
+    else {
+        randomFileName = suffix;
+    }
+    if (parent) {
+        return join(parent, randomFileName);
+    }
+    return randomFileName;
+}
diff -urN -x '*.map' a/vs/base/common/filters.js b/vs/base/common/filters.js
--- a/vs/base/common/filters.js	2023-09-05 08:43:04.222808345 +0000
+++ b/vs/base/common/filters.js	2023-09-05 08:45:14.301196405 +0000
@@ -308,6 +308,14 @@
     // Default Filter
     return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);
 }
+/**
+ * Match pattern against word in a fuzzy way. As in IntelliSense and faster and more
+ * powerful than `matchesFuzzy`
+ */
+export function matchesFuzzy2(pattern, word) {
+    const score = fuzzyScore(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0, { firstMatchCanBeWeak: true, boostFullMatch: true });
+    return score ? createMatches(score) : null;
+}
 export function anyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos) {
     const max = Math.min(13, pattern.length);
     for (; patternPos < max; patternPos++) {
@@ -667,6 +675,9 @@
 export function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, options) {
     return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, options);
 }
+export function fuzzyScoreGraceful(pattern, lowPattern, patternPos, word, lowWord, wordPos, options) {
+    return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, false, options);
+}
 function fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, options) {
     let top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, options);
     if (top && !aggressive) {
diff -urN -x '*.map' a/vs/base/common/fuzzyScorer.js b/vs/base/common/fuzzyScorer.js
--- a/vs/base/common/fuzzyScorer.js	2023-09-05 08:43:04.222808345 +0000
+++ b/vs/base/common/fuzzyScorer.js	2023-09-05 08:45:14.297196348 +0000
@@ -1,7 +1,216 @@
-import { createMatches as createFuzzyMatches, fuzzyScore } from './filters.js';
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { compareAnything } from './comparers.js';
+import { createMatches as createFuzzyMatches, fuzzyScore, isUpper, matchesPrefix } from './filters.js';
+import { hash } from './hash.js';
 import { sep } from './path.js';
-import { isWindows } from './platform.js';
-import { stripWildcards } from './strings.js';
+import { isLinux, isWindows } from './platform.js';
+import { equalsIgnoreCase, stripWildcards } from './strings.js';
+const NO_MATCH = 0;
+const NO_SCORE = [NO_MATCH, []];
+// const DEBUG = true;
+// const DEBUG_MATRIX = false;
+export function scoreFuzzy(target, query, queryLower, allowNonContiguousMatches) {
+    if (!target || !query) {
+        return NO_SCORE; // return early if target or query are undefined
+    }
+    const targetLength = target.length;
+    const queryLength = query.length;
+    if (targetLength < queryLength) {
+        return NO_SCORE; // impossible for query to be contained in target
+    }
+    // if (DEBUG) {
+    // 	console.group(`Target: ${target}, Query: ${query}`);
+    // }
+    const targetLower = target.toLowerCase();
+    const res = doScoreFuzzy(query, queryLower, queryLength, target, targetLower, targetLength, allowNonContiguousMatches);
+    // if (DEBUG) {
+    // 	console.log(`%cFinal Score: ${res[0]}`, 'font-weight: bold');
+    // 	console.groupEnd();
+    // }
+    return res;
+}
+function doScoreFuzzy(query, queryLower, queryLength, target, targetLower, targetLength, allowNonContiguousMatches) {
+    const scores = [];
+    const matches = [];
+    //
+    // Build Scorer Matrix:
+    //
+    // The matrix is composed of query q and target t. For each index we score
+    // q[i] with t[i] and compare that with the previous score. If the score is
+    // equal or larger, we keep the match. In addition to the score, we also keep
+    // the length of the consecutive matches to use as boost for the score.
+    //
+    //      t   a   r   g   e   t
+    //  q
+    //  u
+    //  e
+    //  r
+    //  y
+    //
+    for (let queryIndex = 0; queryIndex < queryLength; queryIndex++) {
+        const queryIndexOffset = queryIndex * targetLength;
+        const queryIndexPreviousOffset = queryIndexOffset - targetLength;
+        const queryIndexGtNull = queryIndex > 0;
+        const queryCharAtIndex = query[queryIndex];
+        const queryLowerCharAtIndex = queryLower[queryIndex];
+        for (let targetIndex = 0; targetIndex < targetLength; targetIndex++) {
+            const targetIndexGtNull = targetIndex > 0;
+            const currentIndex = queryIndexOffset + targetIndex;
+            const leftIndex = currentIndex - 1;
+            const diagIndex = queryIndexPreviousOffset + targetIndex - 1;
+            const leftScore = targetIndexGtNull ? scores[leftIndex] : 0;
+            const diagScore = queryIndexGtNull && targetIndexGtNull ? scores[diagIndex] : 0;
+            const matchesSequenceLength = queryIndexGtNull && targetIndexGtNull ? matches[diagIndex] : 0;
+            // If we are not matching on the first query character any more, we only produce a
+            // score if we had a score previously for the last query index (by looking at the diagScore).
+            // This makes sure that the query always matches in sequence on the target. For example
+            // given a target of "ede" and a query of "de", we would otherwise produce a wrong high score
+            // for query[1] ("e") matching on target[0] ("e") because of the "beginning of word" boost.
+            let score;
+            if (!diagScore && queryIndexGtNull) {
+                score = 0;
+            }
+            else {
+                score = computeCharScore(queryCharAtIndex, queryLowerCharAtIndex, target, targetLower, targetIndex, matchesSequenceLength);
+            }
+            // We have a score and its equal or larger than the left score
+            // Match: sequence continues growing from previous diag value
+            // Score: increases by diag score value
+            const isValidScore = score && diagScore + score >= leftScore;
+            if (isValidScore && (
+            // We don't need to check if it's contiguous if we allow non-contiguous matches
+            allowNonContiguousMatches ||
+                // We must be looking for a contiguous match.
+                // Looking at an index higher than 0 in the query means we must have already
+                // found out this is contiguous otherwise there wouldn't have been a score
+                queryIndexGtNull ||
+                // lastly check if the query is completely contiguous at this index in the target
+                targetLower.startsWith(queryLower, targetIndex))) {
+                matches[currentIndex] = matchesSequenceLength + 1;
+                scores[currentIndex] = diagScore + score;
+            }
+            // We either have no score or the score is lower than the left score
+            // Match: reset to 0
+            // Score: pick up from left hand side
+            else {
+                matches[currentIndex] = NO_MATCH;
+                scores[currentIndex] = leftScore;
+            }
+        }
+    }
+    // Restore Positions (starting from bottom right of matrix)
+    const positions = [];
+    let queryIndex = queryLength - 1;
+    let targetIndex = targetLength - 1;
+    while (queryIndex >= 0 && targetIndex >= 0) {
+        const currentIndex = queryIndex * targetLength + targetIndex;
+        const match = matches[currentIndex];
+        if (match === NO_MATCH) {
+            targetIndex--; // go left
+        }
+        else {
+            positions.push(targetIndex);
+            // go up and left
+            queryIndex--;
+            targetIndex--;
+        }
+    }
+    // Print matrix
+    // if (DEBUG_MATRIX) {
+    // 	printMatrix(query, target, matches, scores);
+    // }
+    return [scores[queryLength * targetLength - 1], positions.reverse()];
+}
+function computeCharScore(queryCharAtIndex, queryLowerCharAtIndex, target, targetLower, targetIndex, matchesSequenceLength) {
+    let score = 0;
+    if (!considerAsEqual(queryLowerCharAtIndex, targetLower[targetIndex])) {
+        return score; // no match of characters
+    }
+    // if (DEBUG) {
+    // 	console.groupCollapsed(`%cFound a match of char: ${queryLowerCharAtIndex} at index ${targetIndex}`, 'font-weight: normal');
+    // }
+    // Character match bonus
+    score += 1;
+    // if (DEBUG) {
+    // 	console.log(`%cCharacter match bonus: +1`, 'font-weight: normal');
+    // }
+    // Consecutive match bonus
+    if (matchesSequenceLength > 0) {
+        score += (matchesSequenceLength * 5);
+        // if (DEBUG) {
+        // 	console.log(`Consecutive match bonus: +${matchesSequenceLength * 5}`);
+        // }
+    }
+    // Same case bonus
+    if (queryCharAtIndex === target[targetIndex]) {
+        score += 1;
+        // if (DEBUG) {
+        // 	console.log('Same case bonus: +1');
+        // }
+    }
+    // Start of word bonus
+    if (targetIndex === 0) {
+        score += 8;
+        // if (DEBUG) {
+        // 	console.log('Start of word bonus: +8');
+        // }
+    }
+    else {
+        // After separator bonus
+        const separatorBonus = scoreSeparatorAtPos(target.charCodeAt(targetIndex - 1));
+        if (separatorBonus) {
+            score += separatorBonus;
+            // if (DEBUG) {
+            // 	console.log(`After separator bonus: +${separatorBonus}`);
+            // }
+        }
+        // Inside word upper case bonus (camel case). We only give this bonus if we're not in a contiguous sequence.
+        // For example:
+        // NPE => NullPointerException = boost
+        // HTTP => HTTP = not boost
+        else if (isUpper(target.charCodeAt(targetIndex)) && matchesSequenceLength === 0) {
+            score += 2;
+            // if (DEBUG) {
+            // 	console.log('Inside word upper case bonus: +2');
+            // }
+        }
+    }
+    // if (DEBUG) {
+    // 	console.log(`Total score: ${score}`);
+    // 	console.groupEnd();
+    // }
+    return score;
+}
+function considerAsEqual(a, b) {
+    if (a === b) {
+        return true;
+    }
+    // Special case path separators: ignore platform differences
+    if (a === '/' || a === '\\') {
+        return b === '/' || b === '\\';
+    }
+    return false;
+}
+function scoreSeparatorAtPos(charCode) {
+    switch (charCode) {
+        case 47 /* CharCode.Slash */:
+        case 92 /* CharCode.Backslash */:
+            return 5; // prefer path separators...
+        case 95 /* CharCode.Underline */:
+        case 45 /* CharCode.Dash */:
+        case 46 /* CharCode.Period */:
+        case 32 /* CharCode.Space */:
+        case 39 /* CharCode.SingleQuote */:
+        case 34 /* CharCode.DoubleQuote */:
+        case 58 /* CharCode.Colon */:
+            return 4; // ...over other separators
+        default:
+            return 0;
+    }
+}
 const NO_SCORE2 = [undefined, []];
 export function scoreFuzzy2(target, query, patternStart = 0, wordStart = 0) {
     // Score: multiple inputs
@@ -37,6 +246,163 @@
     return [score[0], createFuzzyMatches(score)];
 }
 const NO_ITEM_SCORE = Object.freeze({ score: 0 });
+const PATH_IDENTITY_SCORE = 1 << 18;
+const LABEL_PREFIX_SCORE_THRESHOLD = 1 << 17;
+const LABEL_SCORE_THRESHOLD = 1 << 16;
+function getCacheHash(label, description, allowNonContiguousMatches, query) {
+    const values = query.values ? query.values : [query];
+    const cacheHash = hash({
+        [query.normalized]: {
+            values: values.map(v => ({ value: v.normalized, expectContiguousMatch: v.expectContiguousMatch })),
+            label,
+            description,
+            allowNonContiguousMatches
+        }
+    });
+    return cacheHash;
+}
+export function scoreItemFuzzy(item, query, allowNonContiguousMatches, accessor, cache) {
+    if (!item || !query.normalized) {
+        return NO_ITEM_SCORE; // we need an item and query to score on at least
+    }
+    const label = accessor.getItemLabel(item);
+    if (!label) {
+        return NO_ITEM_SCORE; // we need a label at least
+    }
+    const description = accessor.getItemDescription(item);
+    // in order to speed up scoring, we cache the score with a unique hash based on:
+    // - label
+    // - description (if provided)
+    // - whether non-contiguous matching is enabled or not
+    // - hash of the query (normalized) values
+    const cacheHash = getCacheHash(label, description, allowNonContiguousMatches, query);
+    const cached = cache[cacheHash];
+    if (cached) {
+        return cached;
+    }
+    const itemScore = doScoreItemFuzzy(label, description, accessor.getItemPath(item), query, allowNonContiguousMatches);
+    cache[cacheHash] = itemScore;
+    return itemScore;
+}
+function doScoreItemFuzzy(label, description, path, query, allowNonContiguousMatches) {
+    const preferLabelMatches = !path || !query.containsPathSeparator;
+    // Treat identity matches on full path highest
+    if (path && (isLinux ? query.pathNormalized === path : equalsIgnoreCase(query.pathNormalized, path))) {
+        return { score: PATH_IDENTITY_SCORE, labelMatch: [{ start: 0, end: label.length }], descriptionMatch: description ? [{ start: 0, end: description.length }] : undefined };
+    }
+    // Score: multiple inputs
+    if (query.values && query.values.length > 1) {
+        return doScoreItemFuzzyMultiple(label, description, path, query.values, preferLabelMatches, allowNonContiguousMatches);
+    }
+    // Score: single input
+    return doScoreItemFuzzySingle(label, description, path, query, preferLabelMatches, allowNonContiguousMatches);
+}
+function doScoreItemFuzzyMultiple(label, description, path, query, preferLabelMatches, allowNonContiguousMatches) {
+    let totalScore = 0;
+    const totalLabelMatches = [];
+    const totalDescriptionMatches = [];
+    for (const queryPiece of query) {
+        const { score, labelMatch, descriptionMatch } = doScoreItemFuzzySingle(label, description, path, queryPiece, preferLabelMatches, allowNonContiguousMatches);
+        if (score === NO_MATCH) {
+            // if a single query value does not match, return with
+            // no score entirely, we require all queries to match
+            return NO_ITEM_SCORE;
+        }
+        totalScore += score;
+        if (labelMatch) {
+            totalLabelMatches.push(...labelMatch);
+        }
+        if (descriptionMatch) {
+            totalDescriptionMatches.push(...descriptionMatch);
+        }
+    }
+    // if we have a score, ensure that the positions are
+    // sorted in ascending order and distinct
+    return {
+        score: totalScore,
+        labelMatch: normalizeMatches(totalLabelMatches),
+        descriptionMatch: normalizeMatches(totalDescriptionMatches)
+    };
+}
+function doScoreItemFuzzySingle(label, description, path, query, preferLabelMatches, allowNonContiguousMatches) {
+    // Prefer label matches if told so or we have no description
+    if (preferLabelMatches || !description) {
+        const [labelScore, labelPositions] = scoreFuzzy(label, query.normalized, query.normalizedLowercase, allowNonContiguousMatches && !query.expectContiguousMatch);
+        if (labelScore) {
+            // If we have a prefix match on the label, we give a much
+            // higher baseScore to elevate these matches over others
+            // This ensures that typing a file name wins over results
+            // that are present somewhere in the label, but not the
+            // beginning.
+            const labelPrefixMatch = matchesPrefix(query.normalized, label);
+            let baseScore;
+            if (labelPrefixMatch) {
+                baseScore = LABEL_PREFIX_SCORE_THRESHOLD;
+                // We give another boost to labels that are short, e.g. given
+                // files "window.ts" and "windowActions.ts" and a query of
+                // "window", we want "window.ts" to receive a higher score.
+                // As such we compute the percentage the query has within the
+                // label and add that to the baseScore.
+                const prefixLengthBoost = Math.round((query.normalized.length / label.length) * 100);
+                baseScore += prefixLengthBoost;
+            }
+            else {
+                baseScore = LABEL_SCORE_THRESHOLD;
+            }
+            return { score: baseScore + labelScore, labelMatch: labelPrefixMatch || createMatches(labelPositions) };
+        }
+    }
+    // Finally compute description + label scores if we have a description
+    if (description) {
+        let descriptionPrefix = description;
+        if (!!path) {
+            descriptionPrefix = `${description}${sep}`; // assume this is a file path
+        }
+        const descriptionPrefixLength = descriptionPrefix.length;
+        const descriptionAndLabel = `${descriptionPrefix}${label}`;
+        const [labelDescriptionScore, labelDescriptionPositions] = scoreFuzzy(descriptionAndLabel, query.normalized, query.normalizedLowercase, allowNonContiguousMatches && !query.expectContiguousMatch);
+        if (labelDescriptionScore) {
+            const labelDescriptionMatches = createMatches(labelDescriptionPositions);
+            const labelMatch = [];
+            const descriptionMatch = [];
+            // We have to split the matches back onto the label and description portions
+            labelDescriptionMatches.forEach(h => {
+                // Match overlaps label and description part, we need to split it up
+                if (h.start < descriptionPrefixLength && h.end > descriptionPrefixLength) {
+                    labelMatch.push({ start: 0, end: h.end - descriptionPrefixLength });
+                    descriptionMatch.push({ start: h.start, end: descriptionPrefixLength });
+                }
+                // Match on label part
+                else if (h.start >= descriptionPrefixLength) {
+                    labelMatch.push({ start: h.start - descriptionPrefixLength, end: h.end - descriptionPrefixLength });
+                }
+                // Match on description part
+                else {
+                    descriptionMatch.push(h);
+                }
+            });
+            return { score: labelDescriptionScore, labelMatch, descriptionMatch };
+        }
+    }
+    return NO_ITEM_SCORE;
+}
+function createMatches(offsets) {
+    const ret = [];
+    if (!offsets) {
+        return ret;
+    }
+    let last;
+    for (const pos of offsets) {
+        if (last && last.end === pos) {
+            last.end += 1;
+        }
+        else {
+            last = { start: pos, end: pos + 1 };
+            ret.push(last);
+        }
+    }
+    return ret;
+}
 function normalizeMatches(matches) {
     // sort matches by start to be able to normalize
     const sortedMatches = matches.sort((matchA, matchB) => {
@@ -70,6 +436,144 @@
     }
     return true;
 }
+//#endregion
+//#region Comparers
+export function compareItemsByFuzzyScore(itemA, itemB, query, allowNonContiguousMatches, accessor, cache) {
+    const itemScoreA = scoreItemFuzzy(itemA, query, allowNonContiguousMatches, accessor, cache);
+    const itemScoreB = scoreItemFuzzy(itemB, query, allowNonContiguousMatches, accessor, cache);
+    const scoreA = itemScoreA.score;
+    const scoreB = itemScoreB.score;
+    // 1.) identity matches have highest score
+    if (scoreA === PATH_IDENTITY_SCORE || scoreB === PATH_IDENTITY_SCORE) {
+        if (scoreA !== scoreB) {
+            return scoreA === PATH_IDENTITY_SCORE ? -1 : 1;
+        }
+    }
+    // 2.) matches on label are considered higher compared to label+description matches
+    if (scoreA > LABEL_SCORE_THRESHOLD || scoreB > LABEL_SCORE_THRESHOLD) {
+        if (scoreA !== scoreB) {
+            return scoreA > scoreB ? -1 : 1;
+        }
+        // prefer more compact matches over longer in label (unless this is a prefix match where
+        // longer prefix matches are actually preferred)
+        if (scoreA < LABEL_PREFIX_SCORE_THRESHOLD && scoreB < LABEL_PREFIX_SCORE_THRESHOLD) {
+            const comparedByMatchLength = compareByMatchLength(itemScoreA.labelMatch, itemScoreB.labelMatch);
+            if (comparedByMatchLength !== 0) {
+                return comparedByMatchLength;
+            }
+        }
+        // prefer shorter labels over longer labels
+        const labelA = accessor.getItemLabel(itemA) || '';
+        const labelB = accessor.getItemLabel(itemB) || '';
+        if (labelA.length !== labelB.length) {
+            return labelA.length - labelB.length;
+        }
+    }
+    // 3.) compare by score in label+description
+    if (scoreA !== scoreB) {
+        return scoreA > scoreB ? -1 : 1;
+    }
+    // 4.) scores are identical: prefer matches in label over non-label matches
+    const itemAHasLabelMatches = Array.isArray(itemScoreA.labelMatch) && itemScoreA.labelMatch.length > 0;
+    const itemBHasLabelMatches = Array.isArray(itemScoreB.labelMatch) && itemScoreB.labelMatch.length > 0;
+    if (itemAHasLabelMatches && !itemBHasLabelMatches) {
+        return -1;
+    }
+    else if (itemBHasLabelMatches && !itemAHasLabelMatches) {
+        return 1;
+    }
+    // 5.) scores are identical: prefer more compact matches (label and description)
+    const itemAMatchDistance = computeLabelAndDescriptionMatchDistance(itemA, itemScoreA, accessor);
+    const itemBMatchDistance = computeLabelAndDescriptionMatchDistance(itemB, itemScoreB, accessor);
+    if (itemAMatchDistance && itemBMatchDistance && itemAMatchDistance !== itemBMatchDistance) {
+        return itemBMatchDistance > itemAMatchDistance ? -1 : 1;
+    }
+    // 6.) scores are identical: start to use the fallback compare
+    return fallbackCompare(itemA, itemB, query, accessor);
+}
+function computeLabelAndDescriptionMatchDistance(item, score, accessor) {
+    let matchStart = -1;
+    let matchEnd = -1;
+    // If we have description matches, the start is first of description match
+    if (score.descriptionMatch && score.descriptionMatch.length) {
+        matchStart = score.descriptionMatch[0].start;
+    }
+    // Otherwise, the start is the first label match
+    else if (score.labelMatch && score.labelMatch.length) {
+        matchStart = score.labelMatch[0].start;
+    }
+    // If we have label match, the end is the last label match
+    // If we had a description match, we add the length of the description
+    // as offset to the end to indicate this.
+    if (score.labelMatch && score.labelMatch.length) {
+        matchEnd = score.labelMatch[score.labelMatch.length - 1].end;
+        if (score.descriptionMatch && score.descriptionMatch.length) {
+            const itemDescription = accessor.getItemDescription(item);
+            if (itemDescription) {
+                matchEnd += itemDescription.length;
+            }
+        }
+    }
+    // If we have just a description match, the end is the last description match
+    else if (score.descriptionMatch && score.descriptionMatch.length) {
+        matchEnd = score.descriptionMatch[score.descriptionMatch.length - 1].end;
+    }
+    return matchEnd - matchStart;
+}
+function compareByMatchLength(matchesA, matchesB) {
+    if ((!matchesA && !matchesB) || ((!matchesA || !matchesA.length) && (!matchesB || !matchesB.length))) {
+        return 0; // make sure to not cause bad comparing when matches are not provided
+    }
+    if (!matchesB || !matchesB.length) {
+        return -1;
+    }
+    if (!matchesA || !matchesA.length) {
+        return 1;
+    }
+    // Compute match length of A (first to last match)
+    const matchStartA = matchesA[0].start;
+    const matchEndA = matchesA[matchesA.length - 1].end;
+    const matchLengthA = matchEndA - matchStartA;
+    // Compute match length of B (first to last match)
+    const matchStartB = matchesB[0].start;
+    const matchEndB = matchesB[matchesB.length - 1].end;
+    const matchLengthB = matchEndB - matchStartB;
+    // Prefer shorter match length
+    return matchLengthA === matchLengthB ? 0 : matchLengthB < matchLengthA ? 1 : -1;
+}
+function fallbackCompare(itemA, itemB, query, accessor) {
+    // check for label + description length and prefer shorter
+    const labelA = accessor.getItemLabel(itemA) || '';
+    const labelB = accessor.getItemLabel(itemB) || '';
+    const descriptionA = accessor.getItemDescription(itemA);
+    const descriptionB = accessor.getItemDescription(itemB);
+    const labelDescriptionALength = labelA.length + (descriptionA ? descriptionA.length : 0);
+    const labelDescriptionBLength = labelB.length + (descriptionB ? descriptionB.length : 0);
+    if (labelDescriptionALength !== labelDescriptionBLength) {
+        return labelDescriptionALength - labelDescriptionBLength;
+    }
+    // check for path length and prefer shorter
+    const pathA = accessor.getItemPath(itemA);
+    const pathB = accessor.getItemPath(itemB);
+    if (pathA && pathB && pathA.length !== pathB.length) {
+        return pathA.length - pathB.length;
+    }
+    // 7.) finally we have equal scores and equal length, we fallback to comparer
+    // compare by label
+    if (labelA !== labelB) {
+        return compareAnything(labelA, labelB, query.normalized);
+    }
+    // compare by description
+    if (descriptionA && descriptionB && descriptionA !== descriptionB) {
+        return compareAnything(descriptionA, descriptionB, query.normalized);
+    }
+    // compare by path
+    if (pathA && pathB && pathA !== pathB) {
+        return compareAnything(pathA, pathB, query.normalized);
+    }
+    // equal
+    return 0;
+}
 /*
  * If a query is wrapped in quotes, the user does not want to
  * use fuzzy search for this query.
diff -urN -x '*.map' a/vs/base/common/glob.js b/vs/base/common/glob.js
--- a/vs/base/common/glob.js	2023-09-05 08:43:04.222808345 +0000
+++ b/vs/base/common/glob.js	2023-09-05 08:45:14.297196348 +0000
@@ -1,3 +1,7 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
 var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
     function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
     return new (P || (P = Promise))(function (resolve, reject) {
@@ -7,12 +11,16 @@
         step((generator = generator.apply(thisArg, _arguments || [])).next());
     });
 };
+import { equals } from './arrays.js';
 import { isThenable } from './async.js';
 import { isEqualOrParent } from './extpath.js';
 import { LRUCache } from './map.js';
 import { basename, extname, posix, sep } from './path.js';
 import { isLinux } from './platform.js';
 import { escapeRegExpCharacters, ltrim } from './strings.js';
+export function getEmptyExpression() {
+    return Object.create(null);
+}
 export const GLOBSTAR = '**';
 export const GLOB_SPLIT = '/';
 const PATH_REGEX = '[/\\\\]'; // any slash or backslash
@@ -391,6 +399,12 @@
     }
     return typeof rp.base === 'string' && typeof rp.pattern === 'string';
 }
+export function getBasenameTerms(patternOrExpression) {
+    return patternOrExpression.allBasenames || [];
+}
+export function getPathTerms(patternOrExpression) {
+    return patternOrExpression.allPaths || [];
+}
 function parsedExpression(expression, options) {
     const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)
         .map(pattern => parseExpressionPattern(pattern, expression[pattern], options))
@@ -575,3 +589,14 @@
     aggregatedPatterns.push(aggregate);
     return aggregatedPatterns;
 }
+export function patternsEquals(patternsA, patternsB) {
+    return equals(patternsA, patternsB, (a, b) => {
+        if (typeof a === 'string' && typeof b === 'string') {
+            return a === b;
+        }
+        if (typeof a !== 'string' && typeof b !== 'string') {
+            return a.base === b.base && a.pattern === b.pattern;
+        }
+        return false;
+    });
+}
diff -urN -x '*.map' a/vs/base/common/hash.js b/vs/base/common/hash.js
--- a/vs/base/common/hash.js	2023-09-05 08:43:04.222808345 +0000
+++ b/vs/base/common/hash.js	2023-09-05 08:45:14.301196405 +0000
@@ -55,6 +55,18 @@
         return doHash(obj[key], hashVal);
     }, initialHashVal);
 }
+export class Hasher {
+    constructor() {
+        this._value = 0;
+    }
+    get value() {
+        return this._value;
+    }
+    hash(obj) {
+        this._value = doHash(obj, this._value);
+        return this._value;
+    }
+}
 function leftRotate(value, bits, totalBits = 32) {
     // delta + bits = totalBits
     const delta = totalBits - bits;
diff -urN -x '*.map' a/vs/base/common/history.js b/vs/base/common/history.js
--- a/vs/base/common/history.js	2023-09-05 08:43:04.222808345 +0000
+++ b/vs/base/common/history.js	2023-09-05 08:45:14.293196291 +0000
@@ -36,6 +36,9 @@
     last() {
         return this._navigator.last();
     }
+    isFirst() {
+        return this._currentPosition() === 0;
+    }
     isLast() {
         return this._currentPosition() >= this._elements.length - 1;
     }
@@ -45,6 +48,10 @@
     has(t) {
         return this._history.has(t);
     }
+    clear() {
+        this._initialize([]);
+        this._onChange();
+    }
     _onChange() {
         this._reduceToLimit();
         const elements = this._elements;
@@ -75,3 +82,111 @@
         return elements;
     }
 }
+export class HistoryNavigator2 {
+    constructor(history, capacity = 10) {
+        this.capacity = capacity;
+        if (history.length < 1) {
+            throw new Error('not supported');
+        }
+        this.size = 1;
+        this.head = this.tail = this.cursor = {
+            value: history[0],
+            previous: undefined,
+            next: undefined
+        };
+        this.valueSet = new Set([history[0]]);
+        for (let i = 1; i < history.length; i++) {
+            this.add(history[i]);
+        }
+    }
+    add(value) {
+        const node = {
+            value,
+            previous: this.tail,
+            next: undefined
+        };
+        this.tail.next = node;
+        this.tail = node;
+        this.cursor = this.tail;
+        this.size++;
+        if (this.valueSet.has(value)) {
+            this._deleteFromList(value);
+        }
+        else {
+            this.valueSet.add(value);
+        }
+        while (this.size > this.capacity) {
+            this.valueSet.delete(this.head.value);
+            this.head = this.head.next;
+            this.head.previous = undefined;
+            this.size--;
+        }
+    }
+    /**
+     * @returns old last value
+     */
+    replaceLast(value) {
+        if (this.tail.value === value) {
+            return value;
+        }
+        const oldValue = this.tail.value;
+        this.valueSet.delete(oldValue);
+        this.tail.value = value;
+        if (this.valueSet.has(value)) {
+            this._deleteFromList(value);
+        }
+        else {
+            this.valueSet.add(value);
+        }
+        return oldValue;
+    }
+    isAtEnd() {
+        return this.cursor === this.tail;
+    }
+    current() {
+        return this.cursor.value;
+    }
+    previous() {
+        if (this.cursor.previous) {
+            this.cursor = this.cursor.previous;
+        }
+        return this.cursor.value;
+    }
+    next() {
+        if (this.cursor.next) {
+            this.cursor = this.cursor.next;
+        }
+        return this.cursor.value;
+    }
+    has(t) {
+        return this.valueSet.has(t);
+    }
+    resetCursor() {
+        this.cursor = this.tail;
+        return this.cursor.value;
+    }
+    *[Symbol.iterator]() {
+        let node = this.head;
+        while (node) {
+            yield node.value;
+            node = node.next;
+        }
+    }
+    _deleteFromList(value) {
+        let temp = this.head;
+        while (temp !== this.tail) {
+            if (temp.value === value) {
+                if (temp === this.head) {
+                    this.head = this.head.next;
+                    this.head.previous = undefined;
+                }
+                else {
+                    temp.previous.next = temp.next;
+                    temp.next.previous = temp.previous;
+                }
+                this.size--;
+            }
+            temp = temp.next;
+        }
+    }
+}
diff -urN -x '*.map' a/vs/base/common/json.js b/vs/base/common/json.js
--- a/vs/base/common/json.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/base/common/json.js	2023-09-05 08:45:14.301196405 +0000
@@ -0,0 +1,967 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+export var ParseOptions;
+(function (ParseOptions) {
+    ParseOptions.DEFAULT = {
+        allowTrailingComma: true
+    };
+})(ParseOptions || (ParseOptions = {}));
+/**
+ * Creates a JSON scanner on the given text.
+ * If ignoreTrivia is set, whitespaces or comments are ignored.
+ */
+export function createScanner(text, ignoreTrivia = false) {
+    let pos = 0;
+    const len = text.length;
+    let value = '';
+    let tokenOffset = 0;
+    let token = 16 /* SyntaxKind.Unknown */;
+    let scanError = 0 /* ScanError.None */;
+    function scanHexDigits(count) {
+        let digits = 0;
+        let hexValue = 0;
+        while (digits < count) {
+            const ch = text.charCodeAt(pos);
+            if (ch >= 48 /* CharacterCodes._0 */ && ch <= 57 /* CharacterCodes._9 */) {
+                hexValue = hexValue * 16 + ch - 48 /* CharacterCodes._0 */;
+            }
+            else if (ch >= 65 /* CharacterCodes.A */ && ch <= 70 /* CharacterCodes.F */) {
+                hexValue = hexValue * 16 + ch - 65 /* CharacterCodes.A */ + 10;
+            }
+            else if (ch >= 97 /* CharacterCodes.a */ && ch <= 102 /* CharacterCodes.f */) {
+                hexValue = hexValue * 16 + ch - 97 /* CharacterCodes.a */ + 10;
+            }
+            else {
+                break;
+            }
+            pos++;
+            digits++;
+        }
+        if (digits < count) {
+            hexValue = -1;
+        }
+        return hexValue;
+    }
+    function setPosition(newPosition) {
+        pos = newPosition;
+        value = '';
+        tokenOffset = 0;
+        token = 16 /* SyntaxKind.Unknown */;
+        scanError = 0 /* ScanError.None */;
+    }
+    function scanNumber() {
+        const start = pos;
+        if (text.charCodeAt(pos) === 48 /* CharacterCodes._0 */) {
+            pos++;
+        }
+        else {
+            pos++;
+            while (pos < text.length && isDigit(text.charCodeAt(pos))) {
+                pos++;
+            }
+        }
+        if (pos < text.length && text.charCodeAt(pos) === 46 /* CharacterCodes.dot */) {
+            pos++;
+            if (pos < text.length && isDigit(text.charCodeAt(pos))) {
+                pos++;
+                while (pos < text.length && isDigit(text.charCodeAt(pos))) {
+                    pos++;
+                }
+            }
+            else {
+                scanError = 3 /* ScanError.UnexpectedEndOfNumber */;
+                return text.substring(start, pos);
+            }
+        }
+        let end = pos;
+        if (pos < text.length && (text.charCodeAt(pos) === 69 /* CharacterCodes.E */ || text.charCodeAt(pos) === 101 /* CharacterCodes.e */)) {
+            pos++;
+            if (pos < text.length && text.charCodeAt(pos) === 43 /* CharacterCodes.plus */ || text.charCodeAt(pos) === 45 /* CharacterCodes.minus */) {
+                pos++;
+            }
+            if (pos < text.length && isDigit(text.charCodeAt(pos))) {
+                pos++;
+                while (pos < text.length && isDigit(text.charCodeAt(pos))) {
+                    pos++;
+                }
+                end = pos;
+            }
+            else {
+                scanError = 3 /* ScanError.UnexpectedEndOfNumber */;
+            }
+        }
+        return text.substring(start, end);
+    }
+    function scanString() {
+        let result = '', start = pos;
+        while (true) {
+            if (pos >= len) {
+                result += text.substring(start, pos);
+                scanError = 2 /* ScanError.UnexpectedEndOfString */;
+                break;
+            }
+            const ch = text.charCodeAt(pos);
+            if (ch === 34 /* CharacterCodes.doubleQuote */) {
+                result += text.substring(start, pos);
+                pos++;
+                break;
+            }
+            if (ch === 92 /* CharacterCodes.backslash */) {
+                result += text.substring(start, pos);
+                pos++;
+                if (pos >= len) {
+                    scanError = 2 /* ScanError.UnexpectedEndOfString */;
+                    break;
+                }
+                const ch2 = text.charCodeAt(pos++);
+                switch (ch2) {
+                    case 34 /* CharacterCodes.doubleQuote */:
+                        result += '\"';
+                        break;
+                    case 92 /* CharacterCodes.backslash */:
+                        result += '\\';
+                        break;
+                    case 47 /* CharacterCodes.slash */:
+                        result += '/';
+                        break;
+                    case 98 /* CharacterCodes.b */:
+                        result += '\b';
+                        break;
+                    case 102 /* CharacterCodes.f */:
+                        result += '\f';
+                        break;
+                    case 110 /* CharacterCodes.n */:
+                        result += '\n';
+                        break;
+                    case 114 /* CharacterCodes.r */:
+                        result += '\r';
+                        break;
+                    case 116 /* CharacterCodes.t */:
+                        result += '\t';
+                        break;
+                    case 117 /* CharacterCodes.u */: {
+                        const ch3 = scanHexDigits(4);
+                        if (ch3 >= 0) {
+                            result += String.fromCharCode(ch3);
+                        }
+                        else {
+                            scanError = 4 /* ScanError.InvalidUnicode */;
+                        }
+                        break;
+                    }
+                    default:
+                        scanError = 5 /* ScanError.InvalidEscapeCharacter */;
+                }
+                start = pos;
+                continue;
+            }
+            if (ch >= 0 && ch <= 0x1F) {
+                if (isLineBreak(ch)) {
+                    result += text.substring(start, pos);
+                    scanError = 2 /* ScanError.UnexpectedEndOfString */;
+                    break;
+                }
+                else {
+                    scanError = 6 /* ScanError.InvalidCharacter */;
+                    // mark as error but continue with string
+                }
+            }
+            pos++;
+        }
+        return result;
+    }
+    function scanNext() {
+        value = '';
+        scanError = 0 /* ScanError.None */;
+        tokenOffset = pos;
+        if (pos >= len) {
+            // at the end
+            tokenOffset = len;
+            return token = 17 /* SyntaxKind.EOF */;
+        }
+        let code = text.charCodeAt(pos);
+        // trivia: whitespace
+        if (isWhitespace(code)) {
+            do {
+                pos++;
+                value += String.fromCharCode(code);
+                code = text.charCodeAt(pos);
+            } while (isWhitespace(code));
+            return token = 15 /* SyntaxKind.Trivia */;
+        }
+        // trivia: newlines
+        if (isLineBreak(code)) {
+            pos++;
+            value += String.fromCharCode(code);
+            if (code === 13 /* CharacterCodes.carriageReturn */ && text.charCodeAt(pos) === 10 /* CharacterCodes.lineFeed */) {
+                pos++;
+                value += '\n';
+            }
+            return token = 14 /* SyntaxKind.LineBreakTrivia */;
+        }
+        switch (code) {
+            // tokens: []{}:,
+            case 123 /* CharacterCodes.openBrace */:
+                pos++;
+                return token = 1 /* SyntaxKind.OpenBraceToken */;
+            case 125 /* CharacterCodes.closeBrace */:
+                pos++;
+                return token = 2 /* SyntaxKind.CloseBraceToken */;
+            case 91 /* CharacterCodes.openBracket */:
+                pos++;
+                return token = 3 /* SyntaxKind.OpenBracketToken */;
+            case 93 /* CharacterCodes.closeBracket */:
+                pos++;
+                return token = 4 /* SyntaxKind.CloseBracketToken */;
+            case 58 /* CharacterCodes.colon */:
+                pos++;
+                return token = 6 /* SyntaxKind.ColonToken */;
+            case 44 /* CharacterCodes.comma */:
+                pos++;
+                return token = 5 /* SyntaxKind.CommaToken */;
+            // strings
+            case 34 /* CharacterCodes.doubleQuote */:
+                pos++;
+                value = scanString();
+                return token = 10 /* SyntaxKind.StringLiteral */;
+            // comments
+            case 47 /* CharacterCodes.slash */: {
+                const start = pos - 1;
+                // Single-line comment
+                if (text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */) {
+                    pos += 2;
+                    while (pos < len) {
+                        if (isLineBreak(text.charCodeAt(pos))) {
+                            break;
+                        }
+                        pos++;
+                    }
+                    value = text.substring(start, pos);
+                    return token = 12 /* SyntaxKind.LineCommentTrivia */;
+                }
+                // Multi-line comment
+                if (text.charCodeAt(pos + 1) === 42 /* CharacterCodes.asterisk */) {
+                    pos += 2;
+                    const safeLength = len - 1; // For lookahead.
+                    let commentClosed = false;
+                    while (pos < safeLength) {
+                        const ch = text.charCodeAt(pos);
+                        if (ch === 42 /* CharacterCodes.asterisk */ && text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */) {
+                            pos += 2;
+                            commentClosed = true;
+                            break;
+                        }
+                        pos++;
+                    }
+                    if (!commentClosed) {
+                        pos++;
+                        scanError = 1 /* ScanError.UnexpectedEndOfComment */;
+                    }
+                    value = text.substring(start, pos);
+                    return token = 13 /* SyntaxKind.BlockCommentTrivia */;
+                }
+                // just a single slash
+                value += String.fromCharCode(code);
+                pos++;
+                return token = 16 /* SyntaxKind.Unknown */;
+            }
+            // numbers
+            case 45 /* CharacterCodes.minus */:
+                value += String.fromCharCode(code);
+                pos++;
+                if (pos === len || !isDigit(text.charCodeAt(pos))) {
+                    return token = 16 /* SyntaxKind.Unknown */;
+                }
+            // found a minus, followed by a number so
+            // we fall through to proceed with scanning
+            // numbers
+            case 48 /* CharacterCodes._0 */:
+            case 49 /* CharacterCodes._1 */:
+            case 50 /* CharacterCodes._2 */:
+            case 51 /* CharacterCodes._3 */:
+            case 52 /* CharacterCodes._4 */:
+            case 53 /* CharacterCodes._5 */:
+            case 54 /* CharacterCodes._6 */:
+            case 55 /* CharacterCodes._7 */:
+            case 56 /* CharacterCodes._8 */:
+            case 57 /* CharacterCodes._9 */:
+                value += scanNumber();
+                return token = 11 /* SyntaxKind.NumericLiteral */;
+            // literals and unknown symbols
+            default:
+                // is a literal? Read the full word.
+                while (pos < len && isUnknownContentCharacter(code)) {
+                    pos++;
+                    code = text.charCodeAt(pos);
+                }
+                if (tokenOffset !== pos) {
+                    value = text.substring(tokenOffset, pos);
+                    // keywords: true, false, null
+                    switch (value) {
+                        case 'true': return token = 8 /* SyntaxKind.TrueKeyword */;
+                        case 'false': return token = 9 /* SyntaxKind.FalseKeyword */;
+                        case 'null': return token = 7 /* SyntaxKind.NullKeyword */;
+                    }
+                    return token = 16 /* SyntaxKind.Unknown */;
+                }
+                // some
+                value += String.fromCharCode(code);
+                pos++;
+                return token = 16 /* SyntaxKind.Unknown */;
+        }
+    }
+    function isUnknownContentCharacter(code) {
+        if (isWhitespace(code) || isLineBreak(code)) {
+            return false;
+        }
+        switch (code) {
+            case 125 /* CharacterCodes.closeBrace */:
+            case 93 /* CharacterCodes.closeBracket */:
+            case 123 /* CharacterCodes.openBrace */:
+            case 91 /* CharacterCodes.openBracket */:
+            case 34 /* CharacterCodes.doubleQuote */:
+            case 58 /* CharacterCodes.colon */:
+            case 44 /* CharacterCodes.comma */:
+            case 47 /* CharacterCodes.slash */:
+                return false;
+        }
+        return true;
+    }
+    function scanNextNonTrivia() {
+        let result;
+        do {
+            result = scanNext();
+        } while (result >= 12 /* SyntaxKind.LineCommentTrivia */ && result <= 15 /* SyntaxKind.Trivia */);
+        return result;
+    }
+    return {
+        setPosition: setPosition,
+        getPosition: () => pos,
+        scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
+        getToken: () => token,
+        getTokenValue: () => value,
+        getTokenOffset: () => tokenOffset,
+        getTokenLength: () => pos - tokenOffset,
+        getTokenError: () => scanError
+    };
+}
+function isWhitespace(ch) {
+    return ch === 32 /* CharacterCodes.space */ || ch === 9 /* CharacterCodes.tab */ || ch === 11 /* CharacterCodes.verticalTab */ || ch === 12 /* CharacterCodes.formFeed */ ||
+        ch === 160 /* CharacterCodes.nonBreakingSpace */ || ch === 5760 /* CharacterCodes.ogham */ || ch >= 8192 /* CharacterCodes.enQuad */ && ch <= 8203 /* CharacterCodes.zeroWidthSpace */ ||
+        ch === 8239 /* CharacterCodes.narrowNoBreakSpace */ || ch === 8287 /* CharacterCodes.mathematicalSpace */ || ch === 12288 /* CharacterCodes.ideographicSpace */ || ch === 65279 /* CharacterCodes.byteOrderMark */;
+}
+function isLineBreak(ch) {
+    return ch === 10 /* CharacterCodes.lineFeed */ || ch === 13 /* CharacterCodes.carriageReturn */ || ch === 8232 /* CharacterCodes.lineSeparator */ || ch === 8233 /* CharacterCodes.paragraphSeparator */;
+}
+function isDigit(ch) {
+    return ch >= 48 /* CharacterCodes._0 */ && ch <= 57 /* CharacterCodes._9 */;
+}
+/**
+ * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.
+ */
+export function getLocation(text, position) {
+    const segments = []; // strings or numbers
+    const earlyReturnException = new Object();
+    let previousNode = undefined;
+    const previousNodeInst = {
+        value: {},
+        offset: 0,
+        length: 0,
+        type: 'object',
+        parent: undefined
+    };
+    let isAtPropertyKey = false;
+    function setPreviousNode(value, offset, length, type) {
+        previousNodeInst.value = value;
+        previousNodeInst.offset = offset;
+        previousNodeInst.length = length;
+        previousNodeInst.type = type;
+        previousNodeInst.colonOffset = undefined;
+        previousNode = previousNodeInst;
+    }
+    try {
+        visit(text, {
+            onObjectBegin: (offset, length) => {
+                if (position <= offset) {
+                    throw earlyReturnException;
+                }
+                previousNode = undefined;
+                isAtPropertyKey = position > offset;
+                segments.push(''); // push a placeholder (will be replaced)
+            },
+            onObjectProperty: (name, offset, length) => {
+                if (position < offset) {
+                    throw earlyReturnException;
+                }
+                setPreviousNode(name, offset, length, 'property');
+                segments[segments.length - 1] = name;
+                if (position <= offset + length) {
+                    throw earlyReturnException;
+                }
+            },
+            onObjectEnd: (offset, length) => {
+                if (position <= offset) {
+                    throw earlyReturnException;
+                }
+                previousNode = undefined;
+                segments.pop();
+            },
+            onArrayBegin: (offset, length) => {
+                if (position <= offset) {
+                    throw earlyReturnException;
+                }
+                previousNode = undefined;
+                segments.push(0);
+            },
+            onArrayEnd: (offset, length) => {
+                if (position <= offset) {
+                    throw earlyReturnException;
+                }
+                previousNode = undefined;
+                segments.pop();
+            },
+            onLiteralValue: (value, offset, length) => {
+                if (position < offset) {
+                    throw earlyReturnException;
+                }
+                setPreviousNode(value, offset, length, getNodeType(value));
+                if (position <= offset + length) {
+                    throw earlyReturnException;
+                }
+            },
+            onSeparator: (sep, offset, length) => {
+                if (position <= offset) {
+                    throw earlyReturnException;
+                }
+                if (sep === ':' && previousNode && previousNode.type === 'property') {
+                    previousNode.colonOffset = offset;
+                    isAtPropertyKey = false;
+                    previousNode = undefined;
+                }
+                else if (sep === ',') {
+                    const last = segments[segments.length - 1];
+                    if (typeof last === 'number') {
+                        segments[segments.length - 1] = last + 1;
+                    }
+                    else {
+                        isAtPropertyKey = true;
+                        segments[segments.length - 1] = '';
+                    }
+                    previousNode = undefined;
+                }
+            }
+        });
+    }
+    catch (e) {
+        if (e !== earlyReturnException) {
+            throw e;
+        }
+    }
+    return {
+        path: segments,
+        previousNode,
+        isAtPropertyKey,
+        matches: (pattern) => {
+            let k = 0;
+            for (let i = 0; k < pattern.length && i < segments.length; i++) {
+                if (pattern[k] === segments[i] || pattern[k] === '*') {
+                    k++;
+                }
+                else if (pattern[k] !== '**') {
+                    return false;
+                }
+            }
+            return k === pattern.length;
+        }
+    };
+}
+/**
+ * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
+ * Therefore always check the errors list to find out if the input was valid.
+ */
+export function parse(text, errors = [], options = ParseOptions.DEFAULT) {
+    let currentProperty = null;
+    let currentParent = [];
+    const previousParents = [];
+    function onValue(value) {
+        if (Array.isArray(currentParent)) {
+            currentParent.push(value);
+        }
+        else if (currentProperty !== null) {
+            currentParent[currentProperty] = value;
+        }
+    }
+    const visitor = {
+        onObjectBegin: () => {
+            const object = {};
+            onValue(object);
+            previousParents.push(currentParent);
+            currentParent = object;
+            currentProperty = null;
+        },
+        onObjectProperty: (name) => {
+            currentProperty = name;
+        },
+        onObjectEnd: () => {
+            currentParent = previousParents.pop();
+        },
+        onArrayBegin: () => {
+            const array = [];
+            onValue(array);
+            previousParents.push(currentParent);
+            currentParent = array;
+            currentProperty = null;
+        },
+        onArrayEnd: () => {
+            currentParent = previousParents.pop();
+        },
+        onLiteralValue: onValue,
+        onError: (error, offset, length) => {
+            errors.push({ error, offset, length });
+        }
+    };
+    visit(text, visitor, options);
+    return currentParent[0];
+}
+/**
+ * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
+ */
+export function parseTree(text, errors = [], options = ParseOptions.DEFAULT) {
+    let currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: undefined }; // artificial root
+    function ensurePropertyComplete(endOffset) {
+        if (currentParent.type === 'property') {
+            currentParent.length = endOffset - currentParent.offset;
+            currentParent = currentParent.parent;
+        }
+    }
+    function onValue(valueNode) {
+        currentParent.children.push(valueNode);
+        return valueNode;
+    }
+    const visitor = {
+        onObjectBegin: (offset) => {
+            currentParent = onValue({ type: 'object', offset, length: -1, parent: currentParent, children: [] });
+        },
+        onObjectProperty: (name, offset, length) => {
+            currentParent = onValue({ type: 'property', offset, length: -1, parent: currentParent, children: [] });
+            currentParent.children.push({ type: 'string', value: name, offset, length, parent: currentParent });
+        },
+        onObjectEnd: (offset, length) => {
+            currentParent.length = offset + length - currentParent.offset;
+            currentParent = currentParent.parent;
+            ensurePropertyComplete(offset + length);
+        },
+        onArrayBegin: (offset, length) => {
+            currentParent = onValue({ type: 'array', offset, length: -1, parent: currentParent, children: [] });
+        },
+        onArrayEnd: (offset, length) => {
+            currentParent.length = offset + length - currentParent.offset;
+            currentParent = currentParent.parent;
+            ensurePropertyComplete(offset + length);
+        },
+        onLiteralValue: (value, offset, length) => {
+            onValue({ type: getNodeType(value), offset, length, parent: currentParent, value });
+            ensurePropertyComplete(offset + length);
+        },
+        onSeparator: (sep, offset, length) => {
+            if (currentParent.type === 'property') {
+                if (sep === ':') {
+                    currentParent.colonOffset = offset;
+                }
+                else if (sep === ',') {
+                    ensurePropertyComplete(offset);
+                }
+            }
+        },
+        onError: (error, offset, length) => {
+            errors.push({ error, offset, length });
+        }
+    };
+    visit(text, visitor, options);
+    const result = currentParent.children[0];
+    if (result) {
+        delete result.parent;
+    }
+    return result;
+}
+/**
+ * Finds the node at the given path in a JSON DOM.
+ */
+export function findNodeAtLocation(root, path) {
+    if (!root) {
+        return undefined;
+    }
+    let node = root;
+    for (const segment of path) {
+        if (typeof segment === 'string') {
+            if (node.type !== 'object' || !Array.isArray(node.children)) {
+                return undefined;
+            }
+            let found = false;
+            for (const propertyNode of node.children) {
+                if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {
+                    node = propertyNode.children[1];
+                    found = true;
+                    break;
+                }
+            }
+            if (!found) {
+                return undefined;
+            }
+        }
+        else {
+            const index = segment;
+            if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {
+                return undefined;
+            }
+            node = node.children[index];
+        }
+    }
+    return node;
+}
+/**
+ * Gets the JSON path of the given JSON DOM node
+ */
+export function getNodePath(node) {
+    if (!node.parent || !node.parent.children) {
+        return [];
+    }
+    const path = getNodePath(node.parent);
+    if (node.parent.type === 'property') {
+        const key = node.parent.children[0].value;
+        path.push(key);
+    }
+    else if (node.parent.type === 'array') {
+        const index = node.parent.children.indexOf(node);
+        if (index !== -1) {
+            path.push(index);
+        }
+    }
+    return path;
+}
+/**
+ * Evaluates the JavaScript object of the given JSON DOM node
+ */
+export function getNodeValue(node) {
+    switch (node.type) {
+        case 'array':
+            return node.children.map(getNodeValue);
+        case 'object': {
+            const obj = Object.create(null);
+            for (const prop of node.children) {
+                const valueNode = prop.children[1];
+                if (valueNode) {
+                    obj[prop.children[0].value] = getNodeValue(valueNode);
+                }
+            }
+            return obj;
+        }
+        case 'null':
+        case 'string':
+        case 'number':
+        case 'boolean':
+            return node.value;
+        default:
+            return undefined;
+    }
+}
+export function contains(node, offset, includeRightBound = false) {
+    return (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));
+}
+/**
+ * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.
+ */
+export function findNodeAtOffset(node, offset, includeRightBound = false) {
+    if (contains(node, offset, includeRightBound)) {
+        const children = node.children;
+        if (Array.isArray(children)) {
+            for (let i = 0; i < children.length && children[i].offset <= offset; i++) {
+                const item = findNodeAtOffset(children[i], offset, includeRightBound);
+                if (item) {
+                    return item;
+                }
+            }
+        }
+        return node;
+    }
+    return undefined;
+}
+/**
+ * Parses the given text and invokes the visitor functions for each object, array and literal reached.
+ */
+export function visit(text, visitor, options = ParseOptions.DEFAULT) {
+    const _scanner = createScanner(text, false);
+    function toNoArgVisit(visitFunction) {
+        return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;
+    }
+    function toOneArgVisit(visitFunction) {
+        return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;
+    }
+    const onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
+    const disallowComments = options && options.disallowComments;
+    const allowTrailingComma = options && options.allowTrailingComma;
+    function scanNext() {
+        while (true) {
+            const token = _scanner.scan();
+            switch (_scanner.getTokenError()) {
+                case 4 /* ScanError.InvalidUnicode */:
+                    handleError(14 /* ParseErrorCode.InvalidUnicode */);
+                    break;
+                case 5 /* ScanError.InvalidEscapeCharacter */:
+                    handleError(15 /* ParseErrorCode.InvalidEscapeCharacter */);
+                    break;
+                case 3 /* ScanError.UnexpectedEndOfNumber */:
+                    handleError(13 /* ParseErrorCode.UnexpectedEndOfNumber */);
+                    break;
+                case 1 /* ScanError.UnexpectedEndOfComment */:
+                    if (!disallowComments) {
+                        handleError(11 /* ParseErrorCode.UnexpectedEndOfComment */);
+                    }
+                    break;
+                case 2 /* ScanError.UnexpectedEndOfString */:
+                    handleError(12 /* ParseErrorCode.UnexpectedEndOfString */);
+                    break;
+                case 6 /* ScanError.InvalidCharacter */:
+                    handleError(16 /* ParseErrorCode.InvalidCharacter */);
+                    break;
+            }
+            switch (token) {
+                case 12 /* SyntaxKind.LineCommentTrivia */:
+                case 13 /* SyntaxKind.BlockCommentTrivia */:
+                    if (disallowComments) {
+                        handleError(10 /* ParseErrorCode.InvalidCommentToken */);
+                    }
+                    else {
+                        onComment();
+                    }
+                    break;
+                case 16 /* SyntaxKind.Unknown */:
+                    handleError(1 /* ParseErrorCode.InvalidSymbol */);
+                    break;
+                case 15 /* SyntaxKind.Trivia */:
+                case 14 /* SyntaxKind.LineBreakTrivia */:
+                    break;
+                default:
+                    return token;
+            }
+        }
+    }
+    function handleError(error, skipUntilAfter = [], skipUntil = []) {
+        onError(error);
+        if (skipUntilAfter.length + skipUntil.length > 0) {
+            let token = _scanner.getToken();
+            while (token !== 17 /* SyntaxKind.EOF */) {
+                if (skipUntilAfter.indexOf(token) !== -1) {
+                    scanNext();
+                    break;
+                }
+                else if (skipUntil.indexOf(token) !== -1) {
+                    break;
+                }
+                token = scanNext();
+            }
+        }
+    }
+    function parseString(isValue) {
+        const value = _scanner.getTokenValue();
+        if (isValue) {
+            onLiteralValue(value);
+        }
+        else {
+            onObjectProperty(value);
+        }
+        scanNext();
+        return true;
+    }
+    function parseLiteral() {
+        switch (_scanner.getToken()) {
+            case 11 /* SyntaxKind.NumericLiteral */: {
+                let value = 0;
+                try {
+                    value = JSON.parse(_scanner.getTokenValue());
+                    if (typeof value !== 'number') {
+                        handleError(2 /* ParseErrorCode.InvalidNumberFormat */);
+                        value = 0;
+                    }
+                }
+                catch (e) {
+                    handleError(2 /* ParseErrorCode.InvalidNumberFormat */);
+                }
+                onLiteralValue(value);
+                break;
+            }
+            case 7 /* SyntaxKind.NullKeyword */:
+                onLiteralValue(null);
+                break;
+            case 8 /* SyntaxKind.TrueKeyword */:
+                onLiteralValue(true);
+                break;
+            case 9 /* SyntaxKind.FalseKeyword */:
+                onLiteralValue(false);
+                break;
+            default:
+                return false;
+        }
+        scanNext();
+        return true;
+    }
+    function parseProperty() {
+        if (_scanner.getToken() !== 10 /* SyntaxKind.StringLiteral */) {
+            handleError(3 /* ParseErrorCode.PropertyNameExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);
+            return false;
+        }
+        parseString(false);
+        if (_scanner.getToken() === 6 /* SyntaxKind.ColonToken */) {
+            onSeparator(':');
+            scanNext(); // consume colon
+            if (!parseValue()) {
+                handleError(4 /* ParseErrorCode.ValueExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);
+            }
+        }
+        else {
+            handleError(5 /* ParseErrorCode.ColonExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);
+        }
+        return true;
+    }
+    function parseObject() {
+        onObjectBegin();
+        scanNext(); // consume open brace
+        let needsComma = false;
+        while (_scanner.getToken() !== 2 /* SyntaxKind.CloseBraceToken */ && _scanner.getToken() !== 17 /* SyntaxKind.EOF */) {
+            if (_scanner.getToken() === 5 /* SyntaxKind.CommaToken */) {
+                if (!needsComma) {
+                    handleError(4 /* ParseErrorCode.ValueExpected */, [], []);
+                }
+                onSeparator(',');
+                scanNext(); // consume comma
+                if (_scanner.getToken() === 2 /* SyntaxKind.CloseBraceToken */ && allowTrailingComma) {
+                    break;
+                }
+            }
+            else if (needsComma) {
+                handleError(6 /* ParseErrorCode.CommaExpected */, [], []);
+            }
+            if (!parseProperty()) {
+                handleError(4 /* ParseErrorCode.ValueExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);
+            }
+            needsComma = true;
+        }
+        onObjectEnd();
+        if (_scanner.getToken() !== 2 /* SyntaxKind.CloseBraceToken */) {
+            handleError(7 /* ParseErrorCode.CloseBraceExpected */, [2 /* SyntaxKind.CloseBraceToken */], []);
+        }
+        else {
+            scanNext(); // consume close brace
+        }
+        return true;
+    }
+    function parseArray() {
+        onArrayBegin();
+        scanNext(); // consume open bracket
+        let needsComma = false;
+        while (_scanner.getToken() !== 4 /* SyntaxKind.CloseBracketToken */ && _scanner.getToken() !== 17 /* SyntaxKind.EOF */) {
+            if (_scanner.getToken() === 5 /* SyntaxKind.CommaToken */) {
+                if (!needsComma) {
+                    handleError(4 /* ParseErrorCode.ValueExpected */, [], []);
+                }
+                onSeparator(',');
+                scanNext(); // consume comma
+                if (_scanner.getToken() === 4 /* SyntaxKind.CloseBracketToken */ && allowTrailingComma) {
+                    break;
+                }
+            }
+            else if (needsComma) {
+                handleError(6 /* ParseErrorCode.CommaExpected */, [], []);
+            }
+            if (!parseValue()) {
+                handleError(4 /* ParseErrorCode.ValueExpected */, [], [4 /* SyntaxKind.CloseBracketToken */, 5 /* SyntaxKind.CommaToken */]);
+            }
+            needsComma = true;
+        }
+        onArrayEnd();
+        if (_scanner.getToken() !== 4 /* SyntaxKind.CloseBracketToken */) {
+            handleError(8 /* ParseErrorCode.CloseBracketExpected */, [4 /* SyntaxKind.CloseBracketToken */], []);
+        }
+        else {
+            scanNext(); // consume close bracket
+        }
+        return true;
+    }
+    function parseValue() {
+        switch (_scanner.getToken()) {
+            case 3 /* SyntaxKind.OpenBracketToken */:
+                return parseArray();
+            case 1 /* SyntaxKind.OpenBraceToken */:
+                return parseObject();
+            case 10 /* SyntaxKind.StringLiteral */:
+                return parseString(true);
+            default:
+                return parseLiteral();
+        }
+    }
+    scanNext();
+    if (_scanner.getToken() === 17 /* SyntaxKind.EOF */) {
+        if (options.allowEmptyContent) {
+            return true;
+        }
+        handleError(4 /* ParseErrorCode.ValueExpected */, [], []);
+        return false;
+    }
+    if (!parseValue()) {
+        handleError(4 /* ParseErrorCode.ValueExpected */, [], []);
+        return false;
+    }
+    if (_scanner.getToken() !== 17 /* SyntaxKind.EOF */) {
+        handleError(9 /* ParseErrorCode.EndOfFileExpected */, [], []);
+    }
+    return true;
+}
+/**
+ * Takes JSON with JavaScript-style comments and remove
+ * them. Optionally replaces every none-newline character
+ * of comments with a replaceCharacter
+ */
+export function stripComments(text, replaceCh) {
+    const _scanner = createScanner(text);
+    const parts = [];
+    let kind;
+    let offset = 0;
+    let pos;
+    do {
+        pos = _scanner.getPosition();
+        kind = _scanner.scan();
+        switch (kind) {
+            case 12 /* SyntaxKind.LineCommentTrivia */:
+            case 13 /* SyntaxKind.BlockCommentTrivia */:
+            case 17 /* SyntaxKind.EOF */:
+                if (offset !== pos) {
+                    parts.push(text.substring(offset, pos));
+                }
+                if (replaceCh !== undefined) {
+                    parts.push(_scanner.getTokenValue().replace(/[^\r\n]/g, replaceCh));
+                }
+                offset = _scanner.getPosition();
+                break;
+        }
+    } while (kind !== 17 /* SyntaxKind.EOF */);
+    return parts.join('');
+}
+export function getNodeType(value) {
+    switch (typeof value) {
+        case 'boolean': return 'boolean';
+        case 'number': return 'number';
+        case 'string': return 'string';
+        case 'object': {
+            if (!value) {
+                return 'null';
+            }
+            else if (Array.isArray(value)) {
+                return 'array';
+            }
+            return 'object';
+        }
+        default: return 'null';
+    }
+}
diff -urN -x '*.map' a/vs/base/common/keyCodes.js b/vs/base/common/keyCodes.js
--- a/vs/base/common/keyCodes.js	2023-09-05 08:43:04.226808446 +0000
+++ b/vs/base/common/keyCodes.js	2023-09-05 08:45:14.297196348 +0000
@@ -26,6 +26,11 @@
 const scanCodeIntToStr = [];
 const scanCodeStrToInt = Object.create(null);
 const scanCodeLowerCaseStrToInt = Object.create(null);
+export const ScanCodeUtils = {
+    lowerCaseToEnum: (scanCode) => scanCodeLowerCaseStrToInt[scanCode] || 0 /* ScanCode.None */,
+    toEnum: (scanCode) => scanCodeStrToInt[scanCode] || 0 /* ScanCode.None */,
+    toString: (scanCode) => scanCodeIntToStr[scanCode] || 'None'
+};
 /**
  * -1 if a ScanCode => KeyCode mapping depends on kb layout.
  */
diff -urN -x '*.map' a/vs/base/common/keybindings.js b/vs/base/common/keybindings.js
--- a/vs/base/common/keybindings.js	2023-09-05 08:43:04.226808446 +0000
+++ b/vs/base/common/keybindings.js	2023-09-05 08:45:14.297196348 +0000
@@ -56,6 +56,13 @@
             && this.metaKey === other.metaKey
             && this.keyCode === other.keyCode);
     }
+    getHashCode() {
+        const ctrl = this.ctrlKey ? '1' : '0';
+        const shift = this.shiftKey ? '1' : '0';
+        const alt = this.altKey ? '1' : '0';
+        const meta = this.metaKey ? '1' : '0';
+        return `K${ctrl}${shift}${alt}${meta}${this.keyCode}`;
+    }
     isModifierKey() {
         return (this.keyCode === 0 /* KeyCode.Unknown */
             || this.keyCode === 5 /* KeyCode.Ctrl */
@@ -63,6 +70,9 @@
             || this.keyCode === 6 /* KeyCode.Alt */
             || this.keyCode === 4 /* KeyCode.Shift */);
     }
+    toKeybinding() {
+        return new Keybinding([this]);
+    }
     /**
      * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?
      */
@@ -85,6 +95,21 @@
         this.metaKey = metaKey;
         this.scanCode = scanCode;
     }
+    equals(other) {
+        return (other instanceof ScanCodeChord
+            && this.ctrlKey === other.ctrlKey
+            && this.shiftKey === other.shiftKey
+            && this.altKey === other.altKey
+            && this.metaKey === other.metaKey
+            && this.scanCode === other.scanCode);
+    }
+    getHashCode() {
+        const ctrl = this.ctrlKey ? '1' : '0';
+        const shift = this.shiftKey ? '1' : '0';
+        const alt = this.altKey ? '1' : '0';
+        const meta = this.metaKey ? '1' : '0';
+        return `S${ctrl}${shift}${alt}${meta}${this.scanCode}`;
+    }
     /**
      * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?
      */
@@ -105,6 +130,30 @@
         }
         this.chords = chords;
     }
+    getHashCode() {
+        let result = '';
+        for (let i = 0, len = this.chords.length; i < len; i++) {
+            if (i !== 0) {
+                result += ';';
+            }
+            result += this.chords[i].getHashCode();
+        }
+        return result;
+    }
+    equals(other) {
+        if (other === null) {
+            return false;
+        }
+        if (this.chords.length !== other.chords.length) {
+            return false;
+        }
+        for (let i = 0; i < this.chords.length; i++) {
+            if (!this.chords[i].equals(other.chords[i])) {
+                return false;
+            }
+        }
+        return true;
+    }
 }
 export class ResolvedChord {
     constructor(ctrlKey, shiftKey, altKey, metaKey, keyLabel, keyAriaLabel) {
diff -urN -x '*.map' a/vs/base/common/labels.js b/vs/base/common/labels.js
--- a/vs/base/common/labels.js	2023-09-05 08:43:04.226808446 +0000
+++ b/vs/base/common/labels.js	2023-09-05 08:45:14.305196462 +0000
@@ -1,5 +1,90 @@
-import { hasDriveLetter } from './extpath.js';
-import { isWindows } from './platform.js';
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { firstOrDefault } from './arrays.js';
+import { hasDriveLetter, toSlashes } from './extpath.js';
+import { posix, sep, win32 } from './path.js';
+import { isMacintosh, isWindows, OS } from './platform.js';
+import { extUri, extUriIgnorePathCase } from './resources.js';
+import { rtrim, startsWithIgnoreCase } from './strings.js';
+export function getPathLabel(resource, formatting) {
+    const { os, tildify: tildifier, relative: relatifier } = formatting;
+    // return early with a relative path if we can resolve one
+    if (relatifier) {
+        const relativePath = getRelativePathLabel(resource, relatifier, os);
+        if (typeof relativePath === 'string') {
+            return relativePath;
+        }
+    }
+    // otherwise try to resolve a absolute path label and
+    // apply target OS standard path separators if target
+    // OS differs from actual OS we are running in
+    let absolutePath = resource.fsPath;
+    if (os === 1 /* OperatingSystem.Windows */ && !isWindows) {
+        absolutePath = absolutePath.replace(/\//g, '\\');
+    }
+    else if (os !== 1 /* OperatingSystem.Windows */ && isWindows) {
+        absolutePath = absolutePath.replace(/\\/g, '/');
+    }
+    // macOS/Linux: tildify with provided user home directory
+    if (os !== 1 /* OperatingSystem.Windows */ && (tildifier === null || tildifier === void 0 ? void 0 : tildifier.userHome)) {
+        const userHome = tildifier.userHome.fsPath;
+        // This is a bit of a hack, but in order to figure out if the
+        // resource is in the user home, we need to make sure to convert it
+        // to a user home resource. We cannot assume that the resource is
+        // already a user home resource.
+        let userHomeCandidate;
+        if (resource.scheme !== tildifier.userHome.scheme && resource.path.startsWith(posix.sep)) {
+            userHomeCandidate = tildifier.userHome.with({ path: resource.path }).fsPath;
+        }
+        else {
+            userHomeCandidate = resource.fsPath;
+        }
+        absolutePath = tildify(userHomeCandidate, userHome, os);
+    }
+    // normalize
+    const pathLib = os === 1 /* OperatingSystem.Windows */ ? win32 : posix;
+    return pathLib.normalize(normalizeDriveLetter(absolutePath, os === 1 /* OperatingSystem.Windows */));
+}
+function getRelativePathLabel(resource, relativePathProvider, os) {
+    var _a;
+    const pathLib = os === 1 /* OperatingSystem.Windows */ ? win32 : posix;
+    const extUriLib = os === 3 /* OperatingSystem.Linux */ ? extUri : extUriIgnorePathCase;
+    const workspace = relativePathProvider.getWorkspace();
+    const firstFolder = firstOrDefault(workspace.folders);
+    if (!firstFolder) {
+        return undefined;
+    }
+    // This is a bit of a hack, but in order to figure out the folder
+    // the resource belongs to, we need to make sure to convert it
+    // to a workspace resource. We cannot assume that the resource is
+    // already matching the workspace.
+    if (resource.scheme !== firstFolder.uri.scheme && resource.path.startsWith(posix.sep)) {
+        resource = firstFolder.uri.with({ path: resource.path });
+    }
+    const folder = relativePathProvider.getWorkspaceFolder(resource);
+    if (!folder) {
+        return undefined;
+    }
+    let relativePathLabel = undefined;
+    if (extUriLib.isEqual(folder.uri, resource)) {
+        relativePathLabel = ''; // no label if paths are identical
+    }
+    else {
+        relativePathLabel = (_a = extUriLib.relativePath(folder.uri, resource)) !== null && _a !== void 0 ? _a : '';
+    }
+    // normalize
+    if (relativePathLabel) {
+        relativePathLabel = pathLib.normalize(relativePathLabel);
+    }
+    // always show root basename if there are multiple folders
+    if (workspace.folders.length > 1 && !relativePathProvider.noPrefix) {
+        const rootName = folder.name ? folder.name : extUriLib.basenameOrAuthority(folder.uri);
+        relativePathLabel = relativePathLabel ? `${rootName}  ${relativePathLabel}` : rootName;
+    }
+    return relativePathLabel;
+}
 export function normalizeDriveLetter(path, isWindowsOS = isWindows) {
     if (hasDriveLetter(path, isWindowsOS)) {
         return path.charAt(0).toUpperCase() + path.slice(1);
@@ -7,3 +92,262 @@
     return path;
 }
 let normalizedUserHomeCached = Object.create(null);
+export function tildify(path, userHome, os = OS) {
+    if (os === 1 /* OperatingSystem.Windows */ || !path || !userHome) {
+        return path; // unsupported on Windows
+    }
+    let normalizedUserHome = normalizedUserHomeCached.original === userHome ? normalizedUserHomeCached.normalized : undefined;
+    if (!normalizedUserHome) {
+        normalizedUserHome = userHome;
+        if (isWindows) {
+            normalizedUserHome = toSlashes(normalizedUserHome); // make sure that the path is POSIX normalized on Windows
+        }
+        normalizedUserHome = `${rtrim(normalizedUserHome, posix.sep)}${posix.sep}`;
+        normalizedUserHomeCached = { original: userHome, normalized: normalizedUserHome };
+    }
+    let normalizedPath = path;
+    if (isWindows) {
+        normalizedPath = toSlashes(normalizedPath); // make sure that the path is POSIX normalized on Windows
+    }
+    // Linux: case sensitive, macOS: case insensitive
+    if (os === 3 /* OperatingSystem.Linux */ ? normalizedPath.startsWith(normalizedUserHome) : startsWithIgnoreCase(normalizedPath, normalizedUserHome)) {
+        return `~/${normalizedPath.substr(normalizedUserHome.length)}`;
+    }
+    return path;
+}
+export function untildify(path, userHome) {
+    return path.replace(/^~($|\/|\\)/, `${userHome}$1`);
+}
+/**
+ * Shortens the paths but keeps them easy to distinguish.
+ * Replaces not important parts with ellipsis.
+ * Every shorten path matches only one original path and vice versa.
+ *
+ * Algorithm for shortening paths is as follows:
+ * 1. For every path in list, find unique substring of that path.
+ * 2. Unique substring along with ellipsis is shortened path of that path.
+ * 3. To find unique substring of path, consider every segment of length from 1 to path.length of path from end of string
+ *    and if present segment is not substring to any other paths then present segment is unique path,
+ *    else check if it is not present as suffix of any other path and present segment is suffix of path itself,
+ *    if it is true take present segment as unique path.
+ * 4. Apply ellipsis to unique segment according to whether segment is present at start/in-between/end of path.
+ *
+ * Example 1
+ * 1. consider 2 paths i.e. ['a\\b\\c\\d', 'a\\f\\b\\c\\d']
+ * 2. find unique path of first path,
+ * 	a. 'd' is present in path2 and is suffix of path2, hence not unique of present path.
+ * 	b. 'c' is present in path2 and 'c' is not suffix of present path, similarly for 'b' and 'a' also.
+ * 	c. 'd\\c' is suffix of path2.
+ *  d. 'b\\c' is not suffix of present path.
+ *  e. 'a\\b' is not present in path2, hence unique path is 'a\\b...'.
+ * 3. for path2, 'f' is not present in path1 hence unique is '...\\f\\...'.
+ *
+ * Example 2
+ * 1. consider 2 paths i.e. ['a\\b', 'a\\b\\c'].
+ * 	a. Even if 'b' is present in path2, as 'b' is suffix of path1 and is not suffix of path2, unique path will be '...\\b'.
+ * 2. for path2, 'c' is not present in path1 hence unique path is '..\\c'.
+ */
+const ellipsis = '\u2026';
+const unc = '\\\\';
+const home = '~';
+export function shorten(paths, pathSeparator = sep) {
+    const shortenedPaths = new Array(paths.length);
+    // for every path
+    let match = false;
+    for (let pathIndex = 0; pathIndex < paths.length; pathIndex++) {
+        const originalPath = paths[pathIndex];
+        if (originalPath === '') {
+            shortenedPaths[pathIndex] = `.${pathSeparator}`;
+            continue;
+        }
+        if (!originalPath) {
+            shortenedPaths[pathIndex] = originalPath;
+            continue;
+        }
+        match = true;
+        // trim for now and concatenate unc path (e.g. \\network) or root path (/etc, ~/etc) later
+        let prefix = '';
+        let trimmedPath = originalPath;
+        if (trimmedPath.indexOf(unc) === 0) {
+            prefix = trimmedPath.substr(0, trimmedPath.indexOf(unc) + unc.length);
+            trimmedPath = trimmedPath.substr(trimmedPath.indexOf(unc) + unc.length);
+        }
+        else if (trimmedPath.indexOf(pathSeparator) === 0) {
+            prefix = trimmedPath.substr(0, trimmedPath.indexOf(pathSeparator) + pathSeparator.length);
+            trimmedPath = trimmedPath.substr(trimmedPath.indexOf(pathSeparator) + pathSeparator.length);
+        }
+        else if (trimmedPath.indexOf(home) === 0) {
+            prefix = trimmedPath.substr(0, trimmedPath.indexOf(home) + home.length);
+            trimmedPath = trimmedPath.substr(trimmedPath.indexOf(home) + home.length);
+        }
+        // pick the first shortest subpath found
+        const segments = trimmedPath.split(pathSeparator);
+        for (let subpathLength = 1; match && subpathLength <= segments.length; subpathLength++) {
+            for (let start = segments.length - subpathLength; match && start >= 0; start--) {
+                match = false;
+                let subpath = segments.slice(start, start + subpathLength).join(pathSeparator);
+                // that is unique to any other path
+                for (let otherPathIndex = 0; !match && otherPathIndex < paths.length; otherPathIndex++) {
+                    // suffix subpath treated specially as we consider no match 'x' and 'x/...'
+                    if (otherPathIndex !== pathIndex && paths[otherPathIndex] && paths[otherPathIndex].indexOf(subpath) > -1) {
+                        const isSubpathEnding = (start + subpathLength === segments.length);
+                        // Adding separator as prefix for subpath, such that 'endsWith(src, trgt)' considers subpath as directory name instead of plain string.
+                        // prefix is not added when either subpath is root directory or path[otherPathIndex] does not have multiple directories.
+                        const subpathWithSep = (start > 0 && paths[otherPathIndex].indexOf(pathSeparator) > -1) ? pathSeparator + subpath : subpath;
+                        const isOtherPathEnding = paths[otherPathIndex].endsWith(subpathWithSep);
+                        match = !isSubpathEnding || isOtherPathEnding;
+                    }
+                }
+                // found unique subpath
+                if (!match) {
+                    let result = '';
+                    // preserve disk drive or root prefix
+                    if (segments[0].endsWith(':') || prefix !== '') {
+                        if (start === 1) {
+                            // extend subpath to include disk drive prefix
+                            start = 0;
+                            subpathLength++;
+                            subpath = segments[0] + pathSeparator + subpath;
+                        }
+                        if (start > 0) {
+                            result = segments[0] + pathSeparator;
+                        }
+                        result = prefix + result;
+                    }
+                    // add ellipsis at the beginning if needed
+                    if (start > 0) {
+                        result = result + ellipsis + pathSeparator;
+                    }
+                    result = result + subpath;
+                    // add ellipsis at the end if needed
+                    if (start + subpathLength < segments.length) {
+                        result = result + pathSeparator + ellipsis;
+                    }
+                    shortenedPaths[pathIndex] = result;
+                }
+            }
+        }
+        if (match) {
+            shortenedPaths[pathIndex] = originalPath; // use original path if no unique subpaths found
+        }
+    }
+    return shortenedPaths;
+}
+var Type;
+(function (Type) {
+    Type[Type["TEXT"] = 0] = "TEXT";
+    Type[Type["VARIABLE"] = 1] = "VARIABLE";
+    Type[Type["SEPARATOR"] = 2] = "SEPARATOR";
+})(Type || (Type = {}));
+/**
+ * Helper to insert values for specific template variables into the string. E.g. "this $(is) a $(template)" can be
+ * passed to this function together with an object that maps "is" and "template" to strings to have them replaced.
+ * @param value string to which template is applied
+ * @param values the values of the templates to use
+ */
+export function template(template, values = Object.create(null)) {
+    const segments = [];
+    let inVariable = false;
+    let curVal = '';
+    for (const char of template) {
+        // Beginning of variable
+        if (char === '$' || (inVariable && char === '{')) {
+            if (curVal) {
+                segments.push({ value: curVal, type: Type.TEXT });
+            }
+            curVal = '';
+            inVariable = true;
+        }
+        // End of variable
+        else if (char === '}' && inVariable) {
+            const resolved = values[curVal];
+            // Variable
+            if (typeof resolved === 'string') {
+                if (resolved.length) {
+                    segments.push({ value: resolved, type: Type.VARIABLE });
+                }
+            }
+            // Separator
+            else if (resolved) {
+                const prevSegment = segments[segments.length - 1];
+                if (!prevSegment || prevSegment.type !== Type.SEPARATOR) {
+                    segments.push({ value: resolved.label, type: Type.SEPARATOR }); // prevent duplicate separators
+                }
+            }
+            curVal = '';
+            inVariable = false;
+        }
+        // Text or Variable Name
+        else {
+            curVal += char;
+        }
+    }
+    // Tail
+    if (curVal && !inVariable) {
+        segments.push({ value: curVal, type: Type.TEXT });
+    }
+    return segments.filter((segment, index) => {
+        // Only keep separator if we have values to the left and right
+        if (segment.type === Type.SEPARATOR) {
+            const left = segments[index - 1];
+            const right = segments[index + 1];
+            return [left, right].every(segment => segment && (segment.type === Type.VARIABLE || segment.type === Type.TEXT) && segment.value.length > 0);
+        }
+        // accept any TEXT and VARIABLE
+        return true;
+    }).map(segment => segment.value).join('');
+}
+/**
+ * Handles mnemonics for menu items. Depending on OS:
+ * - Windows: Supported via & character (replace && with &)
+ * -   Linux: Supported via & character (replace && with &)
+ * -   macOS: Unsupported (replace && with empty string)
+ */
+export function mnemonicMenuLabel(label, forceDisableMnemonics) {
+    if (isMacintosh || forceDisableMnemonics) {
+        return label.replace(/\(&&\w\)|&&/g, '').replace(/&/g, isMacintosh ? '&' : '&&');
+    }
+    return label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');
+}
+/**
+ * Handles mnemonics for buttons. Depending on OS:
+ * - Windows: Supported via & character (replace && with & and & with && for escaping)
+ * -   Linux: Supported via _ character (replace && with _)
+ * -   macOS: Unsupported (replace && with empty string)
+ */
+export function mnemonicButtonLabel(label, forceDisableMnemonics) {
+    if (isMacintosh || forceDisableMnemonics) {
+        return label.replace(/\(&&\w\)|&&/g, '');
+    }
+    if (isWindows) {
+        return label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');
+    }
+    return label.replace(/&&/g, '_');
+}
+export function unmnemonicLabel(label) {
+    return label.replace(/&/g, '&&');
+}
+/**
+ * Splits a recent label in name and parent path, supporting both '/' and '\' and workspace suffixes
+ */
+export function splitRecentLabel(recentLabel) {
+    if (recentLabel.endsWith(']')) {
+        // label with workspace suffix
+        const lastIndexOfSquareBracket = recentLabel.lastIndexOf(' [', recentLabel.length - 2);
+        if (lastIndexOfSquareBracket !== -1) {
+            const split = splitName(recentLabel.substring(0, lastIndexOfSquareBracket));
+            return { name: split.name, parentPath: split.parentPath + recentLabel.substring(lastIndexOfSquareBracket) };
+        }
+    }
+    return splitName(recentLabel);
+}
+function splitName(fullPath) {
+    const p = fullPath.indexOf('/') !== -1 ? posix : win32;
+    const name = p.basename(fullPath);
+    const parentPath = p.dirname(fullPath);
+    if (name.length) {
+        return { name, parentPath };
+    }
+    // only the root segment
+    return { name: parentPath, parentPath: '' };
+}
diff -urN -x '*.map' a/vs/base/common/lazy.js b/vs/base/common/lazy.js
--- a/vs/base/common/lazy.js	2023-09-05 08:43:04.226808446 +0000
+++ b/vs/base/common/lazy.js	2023-09-05 08:45:14.297196348 +0000
@@ -8,6 +8,10 @@
         this._didRun = false;
     }
     /**
+     * True if the lazy value has been resolved.
+     */
+    get hasValue() { return this._didRun; }
+    /**
      * Get the wrapped value.
      *
      * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only
diff -urN -x '*.map' a/vs/base/common/lifecycle.js b/vs/base/common/lifecycle.js
--- a/vs/base/common/lifecycle.js	2023-09-05 08:43:04.226808446 +0000
+++ b/vs/base/common/lifecycle.js	2023-09-05 08:45:14.305196462 +0000
@@ -2,6 +2,15 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
 import { once } from './functional.js';
 import { Iterable } from './iterator.js';
 // #region Disposable Tracking
@@ -108,6 +117,14 @@
         return arg;
     }
 }
+export function disposeIfDisposable(disposables) {
+    for (const d of disposables) {
+        if (isDisposable(d)) {
+            d.dispose();
+        }
+    }
+    return [];
+}
 /**
  * Combine multiple disposable values into a single {@link IDisposable}.
  */
@@ -268,6 +285,18 @@
         (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();
         this._value = undefined;
     }
+    /**
+     * Clears the value, but does not dispose it.
+     * The old value is returned.
+    */
+    clearAndLeak() {
+        const oldValue = this._value;
+        this._value = undefined;
+        if (oldValue) {
+            setParentOfDisposable(oldValue, null);
+        }
+        return oldValue;
+    }
 }
 export class RefCountedDisposable {
     constructor(_disposable) {
@@ -285,12 +314,92 @@
         return this;
     }
 }
+/**
+ * A safe disposable can be `unset` so that a leaked reference (listener)
+ * can be cut-off.
+ */
+export class SafeDisposable {
+    constructor() {
+        this.dispose = () => { };
+        this.unset = () => { };
+        this.isset = () => false;
+        trackDisposable(this);
+    }
+    set(fn) {
+        let callback = fn;
+        this.unset = () => callback = undefined;
+        this.isset = () => callback !== undefined;
+        this.dispose = () => {
+            if (callback) {
+                callback();
+                callback = undefined;
+                markAsDisposed(this);
+            }
+        };
+        return this;
+    }
+}
+export class ReferenceCollection {
+    constructor() {
+        this.references = new Map();
+    }
+    acquire(key, ...args) {
+        let reference = this.references.get(key);
+        if (!reference) {
+            reference = { counter: 0, object: this.createReferencedObject(key, ...args) };
+            this.references.set(key, reference);
+        }
+        const { object } = reference;
+        const dispose = once(() => {
+            if (--reference.counter === 0) {
+                this.destroyReferencedObject(key, reference.object);
+                this.references.delete(key);
+            }
+        });
+        reference.counter++;
+        return { object, dispose };
+    }
+}
+/**
+ * Unwraps a reference collection of promised values. Makes sure
+ * references are disposed whenever promises get rejected.
+ */
+export class AsyncReferenceCollection {
+    constructor(referenceCollection) {
+        this.referenceCollection = referenceCollection;
+    }
+    acquire(key, ...args) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const ref = this.referenceCollection.acquire(key, ...args);
+            try {
+                const object = yield ref.object;
+                return {
+                    object,
+                    dispose: () => ref.dispose()
+                };
+            }
+            catch (error) {
+                ref.dispose();
+                throw error;
+            }
+        });
+    }
+}
 export class ImmortalReference {
     constructor(object) {
         this.object = object;
     }
     dispose() { }
 }
+export function disposeOnReturn(fn) {
+    const store = new DisposableStore();
+    try {
+        fn(store);
+    }
+    finally {
+        store.dispose();
+    }
+}
 /**
  * A map the manages the lifecycle of the values that it stores.
  */
@@ -324,6 +433,9 @@
             this._store.clear();
         }
     }
+    has(key) {
+        return this._store.has(key);
+    }
     get(key) {
         return this._store.get(key);
     }
diff -urN -x '*.map' a/vs/base/common/map.js b/vs/base/common/map.js
--- a/vs/base/common/map.js	2023-09-05 08:43:04.226808446 +0000
+++ b/vs/base/common/map.js	2023-09-05 08:45:14.301196405 +0000
@@ -2,7 +2,29 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-var _a, _b;
+var _a, _b, _c;
+export function getOrSet(map, key, value) {
+    let result = map.get(key);
+    if (result === undefined) {
+        result = value;
+        map.set(key, result);
+    }
+    return result;
+}
+export function mapToString(map) {
+    const entries = [];
+    map.forEach((value, key) => {
+        entries.push(`${key} => ${value}`);
+    });
+    return `Map(${map.size}) {${entries.join(', ')}}`;
+}
+export function setToString(set) {
+    const entries = [];
+    set.forEach(value => {
+        entries.push(value);
+    });
+    return `Set(${set.size}) {${entries.join(', ')}}`;
+}
 class ResourceMapEntry {
     constructor(uri, value) {
         this.uri = uri;
@@ -26,8 +48,8 @@
         return this;
     }
     get(resource) {
-        var _c;
-        return (_c = this.map.get(this.toKey(resource))) === null || _c === void 0 ? void 0 : _c.value;
+        var _d;
+        return (_d = this.map.get(this.toKey(resource))) === null || _d === void 0 ? void 0 : _d.value;
     }
     has(resource) {
         return this.map.has(this.toKey(resource));
@@ -71,9 +93,52 @@
     }
 }
 ResourceMap.defaultToKey = (resource) => resource.toString();
+export class ResourceSet {
+    constructor(entriesOrKey, toKey) {
+        this[_b] = 'ResourceSet';
+        if (!entriesOrKey || typeof entriesOrKey === 'function') {
+            this._map = new ResourceMap(entriesOrKey);
+        }
+        else {
+            this._map = new ResourceMap(toKey);
+            entriesOrKey.forEach(this.add, this);
+        }
+    }
+    get size() {
+        return this._map.size;
+    }
+    add(value) {
+        this._map.set(value, value);
+        return this;
+    }
+    clear() {
+        this._map.clear();
+    }
+    delete(value) {
+        return this._map.delete(value);
+    }
+    forEach(callbackfn, thisArg) {
+        this._map.forEach((_value, key) => callbackfn.call(thisArg, key, key, this));
+    }
+    has(value) {
+        return this._map.has(value);
+    }
+    entries() {
+        return this._map.entries();
+    }
+    keys() {
+        return this._map.keys();
+    }
+    values() {
+        return this._map.keys();
+    }
+    [(_b = Symbol.toStringTag, Symbol.iterator)]() {
+        return this.keys();
+    }
+}
 export class LinkedMap {
     constructor() {
-        this[_b] = 'LinkedMap';
+        this[_c] = 'LinkedMap';
         this._map = new Map();
         this._head = undefined;
         this._tail = undefined;
@@ -94,12 +159,12 @@
         return this._size;
     }
     get first() {
-        var _c;
-        return (_c = this._head) === null || _c === void 0 ? void 0 : _c.value;
+        var _d;
+        return (_d = this._head) === null || _d === void 0 ? void 0 : _d.value;
     }
     get last() {
-        var _c;
-        return (_c = this._tail) === null || _c === void 0 ? void 0 : _c.value;
+        var _d;
+        return (_d = this._tail) === null || _d === void 0 ? void 0 : _d.value;
     }
     has(key) {
         return this._map.has(key);
@@ -257,7 +322,7 @@
         };
         return iterator;
     }
-    [(_b = Symbol.toStringTag, Symbol.iterator)]() {
+    [(_c = Symbol.toStringTag, Symbol.iterator)]() {
         return this.entries();
     }
     trimOld(newSize) {
@@ -432,6 +497,13 @@
         this._limit = limit;
         this.checkTrim();
     }
+    get ratio() {
+        return this._ratio;
+    }
+    set ratio(ratio) {
+        this._ratio = Math.min(Math.max(0, ratio), 1);
+        this.checkTrim();
+    }
     get(key, touch = 2 /* Touch.AsNew */) {
         return super.get(key, touch);
     }
@@ -449,3 +521,29 @@
         }
     }
 }
+export class CounterSet {
+    constructor() {
+        this.map = new Map();
+    }
+    add(value) {
+        this.map.set(value, (this.map.get(value) || 0) + 1);
+        return this;
+    }
+    delete(value) {
+        let counter = this.map.get(value) || 0;
+        if (counter === 0) {
+            return false;
+        }
+        counter--;
+        if (counter === 0) {
+            this.map.delete(value);
+        }
+        else {
+            this.map.set(value, counter);
+        }
+        return true;
+    }
+    has(value) {
+        return this.map.has(value);
+    }
+}
diff -urN -x '*.map' a/vs/base/common/mime.js b/vs/base/common/mime.js
--- a/vs/base/common/mime.js	2023-09-05 08:43:04.230808548 +0000
+++ b/vs/base/common/mime.js	2023-09-05 08:45:14.301196405 +0000
@@ -1,3 +1,8 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { extname } from './path.js';
 export const Mimes = Object.freeze({
     text: 'text/plain',
     binary: 'application/octet-stream',
@@ -6,3 +11,101 @@
     latex: 'text/latex',
     uriList: 'text/uri-list',
 });
+const mapExtToTextMimes = {
+    '.css': 'text/css',
+    '.csv': 'text/csv',
+    '.htm': 'text/html',
+    '.html': 'text/html',
+    '.ics': 'text/calendar',
+    '.js': 'text/javascript',
+    '.mjs': 'text/javascript',
+    '.txt': 'text/plain',
+    '.xml': 'text/xml'
+};
+// Known media mimes that we can handle
+const mapExtToMediaMimes = {
+    '.aac': 'audio/x-aac',
+    '.avi': 'video/x-msvideo',
+    '.bmp': 'image/bmp',
+    '.flv': 'video/x-flv',
+    '.gif': 'image/gif',
+    '.ico': 'image/x-icon',
+    '.jpe': 'image/jpg',
+    '.jpeg': 'image/jpg',
+    '.jpg': 'image/jpg',
+    '.m1v': 'video/mpeg',
+    '.m2a': 'audio/mpeg',
+    '.m2v': 'video/mpeg',
+    '.m3a': 'audio/mpeg',
+    '.mid': 'audio/midi',
+    '.midi': 'audio/midi',
+    '.mk3d': 'video/x-matroska',
+    '.mks': 'video/x-matroska',
+    '.mkv': 'video/x-matroska',
+    '.mov': 'video/quicktime',
+    '.movie': 'video/x-sgi-movie',
+    '.mp2': 'audio/mpeg',
+    '.mp2a': 'audio/mpeg',
+    '.mp3': 'audio/mpeg',
+    '.mp4': 'video/mp4',
+    '.mp4a': 'audio/mp4',
+    '.mp4v': 'video/mp4',
+    '.mpe': 'video/mpeg',
+    '.mpeg': 'video/mpeg',
+    '.mpg': 'video/mpeg',
+    '.mpg4': 'video/mp4',
+    '.mpga': 'audio/mpeg',
+    '.oga': 'audio/ogg',
+    '.ogg': 'audio/ogg',
+    '.opus': 'audio/opus',
+    '.ogv': 'video/ogg',
+    '.png': 'image/png',
+    '.psd': 'image/vnd.adobe.photoshop',
+    '.qt': 'video/quicktime',
+    '.spx': 'audio/ogg',
+    '.svg': 'image/svg+xml',
+    '.tga': 'image/x-tga',
+    '.tif': 'image/tiff',
+    '.tiff': 'image/tiff',
+    '.wav': 'audio/x-wav',
+    '.webm': 'video/webm',
+    '.webp': 'image/webp',
+    '.wma': 'audio/x-ms-wma',
+    '.wmv': 'video/x-ms-wmv',
+    '.woff': 'application/font-woff',
+};
+export function getMediaOrTextMime(path) {
+    const ext = extname(path);
+    const textMime = mapExtToTextMimes[ext.toLowerCase()];
+    if (textMime !== undefined) {
+        return textMime;
+    }
+    else {
+        return getMediaMime(path);
+    }
+}
+export function getMediaMime(path) {
+    const ext = extname(path);
+    return mapExtToMediaMimes[ext.toLowerCase()];
+}
+export function getExtensionForMimeType(mimeType) {
+    for (const extension in mapExtToMediaMimes) {
+        if (mapExtToMediaMimes[extension] === mimeType) {
+            return extension;
+        }
+    }
+    return undefined;
+}
+const _simplePattern = /^(.+)\/(.+?)(;.+)?$/;
+export function normalizeMimeType(mimeType, strict) {
+    var _a;
+    const match = _simplePattern.exec(mimeType);
+    if (!match) {
+        return strict
+            ? undefined
+            : mimeType;
+    }
+    // https://datatracker.ietf.org/doc/html/rfc2045#section-5.1
+    // media and subtype must ALWAYS be lowercase, parameter not
+    return `${match[1].toLowerCase()}/${match[2].toLowerCase()}${(_a = match[3]) !== null && _a !== void 0 ? _a : ''}`;
+}
diff -urN -x '*.map' a/vs/base/common/network.js b/vs/base/common/network.js
--- a/vs/base/common/network.js	2023-09-05 08:43:04.230808548 +0000
+++ b/vs/base/common/network.js	2023-09-05 08:45:14.301196405 +0000
@@ -3,6 +3,8 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import * as errors from './errors.js';
+import { toDisposable } from './lifecycle.js';
+import { ResourceMap } from './map.js';
 import * as platform from './platform.js';
 import { URI } from './uri.js';
 export var Schemas;
@@ -78,6 +80,7 @@
      */
     Schemas.vscodeSourceControl = 'vscode-scm';
 })(Schemas || (Schemas = {}));
+export const connectionTokenCookieName = 'vscode-tkn';
 export const connectionTokenQueryName = 'tkn';
 class RemoteAuthoritiesImpl {
     constructor() {
@@ -91,6 +94,22 @@
     setPreferredWebSchema(schema) {
         this._preferredWebSchema = schema;
     }
+    setDelegate(delegate) {
+        this._delegate = delegate;
+    }
+    setServerRootPath(serverRootPath) {
+        this._remoteResourcesPath = `${serverRootPath}/${Schemas.vscodeRemoteResource}`;
+    }
+    set(authority, host, port) {
+        this._hosts[authority] = host;
+        this._ports[authority] = port;
+    }
+    setConnectionToken(authority, connectionToken) {
+        this._connectionTokens[authority] = connectionToken;
+    }
+    getPreferredWebSchema() {
+        return this._preferredWebSchema;
+    }
     rewrite(uri) {
         if (this._delegate) {
             try {
@@ -121,7 +140,24 @@
     }
 }
 export const RemoteAuthorities = new RemoteAuthoritiesImpl();
+export const builtinExtensionsPath = 'vs/../../extensions';
+export const nodeModulesPath = 'vs/../../node_modules';
+export const nodeModulesAsarPath = 'vs/../../node_modules.asar';
+export const nodeModulesAsarUnpackedPath = 'vs/../../node_modules.asar.unpacked';
 class FileAccessImpl {
+    constructor() {
+        this.staticBrowserUris = new ResourceMap();
+    }
+    /**
+     * Returns a URI to use in contexts where the browser is responsible
+     * for loading (e.g. fetch()) or when used within the DOM.
+     *
+     * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
+     */
+    asBrowserUri(resourcePath) {
+        const uri = this.toUri(resourcePath, window.monacoRequire);
+        return this.uriToBrowserUri(uri);
+    }
     /**
      * Returns a URI to use in contexts where the browser is responsible
      * for loading (e.g. fetch()) or when used within the DOM.
@@ -129,6 +165,7 @@
      * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
      */
     uriToBrowserUri(uri) {
+        var _a;
         // Handle remote URIs via `RemoteAuthorities`
         if (uri.scheme === Schemas.vscodeRemote) {
             return RemoteAuthorities.rewrite(uri);
@@ -153,8 +190,52 @@
                 fragment: null
             });
         }
+        return (_a = this.staticBrowserUris.get(uri)) !== null && _a !== void 0 ? _a : uri;
+    }
+    /**
+     * Returns the `file` URI to use in contexts where node.js
+     * is responsible for loading.
+     */
+    asFileUri(resourcePath) {
+        const uri = this.toUri(resourcePath, window.monacoRequire);
+        return this.uriToFileUri(uri);
+    }
+    /**
+     * Returns the `file` URI to use in contexts where node.js
+     * is responsible for loading.
+     */
+    uriToFileUri(uri) {
+        // Only convert the URI if it is `vscode-file:` scheme
+        if (uri.scheme === Schemas.vscodeFileResource) {
+            return uri.with({
+                scheme: Schemas.file,
+                // Only preserve the `authority` if it is different from
+                // our fallback authority. This ensures we properly preserve
+                // Windows UNC paths that come with their own authority.
+                authority: uri.authority !== FileAccessImpl.FALLBACK_AUTHORITY ? uri.authority : null,
+                query: null,
+                fragment: null
+            });
+        }
         return uri;
     }
+    toUri(uriOrModule, moduleIdToUrl) {
+        if (URI.isUri(uriOrModule)) {
+            return uriOrModule;
+        }
+        return URI.parse(moduleIdToUrl.toUrl(uriOrModule));
+    }
+    registerStaticBrowserUri(uri, browserUri) {
+        this.staticBrowserUris.set(uri, browserUri);
+        return toDisposable(() => {
+            if (this.staticBrowserUris.get(uri) === browserUri) {
+                this.staticBrowserUris.delete(uri);
+            }
+        });
+    }
+    getRegisteredBrowserUris() {
+        return this.staticBrowserUris.keys();
+    }
 }
 FileAccessImpl.FALLBACK_AUTHORITY = 'vscode-app';
 export const FileAccess = new FileAccessImpl();
diff -urN -x '*.map' a/vs/base/common/numbers.js b/vs/base/common/numbers.js
--- a/vs/base/common/numbers.js	2023-09-05 08:43:04.230808548 +0000
+++ b/vs/base/common/numbers.js	2023-09-05 08:45:14.301196405 +0000
@@ -5,6 +5,17 @@
 export function clamp(value, min, max) {
     return Math.min(Math.max(value, min), max);
 }
+export function rot(index, modulo) {
+    return (modulo + (index % modulo)) % modulo;
+}
+export class Counter {
+    constructor() {
+        this._next = 0;
+    }
+    getNext() {
+        return this._next++;
+    }
+}
 export class MovingAverage {
     constructor() {
         this._n = 1;
diff -urN -x '*.map' a/vs/base/common/objects.js b/vs/base/common/objects.js
--- a/vs/base/common/objects.js	2023-09-05 08:43:04.230808548 +0000
+++ b/vs/base/common/objects.js	2023-09-05 08:45:14.301196405 +0000
@@ -147,6 +147,64 @@
     }
     return true;
 }
+/**
+ * Calls `JSON.Stringify` with a replacer to break apart any circular references.
+ * This prevents `JSON`.stringify` from throwing the exception
+ *  "Uncaught TypeError: Converting circular structure to JSON"
+ */
+export function safeStringify(obj) {
+    const seen = new Set();
+    return JSON.stringify(obj, (key, value) => {
+        if (isObject(value) || Array.isArray(value)) {
+            if (seen.has(value)) {
+                return '[Circular]';
+            }
+            else {
+                seen.add(value);
+            }
+        }
+        return value;
+    });
+}
+/**
+ * Returns an object that has keys for each value that is different in the base object. Keys
+ * that do not exist in the target but in the base object are not considered.
+ *
+ * Note: This is not a deep-diffing method, so the values are strictly taken into the resulting
+ * object if they differ.
+ *
+ * @param base the object to diff against
+ * @param obj the object to use for diffing
+ */
+export function distinct(base, target) {
+    const result = Object.create(null);
+    if (!base || !target) {
+        return result;
+    }
+    const targetKeys = Object.keys(target);
+    targetKeys.forEach(k => {
+        const baseValue = base[k];
+        const targetValue = target[k];
+        if (!equals(baseValue, targetValue)) {
+            result[k] = targetValue;
+        }
+    });
+    return result;
+}
+export function getCaseInsensitive(target, key) {
+    const lowercaseKey = key.toLowerCase();
+    const equivalentKey = Object.keys(target).find(k => k.toLowerCase() === lowercaseKey);
+    return equivalentKey ? target[equivalentKey] : target[key];
+}
+export function filter(obj, predicate) {
+    const result = Object.create(null);
+    for (const [key, value] of Object.entries(obj)) {
+        if (predicate(key, value)) {
+            result[key] = value;
+        }
+    }
+    return result;
+}
 export function getAllPropertyNames(obj) {
     let res = [];
     while (Object.prototype !== obj) {
diff -urN -x '*.map' a/vs/base/common/observable.js b/vs/base/common/observable.js
--- a/vs/base/common/observable.js	2023-09-05 08:43:04.230808548 +0000
+++ b/vs/base/common/observable.js	2023-09-05 08:45:14.293196291 +0000
@@ -2,9 +2,9 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
-export { observableValue, transaction } from './observableImpl/base.js';
-export { derived } from './observableImpl/derived.js';
-export { autorun, autorunHandleChanges, autorunWithStore } from './observableImpl/autorun.js';
+export { observableValue, transaction, } from './observableImpl/base';
+export { derived } from './observableImpl/derived';
+export { autorun, autorunDelta, autorunHandleChanges, autorunWithStore, } from './observableImpl/autorun';
 export * from './observableImpl/utils.js';
 import { ConsoleObservableLogger, setLogger } from './observableImpl/logging.js';
 const enableLogging = false;
diff -urN -x '*.map' a/vs/base/common/observableImpl/autorun.js b/vs/base/common/observableImpl/autorun.js
--- a/vs/base/common/observableImpl/autorun.js	2023-09-05 08:43:04.214808143 +0000
+++ b/vs/base/common/observableImpl/autorun.js	2023-09-05 08:45:14.297196348 +0000
@@ -15,6 +15,20 @@
 export function autorunWithStore2(debugName, fn) {
     return autorunWithStore(fn, debugName);
 }
+export function autorunWithStoreHandleChanges(debugName, options, fn) {
+    const store = new DisposableStore();
+    const disposable = autorunHandleChanges(debugName, {
+        createEmptyChangeSummary: options.createEmptyChangeSummary,
+        handleChange: options.handleChange,
+    }, (reader, changeSummary) => {
+        store.clear();
+        fn(reader, changeSummary, store);
+    });
+    return toDisposable(() => {
+        disposable.dispose();
+        store.dispose();
+    });
+}
 // TODO@hediet deprecate, rename to autorunWithStoreEx
 export function autorunWithStore(fn, debugName) {
     const store = new DisposableStore();
@@ -136,3 +150,12 @@
 (function (autorun) {
     autorun.Observer = AutorunObserver;
 })(autorun || (autorun = {}));
+export function autorunDelta(name, observable, handler) {
+    let _lastValue;
+    return autorun(name, (reader) => {
+        const newValue = observable.read(reader);
+        const lastValue = _lastValue;
+        _lastValue = newValue;
+        handler({ lastValue, newValue });
+    });
+}
diff -urN -x '*.map' a/vs/base/common/observableImpl/utils.js b/vs/base/common/observableImpl/utils.js
--- a/vs/base/common/observableImpl/utils.js	2023-09-05 08:43:04.214808143 +0000
+++ b/vs/base/common/observableImpl/utils.js	2023-09-05 08:45:14.297196348 +0000
@@ -4,7 +4,8 @@
  *--------------------------------------------------------------------------------------------*/
 import { toDisposable } from '../lifecycle.js';
 import { autorun } from './autorun.js';
-import { BaseObservable, ConvenientObservable, getFunctionName, transaction } from './base.js';
+import { BaseObservable, ConvenientObservable, getFunctionName, observableValue, transaction } from './base.js';
+import { derived } from './derived.js';
 import { getLogger } from './logging.js';
 export function constObservable(value) {
     return new ConstObservable(value);
@@ -30,6 +31,13 @@
         return `Const: ${this.value}`;
     }
 }
+export function observableFromPromise(promise) {
+    const observable = observableValue('promiseValue', {});
+    promise.then((value) => {
+        observable.set({ value }, undefined);
+    });
+    return observable;
+}
 export function waitForState(observable, predicate) {
     return new Promise(resolve => {
         let didRun = false;
@@ -170,6 +178,36 @@
         // NO OP
     }
 }
+export function debouncedObservable(observable, debounceMs, disposableStore) {
+    const debouncedObservable = observableValue('debounced', undefined);
+    let timeout = undefined;
+    disposableStore.add(autorun('debounce', reader => {
+        const value = observable.read(reader);
+        if (timeout) {
+            clearTimeout(timeout);
+        }
+        timeout = setTimeout(() => {
+            transaction(tx => {
+                debouncedObservable.set(value, tx);
+            });
+        }, debounceMs);
+    }));
+    return debouncedObservable;
+}
+export function wasEventTriggeredRecently(event, timeoutMs, disposableStore) {
+    const observable = observableValue('triggeredRecently', false);
+    let timeout = undefined;
+    disposableStore.add(event(() => {
+        observable.set(true, undefined);
+        if (timeout) {
+            clearTimeout(timeout);
+        }
+        timeout = setTimeout(() => {
+            observable.set(false, undefined);
+        }, timeoutMs);
+    }));
+    return observable;
+}
 // TODO@hediet: Have `keepCacheAlive` and `recomputeOnChange` instead of forceRecompute
 /**
  * This ensures the observable is being observed.
@@ -211,3 +249,26 @@
         // NO OP
     }
 }
+export function derivedObservableWithCache(name, computeFn) {
+    let lastValue = undefined;
+    const observable = derived(name, reader => {
+        lastValue = computeFn(reader, lastValue);
+        return lastValue;
+    });
+    return observable;
+}
+export function derivedObservableWithWritableCache(name, computeFn) {
+    let lastValue = undefined;
+    const counter = observableValue('derivedObservableWithWritableCache.counter', 0);
+    const observable = derived(name, reader => {
+        counter.read(reader);
+        lastValue = computeFn(reader, lastValue);
+        return lastValue;
+    });
+    return Object.assign(observable, {
+        clearCache: (transaction) => {
+            lastValue = undefined;
+            counter.set(counter.get() + 1, transaction);
+        },
+    });
+}
diff -urN -x '*.map' a/vs/base/common/paging.js b/vs/base/common/paging.js
--- a/vs/base/common/paging.js	2023-09-05 08:43:04.230808548 +0000
+++ b/vs/base/common/paging.js	2023-09-05 08:45:14.305196462 +0000
@@ -1 +1,130 @@
-export {};
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { range } from './arrays.js';
+import { CancellationTokenSource } from './cancellation.js';
+import { canceled } from './errors.js';
+function createPage(elements) {
+    return {
+        isResolved: !!elements,
+        promise: null,
+        cts: null,
+        promiseIndexes: new Set(),
+        elements: elements || []
+    };
+}
+export function singlePagePager(elements) {
+    return {
+        firstPage: elements,
+        total: elements.length,
+        pageSize: elements.length,
+        getPage: (pageIndex, cancellationToken) => {
+            return Promise.resolve(elements);
+        }
+    };
+}
+export class PagedModel {
+    get length() { return this.pager.total; }
+    constructor(arg) {
+        this.pages = [];
+        this.pager = Array.isArray(arg) ? singlePagePager(arg) : arg;
+        const totalPages = Math.ceil(this.pager.total / this.pager.pageSize);
+        this.pages = [
+            createPage(this.pager.firstPage.slice()),
+            ...range(totalPages - 1).map(() => createPage())
+        ];
+    }
+    isResolved(index) {
+        const pageIndex = Math.floor(index / this.pager.pageSize);
+        const page = this.pages[pageIndex];
+        return !!page.isResolved;
+    }
+    get(index) {
+        const pageIndex = Math.floor(index / this.pager.pageSize);
+        const indexInPage = index % this.pager.pageSize;
+        const page = this.pages[pageIndex];
+        return page.elements[indexInPage];
+    }
+    resolve(index, cancellationToken) {
+        if (cancellationToken.isCancellationRequested) {
+            return Promise.reject(canceled());
+        }
+        const pageIndex = Math.floor(index / this.pager.pageSize);
+        const indexInPage = index % this.pager.pageSize;
+        const page = this.pages[pageIndex];
+        if (page.isResolved) {
+            return Promise.resolve(page.elements[indexInPage]);
+        }
+        if (!page.promise) {
+            page.cts = new CancellationTokenSource();
+            page.promise = this.pager.getPage(pageIndex, page.cts.token)
+                .then(elements => {
+                page.elements = elements;
+                page.isResolved = true;
+                page.promise = null;
+                page.cts = null;
+            }, err => {
+                page.isResolved = false;
+                page.promise = null;
+                page.cts = null;
+                return Promise.reject(err);
+            });
+        }
+        cancellationToken.onCancellationRequested(() => {
+            if (!page.cts) {
+                return;
+            }
+            page.promiseIndexes.delete(index);
+            if (page.promiseIndexes.size === 0) {
+                page.cts.cancel();
+            }
+        });
+        page.promiseIndexes.add(index);
+        return page.promise.then(() => page.elements[indexInPage]);
+    }
+}
+export class DelayedPagedModel {
+    get length() { return this.model.length; }
+    constructor(model, timeout = 500) {
+        this.model = model;
+        this.timeout = timeout;
+    }
+    isResolved(index) {
+        return this.model.isResolved(index);
+    }
+    get(index) {
+        return this.model.get(index);
+    }
+    resolve(index, cancellationToken) {
+        return new Promise((c, e) => {
+            if (cancellationToken.isCancellationRequested) {
+                return e(canceled());
+            }
+            const timer = setTimeout(() => {
+                if (cancellationToken.isCancellationRequested) {
+                    return e(canceled());
+                }
+                timeoutCancellation.dispose();
+                this.model.resolve(index, cancellationToken).then(c, e);
+            }, this.timeout);
+            const timeoutCancellation = cancellationToken.onCancellationRequested(() => {
+                clearTimeout(timer);
+                timeoutCancellation.dispose();
+                e(canceled());
+            });
+        });
+    }
+}
+/**
+ * Similar to array.map, `mapPager` lets you map the elements of an
+ * abstract paged collection to another type.
+ */
+export function mapPager(pager, fn) {
+    return {
+        firstPage: pager.firstPage.map(fn),
+        total: pager.total,
+        pageSize: pager.pageSize,
+        getPage: (pageIndex, token) => pager.getPage(pageIndex, token).then(r => r.map(fn))
+    };
+}
diff -urN -x '*.map' a/vs/base/common/path.js b/vs/base/common/path.js
--- a/vs/base/common/path.js	2023-09-05 08:43:04.230808548 +0000
+++ b/vs/base/common/path.js	2023-09-05 08:45:14.301196405 +0000
@@ -1385,9 +1385,15 @@
 posix.win32 = win32.win32 = win32;
 posix.posix = win32.posix = posix;
 export const normalize = (platformIsWin32 ? win32.normalize : posix.normalize);
+export const isAbsolute = (platformIsWin32 ? win32.isAbsolute : posix.isAbsolute);
+export const join = (platformIsWin32 ? win32.join : posix.join);
 export const resolve = (platformIsWin32 ? win32.resolve : posix.resolve);
 export const relative = (platformIsWin32 ? win32.relative : posix.relative);
 export const dirname = (platformIsWin32 ? win32.dirname : posix.dirname);
 export const basename = (platformIsWin32 ? win32.basename : posix.basename);
 export const extname = (platformIsWin32 ? win32.extname : posix.extname);
+export const format = (platformIsWin32 ? win32.format : posix.format);
+export const parse = (platformIsWin32 ? win32.parse : posix.parse);
+export const toNamespacedPath = (platformIsWin32 ? win32.toNamespacedPath : posix.toNamespacedPath);
 export const sep = (platformIsWin32 ? win32.sep : posix.sep);
+export const delimiter = (platformIsWin32 ? win32.delimiter : posix.delimiter);
diff -urN -x '*.map' a/vs/base/common/performance.js b/vs/base/common/performance.js
--- a/vs/base/common/performance.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/base/common/performance.js	2023-09-05 08:45:14.297196348 +0000
@@ -0,0 +1,149 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+
+'use strict';
+
+//@ts-check
+// ESM-comment-begin
+// (function () {
+// 
+// 	/**
+// 	 * @returns {{mark(name:string):void, getMarks():{name:string, startTime:number}[]}}
+// 	 */
+// 	function _definePolyfillMarks(timeOrigin) {
+// 
+// 		const _data = [];
+// 		if (typeof timeOrigin === 'number') {
+// 			_data.push('code/timeOrigin', timeOrigin);
+// 		}
+// 
+// 		function mark(name) {
+// 			_data.push(name, Date.now());
+// 		}
+// 		function getMarks() {
+// 			const result = [];
+// 			for (let i = 0; i < _data.length; i += 2) {
+// 				result.push({
+// 					name: _data[i],
+// 					startTime: _data[i + 1],
+// 				});
+// 			}
+// 			return result;
+// 		}
+// 		return { mark, getMarks };
+// 	}
+// 
+// 	/**
+// 	 * @returns {{mark(name:string):void, getMarks():{name:string, startTime:number}[]}}
+// 	 */
+// 	function _define() {
+// 
+// 		// Identify browser environment when following property is not present
+// 		// https://nodejs.org/dist/latest-v16.x/docs/api/perf_hooks.html#performancenodetiming
+// 		if (typeof performance === 'object' && typeof performance.mark === 'function' && !performance.nodeTiming) {
+// 			// in a browser context, reuse performance-util
+// 
+// 			if (typeof performance.timeOrigin !== 'number' && !performance.timing) {
+// 				// safari & webworker: because there is no timeOrigin and no workaround
+// 				// we use the `Date.now`-based polyfill.
+// 				return _definePolyfillMarks();
+// 
+// 			} else {
+// 				// use "native" performance for mark and getMarks
+// 				return {
+// 					mark(name) {
+// 						performance.mark(name);
+// 					},
+// 					getMarks() {
+// 						let timeOrigin = performance.timeOrigin;
+// 						if (typeof timeOrigin !== 'number') {
+// 							// safari: there is no timerOrigin but in renderers there is the timing-property
+// 							// see https://bugs.webkit.org/show_bug.cgi?id=174862
+// 							timeOrigin = performance.timing.navigationStart || performance.timing.redirectStart || performance.timing.fetchStart;
+// 						}
+// 						const result = [{ name: 'code/timeOrigin', startTime: Math.round(timeOrigin) }];
+// 						for (const entry of performance.getEntriesByType('mark')) {
+// 							result.push({
+// 								name: entry.name,
+// 								startTime: Math.round(timeOrigin + entry.startTime)
+// 							});
+// 						}
+// 						return result;
+// 					}
+// 				};
+// 			}
+// 
+// 		} else if (typeof process === 'object') {
+// 			// node.js: use the normal polyfill but add the timeOrigin
+// 			// from the node perf_hooks API as very first mark
+// 			const timeOrigin = performance?.timeOrigin ?? Math.round((require.__$__nodeRequire || require)('perf_hooks').performance.timeOrigin);
+// 			return _definePolyfillMarks(timeOrigin);
+// 
+// 		} else {
+// 			// unknown environment
+// 			console.trace('perf-util loaded in UNKNOWN environment');
+// 			return _definePolyfillMarks();
+// 		}
+// 	}
+// 
+// 	function _factory(sharedObj) {
+// 		if (!sharedObj.MonacoPerformanceMarks) {
+// 			sharedObj.MonacoPerformanceMarks = _define();
+// 		}
+// 		return sharedObj.MonacoPerformanceMarks;
+// 	}
+// 
+// 	// This module can be loaded in an amd and commonjs-context.
+// 	// Because we want both instances to use the same perf-data
+// 	// we store them globally
+// 
+// 	// eslint-disable-next-line no-var
+// 	var sharedObj;
+// 	if (typeof global === 'object') {
+// 		// nodejs
+// 		sharedObj = global;
+// 	} else if (typeof self === 'object') {
+// 		// browser
+// 		sharedObj = self;
+// 	} else {
+// 		sharedObj = {};
+// 	}
+// 
+// 	if (typeof define === 'function') {
+// 		// amd
+// 		define([], function () { return _factory(sharedObj); });
+// 	} else if (typeof module === 'object' && typeof module.exports === 'object') {
+// 		// commonjs
+// 		module.exports = _factory(sharedObj);
+// 	} else {
+// 		console.trace('perf-util defined in UNKNOWN context (neither requirejs or commonjs)');
+// 		sharedObj.perf = _factory(sharedObj);
+// 	}
+// 
+// })();
+// ESM-comment-end
+
+// ESM-uncomment-begin
+export const mark = (name) => {
+	performance.mark(name);
+};
+
+export const getMarks = () => {
+	let timeOrigin = performance.timeOrigin;
+	if (typeof timeOrigin !== 'number') {
+		// safari: there is no timerOrigin but in renderers there is the timing-property
+		// see https://bugs.webkit.org/show_bug.cgi?id=174862
+		timeOrigin = performance.timing.navigationStart || performance.timing.redirectStart || performance.timing.fetchStart;
+	}
+	const result = [{ name: 'code/timeOrigin', startTime: Math.round(timeOrigin) }];
+	for (const entry of performance.getEntriesByType('mark')) {
+		result.push({
+			name: entry.name,
+			startTime: Math.round(timeOrigin + entry.startTime)
+		});
+	}
+	return result;
+};
+// ESM-uncomment-end
diff -urN -x '*.map' a/vs/base/common/platform.js b/vs/base/common/platform.js
--- a/vs/base/common/platform.js	2023-09-05 08:43:04.230808548 +0000
+++ b/vs/base/common/platform.js	2023-09-05 08:45:14.301196405 +0000
@@ -84,6 +84,14 @@
 else {
     console.error('Unable to resolve platform.');
 }
+export function PlatformToString(platform) {
+    switch (platform) {
+        case 0 /* Platform.Web */: return 'Web';
+        case 1 /* Platform.Mac */: return 'Mac';
+        case 2 /* Platform.Linux */: return 'Linux';
+        case 3 /* Platform.Windows */: return 'Windows';
+    }
+}
 let _platform = 0 /* Platform.Web */;
 if (_isMacintosh) {
     _platform = 1 /* Platform.Mac */;
@@ -97,11 +105,19 @@
 export const isWindows = _isWindows;
 export const isMacintosh = _isMacintosh;
 export const isLinux = _isLinux;
+export const isLinuxSnap = _isLinuxSnap;
 export const isNative = _isNative;
+export const isElectron = _isElectron;
 export const isWeb = _isWeb;
 export const isWebWorker = (_isWeb && typeof globals.importScripts === 'function');
 export const isIOS = _isIOS;
 export const isMobile = _isMobile;
+/**
+ * Whether we run inside a CI environment, such as
+ * GH actions or Azure Pipelines.
+ */
+export const isCI = _isCI;
+export const platform = _platform;
 export const userAgent = _userAgent;
 /**
  * The language used for the user interface. The format of
@@ -109,6 +125,46 @@
  * Chinese)
  */
 export const language = _language;
+export var Language;
+(function (Language) {
+    function value() {
+        return language;
+    }
+    Language.value = value;
+    function isDefaultVariant() {
+        if (language.length === 2) {
+            return language === 'en';
+        }
+        else if (language.length >= 3) {
+            return language[0] === 'e' && language[1] === 'n' && language[2] === '-';
+        }
+        else {
+            return false;
+        }
+    }
+    Language.isDefaultVariant = isDefaultVariant;
+    function isDefault() {
+        return language === 'en';
+    }
+    Language.isDefault = isDefault;
+})(Language || (Language = {}));
+/**
+ * The OS locale or the locale specified by --locale. The format of
+ * the string is all lower case (e.g. zh-tw for Traditional
+ * Chinese). The UI is not necessarily shown in the provided locale.
+ */
+export const locale = _locale;
+/**
+ * This will always be set to the OS/browser's locale regardless of
+ * what was specified by --locale. The format of the string is all
+ * lower case (e.g. zh-tw for Traditional Chinese). The UI is not
+ * necessarily shown in the provided locale.
+ */
+export const platformLocale = _platformLocale;
+/**
+ * The translations that are available through language packs.
+ */
+export const translationsConfigFile = _translationsConfigFile;
 export const setTimeout0IsFaster = (typeof globals.postMessage === 'function' && !globals.importScripts);
 /**
  * See https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#:~:text=than%204%2C%20then-,set%20timeout%20to%204,-.
diff -urN -x '*.map' a/vs/base/common/process.js b/vs/base/common/process.js
--- a/vs/base/common/process.js	2023-09-05 08:43:04.234808649 +0000
+++ b/vs/base/common/process.js	2023-09-05 08:45:14.297196348 +0000
@@ -55,3 +55,9 @@
  * environments.
  */
 export const platform = safeProcess.platform;
+/**
+ * Provides safe access to the `arch` method in node.js, sandboxed or web
+ * environments.
+ * Note: `arch` is `undefined` in web
+ */
+export const arch = safeProcess.arch;
diff -urN -x '*.map' a/vs/base/common/product.js b/vs/base/common/product.js
--- a/vs/base/common/product.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/base/common/product.js	2023-09-05 08:45:14.301196405 +0000
@@ -0,0 +1,5 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+export {};
diff -urN -x '*.map' a/vs/base/common/resources.js b/vs/base/common/resources.js
--- a/vs/base/common/resources.js	2023-09-05 08:43:04.234808649 +0000
+++ b/vs/base/common/resources.js	2023-09-05 08:45:14.297196348 +0000
@@ -36,6 +36,9 @@
             fragment: ignoreFragment ? null : undefined
         }).toString();
     }
+    ignorePathCasing(uri) {
+        return this._ignorePathCasing(uri);
+    }
     isEqualOrParent(base, parentCandidate, ignoreFragment = false) {
         if (base.scheme === parentCandidate.scheme) {
             if (base.scheme === Schemas.file) {
@@ -224,6 +227,23 @@
 export const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);
 export const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);
 export const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);
+//#endregion
+export function distinctParents(items, resourceAccessor) {
+    const distinctParents = [];
+    for (let i = 0; i < items.length; i++) {
+        const candidateResource = resourceAccessor(items[i]);
+        if (items.some((otherItem, index) => {
+            if (index === i) {
+                return false;
+            }
+            return isEqualOrParent(candidateResource, resourceAccessor(otherItem));
+        })) {
+            continue;
+        }
+        distinctParents.push(items[i]);
+    }
+    return distinctParents;
+}
 /**
  * Data URI related helpers.
  */
@@ -254,3 +274,13 @@
     }
     DataUri.parseMetaData = parseMetaData;
 })(DataUri || (DataUri = {}));
+export function toLocalResource(resource, authority, localScheme) {
+    if (authority) {
+        let path = resource.path;
+        if (path && path[0] !== paths.posix.sep) {
+            path = paths.posix.sep + path;
+        }
+        return resource.with({ scheme: localScheme, authority, path });
+    }
+    return resource.with({ scheme: localScheme });
+}
diff -urN -x '*.map' a/vs/base/common/sequence.js b/vs/base/common/sequence.js
--- a/vs/base/common/sequence.js	2023-09-05 08:43:04.234808649 +0000
+++ b/vs/base/common/sequence.js	2023-09-05 08:45:14.297196348 +0000
@@ -1 +1,16 @@
-export {};
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { Emitter } from './event.js';
+export class Sequence {
+    constructor() {
+        this.elements = [];
+        this._onDidSplice = new Emitter();
+        this.onDidSplice = this._onDidSplice.event;
+    }
+    splice(start, deleteCount, toInsert = []) {
+        this.elements.splice(start, deleteCount, ...toInsert);
+        this._onDidSplice.fire({ start, deleteCount, toInsert });
+    }
+}
diff -urN -x '*.map' a/vs/base/common/stopwatch.js b/vs/base/common/stopwatch.js
--- a/vs/base/common/stopwatch.js	2023-09-05 08:43:04.234808649 +0000
+++ b/vs/base/common/stopwatch.js	2023-09-05 08:45:14.305196462 +0000
@@ -15,6 +15,10 @@
     stop() {
         this._stopTime = this._now();
     }
+    reset() {
+        this._startTime = this._now();
+        this._stopTime = -1;
+    }
     elapsed() {
         if (this._stopTime !== -1) {
             return this._stopTime - this._startTime;
diff -urN -x '*.map' a/vs/base/common/stream.js b/vs/base/common/stream.js
--- a/vs/base/common/stream.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/base/common/stream.js	2023-09-05 08:45:14.301196405 +0000
@@ -0,0 +1,463 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { onUnexpectedError } from './errors.js';
+import { DisposableStore, toDisposable } from './lifecycle.js';
+export function isReadable(obj) {
+    const candidate = obj;
+    if (!candidate) {
+        return false;
+    }
+    return typeof candidate.read === 'function';
+}
+export function isReadableStream(obj) {
+    const candidate = obj;
+    if (!candidate) {
+        return false;
+    }
+    return [candidate.on, candidate.pause, candidate.resume, candidate.destroy].every(fn => typeof fn === 'function');
+}
+export function isReadableBufferedStream(obj) {
+    const candidate = obj;
+    if (!candidate) {
+        return false;
+    }
+    return isReadableStream(candidate.stream) && Array.isArray(candidate.buffer) && typeof candidate.ended === 'boolean';
+}
+export function newWriteableStream(reducer, options) {
+    return new WriteableStreamImpl(reducer, options);
+}
+class WriteableStreamImpl {
+    constructor(reducer, options) {
+        this.reducer = reducer;
+        this.options = options;
+        this.state = {
+            flowing: false,
+            ended: false,
+            destroyed: false
+        };
+        this.buffer = {
+            data: [],
+            error: []
+        };
+        this.listeners = {
+            data: [],
+            error: [],
+            end: []
+        };
+        this.pendingWritePromises = [];
+    }
+    pause() {
+        if (this.state.destroyed) {
+            return;
+        }
+        this.state.flowing = false;
+    }
+    resume() {
+        if (this.state.destroyed) {
+            return;
+        }
+        if (!this.state.flowing) {
+            this.state.flowing = true;
+            // emit buffered events
+            this.flowData();
+            this.flowErrors();
+            this.flowEnd();
+        }
+    }
+    write(data) {
+        var _a;
+        if (this.state.destroyed) {
+            return;
+        }
+        // flowing: directly send the data to listeners
+        if (this.state.flowing) {
+            this.emitData(data);
+        }
+        // not yet flowing: buffer data until flowing
+        else {
+            this.buffer.data.push(data);
+            // highWaterMark: if configured, signal back when buffer reached limits
+            if (typeof ((_a = this.options) === null || _a === void 0 ? void 0 : _a.highWaterMark) === 'number' && this.buffer.data.length > this.options.highWaterMark) {
+                return new Promise(resolve => this.pendingWritePromises.push(resolve));
+            }
+        }
+    }
+    error(error) {
+        if (this.state.destroyed) {
+            return;
+        }
+        // flowing: directly send the error to listeners
+        if (this.state.flowing) {
+            this.emitError(error);
+        }
+        // not yet flowing: buffer errors until flowing
+        else {
+            this.buffer.error.push(error);
+        }
+    }
+    end(result) {
+        if (this.state.destroyed) {
+            return;
+        }
+        // end with data if provided
+        if (typeof result !== 'undefined') {
+            this.write(result);
+        }
+        // flowing: send end event to listeners
+        if (this.state.flowing) {
+            this.emitEnd();
+            this.destroy();
+        }
+        // not yet flowing: remember state
+        else {
+            this.state.ended = true;
+        }
+    }
+    emitData(data) {
+        this.listeners.data.slice(0).forEach(listener => listener(data)); // slice to avoid listener mutation from delivering event
+    }
+    emitError(error) {
+        if (this.listeners.error.length === 0) {
+            onUnexpectedError(error); // nobody listened to this error so we log it as unexpected
+        }
+        else {
+            this.listeners.error.slice(0).forEach(listener => listener(error)); // slice to avoid listener mutation from delivering event
+        }
+    }
+    emitEnd() {
+        this.listeners.end.slice(0).forEach(listener => listener()); // slice to avoid listener mutation from delivering event
+    }
+    on(event, callback) {
+        if (this.state.destroyed) {
+            return;
+        }
+        switch (event) {
+            case 'data':
+                this.listeners.data.push(callback);
+                // switch into flowing mode as soon as the first 'data'
+                // listener is added and we are not yet in flowing mode
+                this.resume();
+                break;
+            case 'end':
+                this.listeners.end.push(callback);
+                // emit 'end' event directly if we are flowing
+                // and the end has already been reached
+                //
+                // finish() when it went through
+                if (this.state.flowing && this.flowEnd()) {
+                    this.destroy();
+                }
+                break;
+            case 'error':
+                this.listeners.error.push(callback);
+                // emit buffered 'error' events unless done already
+                // now that we know that we have at least one listener
+                if (this.state.flowing) {
+                    this.flowErrors();
+                }
+                break;
+        }
+    }
+    removeListener(event, callback) {
+        if (this.state.destroyed) {
+            return;
+        }
+        let listeners = undefined;
+        switch (event) {
+            case 'data':
+                listeners = this.listeners.data;
+                break;
+            case 'end':
+                listeners = this.listeners.end;
+                break;
+            case 'error':
+                listeners = this.listeners.error;
+                break;
+        }
+        if (listeners) {
+            const index = listeners.indexOf(callback);
+            if (index >= 0) {
+                listeners.splice(index, 1);
+            }
+        }
+    }
+    flowData() {
+        if (this.buffer.data.length > 0) {
+            const fullDataBuffer = this.reducer(this.buffer.data);
+            this.emitData(fullDataBuffer);
+            this.buffer.data.length = 0;
+            // When the buffer is empty, resolve all pending writers
+            const pendingWritePromises = [...this.pendingWritePromises];
+            this.pendingWritePromises.length = 0;
+            pendingWritePromises.forEach(pendingWritePromise => pendingWritePromise());
+        }
+    }
+    flowErrors() {
+        if (this.listeners.error.length > 0) {
+            for (const error of this.buffer.error) {
+                this.emitError(error);
+            }
+            this.buffer.error.length = 0;
+        }
+    }
+    flowEnd() {
+        if (this.state.ended) {
+            this.emitEnd();
+            return this.listeners.end.length > 0;
+        }
+        return false;
+    }
+    destroy() {
+        if (!this.state.destroyed) {
+            this.state.destroyed = true;
+            this.state.ended = true;
+            this.buffer.data.length = 0;
+            this.buffer.error.length = 0;
+            this.listeners.data.length = 0;
+            this.listeners.error.length = 0;
+            this.listeners.end.length = 0;
+            this.pendingWritePromises.length = 0;
+        }
+    }
+}
+/**
+ * Helper to fully read a T readable into a T.
+ */
+export function consumeReadable(readable, reducer) {
+    const chunks = [];
+    let chunk;
+    while ((chunk = readable.read()) !== null) {
+        chunks.push(chunk);
+    }
+    return reducer(chunks);
+}
+/**
+ * Helper to read a T readable up to a maximum of chunks. If the limit is
+ * reached, will return a readable instead to ensure all data can still
+ * be read.
+ */
+export function peekReadable(readable, reducer, maxChunks) {
+    const chunks = [];
+    let chunk = undefined;
+    while ((chunk = readable.read()) !== null && chunks.length < maxChunks) {
+        chunks.push(chunk);
+    }
+    // If the last chunk is null, it means we reached the end of
+    // the readable and return all the data at once
+    if (chunk === null && chunks.length > 0) {
+        return reducer(chunks);
+    }
+    // Otherwise, we still have a chunk, it means we reached the maxChunks
+    // value and as such we return a new Readable that first returns
+    // the existing read chunks and then continues with reading from
+    // the underlying readable.
+    return {
+        read: () => {
+            // First consume chunks from our array
+            if (chunks.length > 0) {
+                return chunks.shift();
+            }
+            // Then ensure to return our last read chunk
+            if (typeof chunk !== 'undefined') {
+                const lastReadChunk = chunk;
+                // explicitly use undefined here to indicate that we consumed
+                // the chunk, which could have either been null or valued.
+                chunk = undefined;
+                return lastReadChunk;
+            }
+            // Finally delegate back to the Readable
+            return readable.read();
+        }
+    };
+}
+export function consumeStream(stream, reducer) {
+    return new Promise((resolve, reject) => {
+        const chunks = [];
+        listenStream(stream, {
+            onData: chunk => {
+                if (reducer) {
+                    chunks.push(chunk);
+                }
+            },
+            onError: error => {
+                if (reducer) {
+                    reject(error);
+                }
+                else {
+                    resolve(undefined);
+                }
+            },
+            onEnd: () => {
+                if (reducer) {
+                    resolve(reducer(chunks));
+                }
+                else {
+                    resolve(undefined);
+                }
+            }
+        });
+    });
+}
+/**
+ * Helper to listen to all events of a T stream in proper order.
+ */
+export function listenStream(stream, listener) {
+    let destroyed = false;
+    stream.on('error', error => {
+        if (!destroyed) {
+            listener.onError(error);
+        }
+    });
+    stream.on('end', () => {
+        if (!destroyed) {
+            listener.onEnd();
+        }
+    });
+    // Adding the `data` listener will turn the stream
+    // into flowing mode. As such it is important to
+    // add this listener last (DO NOT CHANGE!)
+    stream.on('data', data => {
+        if (!destroyed) {
+            listener.onData(data);
+        }
+    });
+    return toDisposable(() => destroyed = true);
+}
+/**
+ * Helper to peek up to `maxChunks` into a stream. The return type signals if
+ * the stream has ended or not. If not, caller needs to add a `data` listener
+ * to continue reading.
+ */
+export function peekStream(stream, maxChunks) {
+    return new Promise((resolve, reject) => {
+        const streamListeners = new DisposableStore();
+        const buffer = [];
+        // Data Listener
+        const dataListener = (chunk) => {
+            // Add to buffer
+            buffer.push(chunk);
+            // We reached maxChunks and thus need to return
+            if (buffer.length > maxChunks) {
+                // Dispose any listeners and ensure to pause the
+                // stream so that it can be consumed again by caller
+                streamListeners.dispose();
+                stream.pause();
+                return resolve({ stream, buffer, ended: false });
+            }
+        };
+        // Error Listener
+        const errorListener = (error) => {
+            return reject(error);
+        };
+        // End Listener
+        const endListener = () => {
+            return resolve({ stream, buffer, ended: true });
+        };
+        streamListeners.add(toDisposable(() => stream.removeListener('error', errorListener)));
+        stream.on('error', errorListener);
+        streamListeners.add(toDisposable(() => stream.removeListener('end', endListener)));
+        stream.on('end', endListener);
+        // Important: leave the `data` listener last because
+        // this can turn the stream into flowing mode and we
+        // want `error` events to be received as well.
+        streamListeners.add(toDisposable(() => stream.removeListener('data', dataListener)));
+        stream.on('data', dataListener);
+    });
+}
+/**
+ * Helper to create a readable stream from an existing T.
+ */
+export function toStream(t, reducer) {
+    const stream = newWriteableStream(reducer);
+    stream.end(t);
+    return stream;
+}
+/**
+ * Helper to create an empty stream
+ */
+export function emptyStream() {
+    const stream = newWriteableStream(() => { throw new Error('not supported'); });
+    stream.end();
+    return stream;
+}
+/**
+ * Helper to convert a T into a Readable<T>.
+ */
+export function toReadable(t) {
+    let consumed = false;
+    return {
+        read: () => {
+            if (consumed) {
+                return null;
+            }
+            consumed = true;
+            return t;
+        }
+    };
+}
+/**
+ * Helper to transform a readable stream into another stream.
+ */
+export function transform(stream, transformer, reducer) {
+    const target = newWriteableStream(reducer);
+    listenStream(stream, {
+        onData: data => target.write(transformer.data(data)),
+        onError: error => target.error(transformer.error ? transformer.error(error) : error),
+        onEnd: () => target.end()
+    });
+    return target;
+}
+/**
+ * Helper to take an existing readable that will
+ * have a prefix injected to the beginning.
+ */
+export function prefixedReadable(prefix, readable, reducer) {
+    let prefixHandled = false;
+    return {
+        read: () => {
+            const chunk = readable.read();
+            // Handle prefix only once
+            if (!prefixHandled) {
+                prefixHandled = true;
+                // If we have also a read-result, make
+                // sure to reduce it to a single result
+                if (chunk !== null) {
+                    return reducer([prefix, chunk]);
+                }
+                // Otherwise, just return prefix directly
+                return prefix;
+            }
+            return chunk;
+        }
+    };
+}
+/**
+ * Helper to take an existing stream that will
+ * have a prefix injected to the beginning.
+ */
+export function prefixedStream(prefix, stream, reducer) {
+    let prefixHandled = false;
+    const target = newWriteableStream(reducer);
+    listenStream(stream, {
+        onData: data => {
+            // Handle prefix only once
+            if (!prefixHandled) {
+                prefixHandled = true;
+                return target.write(reducer([prefix, data]));
+            }
+            return target.write(data);
+        },
+        onError: error => target.error(error),
+        onEnd: () => {
+            // Handle prefix only once
+            if (!prefixHandled) {
+                prefixHandled = true;
+                target.write(prefix);
+            }
+            target.end();
+        }
+    });
+    return target;
+}
diff -urN -x '*.map' a/vs/base/common/strings.js b/vs/base/common/strings.js
--- a/vs/base/common/strings.js	2023-09-05 08:43:04.238808750 +0000
+++ b/vs/base/common/strings.js	2023-09-05 08:45:14.293196291 +0000
@@ -29,6 +29,14 @@
             args[idx];
     });
 }
+const _format2Regexp = /{([^}]+)}/g;
+/**
+ * Helper to create a string from a template and a string record.
+ * Similar to `format` but with objects instead of positional arguments.
+ */
+export function format2(template, values) {
+    return template.replace(_format2Regexp, (match, group) => { var _b; return ((_b = values[group]) !== null && _b !== void 0 ? _b : match); });
+}
 /**
  * Converts HTML characters inside the string to use entities instead. Makes the string safe from
  * being used e.g. in HTMLElement.innerHTML.
@@ -50,6 +58,25 @@
     return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, '\\$&');
 }
 /**
+ * Counts how often `character` occurs inside `value`.
+ */
+export function count(value, character) {
+    let result = 0;
+    const ch = character.charCodeAt(0);
+    for (let i = value.length - 1; i >= 0; i--) {
+        if (value.charCodeAt(i) === ch) {
+            result++;
+        }
+    }
+    return result;
+}
+export function truncate(value, maxLength, suffix = '') {
+    if (value.length <= maxLength) {
+        return value;
+    }
+    return `${value.substr(0, maxLength)}${suffix}`;
+}
+/**
  * Removes all occurrences of needle from the beginning and end of haystack.
  * @param haystack string to trim
  * @param needle the thing to trim (default is a blank)
@@ -150,6 +177,9 @@
     const match = regexp.exec('');
     return !!(match && regexp.lastIndex === 0);
 }
+export function regExpContainsBackreference(regexpValue) {
+    return !!regexpValue.match(/([^\\]|^)(\\\\)*\\\d+/);
+}
 export function regExpFlags(regexp) {
     return (regexp.global ? 'g' : '')
         + (regexp.ignoreCase ? 'i' : '')
@@ -198,6 +228,24 @@
     }
     return -1;
 }
+/**
+ * Function that works identically to String.prototype.replace, except, the
+ * replace function is allowed to be async and return a Promise.
+ */
+export function replaceAsync(str, search, replacer) {
+    const parts = [];
+    let last = 0;
+    for (const match of str.matchAll(search)) {
+        parts.push(str.slice(last, match.index));
+        if (match.index === undefined) {
+            throw new Error('match.index should be defined');
+        }
+        last = match.index + match[0].length;
+        parts.push(replacer(match[0], ...match.slice(1), match.index, str, match.groups));
+    }
+    parts.push(str.slice(last));
+    return Promise.all(parts).then(p => p.join(''));
+}
 export function compare(a, b) {
     if (a < b) {
         return -1;
@@ -448,6 +496,15 @@
     const startOffset = endOffset - prevCharLength(str, endOffset);
     return [startOffset, endOffset];
 }
+export function charCount(str) {
+    const iterator = new GraphemeIterator(str);
+    let length = 0;
+    while (!iterator.eol()) {
+        length++;
+        iterator.nextGraphemeLength();
+    }
+    return length;
+}
 let CONTAINS_RTL = undefined;
 function makeContainsRtl() {
     // Generated using https://github.com/alexdima/unicode-utils/blob/main/rtl-test.js
@@ -530,11 +587,68 @@
         || (x >= 128992 && x <= 129008) || (x >= 129280 && x <= 129535)
         || (x >= 129648 && x <= 129782));
 }
+/**
+ * Given a string and a max length returns a shorted version. Shorting
+ * happens at favorable positions - such as whitespace or punctuation characters.
+ */
+export function lcut(text, n) {
+    if (text.length < n) {
+        return text;
+    }
+    const re = /\b/g;
+    let i = 0;
+    while (re.test(text)) {
+        if (text.length - re.lastIndex < n) {
+            break;
+        }
+        i = re.lastIndex;
+        re.lastIndex += 1;
+    }
+    return text.substring(i).replace(/^\s/, '');
+}
+// Escape codes, compiled from https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Functions-using-CSI-_-ordered-by-the-final-character_s_
+const CSI_SEQUENCE = /(:?\x1b\[|\x9B)[=?>!]?[\d;:]*["$#'* ]?[a-zA-Z@^`{}|~]/g;
+// Plus additional markers for custom `\x1b]...\x07` instructions.
+const CSI_CUSTOM_SEQUENCE = /\x1b\].*?\x07/g;
+export function removeAnsiEscapeCodes(str) {
+    if (str) {
+        str = str.replace(CSI_SEQUENCE, '').replace(CSI_CUSTOM_SEQUENCE, '');
+    }
+    return str;
+}
 // -- UTF-8 BOM
 export const UTF8_BOM_CHARACTER = String.fromCharCode(65279 /* CharCode.UTF8_BOM */);
 export function startsWithUTF8BOM(str) {
     return !!(str && str.length > 0 && str.charCodeAt(0) === 65279 /* CharCode.UTF8_BOM */);
 }
+export function stripUTF8BOM(str) {
+    return startsWithUTF8BOM(str) ? str.substr(1) : str;
+}
+/**
+ * Checks if the characters of the provided query string are included in the
+ * target string. The characters do not have to be contiguous within the string.
+ */
+export function fuzzyContains(target, query) {
+    if (!target || !query) {
+        return false; // return early if target or query are undefined
+    }
+    if (target.length < query.length) {
+        return false; // impossible for query to be contained in target
+    }
+    const queryLen = query.length;
+    const targetLower = target.toLowerCase();
+    let index = 0;
+    let lastIndexOf = -1;
+    while (index < queryLen) {
+        const indexOf = targetLower.indexOf(query[index], lastIndexOf + 1);
+        if (indexOf < 0) {
+            return false;
+        }
+        lastIndexOf = indexOf;
+        index++;
+    }
+    return true;
+}
 export function containsUppercaseCharacter(target, ignoreEscapedChars = false) {
     if (!target) {
         return false;
@@ -544,6 +658,26 @@
     }
     return target.toLowerCase() !== target;
 }
+export function uppercaseFirstLetter(str) {
+    return str.charAt(0).toUpperCase() + str.slice(1);
+}
+export function getNLines(str, n = 1) {
+    if (n === 0) {
+        return '';
+    }
+    let idx = -1;
+    do {
+        idx = str.indexOf('\n', idx + 1);
+        n--;
+    } while (n > 0 && idx >= 0);
+    if (idx === -1) {
+        return str;
+    }
+    if (str[idx - 1] === '\r') {
+        idx--;
+    }
+    return str.substr(0, idx);
+}
 /**
  * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.
  */
@@ -555,6 +689,11 @@
     }
     return String.fromCharCode(65 /* CharCode.A */ + n - LETTERS_CNT);
 }
+//#region Unicode Grapheme Break
+export function getGraphemeBreakType(codePoint) {
+    const graphemeBreakTree = GraphemeBreakTree.getInstance();
+    return graphemeBreakTree.getGraphemeBreakType(codePoint);
+}
 function breakBetweenGraphemeBreakType(breakTypeA, breakTypeB) {
     // http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundary_Rules
     // !!! Let's make the common case a bit faster
diff -urN -x '*.map' a/vs/base/common/ternarySearchTree.js b/vs/base/common/ternarySearchTree.js
--- a/vs/base/common/ternarySearchTree.js	2023-09-05 08:43:04.238808750 +0000
+++ b/vs/base/common/ternarySearchTree.js	2023-09-05 08:45:14.301196405 +0000
@@ -1,3 +1,8 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { shuffle } from './arrays.js';
 import { compare, compareIgnoreCase, compareSubstring, compareSubstringIgnoreCase } from './strings.js';
 export class StringIterator {
     constructor() {
@@ -205,6 +210,9 @@
     constructor() {
         this.height = 1;
     }
+    isEmpty() {
+        return !this.left && !this.mid && !this.right && !this.value;
+    }
     rotateLeft() {
         const tmp = this.right;
         this.right = tmp.left;
@@ -240,6 +248,9 @@
     static forUris(ignorePathCasing = () => false, ignoreQueryAndFragment = () => false) {
         return new TernarySearchTree(new UriIterator(ignorePathCasing, ignoreQueryAndFragment));
     }
+    static forPaths(ignorePathCasing = false) {
+        return new TernarySearchTree(new PathIterator(undefined, !ignorePathCasing));
+    }
     static forStrings() {
         return new TernarySearchTree(new StringIterator());
     }
@@ -252,6 +263,22 @@
     clear() {
         this._root = undefined;
     }
+    fill(values, keys) {
+        if (keys) {
+            const arr = keys.slice(0);
+            shuffle(arr);
+            for (const k of arr) {
+                this.set(k, values);
+            }
+        }
+        else {
+            const arr = values.slice(0);
+            shuffle(arr);
+            for (const entry of arr) {
+                this.set(entry[0], entry[1]);
+            }
+        }
+    }
     set(key, element) {
         const iter = this._iter.reset(key);
         let node;
@@ -588,6 +615,9 @@
         }
         return undefined;
     }
+    hasElementOrSubtree(key) {
+        return this._findSuperstrOrElement(key, true) !== undefined;
+    }
     forEach(callback) {
         for (const [key, value] of this) {
             callback(value, key);
@@ -619,4 +649,18 @@
             this._dfsEntries(node.right, bucket);
         }
     }
+    // for debug/testing
+    _isBalanced() {
+        const nodeIsBalanced = (node) => {
+            if (!node) {
+                return true;
+            }
+            const bf = node.balanceFactor();
+            if (bf < -1 || bf > 1) {
+                return false;
+            }
+            return nodeIsBalanced(node.left) && nodeIsBalanced(node.right);
+        };
+        return nodeIsBalanced(this._root);
+    }
 }
diff -urN -x '*.map' a/vs/base/common/themables.js b/vs/base/common/themables.js
--- a/vs/base/common/themables.js	2023-09-05 08:43:04.238808750 +0000
+++ b/vs/base/common/themables.js	2023-09-05 08:45:14.297196348 +0000
@@ -10,6 +10,9 @@
     }
     ThemeColor.isThemeColor = isThemeColor;
 })(ThemeColor || (ThemeColor = {}));
+export function themeColorFromId(id) {
+    return { id };
+}
 export var ThemeIcon;
 (function (ThemeIcon) {
     ThemeIcon.iconNameSegment = '[A-Za-z0-9]+';
diff -urN -x '*.map' a/vs/base/common/types.js b/vs/base/common/types.js
--- a/vs/base/common/types.js	2023-09-05 08:43:04.238808750 +0000
+++ b/vs/base/common/types.js	2023-09-05 08:45:14.297196348 +0000
@@ -9,6 +9,12 @@
     return (typeof str === 'string');
 }
 /**
+ * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.
+ */
+export function isStringArray(value) {
+    return Array.isArray(value) && value.every(elem => isString(elem));
+}
+/**
  * @returns whether the provided parameter is of type `object` but **not**
  *	`null`, an `array`, a `regexp`, nor a `date`.
  */
@@ -81,12 +87,44 @@
     }
     return arg;
 }
+export function assertAllDefined(...args) {
+    const result = [];
+    for (let i = 0; i < args.length; i++) {
+        const arg = args[i];
+        if (isUndefinedOrNull(arg)) {
+            throw new Error(`Assertion Failed: argument at index ${i} is undefined or null`);
+        }
+        result.push(arg);
+    }
+    return result;
+}
+const hasOwnProperty = Object.prototype.hasOwnProperty;
+/**
+ * @returns whether the provided parameter is an empty JavaScript Object or not.
+ */
+export function isEmptyObject(obj) {
+    if (!isObject(obj)) {
+        return false;
+    }
+    for (const key in obj) {
+        if (hasOwnProperty.call(obj, key)) {
+            return false;
+        }
+    }
+    return true;
+}
 /**
  * @returns whether the provided parameter is a JavaScript Function or not.
  */
 export function isFunction(obj) {
     return (typeof obj === 'function');
 }
+/**
+ * @returns whether the provided parameters is are JavaScript Function or not.
+ */
+export function areFunctions(...objects) {
+    return objects.length > 0 && objects.every(isFunction);
+}
 export function validateConstraints(args, constraints) {
     const len = Math.min(args.length, constraints.length);
     for (let i = 0; i < len; i++) {
diff -urN -x '*.map' a/vs/base/common/uri.js b/vs/base/common/uri.js
--- a/vs/base/common/uri.js	2023-09-05 08:43:04.238808750 +0000
+++ b/vs/base/common/uri.js	2023-09-05 08:45:14.305196462 +0000
@@ -323,6 +323,16 @@
         }
     }
 }
+export function isUriComponents(thing) {
+    if (!thing || typeof thing !== 'object') {
+        return false;
+    }
+    return typeof thing.scheme === 'string'
+        && (typeof thing.authority === 'string' || typeof thing.authority === 'undefined')
+        && (typeof thing.path === 'string' || typeof thing.path === 'undefined')
+        && (typeof thing.query === 'string' || typeof thing.query === 'undefined')
+        && (typeof thing.fragment === 'string' || typeof thing.fragment === 'undefined');
+}
 const _pathSepMarker = isWindows ? 1 : undefined;
 // This class exists so that URI is compatible with vscode.Uri (API).
 class Uri extends URI {
diff -urN -x '*.map' a/vs/base/common/uuid.js b/vs/base/common/uuid.js
--- a/vs/base/common/uuid.js	2023-09-05 08:43:04.238808750 +0000
+++ b/vs/base/common/uuid.js	2023-09-05 08:45:14.301196405 +0000
@@ -1,3 +1,11 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+const _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
+export function isUUID(value) {
+    return _UUIDPattern.test(value);
+}
 export const generateUuid = (function () {
     // use `randomUUID` if possible
     if (typeof crypto === 'object' && typeof crypto.randomUUID === 'function') {
diff -urN -x '*.map' a/vs/base/parts/sandbox/common/electronTypes.js b/vs/base/parts/sandbox/common/electronTypes.js
--- a/vs/base/parts/sandbox/common/electronTypes.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/base/parts/sandbox/common/electronTypes.js	2023-09-05 08:45:14.285196176 +0000
@@ -0,0 +1,5 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+export {};
diff -urN -x '*.map' a/vs/base/parts/storage/common/storage.js b/vs/base/parts/storage/common/storage.js
--- a/vs/base/parts/storage/common/storage.js	2023-09-05 08:43:04.242808851 +0000
+++ b/vs/base/parts/storage/common/storage.js	2023-09-05 08:45:14.285196176 +0000
@@ -14,7 +14,7 @@
 import { ThrottledDelayer } from '../../../common/async.js';
 import { Event, PauseableEmitter } from '../../../common/event.js';
 import { Disposable } from '../../../common/lifecycle.js';
-import { stringify } from '../../../common/marshalling.js';
+import { parse, stringify } from '../../../common/marshalling.js';
 import { isObject, isUndefinedOrNull } from '../../../common/types.js';
 export var StorageHint;
 (function (StorageHint) {
@@ -27,6 +27,10 @@
     // is backed by an in-memory storage.
     StorageHint[StorageHint["STORAGE_IN_MEMORY"] = 1] = "STORAGE_IN_MEMORY";
 })(StorageHint || (StorageHint = {}));
+export function isStorageItemsChangeEvent(thing) {
+    const candidate = thing;
+    return (candidate === null || candidate === void 0 ? void 0 : candidate.changed) instanceof Map || (candidate === null || candidate === void 0 ? void 0 : candidate.deleted) instanceof Set;
+}
 export var StorageState;
 (function (StorageState) {
     StorageState[StorageState["None"] = 0] = "None";
@@ -45,6 +49,7 @@
         this.flushDelayer = new ThrottledDelayer(Storage.DEFAULT_FLUSH_DELAY);
         this.pendingDeletes = new Set();
         this.pendingInserts = new Map();
+        this.pendingClose = undefined;
         this.whenFlushedCallbacks = [];
         this.registerListeners();
     }
@@ -87,6 +92,27 @@
             this._onDidChangeStorage.fire({ key, external: true });
         }
     }
+    get items() {
+        return this.cache;
+    }
+    get size() {
+        return this.cache.size;
+    }
+    init() {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (this.state !== StorageState.None) {
+                return; // either closed or already initialized
+            }
+            this.state = StorageState.Initialized;
+            if (this.options.hint === StorageHint.STORAGE_DOES_NOT_EXIST) {
+                // return early if we know the storage file does not exist. this is a performance
+                // optimization to not load all items of the underlying storage if we know that
+                // there can be no items because the storage does not exist.
+                return;
+            }
+            this.cache = yield this.database.getItems();
+        });
+    }
     get(key, fallbackValue) {
         const value = this.cache.get(key);
         if (isUndefinedOrNull(value)) {
@@ -108,6 +134,13 @@
         }
         return parseInt(value, 10);
     }
+    getObject(key, fallbackValue) {
+        const value = this.get(key);
+        if (isUndefinedOrNull(value)) {
+            return fallbackValue;
+        }
+        return parse(value);
+    }
     set(key, value, external = false) {
         return __awaiter(this, void 0, void 0, function* () {
             if (this.state === StorageState.Closed) {
@@ -154,6 +187,33 @@
             return this.doFlush();
         });
     }
+    close() {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (!this.pendingClose) {
+                this.pendingClose = this.doClose();
+            }
+            return this.pendingClose;
+        });
+    }
+    doClose() {
+        return __awaiter(this, void 0, void 0, function* () {
+            // Update state
+            this.state = StorageState.Closed;
+            // Trigger new flush to ensure data is persisted and then close
+            // even if there is an error flushing. We must always ensure
+            // the DB is closed to avoid corruption.
+            //
+            // Recovery: we pass our cache over as recovery option in case
+            // the DB is not healthy.
+            try {
+                yield this.doFlush(0 /* as soon as possible */);
+            }
+            catch (error) {
+                // Ignore
+            }
+            yield this.database.close(() => this.cache);
+        });
+    }
     get hasPending() {
         return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;
     }
@@ -179,11 +239,30 @@
             });
         });
     }
+    flush(delay) {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (!this.hasPending) {
+                return; // return early if nothing to do
+            }
+            return this.doFlush(delay);
+        });
+    }
     doFlush(delay) {
         return __awaiter(this, void 0, void 0, function* () {
             return this.flushDelayer.trigger(() => this.flushPending(), delay);
         });
     }
+    whenFlushed() {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (!this.hasPending) {
+                return; // return early if nothing to do
+            }
+            return new Promise(resolve => this.whenFlushedCallbacks.push(resolve));
+        });
+    }
+    isInMemory() {
+        return this.options.hint === StorageHint.STORAGE_IN_MEMORY;
+    }
     dispose() {
         this.flushDelayer.dispose();
         super.dispose();
@@ -195,6 +274,11 @@
         this.onDidChangeItemsExternal = Event.None;
         this.items = new Map();
     }
+    getItems() {
+        return __awaiter(this, void 0, void 0, function* () {
+            return this.items;
+        });
+    }
     updateItems(request) {
         var _a, _b;
         return __awaiter(this, void 0, void 0, function* () {
@@ -202,4 +286,7 @@
             (_b = request.delete) === null || _b === void 0 ? void 0 : _b.forEach(key => this.items.delete(key));
         });
     }
+    close() {
+        return __awaiter(this, void 0, void 0, function* () { });
+    }
 }
diff -urN -x '*.map' a/vs/editor/browser/config/editorConfiguration.js b/vs/editor/browser/config/editorConfiguration.js
--- a/vs/editor/browser/config/editorConfiguration.js	2023-09-05 08:43:04.410812827 +0000
+++ b/vs/editor/browser/config/editorConfiguration.js	2023-09-05 08:45:14.321196692 +0000
@@ -212,7 +212,7 @@
         this._values[id] = value;
     }
 }
-class EditorOptionsUtil {
+export class EditorOptionsUtil {
     static validateOptions(options) {
         const result = new ValidatedEditorOptions();
         for (const editorOption of editorOptionsRegistry) {
diff -urN -x '*.map' a/vs/editor/browser/config/fontMeasurements.js b/vs/editor/browser/config/fontMeasurements.js
--- a/vs/editor/browser/config/fontMeasurements.js	2023-09-05 08:43:04.410812827 +0000
+++ b/vs/editor/browser/config/fontMeasurements.js	2023-09-05 08:45:14.321196692 +0000
@@ -7,7 +7,7 @@
 import { Disposable } from '../../../base/common/lifecycle.js';
 import { CharWidthRequest, readCharWidths } from './charWidthReader.js';
 import { EditorFontLigatures } from '../../common/config/editorOptions.js';
-import { FontInfo } from '../../common/config/fontInfo.js';
+import { FontInfo, SERIALIZED_FONT_INFO_VERSION } from '../../common/config/fontInfo.js';
 export class FontMeasurementsImpl extends Disposable {
     constructor() {
         super();
@@ -54,6 +54,28 @@
         }
     }
     /**
+     * Serialized currently cached font information.
+     */
+    serializeFontInfo() {
+        // Only save trusted font info (that has been measured in this running instance)
+        return this._cache.getValues().filter(item => item.isTrusted);
+    }
+    /**
+     * Restore previously serialized font informations.
+     */
+    restoreFontInfo(savedFontInfos) {
+        // Take all the saved font info and insert them in the cache without the trusted flag.
+        // The reason for this is that a font might have been installed on the OS in the meantime.
+        for (const savedFontInfo of savedFontInfos) {
+            if (savedFontInfo.version !== SERIALIZED_FONT_INFO_VERSION) {
+                // cannot use older version
+                continue;
+            }
+            const fontInfo = new FontInfo(savedFontInfo, false);
+            this._writeToCache(fontInfo, fontInfo);
+        }
+    }
+    /**
      * Read font information.
      */
     readFontInfo(bareFontInfo) {
diff -urN -x '*.map' a/vs/editor/browser/controller/mouseHandler.js b/vs/editor/browser/controller/mouseHandler.js
--- a/vs/editor/browser/controller/mouseHandler.js	2023-09-05 08:43:04.398812547 +0000
+++ b/vs/editor/browser/controller/mouseHandler.js	2023-09-05 08:45:14.321196692 +0000
@@ -249,6 +249,9 @@
             target: t
         });
     }
+    _onMouseWheel(e) {
+        this.viewController.emitMouseWheel(e);
+    }
 }
 class MouseDownOperation extends Disposable {
     constructor(_context, _viewController, _viewHelper, _mouseTargetFactory, createMouseTarget, getMouseColumn) {
diff -urN -x '*.map' a/vs/editor/browser/controller/textAreaHandler.js b/vs/editor/browser/controller/textAreaHandler.js
--- a/vs/editor/browser/controller/textAreaHandler.js	2023-09-05 08:43:04.402812640 +0000
+++ b/vs/editor/browser/controller/textAreaHandler.js	2023-09-05 08:45:14.321196692 +0000
@@ -550,6 +550,9 @@
     focusTextArea() {
         this._textAreaInput.focusTextArea();
     }
+    refreshFocusState() {
+        this._textAreaInput.refreshFocusState();
+    }
     getLastRenderData() {
         return this._lastRenderPosition;
     }
diff -urN -x '*.map' a/vs/editor/browser/controller/textAreaInput.js b/vs/editor/browser/controller/textAreaInput.js
--- a/vs/editor/browser/controller/textAreaInput.js	2023-09-05 08:43:04.402812640 +0000
+++ b/vs/editor/browser/controller/textAreaInput.js	2023-09-05 08:45:14.321196692 +0000
@@ -309,6 +309,10 @@
             }
         }));
     }
+    _initializeFromTest() {
+        this._hasFocus = true;
+        this._textAreaState = TextAreaState.readFromTextArea(this._textArea, null);
+    }
     _installSelectionChangeListener() {
         // See https://github.com/microsoft/vscode/issues/27216 and https://github.com/microsoft/vscode/issues/98256
         // When using a Braille display, it is possible for users to reposition the
@@ -489,6 +493,7 @@
         super();
         this._actual = _actual;
         this.onKeyDown = this._register(new DomEmitter(this._actual, 'keydown')).event;
+        this.onKeyPress = this._register(new DomEmitter(this._actual, 'keypress')).event;
         this.onKeyUp = this._register(new DomEmitter(this._actual, 'keyup')).event;
         this.onCompositionStart = this._register(new DomEmitter(this._actual, 'compositionstart')).event;
         this.onCompositionUpdate = this._register(new DomEmitter(this._actual, 'compositionupdate')).event;
diff -urN -x '*.map' a/vs/editor/browser/editorBrowser.js b/vs/editor/browser/editorBrowser.js
--- a/vs/editor/browser/editorBrowser.js	2023-09-05 08:43:04.414812920 +0000
+++ b/vs/editor/browser/editorBrowser.js	2023-09-05 08:45:14.329196806 +0000
@@ -48,3 +48,12 @@
     }
     return null;
 }
+/**
+ *@internal
+ */
+export function getIEditor(thing) {
+    if (isCodeEditor(thing) || isDiffEditor(thing)) {
+        return thing;
+    }
+    return null;
+}
diff -urN -x '*.map' a/vs/editor/browser/editorExtensions.js b/vs/editor/browser/editorExtensions.js
--- a/vs/editor/browser/editorExtensions.js	2023-09-05 08:43:04.414812920 +0000
+++ b/vs/editor/browser/editorExtensions.js	2023-09-05 08:45:14.317196634 +0000
@@ -332,6 +332,13 @@
 export function registerEditorContribution(id, ctor, instantiation) {
     EditorContributionRegistry.INSTANCE.registerEditorContribution(id, ctor, instantiation);
 }
+/**
+ * Registers a diff editor contribution. Diff editor contributions have a lifecycle which
+ * is bound to a specific diff editor instance.
+ */
+export function registerDiffEditorContribution(id, ctor) {
+    EditorContributionRegistry.INSTANCE.registerDiffEditorContribution(id, ctor);
+}
 export var EditorExtensionsRegistry;
 (function (EditorExtensionsRegistry) {
     function getEditorCommand(commandId) {
@@ -372,6 +379,9 @@
     getEditorContributions() {
         return this.editorContributions.slice(0);
     }
+    registerDiffEditorContribution(id, ctor) {
+        this.diffEditorContributions.push({ id, ctor: ctor });
+    }
     getDiffEditorContributions() {
         return this.diffEditorContributions.slice(0);
     }
diff -urN -x '*.map' a/vs/editor/browser/services/abstractCodeEditorService.js b/vs/editor/browser/services/abstractCodeEditorService.js
--- a/vs/editor/browser/services/abstractCodeEditorService.js	2023-09-05 08:43:04.402812640 +0000
+++ b/vs/editor/browser/services/abstractCodeEditorService.js	2023-09-05 08:45:14.317196634 +0000
@@ -1,3 +1,7 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
 var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
     var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
     if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
@@ -16,26 +20,39 @@
         step((generator = generator.apply(thisArg, _arguments || [])).next());
     });
 };
+import * as dom from '../../../base/browser/dom.js';
 import { Emitter } from '../../../base/common/event.js';
-import { Disposable, toDisposable } from '../../../base/common/lifecycle.js';
+import { DisposableStore, Disposable, toDisposable } from '../../../base/common/lifecycle.js';
 import { LinkedList } from '../../../base/common/linkedList.js';
+import * as strings from '../../../base/common/strings.js';
+import { URI } from '../../../base/common/uri.js';
+import { isThemeColor } from '../../common/editorCommon.js';
+import { OverviewRulerLane } from '../../common/model.js';
 import { IThemeService } from '../../../platform/theme/common/themeService.js';
 let AbstractCodeEditorService = class AbstractCodeEditorService extends Disposable {
     constructor(_themeService) {
         super();
         this._themeService = _themeService;
         this._onWillCreateCodeEditor = this._register(new Emitter());
+        this.onWillCreateCodeEditor = this._onWillCreateCodeEditor.event;
         this._onCodeEditorAdd = this._register(new Emitter());
         this.onCodeEditorAdd = this._onCodeEditorAdd.event;
         this._onCodeEditorRemove = this._register(new Emitter());
         this.onCodeEditorRemove = this._onCodeEditorRemove.event;
         this._onWillCreateDiffEditor = this._register(new Emitter());
+        this.onWillCreateDiffEditor = this._onWillCreateDiffEditor.event;
         this._onDiffEditorAdd = this._register(new Emitter());
         this.onDiffEditorAdd = this._onDiffEditorAdd.event;
         this._onDiffEditorRemove = this._register(new Emitter());
         this.onDiffEditorRemove = this._onDiffEditorRemove.event;
+        this._onDidChangeTransientModelProperty = this._register(new Emitter());
+        this.onDidChangeTransientModelProperty = this._onDidChangeTransientModelProperty.event;
+        this._onDecorationTypeRegistered = this._register(new Emitter());
+        this.onDecorationTypeRegistered = this._onDecorationTypeRegistered.event;
         this._decorationOptionProviders = new Map();
+        this._editorStyleSheets = new Map();
         this._codeEditorOpenHandlers = new LinkedList();
+        this._transientWatchers = {};
         this._modelProperties = new Map();
         this._codeEditors = Object.create(null);
         this._diffEditors = Object.create(null);
@@ -85,6 +102,57 @@
         }
         return editorWithWidgetFocus;
     }
+    _getOrCreateGlobalStyleSheet() {
+        if (!this._globalStyleSheet) {
+            this._globalStyleSheet = this._createGlobalStyleSheet();
+        }
+        return this._globalStyleSheet;
+    }
+    _createGlobalStyleSheet() {
+        return new GlobalStyleSheet(dom.createStyleSheet());
+    }
+    _getOrCreateStyleSheet(editor) {
+        if (!editor) {
+            return this._getOrCreateGlobalStyleSheet();
+        }
+        const domNode = editor.getContainerDomNode();
+        if (!dom.isInShadowDOM(domNode)) {
+            return this._getOrCreateGlobalStyleSheet();
+        }
+        const editorId = editor.getId();
+        if (!this._editorStyleSheets.has(editorId)) {
+            const refCountedStyleSheet = new RefCountedStyleSheet(this, editorId, dom.createStyleSheet(domNode));
+            this._editorStyleSheets.set(editorId, refCountedStyleSheet);
+        }
+        return this._editorStyleSheets.get(editorId);
+    }
+    _removeEditorStyleSheets(editorId) {
+        this._editorStyleSheets.delete(editorId);
+    }
+    registerDecorationType(description, key, options, parentTypeKey, editor) {
+        let provider = this._decorationOptionProviders.get(key);
+        if (!provider) {
+            const styleSheet = this._getOrCreateStyleSheet(editor);
+            const providerArgs = {
+                styleSheet: styleSheet,
+                key: key,
+                parentTypeKey: parentTypeKey,
+                options: options || Object.create(null)
+            };
+            if (!parentTypeKey) {
+                provider = new DecorationTypeOptionsProvider(description, this._themeService, styleSheet, providerArgs);
+            }
+            else {
+                provider = new DecorationSubTypeOptionsProvider(this._themeService, styleSheet, providerArgs);
+            }
+            this._decorationOptionProviders.set(key, provider);
+            this._onDecorationTypeRegistered.fire(key);
+        }
+        provider.refCount++;
+    }
+    listDecorationTypes() {
+        return Array.from(this._decorationOptionProviders.keys());
+    }
     removeDecorationType(key) {
         const provider = this._decorationOptionProviders.get(key);
         if (provider) {
@@ -96,6 +164,20 @@
             }
         }
     }
+    resolveDecorationOptions(decorationTypeKey, writable) {
+        const provider = this._decorationOptionProviders.get(decorationTypeKey);
+        if (!provider) {
+            throw new Error('Unknown decoration type key: ' + decorationTypeKey);
+        }
+        return provider.getOptions(this, writable);
+    }
+    resolveDecorationCSSRules(decorationTypeKey) {
+        const provider = this._decorationOptionProviders.get(decorationTypeKey);
+        if (!provider) {
+            return null;
+        }
+        return provider.resolveDecorationCSSRules();
+    }
     setModelProperty(resource, key, value) {
         const key1 = resource.toString();
         let dest;
@@ -116,6 +198,39 @@
         }
         return undefined;
     }
+    setTransientModelProperty(model, key, value) {
+        const uri = model.uri.toString();
+        let w;
+        if (this._transientWatchers.hasOwnProperty(uri)) {
+            w = this._transientWatchers[uri];
+        }
+        else {
+            w = new ModelTransientSettingWatcher(uri, model, this);
+            this._transientWatchers[uri] = w;
+        }
+        const previousValue = w.get(key);
+        if (previousValue !== value) {
+            w.set(key, value);
+            this._onDidChangeTransientModelProperty.fire(model);
+        }
+    }
+    getTransientModelProperty(model, key) {
+        const uri = model.uri.toString();
+        if (!this._transientWatchers.hasOwnProperty(uri)) {
+            return undefined;
+        }
+        return this._transientWatchers[uri].get(key);
+    }
+    getTransientModelProperties(model) {
+        const uri = model.uri.toString();
+        if (!this._transientWatchers.hasOwnProperty(uri)) {
+            return undefined;
+        }
+        return this._transientWatchers[uri].keys().map(key => [key, this._transientWatchers[uri].get(key)]);
+    }
+    _removeWatcher(w) {
+        delete this._transientWatchers[w.uri];
+    }
     openCodeEditor(input, source, sideBySide) {
         return __awaiter(this, void 0, void 0, function* () {
             for (const handler of this._codeEditorOpenHandlers) {
@@ -136,8 +251,441 @@
     __param(0, IThemeService)
 ], AbstractCodeEditorService);
 export { AbstractCodeEditorService };
+export class ModelTransientSettingWatcher {
+    constructor(uri, model, owner) {
+        this.uri = uri;
+        this._values = {};
+        model.onWillDispose(() => owner._removeWatcher(this));
+    }
+    set(key, value) {
+        this._values[key] = value;
+    }
+    get(key) {
+        return this._values[key];
+    }
+    keys() {
+        return Object.keys(this._values);
+    }
+}
+class RefCountedStyleSheet {
+    get sheet() {
+        return this._styleSheet.sheet;
+    }
+    constructor(parent, editorId, styleSheet) {
+        this._parent = parent;
+        this._editorId = editorId;
+        this._styleSheet = styleSheet;
+        this._refCount = 0;
+    }
+    ref() {
+        this._refCount++;
+    }
+    unref() {
+        var _a;
+        this._refCount--;
+        if (this._refCount === 0) {
+            (_a = this._styleSheet.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this._styleSheet);
+            this._parent._removeEditorStyleSheets(this._editorId);
+        }
+    }
+    insertRule(rule, index) {
+        const sheet = this._styleSheet.sheet;
+        sheet.insertRule(rule, index);
+    }
+    removeRulesContainingSelector(ruleName) {
+        dom.removeCSSRulesContainingSelector(ruleName, this._styleSheet);
+    }
+}
 export class GlobalStyleSheet {
+    get sheet() {
+        return this._styleSheet.sheet;
+    }
     constructor(styleSheet) {
         this._styleSheet = styleSheet;
     }
+    ref() {
+    }
+    unref() {
+    }
+    insertRule(rule, index) {
+        const sheet = this._styleSheet.sheet;
+        sheet.insertRule(rule, index);
+    }
+    removeRulesContainingSelector(ruleName) {
+        dom.removeCSSRulesContainingSelector(ruleName, this._styleSheet);
+    }
+}
+class DecorationSubTypeOptionsProvider {
+    constructor(themeService, styleSheet, providerArgs) {
+        this._styleSheet = styleSheet;
+        this._styleSheet.ref();
+        this._parentTypeKey = providerArgs.parentTypeKey;
+        this.refCount = 0;
+        this._beforeContentRules = new DecorationCSSRules(3 /* ModelDecorationCSSRuleType.BeforeContentClassName */, providerArgs, themeService);
+        this._afterContentRules = new DecorationCSSRules(4 /* ModelDecorationCSSRuleType.AfterContentClassName */, providerArgs, themeService);
+    }
+    getOptions(codeEditorService, writable) {
+        const options = codeEditorService.resolveDecorationOptions(this._parentTypeKey, true);
+        if (this._beforeContentRules) {
+            options.beforeContentClassName = this._beforeContentRules.className;
+        }
+        if (this._afterContentRules) {
+            options.afterContentClassName = this._afterContentRules.className;
+        }
+        return options;
+    }
+    resolveDecorationCSSRules() {
+        return this._styleSheet.sheet.cssRules;
+    }
+    dispose() {
+        if (this._beforeContentRules) {
+            this._beforeContentRules.dispose();
+            this._beforeContentRules = null;
+        }
+        if (this._afterContentRules) {
+            this._afterContentRules.dispose();
+            this._afterContentRules = null;
+        }
+        this._styleSheet.unref();
+    }
+}
+class DecorationTypeOptionsProvider {
+    constructor(description, themeService, styleSheet, providerArgs) {
+        this._disposables = new DisposableStore();
+        this.description = description;
+        this._styleSheet = styleSheet;
+        this._styleSheet.ref();
+        this.refCount = 0;
+        const createCSSRules = (type) => {
+            const rules = new DecorationCSSRules(type, providerArgs, themeService);
+            this._disposables.add(rules);
+            if (rules.hasContent) {
+                return rules.className;
+            }
+            return undefined;
+        };
+        const createInlineCSSRules = (type) => {
+            const rules = new DecorationCSSRules(type, providerArgs, themeService);
+            this._disposables.add(rules);
+            if (rules.hasContent) {
+                return { className: rules.className, hasLetterSpacing: rules.hasLetterSpacing };
+            }
+            return null;
+        };
+        this.className = createCSSRules(0 /* ModelDecorationCSSRuleType.ClassName */);
+        const inlineData = createInlineCSSRules(1 /* ModelDecorationCSSRuleType.InlineClassName */);
+        if (inlineData) {
+            this.inlineClassName = inlineData.className;
+            this.inlineClassNameAffectsLetterSpacing = inlineData.hasLetterSpacing;
+        }
+        this.beforeContentClassName = createCSSRules(3 /* ModelDecorationCSSRuleType.BeforeContentClassName */);
+        this.afterContentClassName = createCSSRules(4 /* ModelDecorationCSSRuleType.AfterContentClassName */);
+        if (providerArgs.options.beforeInjectedText && providerArgs.options.beforeInjectedText.contentText) {
+            const beforeInlineData = createInlineCSSRules(5 /* ModelDecorationCSSRuleType.BeforeInjectedTextClassName */);
+            this.beforeInjectedText = {
+                content: providerArgs.options.beforeInjectedText.contentText,
+                inlineClassName: beforeInlineData === null || beforeInlineData === void 0 ? void 0 : beforeInlineData.className,
+                inlineClassNameAffectsLetterSpacing: (beforeInlineData === null || beforeInlineData === void 0 ? void 0 : beforeInlineData.hasLetterSpacing) || providerArgs.options.beforeInjectedText.affectsLetterSpacing
+            };
+        }
+        if (providerArgs.options.afterInjectedText && providerArgs.options.afterInjectedText.contentText) {
+            const afterInlineData = createInlineCSSRules(6 /* ModelDecorationCSSRuleType.AfterInjectedTextClassName */);
+            this.afterInjectedText = {
+                content: providerArgs.options.afterInjectedText.contentText,
+                inlineClassName: afterInlineData === null || afterInlineData === void 0 ? void 0 : afterInlineData.className,
+                inlineClassNameAffectsLetterSpacing: (afterInlineData === null || afterInlineData === void 0 ? void 0 : afterInlineData.hasLetterSpacing) || providerArgs.options.afterInjectedText.affectsLetterSpacing
+            };
+        }
+        this.glyphMarginClassName = createCSSRules(2 /* ModelDecorationCSSRuleType.GlyphMarginClassName */);
+        const options = providerArgs.options;
+        this.isWholeLine = Boolean(options.isWholeLine);
+        this.stickiness = options.rangeBehavior;
+        const lightOverviewRulerColor = options.light && options.light.overviewRulerColor || options.overviewRulerColor;
+        const darkOverviewRulerColor = options.dark && options.dark.overviewRulerColor || options.overviewRulerColor;
+        if (typeof lightOverviewRulerColor !== 'undefined'
+            || typeof darkOverviewRulerColor !== 'undefined') {
+            this.overviewRuler = {
+                color: lightOverviewRulerColor || darkOverviewRulerColor,
+                darkColor: darkOverviewRulerColor || lightOverviewRulerColor,
+                position: options.overviewRulerLane || OverviewRulerLane.Center
+            };
+        }
+    }
+    getOptions(codeEditorService, writable) {
+        if (!writable) {
+            return this;
+        }
+        return {
+            description: this.description,
+            inlineClassName: this.inlineClassName,
+            beforeContentClassName: this.beforeContentClassName,
+            afterContentClassName: this.afterContentClassName,
+            className: this.className,
+            glyphMarginClassName: this.glyphMarginClassName,
+            isWholeLine: this.isWholeLine,
+            overviewRuler: this.overviewRuler,
+            stickiness: this.stickiness,
+            before: this.beforeInjectedText,
+            after: this.afterInjectedText
+        };
+    }
+    resolveDecorationCSSRules() {
+        return this._styleSheet.sheet.rules;
+    }
+    dispose() {
+        this._disposables.dispose();
+        this._styleSheet.unref();
+    }
+}
+export const _CSS_MAP = {
+    color: 'color:{0} !important;',
+    opacity: 'opacity:{0};',
+    backgroundColor: 'background-color:{0};',
+    outline: 'outline:{0};',
+    outlineColor: 'outline-color:{0};',
+    outlineStyle: 'outline-style:{0};',
+    outlineWidth: 'outline-width:{0};',
+    border: 'border:{0};',
+    borderColor: 'border-color:{0};',
+    borderRadius: 'border-radius:{0};',
+    borderSpacing: 'border-spacing:{0};',
+    borderStyle: 'border-style:{0};',
+    borderWidth: 'border-width:{0};',
+    fontStyle: 'font-style:{0};',
+    fontWeight: 'font-weight:{0};',
+    fontSize: 'font-size:{0};',
+    fontFamily: 'font-family:{0};',
+    textDecoration: 'text-decoration:{0};',
+    cursor: 'cursor:{0};',
+    letterSpacing: 'letter-spacing:{0};',
+    gutterIconPath: 'background:{0} center center no-repeat;',
+    gutterIconSize: 'background-size:{0};',
+    contentText: 'content:\'{0}\';',
+    contentIconPath: 'content:{0};',
+    margin: 'margin:{0};',
+    padding: 'padding:{0};',
+    width: 'width:{0};',
+    height: 'height:{0};',
+    verticalAlign: 'vertical-align:{0};',
+};
+class DecorationCSSRules {
+    constructor(ruleType, providerArgs, themeService) {
+        this._theme = themeService.getColorTheme();
+        this._ruleType = ruleType;
+        this._providerArgs = providerArgs;
+        this._usesThemeColors = false;
+        this._hasContent = false;
+        this._hasLetterSpacing = false;
+        let className = CSSNameHelper.getClassName(this._providerArgs.key, ruleType);
+        if (this._providerArgs.parentTypeKey) {
+            className = className + ' ' + CSSNameHelper.getClassName(this._providerArgs.parentTypeKey, ruleType);
+        }
+        this._className = className;
+        this._unThemedSelector = CSSNameHelper.getSelector(this._providerArgs.key, this._providerArgs.parentTypeKey, ruleType);
+        this._buildCSS();
+        if (this._usesThemeColors) {
+            this._themeListener = themeService.onDidColorThemeChange(theme => {
+                this._theme = themeService.getColorTheme();
+                this._removeCSS();
+                this._buildCSS();
+            });
+        }
+        else {
+            this._themeListener = null;
+        }
+    }
+    dispose() {
+        if (this._hasContent) {
+            this._removeCSS();
+            this._hasContent = false;
+        }
+        if (this._themeListener) {
+            this._themeListener.dispose();
+            this._themeListener = null;
+        }
+    }
+    get hasContent() {
+        return this._hasContent;
+    }
+    get hasLetterSpacing() {
+        return this._hasLetterSpacing;
+    }
+    get className() {
+        return this._className;
+    }
+    _buildCSS() {
+        const options = this._providerArgs.options;
+        let unthemedCSS, lightCSS, darkCSS;
+        switch (this._ruleType) {
+            case 0 /* ModelDecorationCSSRuleType.ClassName */:
+                unthemedCSS = this.getCSSTextForModelDecorationClassName(options);
+                lightCSS = this.getCSSTextForModelDecorationClassName(options.light);
+                darkCSS = this.getCSSTextForModelDecorationClassName(options.dark);
+                break;
+            case 1 /* ModelDecorationCSSRuleType.InlineClassName */:
+                unthemedCSS = this.getCSSTextForModelDecorationInlineClassName(options);
+                lightCSS = this.getCSSTextForModelDecorationInlineClassName(options.light);
+                darkCSS = this.getCSSTextForModelDecorationInlineClassName(options.dark);
+                break;
+            case 2 /* ModelDecorationCSSRuleType.GlyphMarginClassName */:
+                unthemedCSS = this.getCSSTextForModelDecorationGlyphMarginClassName(options);
+                lightCSS = this.getCSSTextForModelDecorationGlyphMarginClassName(options.light);
+                darkCSS = this.getCSSTextForModelDecorationGlyphMarginClassName(options.dark);
+                break;
+            case 3 /* ModelDecorationCSSRuleType.BeforeContentClassName */:
+                unthemedCSS = this.getCSSTextForModelDecorationContentClassName(options.before);
+                lightCSS = this.getCSSTextForModelDecorationContentClassName(options.light && options.light.before);
+                darkCSS = this.getCSSTextForModelDecorationContentClassName(options.dark && options.dark.before);
+                break;
+            case 4 /* ModelDecorationCSSRuleType.AfterContentClassName */:
+                unthemedCSS = this.getCSSTextForModelDecorationContentClassName(options.after);
+                lightCSS = this.getCSSTextForModelDecorationContentClassName(options.light && options.light.after);
+                darkCSS = this.getCSSTextForModelDecorationContentClassName(options.dark && options.dark.after);
+                break;
+            case 5 /* ModelDecorationCSSRuleType.BeforeInjectedTextClassName */:
+                unthemedCSS = this.getCSSTextForModelDecorationContentClassName(options.beforeInjectedText);
+                lightCSS = this.getCSSTextForModelDecorationContentClassName(options.light && options.light.beforeInjectedText);
+                darkCSS = this.getCSSTextForModelDecorationContentClassName(options.dark && options.dark.beforeInjectedText);
+                break;
+            case 6 /* ModelDecorationCSSRuleType.AfterInjectedTextClassName */:
+                unthemedCSS = this.getCSSTextForModelDecorationContentClassName(options.afterInjectedText);
+                lightCSS = this.getCSSTextForModelDecorationContentClassName(options.light && options.light.afterInjectedText);
+                darkCSS = this.getCSSTextForModelDecorationContentClassName(options.dark && options.dark.afterInjectedText);
+                break;
+            default:
+                throw new Error('Unknown rule type: ' + this._ruleType);
+        }
+        const sheet = this._providerArgs.styleSheet;
+        let hasContent = false;
+        if (unthemedCSS.length > 0) {
+            sheet.insertRule(`${this._unThemedSelector} {${unthemedCSS}}`, 0);
+            hasContent = true;
+        }
+        if (lightCSS.length > 0) {
+            sheet.insertRule(`.vs${this._unThemedSelector}, .hc-light${this._unThemedSelector} {${lightCSS}}`, 0);
+            hasContent = true;
+        }
+        if (darkCSS.length > 0) {
+            sheet.insertRule(`.vs-dark${this._unThemedSelector}, .hc-black${this._unThemedSelector} {${darkCSS}}`, 0);
+            hasContent = true;
+        }
+        this._hasContent = hasContent;
+    }
+    _removeCSS() {
+        this._providerArgs.styleSheet.removeRulesContainingSelector(this._unThemedSelector);
+    }
+    /**
+     * Build the CSS for decorations styled via `className`.
+     */
+    getCSSTextForModelDecorationClassName(opts) {
+        if (!opts) {
+            return '';
+        }
+        const cssTextArr = [];
+        this.collectCSSText(opts, ['backgroundColor'], cssTextArr);
+        this.collectCSSText(opts, ['outline', 'outlineColor', 'outlineStyle', 'outlineWidth'], cssTextArr);
+        this.collectBorderSettingsCSSText(opts, cssTextArr);
+        return cssTextArr.join('');
+    }
+    /**
+     * Build the CSS for decorations styled via `inlineClassName`.
+     */
+    getCSSTextForModelDecorationInlineClassName(opts) {
+        if (!opts) {
+            return '';
+        }
+        const cssTextArr = [];
+        this.collectCSSText(opts, ['fontStyle', 'fontWeight', 'textDecoration', 'cursor', 'color', 'opacity', 'letterSpacing'], cssTextArr);
+        if (opts.letterSpacing) {
+            this._hasLetterSpacing = true;
+        }
+        return cssTextArr.join('');
+    }
+    /**
+     * Build the CSS for decorations styled before or after content.
+     */
+    getCSSTextForModelDecorationContentClassName(opts) {
+        if (!opts) {
+            return '';
+        }
+        const cssTextArr = [];
+        if (typeof opts !== 'undefined') {
+            this.collectBorderSettingsCSSText(opts, cssTextArr);
+            if (typeof opts.contentIconPath !== 'undefined') {
+                cssTextArr.push(strings.format(_CSS_MAP.contentIconPath, dom.asCSSUrl(URI.revive(opts.contentIconPath))));
+            }
+            if (typeof opts.contentText === 'string') {
+                const truncated = opts.contentText.match(/^.*$/m)[0]; // only take first line
+                const escaped = truncated.replace(/['\\]/g, '\\$&');
+                cssTextArr.push(strings.format(_CSS_MAP.contentText, escaped));
+            }
+            this.collectCSSText(opts, ['verticalAlign', 'fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'textDecoration', 'color', 'opacity', 'backgroundColor', 'margin', 'padding'], cssTextArr);
+            if (this.collectCSSText(opts, ['width', 'height'], cssTextArr)) {
+                cssTextArr.push('display:inline-block;');
+            }
+        }
+        return cssTextArr.join('');
+    }
+    /**
+     * Build the CSS for decorations styled via `glyphMarginClassName`.
+     */
+    getCSSTextForModelDecorationGlyphMarginClassName(opts) {
+        if (!opts) {
+            return '';
+        }
+        const cssTextArr = [];
+        if (typeof opts.gutterIconPath !== 'undefined') {
+            cssTextArr.push(strings.format(_CSS_MAP.gutterIconPath, dom.asCSSUrl(URI.revive(opts.gutterIconPath))));
+            if (typeof opts.gutterIconSize !== 'undefined') {
+                cssTextArr.push(strings.format(_CSS_MAP.gutterIconSize, opts.gutterIconSize));
+            }
+        }
+        return cssTextArr.join('');
+    }
+    collectBorderSettingsCSSText(opts, cssTextArr) {
+        if (this.collectCSSText(opts, ['border', 'borderColor', 'borderRadius', 'borderSpacing', 'borderStyle', 'borderWidth'], cssTextArr)) {
+            cssTextArr.push(strings.format('box-sizing: border-box;'));
+            return true;
+        }
+        return false;
+    }
+    collectCSSText(opts, properties, cssTextArr) {
+        const lenBefore = cssTextArr.length;
+        for (const property of properties) {
+            const value = this.resolveValue(opts[property]);
+            if (typeof value === 'string') {
+                cssTextArr.push(strings.format(_CSS_MAP[property], value));
+            }
+        }
+        return cssTextArr.length !== lenBefore;
+    }
+    resolveValue(value) {
+        if (isThemeColor(value)) {
+            this._usesThemeColors = true;
+            const color = this._theme.getColor(value.id);
+            if (color) {
+                return color.toString();
+            }
+            return 'transparent';
+        }
+        return value;
+    }
+}
+class CSSNameHelper {
+    static getClassName(key, type) {
+        return 'ced-' + key + '-' + type;
+    }
+    static getSelector(key, parentKey, ruleType) {
+        let selector = '.monaco-editor .' + this.getClassName(key, ruleType);
+        if (parentKey) {
+            selector = selector + '.' + this.getClassName(parentKey, ruleType);
+        }
+        if (ruleType === 3 /* ModelDecorationCSSRuleType.BeforeContentClassName */) {
+            selector += '::before';
+        }
+        else if (ruleType === 4 /* ModelDecorationCSSRuleType.AfterContentClassName */) {
+            selector += '::after';
+        }
+        return selector;
+    }
 }
diff -urN -x '*.map' a/vs/editor/browser/services/editorWorkerService.js b/vs/editor/browser/services/editorWorkerService.js
--- a/vs/editor/browser/services/editorWorkerService.js	2023-09-05 08:43:04.402812640 +0000
+++ b/vs/editor/browser/services/editorWorkerService.js	2023-09-05 08:45:14.317196634 +0000
@@ -33,7 +33,7 @@
 import { isNonEmptyArray } from '../../../base/common/arrays.js';
 import { ILogService } from '../../../platform/log/common/log.js';
 import { StopWatch } from '../../../base/common/stopwatch.js';
-import { canceled } from '../../../base/common/errors.js';
+import { canceled, onUnexpectedError } from '../../../base/common/errors.js';
 import { ILanguageFeaturesService } from '../../common/services/languageFeatures.js';
 import { LineRangeMapping, MovedText, RangeMapping, SimpleLineRangeMapping } from '../../common/diff/linesDiffComputer.js';
 import { LineRange } from '../../common/core/lineRange.js';
@@ -105,6 +105,12 @@
             }
         });
     }
+    canComputeDirtyDiff(original, modified) {
+        return (canSyncModel(this._modelService, original) && canSyncModel(this._modelService, modified));
+    }
+    computeDirtyDiff(original, modified, ignoreTrimWhitespace) {
+        return this._workerManager.withWorker().then(client => client.computeDirtyDiff(original, modified, ignoreTrimWhitespace));
+    }
     computeMoreMinimalEdits(resource, edits, pretty = false) {
         if (isNonEmptyArray(edits)) {
             if (!canSyncModel(this._modelService, resource)) {
@@ -119,6 +125,24 @@
             return Promise.resolve(undefined);
         }
     }
+    computeHumanReadableDiff(resource, edits) {
+        if (isNonEmptyArray(edits)) {
+            if (!canSyncModel(this._modelService, resource)) {
+                return Promise.resolve(edits); // File too large
+            }
+            const sw = StopWatch.create();
+            const result = this._workerManager.withWorker().then(client => client.computeHumanReadableDiff(resource, edits, { ignoreTrimWhitespace: false, maxComputationTimeMs: 1000, computeMoves: false, })).catch((err) => {
+                onUnexpectedError(err);
+                // In case of an exception, fall back to computeMoreMinimalEdits
+                return this.computeMoreMinimalEdits(resource, edits, true);
+            });
+            result.finally(() => this._logService.trace('FORMAT#computeHumanReadableDiff', resource.toString(true), sw.elapsed()));
+            return result;
+        }
+        else {
+            return Promise.resolve(undefined);
+        }
+    }
     canNavigateValueSet(resource) {
         return (canSyncModel(this._modelService, resource));
     }
@@ -415,11 +439,21 @@
             return proxy.computeDiff(original.toString(), modified.toString(), options, algorithm);
         });
     }
+    computeDirtyDiff(original, modified, ignoreTrimWhitespace) {
+        return this._withSyncedResources([original, modified]).then(proxy => {
+            return proxy.computeDirtyDiff(original.toString(), modified.toString(), ignoreTrimWhitespace);
+        });
+    }
     computeMoreMinimalEdits(resource, edits, pretty) {
         return this._withSyncedResources([resource]).then(proxy => {
             return proxy.computeMoreMinimalEdits(resource.toString(), edits, pretty);
         });
     }
+    computeHumanReadableDiff(resource, edits, options) {
+        return this._withSyncedResources([resource]).then(proxy => {
+            return proxy.computeHumanReadableDiff(resource.toString(), edits, options);
+        });
+    }
     computeLinks(resource) {
         return this._withSyncedResources([resource]).then(proxy => {
             return proxy.computeLinks(resource.toString());
diff -urN -x '*.map' a/vs/editor/browser/services/openerService.js b/vs/editor/browser/services/openerService.js
--- a/vs/editor/browser/services/openerService.js	2023-09-05 08:43:04.402812640 +0000
+++ b/vs/editor/browser/services/openerService.js	2023-09-05 08:45:14.317196634 +0000
@@ -147,6 +147,21 @@
         const remove = this._openers.unshift(opener);
         return { dispose: remove };
     }
+    registerValidator(validator) {
+        const remove = this._validators.push(validator);
+        return { dispose: remove };
+    }
+    registerExternalUriResolver(resolver) {
+        const remove = this._resolvers.push(resolver);
+        return { dispose: remove };
+    }
+    setDefaultExternalOpener(externalOpener) {
+        this._defaultExternalOpener = externalOpener;
+    }
+    registerExternalOpener(opener) {
+        const remove = this._externalOpeners.push(opener);
+        return { dispose: remove };
+    }
     open(target, options) {
         var _a;
         return __awaiter(this, void 0, void 0, function* () {
diff -urN -x '*.map' a/vs/editor/browser/view/renderingContext.js b/vs/editor/browser/view/renderingContext.js
--- a/vs/editor/browser/view/renderingContext.js	2023-09-05 08:43:04.414812920 +0000
+++ b/vs/editor/browser/view/renderingContext.js	2023-09-05 08:45:14.321196692 +0000
@@ -44,6 +44,36 @@
     }
 }
 export class LineVisibleRanges {
+    /**
+     * Returns the element with the smallest `lineNumber`.
+     */
+    static firstLine(ranges) {
+        if (!ranges) {
+            return null;
+        }
+        let result = null;
+        for (const range of ranges) {
+            if (!result || range.lineNumber < result.lineNumber) {
+                result = range;
+            }
+        }
+        return result;
+    }
+    /**
+     * Returns the element with the largest `lineNumber`.
+     */
+    static lastLine(ranges) {
+        if (!ranges) {
+            return null;
+        }
+        let result = null;
+        for (const range of ranges) {
+            if (!result || range.lineNumber > result.lineNumber) {
+                result = range;
+            }
+        }
+        return result;
+    }
     constructor(outsideRenderedLine, lineNumber, ranges, 
     /**
      * Indicates if the requested range does not end in this line, but continues on the next line.
diff -urN -x '*.map' a/vs/editor/browser/view.js b/vs/editor/browser/view.js
--- a/vs/editor/browser/view.js	2023-09-05 08:43:04.414812920 +0000
+++ b/vs/editor/browser/view.js	2023-09-05 08:45:14.329196806 +0000
@@ -435,6 +435,9 @@
     isFocused() {
         return this._textAreaHandler.isFocused();
     }
+    refreshFocusState() {
+        this._textAreaHandler.refreshFocusState();
+    }
     setAriaOptions(options) {
         this._textAreaHandler.setAriaOptions(options);
     }
diff -urN -x '*.map' a/vs/editor/browser/viewParts/lines/viewLines.js b/vs/editor/browser/viewParts/lines/viewLines.js
--- a/vs/editor/browser/viewParts/lines/viewLines.js	2023-09-05 08:43:04.386812267 +0000
+++ b/vs/editor/browser/viewParts/lines/viewLines.js	2023-09-05 08:45:14.317196634 +0000
@@ -377,6 +377,10 @@
         }
         return new HorizontalPosition(visibleRanges.outsideRenderedLine, visibleRanges.ranges[0].left);
     }
+    // --- implementation
+    updateLineWidths() {
+        this._updateLineWidths(false);
+    }
     /**
      * Updates the max line width if it is fast to compute.
      * Returns true if all lines were taken into account.
diff -urN -x '*.map' a/vs/editor/browser/widget/codeEditorContributions.js b/vs/editor/browser/widget/codeEditorContributions.js
--- a/vs/editor/browser/widget/codeEditorContributions.js	2023-09-05 08:43:04.394812454 +0000
+++ b/vs/editor/browser/widget/codeEditorContributions.js	2023-09-05 08:45:14.325196749 +0000
@@ -78,6 +78,12 @@
         this._instantiateById(id);
         return this._instances.get(id) || null;
     }
+    /**
+     * used by tests
+     */
+    set(id, value) {
+        this._instances.set(id, value);
+    }
     onBeforeInteractionEvent() {
         // this method is called very often by the editor!
         this._instantiateSome(2 /* EditorContributionInstantiation.BeforeFirstInteraction */);
diff -urN -x '*.map' a/vs/editor/browser/widget/codeEditorWidget.js b/vs/editor/browser/widget/codeEditorWidget.js
--- a/vs/editor/browser/widget/codeEditorWidget.js	2023-09-05 08:43:04.394812454 +0000
+++ b/vs/editor/browser/widget/codeEditorWidget.js	2023-09-05 08:45:14.329196806 +0000
@@ -26,6 +26,7 @@
 import * as dom from '../../../base/browser/dom.js';
 import { onUnexpectedError } from '../../../base/common/errors.js';
 import { Emitter, createEventDeliveryQueue } from '../../../base/common/event.js';
+import { hash } from '../../../base/common/hash.js';
 import { Disposable, dispose } from '../../../base/common/lifecycle.js';
 import { Schemas } from '../../../base/common/network.js';
 import { EditorConfiguration } from '../config/editorConfiguration.js';
@@ -434,6 +435,14 @@
         const tabSize = this._modelData.model.getOptions().tabSize;
         return CursorColumns.visibleColumnFromColumn(this._modelData.model.getLineContent(position.lineNumber), position.column, tabSize) + 1;
     }
+    getStatusbarColumn(rawPosition) {
+        if (!this._modelData) {
+            return rawPosition.column;
+        }
+        const position = this._modelData.model.validatePosition(rawPosition);
+        const tabSize = this._modelData.model.getOptions().tabSize;
+        return CursorColumns.toStatusbarColumn(this._modelData.model.getLineContent(position.lineNumber), position.column, tabSize);
+    }
     getPosition() {
         if (!this._modelData) {
             return null;
@@ -704,6 +713,15 @@
         var _a;
         (_a = this._getViewModel()) === null || _a === void 0 ? void 0 : _a.visibleLinesStabilized();
     }
+    onVisible() {
+        var _a;
+        (_a = this._modelData) === null || _a === void 0 ? void 0 : _a.view.refreshFocusState();
+    }
+    onHide() {
+        var _a;
+        (_a = this._modelData) === null || _a === void 0 ? void 0 : _a.view.refreshFocusState();
+        this._focusTracker.refreshState();
+    }
     getContribution(id) {
         return this._contributions.get(id);
     }
@@ -935,6 +953,58 @@
             changeAccessor.deltaDecorations(decorationIds, []);
         });
     }
+    setDecorationsByType(description, decorationTypeKey, decorationOptions) {
+        const newDecorationsSubTypes = {};
+        const oldDecorationsSubTypes = this._decorationTypeSubtypes[decorationTypeKey] || {};
+        this._decorationTypeSubtypes[decorationTypeKey] = newDecorationsSubTypes;
+        const newModelDecorations = [];
+        for (const decorationOption of decorationOptions) {
+            let typeKey = decorationTypeKey;
+            if (decorationOption.renderOptions) {
+                // identify custom render options by a hash code over all keys and values
+                // For custom render options register a decoration type if necessary
+                const subType = hash(decorationOption.renderOptions).toString(16);
+                // The fact that `decorationTypeKey` appears in the typeKey has no influence
+                // it is just a mechanism to get predictable and unique keys (repeatable for the same options and unique across clients)
+                typeKey = decorationTypeKey + '-' + subType;
+                if (!oldDecorationsSubTypes[subType] && !newDecorationsSubTypes[subType]) {
+                    // decoration type did not exist before, register new one
+                    this._registerDecorationType(description, typeKey, decorationOption.renderOptions, decorationTypeKey);
+                }
+                newDecorationsSubTypes[subType] = true;
+            }
+            const opts = this._resolveDecorationOptions(typeKey, !!decorationOption.hoverMessage);
+            if (decorationOption.hoverMessage) {
+                opts.hoverMessage = decorationOption.hoverMessage;
+            }
+            newModelDecorations.push({ range: decorationOption.range, options: opts });
+        }
+        // remove decoration sub types that are no longer used, deregister decoration type if necessary
+        for (const subType in oldDecorationsSubTypes) {
+            if (!newDecorationsSubTypes[subType]) {
+                this._removeDecorationType(decorationTypeKey + '-' + subType);
+            }
+        }
+        // update all decorations
+        const oldDecorationsIds = this._decorationTypeKeysToIds[decorationTypeKey] || [];
+        this._decorationTypeKeysToIds[decorationTypeKey] = this.deltaDecorations(oldDecorationsIds, newModelDecorations);
+    }
+    setDecorationsByTypeFast(decorationTypeKey, ranges) {
+        // remove decoration sub types that are no longer used, deregister decoration type if necessary
+        const oldDecorationsSubTypes = this._decorationTypeSubtypes[decorationTypeKey] || {};
+        for (const subType in oldDecorationsSubTypes) {
+            this._removeDecorationType(decorationTypeKey + '-' + subType);
+        }
+        this._decorationTypeSubtypes[decorationTypeKey] = {};
+        const opts = ModelDecorationOptions.createDynamic(this._resolveDecorationOptions(decorationTypeKey, false));
+        const newModelDecorations = new Array(ranges.length);
+        for (let i = 0, len = ranges.length; i < len; i++) {
+            newModelDecorations[i] = { range: ranges[i], options: opts };
+        }
+        // update all decorations
+        const oldDecorationsIds = this._decorationTypeKeysToIds[decorationTypeKey] || [];
+        this._decorationTypeKeysToIds[decorationTypeKey] = this.deltaDecorations(oldDecorationsIds, newModelDecorations);
+    }
     removeDecorationsByType(decorationTypeKey) {
         // remove decorations for type and sub type
         const oldDecorationsIds = this._decorationTypeKeysToIds[decorationTypeKey];
@@ -1369,9 +1439,18 @@
         }
         return model;
     }
+    _registerDecorationType(description, key, options, parentTypeKey) {
+        this._codeEditorService.registerDecorationType(description, key, options, parentTypeKey, this);
+    }
     _removeDecorationType(key) {
         this._codeEditorService.removeDecorationType(key);
     }
+    _resolveDecorationOptions(typeKey, writable) {
+        return this._codeEditorService.resolveDecorationOptions(typeKey, writable);
+    }
+    getTelemetryData() {
+        return this._telemetryData;
+    }
     hasModel() {
         return (this._modelData !== null);
     }
@@ -1626,6 +1705,10 @@
     hasFocus() {
         return this._hasFocus;
     }
+    refreshState() {
+        var _a, _b;
+        (_b = (_a = this._domFocusTracker).refreshState) === null || _b === void 0 ? void 0 : _b.call(_a);
+    }
 }
 class EditorDecorationsCollection {
     get length() {
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditorWidget.js b/vs/editor/browser/widget/diffEditorWidget.js
--- a/vs/editor/browser/widget/diffEditorWidget.js	2023-09-05 08:43:04.398812547 +0000
+++ b/vs/editor/browser/widget/diffEditorWidget.js	2023-09-05 08:45:14.329196806 +0000
@@ -149,6 +149,7 @@
         this._onDidUpdateDiff = this._register(new Emitter());
         this.onDidUpdateDiff = this._onDidUpdateDiff.event;
         this._onDidContentSizeChange = this._register(new Emitter());
+        this.onDidContentSizeChange = this._onDidContentSizeChange.event;
         this._lastOriginalWarning = null;
         this._lastModifiedWarning = null;
         codeEditorService.willCreateDiffEditor();
@@ -266,6 +267,25 @@
         }
         this._codeEditorService.addDiffEditor(this);
     }
+    get ignoreTrimWhitespace() {
+        return this._options.ignoreTrimWhitespace;
+    }
+    get maxComputationTime() {
+        return this._options.maxComputationTime;
+    }
+    get renderSideBySide() {
+        return this._options.renderSideBySide;
+    }
+    getContentHeight() {
+        return this._modifiedEditor.getContentHeight();
+    }
+    getViewWidth() {
+        return this._elementSizeObserver.getWidth();
+    }
+    setBoundarySashes(sashes) {
+        this._boundarySashes = sashes;
+        this._strategy.setBoundarySashes(sashes);
+    }
     _setState(newState) {
         if (this._state === newState) {
             return;
@@ -279,6 +299,9 @@
             this._updatingDiffProgress = this._editorProgressService.show(true, 1000);
         }
     }
+    hasWidgetFocus() {
+        return dom.isAncestor(document.activeElement, this._domElement);
+    }
     accessibleDiffViewerNext() {
         this._reviewPane.next();
     }
@@ -552,6 +575,9 @@
         }
         return this._diffComputationResult.changes;
     }
+    getDiffComputationResult() {
+        return this._diffComputationResult;
+    }
     getOriginalEditor() {
         return this._originalEditor;
     }
@@ -657,6 +683,9 @@
     getVisibleColumnFromPosition(position) {
         return this._modifiedEditor.getVisibleColumnFromPosition(position);
     }
+    getStatusbarColumn(position) {
+        return this._modifiedEditor.getStatusbarColumn(position);
+    }
     getPosition() {
         return this._modifiedEditor.getPosition();
     }
@@ -766,6 +795,20 @@
     hasTextFocus() {
         return this._originalEditor.hasTextFocus() || this._modifiedEditor.hasTextFocus();
     }
+    onVisible() {
+        this._isVisible = true;
+        this._originalEditor.onVisible();
+        this._modifiedEditor.onVisible();
+        // Begin comparing
+        this._beginUpdateDecorations();
+    }
+    onHide() {
+        this._isVisible = false;
+        this._originalEditor.onHide();
+        this._modifiedEditor.onHide();
+        // Remove all view zones & decorations
+        this._cleanViewZonesAndDecorations();
+    }
     //------------ end IDiffEditor methods
     //------------ begin layouting methods
     _onDidContainerSizeChanged() {
@@ -1109,6 +1152,21 @@
         // Just do a layout, the strategy might need it
         this._doLayout();
     }
+    goToDiff(target) {
+        var _a, _b;
+        if (target === 'next') {
+            (_a = this._diffNavigator) === null || _a === void 0 ? void 0 : _a.next();
+        }
+        else {
+            (_b = this._diffNavigator) === null || _b === void 0 ? void 0 : _b.previous();
+        }
+    }
+    revealFirstDiff() {
+        // This is a hack, but it works.
+        if (this._diffNavigator) {
+            this._diffNavigator.revealFirst = true;
+        }
+    }
 };
 DiffEditorWidget.ONE_OVERVIEW_WIDTH = 15;
 DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH = 30;
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditorWidget2/delegatingEditorImpl.js b/vs/editor/browser/widget/diffEditorWidget2/delegatingEditorImpl.js
--- a/vs/editor/browser/widget/diffEditorWidget2/delegatingEditorImpl.js	2023-09-05 08:43:04.390812361 +0000
+++ b/vs/editor/browser/widget/diffEditorWidget2/delegatingEditorImpl.js	2023-09-05 08:45:14.329196806 +0000
@@ -17,6 +17,9 @@
     getVisibleColumnFromPosition(position) {
         return this._targetEditor.getVisibleColumnFromPosition(position);
     }
+    getStatusbarColumn(position) {
+        return this._targetEditor.getStatusbarColumn(position);
+    }
     getPosition() {
         return this._targetEditor.getPosition();
     }
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditorWidget2/diffEditorEditors.js b/vs/editor/browser/widget/diffEditorWidget2/diffEditorEditors.js
--- a/vs/editor/browser/widget/diffEditorWidget2/diffEditorEditors.js	2023-09-05 08:43:04.390812361 +0000
+++ b/vs/editor/browser/widget/diffEditorWidget2/diffEditorEditors.js	2023-09-05 08:45:14.329196806 +0000
@@ -20,6 +20,7 @@
 import { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';
 import { IKeybindingService } from '../../../../platform/keybinding/common/keybinding.js';
 let DiffEditorEditors = class DiffEditorEditors extends Disposable {
+    get onDidContentSizeChange() { return this._onDidContentSizeChange.event; }
     constructor(originalEditorElement, modifiedEditorElement, _options, codeEditorWidgetOptions, _createInnerEditor, _instantiationService, _keybindingService) {
         super();
         this.originalEditorElement = originalEditorElement;
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditorWidget2/diffEditorWidget2.js b/vs/editor/browser/widget/diffEditorWidget2/diffEditorWidget2.js
--- a/vs/editor/browser/widget/diffEditorWidget2/diffEditorWidget2.js	2023-09-05 08:43:04.390812361 +0000
+++ b/vs/editor/browser/widget/diffEditorWidget2/diffEditorWidget2.js	2023-09-05 08:45:14.329196806 +0000
@@ -7,11 +7,21 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
 /*---------------------------------------------------------------------------------------------
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import { $, h } from '../../../../base/browser/dom.js';
+import { findLast } from '../../../../base/common/arrays.js';
 import { onUnexpectedError } from '../../../../base/common/errors.js';
 import { Event } from '../../../../base/common/event.js';
 import { autorun, derived, keepAlive, observableValue } from '../../../../base/common/observable.js';
@@ -30,6 +40,7 @@
 import { UnchangedRangesFeature } from './unchangedRanges.js';
 import { ObservableElementSizeObserver, applyStyle, readHotReloadableExport } from './utils.js';
 import { WorkerBasedDocumentDiffProvider } from '../workerBasedDocumentDiffProvider.js';
+import { Position } from '../../../common/core/position.js';
 import { EditorType } from '../../../common/editorCommon.js';
 import { EditorContextKeys } from '../../../common/editorContextKeys.js';
 import { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';
@@ -41,8 +52,11 @@
 import { DiffEditorViewModel } from './diffEditorViewModel.js';
 import { AccessibleDiffViewer } from './accessibleDiffViewer.js';
 import { AudioCue, IAudioCueService } from '../../../../platform/audioCues/browser/audioCueService.js';
+import { LengthObj } from '../../../common/model/bracketPairsTextModelPart/bracketPairsTree/length.js';
+import { Range } from '../../../common/core/range.js';
 import './colors.js';
 let DiffEditorWidget2 = class DiffEditorWidget2 extends DelegatingEditor {
+    get onDidContentSizeChange() { return this._editors.onDidContentSizeChange; }
     constructor(_domElement, options, codeEditorWidgetOptions, _parentContextKeyService, _parentInstantiationService, codeEditorService, _audioCueService) {
         var _a;
         super();
@@ -206,6 +220,9 @@
             }
         }));
     }
+    getContentHeight() {
+        return this._editors.modified.getContentHeight();
+    }
     _createInnerEditor(instantiationService, container, options, editorWidgetOptions) {
         const editor = instantiationService.createInstance(CodeEditorWidget, container, options, editorWidgetOptions);
         return editor;
@@ -223,6 +240,15 @@
     }
     get _targetEditor() { return this._editors.modified; }
     getEditorType() { return EditorType.IDiffEditor; }
+    onVisible() {
+        // TODO: Only compute diffs when diff editor is visible
+        this._editors.original.onVisible();
+        this._editors.modified.onVisible();
+    }
+    onHide() {
+        this._editors.original.onHide();
+        this._editors.modified.onHide();
+    }
     layout(dimension) { this._rootSizeObserver.observe(dimension); }
     hasTextFocus() { return this._editors.original.hasTextFocus() || this._editors.modified.hasTextFocus(); }
     saveViewState() {
@@ -273,6 +299,12 @@
     getContainerDomNode() { return this._domElement; }
     getOriginalEditor() { return this._editors.original; }
     getModifiedEditor() { return this._editors.modified; }
+    setBoundarySashes(sashes) {
+        this._boundarySashes.set(sashes, undefined);
+    }
+    get ignoreTrimWhitespace() { return this._options.ignoreTrimWhitespace.get(); }
+    get maxComputationTime() { return this._options.maxComputationTimeMs.get(); }
+    get renderSideBySide() { return this._options.renderSideBySide.get(); }
     /**
      * @deprecated Use `this.getDiffComputationResult().changes2` instead.
      */
@@ -284,6 +316,19 @@
         }
         return toLineChanges(diffState);
     }
+    getDiffComputationResult() {
+        var _a;
+        const diffState = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.diff.get();
+        if (!diffState) {
+            return null;
+        }
+        return {
+            changes: this.getLineChanges(),
+            changes2: diffState.mappings.map(m => m.lineRangeMapping),
+            identical: diffState.identical,
+            quitEarly: diffState.quitEarly,
+        };
+    }
     revert(diff) {
         var _a;
         const model = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.model;
@@ -303,8 +348,78 @@
             ];
         this._editors.modified.executeEdits('diffEditor', changes);
     }
+    _goTo(diff) {
+        this._editors.modified.setPosition(new Position(diff.lineRangeMapping.modifiedRange.startLineNumber, 1));
+        this._editors.modified.revealRangeInCenter(diff.lineRangeMapping.modifiedRange.toExclusiveRange());
+    }
+    goToDiff(target) {
+        var _a, _b, _c, _d;
+        const diffs = (_b = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.diff.get()) === null || _b === void 0 ? void 0 : _b.mappings;
+        if (!diffs || diffs.length === 0) {
+            return;
+        }
+        const curLineNumber = this._editors.modified.getPosition().lineNumber;
+        let diff;
+        if (target === 'next') {
+            diff = (_c = diffs.find(d => d.lineRangeMapping.modifiedRange.startLineNumber > curLineNumber)) !== null && _c !== void 0 ? _c : diffs[0];
+        }
+        else {
+            diff = (_d = findLast(diffs, d => d.lineRangeMapping.modifiedRange.startLineNumber < curLineNumber)) !== null && _d !== void 0 ? _d : diffs[diffs.length - 1];
+        }
+        this._goTo(diff);
+        if (diff.lineRangeMapping.modifiedRange.isEmpty) {
+            this._audioCueService.playAudioCue(AudioCue.diffLineDeleted);
+        }
+        else if (diff.lineRangeMapping.originalRange.isEmpty) {
+            this._audioCueService.playAudioCue(AudioCue.diffLineInserted);
+        }
+        else if (diff) {
+            this._audioCueService.playAudioCue(AudioCue.diffLineModified);
+        }
+    }
+    revealFirstDiff() {
+        const diffModel = this._diffModel.get();
+        if (!diffModel) {
+            return;
+        }
+        // wait for the diff computation to finish
+        this.waitForDiff().then(() => {
+            var _a;
+            const diffs = (_a = diffModel.diff.get()) === null || _a === void 0 ? void 0 : _a.mappings;
+            if (!diffs || diffs.length === 0) {
+                return;
+            }
+            this._goTo(diffs[0]);
+        });
+    }
     accessibleDiffViewerNext() { this._accessibleDiffViewer.next(); }
     accessibleDiffViewerPrev() { this._accessibleDiffViewer.prev(); }
+    waitForDiff() {
+        return __awaiter(this, void 0, void 0, function* () {
+            const diffModel = this._diffModel.get();
+            if (!diffModel) {
+                return;
+            }
+            yield diffModel.waitForDiff();
+        });
+    }
+    switchSide() {
+        var _a, _b;
+        const isModifiedFocus = this._editors.modified.hasWidgetFocus();
+        const source = isModifiedFocus ? this._editors.modified : this._editors.original;
+        const destination = isModifiedFocus ? this._editors.original : this._editors.modified;
+        const sourceSelection = source.getSelection();
+        if (sourceSelection) {
+            const mappings = (_b = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.diff.get()) === null || _b === void 0 ? void 0 : _b.mappings.map(m => isModifiedFocus ? m.lineRangeMapping.flip() : m.lineRangeMapping);
+            if (mappings) {
+                const newRange1 = translatePosition(sourceSelection.getStartPosition(), mappings);
+                const newRange2 = translatePosition(sourceSelection.getEndPosition(), mappings);
+                const range = Range.plusRange(newRange1, newRange2);
+                destination.setSelection(range);
+            }
+        }
+        destination.focus();
+    }
 };
 DiffEditorWidget2 = __decorate([
     __param(3, IContextKeyService),
@@ -313,6 +428,49 @@
     __param(6, IAudioCueService)
 ], DiffEditorWidget2);
 export { DiffEditorWidget2 };
+function translatePosition(posInOriginal, mappings) {
+    const mapping = findLast(mappings, m => m.originalRange.startLineNumber <= posInOriginal.lineNumber);
+    if (!mapping) {
+        // No changes before the position
+        return Range.fromPositions(posInOriginal);
+    }
+    if (mapping.originalRange.endLineNumberExclusive <= posInOriginal.lineNumber) {
+        const newLineNumber = posInOriginal.lineNumber - mapping.originalRange.endLineNumberExclusive + mapping.modifiedRange.endLineNumberExclusive;
+        return Range.fromPositions(new Position(newLineNumber, posInOriginal.column));
+    }
+    if (!mapping.innerChanges) {
+        // Only for legacy algorithm
+        return Range.fromPositions(new Position(mapping.modifiedRange.startLineNumber, 1));
+    }
+    const innerMapping = findLast(mapping.innerChanges, m => m.originalRange.getStartPosition().isBeforeOrEqual(posInOriginal));
+    if (!innerMapping) {
+        const newLineNumber = posInOriginal.lineNumber - mapping.originalRange.startLineNumber + mapping.modifiedRange.startLineNumber;
+        return Range.fromPositions(new Position(newLineNumber, posInOriginal.column));
+    }
+    if (innerMapping.originalRange.containsPosition(posInOriginal)) {
+        return innerMapping.modifiedRange;
+    }
+    else {
+        const l = lengthBetweenPositions(innerMapping.originalRange.getEndPosition(), posInOriginal);
+        return Range.fromPositions(addLength(innerMapping.modifiedRange.getEndPosition(), l));
+    }
+}
+function lengthBetweenPositions(position1, position2) {
+    if (position1.lineNumber === position2.lineNumber) {
+        return new LengthObj(0, position2.column - position1.column);
+    }
+    else {
+        return new LengthObj(position2.lineNumber - position1.lineNumber, position2.column - 1);
+    }
+}
+function addLength(position, length) {
+    if (length.lineCount === 0) {
+        return new Position(position.lineNumber, position.column + length.columnCount);
+    }
+    else {
+        return new Position(position.lineNumber + length.lineCount, length.columnCount + 1);
+    }
+}
 function toLineChanges(state) {
     return state.mappings.map(x => {
         const m = x.lineRangeMapping;
diff -urN -x '*.map' a/vs/editor/browser/widget/diffEditorWidget2/utils.js b/vs/editor/browser/widget/diffEditorWidget2/utils.js
--- a/vs/editor/browser/widget/diffEditorWidget2/utils.js	2023-09-05 08:43:04.394812454 +0000
+++ b/vs/editor/browser/widget/diffEditorWidget2/utils.js	2023-09-05 08:45:14.329196806 +0000
@@ -3,7 +3,7 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';
-import { autorun, autorunHandleChanges, observableSignalFromEvent, observableValue, transaction } from '../../../../base/common/observable.js';
+import { autorun, autorunHandleChanges, observableFromEvent, observableSignalFromEvent, observableValue, transaction } from '../../../../base/common/observable.js';
 import { ElementSizeObserver } from '../../config/elementSizeObserver.js';
 export function joinCombine(arr1, arr2, keySelector, combine) {
     if (arr1.length === 0) {
@@ -65,6 +65,13 @@
         parent.removeChild(child);
     });
 }
+export function observableConfigValue(key, defaultValue, configurationService) {
+    return observableFromEvent((handleChange) => configurationService.onDidChangeConfiguration(e => {
+        if (e.affectsConfiguration(key)) {
+            handleChange(e);
+        }
+    }), () => { var _a; return (_a = configurationService.getValue(key)) !== null && _a !== void 0 ? _a : defaultValue; });
+}
 export class ObservableElementSizeObserver extends Disposable {
     get width() { return this._width; }
     get height() { return this._height; }
@@ -132,6 +139,22 @@
 function easeOutExpo(t, b, c, d) {
     return t === d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
 }
+export function deepMerge(source1, source2) {
+    const result = {};
+    for (const key in source1) {
+        result[key] = source1[key];
+    }
+    for (const key in source2) {
+        const source2Value = source2[key];
+        if (typeof result[key] === 'object' && source2Value && typeof source2Value === 'object') {
+            result[key] = deepMerge(result[key], source2Value);
+        }
+        else {
+            result[key] = source2Value;
+        }
+    }
+    return result;
+}
 export class ViewZoneOverlayWidget extends Disposable {
     constructor(editor, viewZone, htmlElement) {
         super();
diff -urN -x '*.map' a/vs/editor/browser/widget/diffNavigator.js b/vs/editor/browser/widget/diffNavigator.js
--- a/vs/editor/browser/widget/diffNavigator.js	2023-09-05 08:43:04.398812547 +0000
+++ b/vs/editor/browser/widget/diffNavigator.js	2023-09-05 08:45:14.329196806 +0000
@@ -35,6 +35,7 @@
         this._codeEditorService = _codeEditorService;
         this._accessibilityService = _accessibilityService;
         this._onDidUpdate = this._register(new Emitter());
+        this.onDidUpdate = this._onDidUpdate.event;
         this._editor = editor;
         this._options = objects.mixin(options, defaultOptions, false);
         this.disposed = false;
diff -urN -x '*.map' a/vs/editor/browser/widget/embeddedCodeEditorWidget.js b/vs/editor/browser/widget/embeddedCodeEditorWidget.js
--- a/vs/editor/browser/widget/embeddedCodeEditorWidget.js	2023-09-05 08:43:04.398812547 +0000
+++ b/vs/editor/browser/widget/embeddedCodeEditorWidget.js	2023-09-05 08:45:14.325196749 +0000
@@ -14,14 +14,20 @@
 import * as objects from '../../../base/common/objects.js';
 import { ICodeEditorService } from '../services/codeEditorService.js';
 import { CodeEditorWidget } from './codeEditorWidget.js';
+import { DiffEditorWidget } from './diffEditorWidget.js';
 import { ICommandService } from '../../../platform/commands/common/commands.js';
 import { IContextKeyService } from '../../../platform/contextkey/common/contextkey.js';
 import { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';
 import { INotificationService } from '../../../platform/notification/common/notification.js';
 import { IThemeService } from '../../../platform/theme/common/themeService.js';
 import { IAccessibilityService } from '../../../platform/accessibility/common/accessibility.js';
+import { IContextMenuService } from '../../../platform/contextview/browser/contextView.js';
+import { IClipboardService } from '../../../platform/clipboard/common/clipboardService.js';
+import { IEditorProgressService } from '../../../platform/progress/common/progress.js';
 import { ILanguageConfigurationService } from '../../common/languages/languageConfigurationRegistry.js';
 import { ILanguageFeaturesService } from '../../common/services/languageFeatures.js';
+import { DiffEditorWidget2 } from './diffEditorWidget2/diffEditorWidget2.js';
+import { IAudioCueService } from '../../../platform/audioCues/browser/audioCueService.js';
 let EmbeddedCodeEditorWidget = class EmbeddedCodeEditorWidget extends CodeEditorWidget {
     constructor(domElement, options, codeEditorWidgetOptions, parentEditor, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService) {
         super(domElement, Object.assign(Object.assign({}, parentEditor.getRawOptions()), { overflowWidgetsDomNode: parentEditor.getOverflowWidgetsDomNode() }), codeEditorWidgetOptions, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService);
@@ -55,3 +61,69 @@
     __param(12, ILanguageFeaturesService)
 ], EmbeddedCodeEditorWidget);
 export { EmbeddedCodeEditorWidget };
+/**
+ * @deprecated Use EmbeddedDiffEditorWidget2 instead.
+ */
+let EmbeddedDiffEditorWidget = class EmbeddedDiffEditorWidget extends DiffEditorWidget {
+    constructor(domElement, options, codeEditorWidgetOptions, parentEditor, contextKeyService, instantiationService, codeEditorService, themeService, notificationService, contextMenuService, clipboardService, editorProgressService) {
+        super(domElement, parentEditor.getRawOptions(), codeEditorWidgetOptions, clipboardService, contextKeyService, instantiationService, codeEditorService, themeService, notificationService, contextMenuService, editorProgressService);
+        this._parentEditor = parentEditor;
+        this._overwriteOptions = options;
+        // Overwrite parent's options
+        super.updateOptions(this._overwriteOptions);
+        this._register(parentEditor.onDidChangeConfiguration(e => this._onParentConfigurationChanged(e)));
+    }
+    getParentEditor() {
+        return this._parentEditor;
+    }
+    _onParentConfigurationChanged(e) {
+        super.updateOptions(this._parentEditor.getRawOptions());
+        super.updateOptions(this._overwriteOptions);
+    }
+    updateOptions(newOptions) {
+        objects.mixin(this._overwriteOptions, newOptions, true);
+        super.updateOptions(this._overwriteOptions);
+    }
+};
+EmbeddedDiffEditorWidget = __decorate([
+    __param(4, IContextKeyService),
+    __param(5, IInstantiationService),
+    __param(6, ICodeEditorService),
+    __param(7, IThemeService),
+    __param(8, INotificationService),
+    __param(9, IContextMenuService),
+    __param(10, IClipboardService),
+    __param(11, IEditorProgressService)
+], EmbeddedDiffEditorWidget);
+export { EmbeddedDiffEditorWidget };
+/**
+ * TODO: Rename to EmbeddedDiffEditorWidget once EmbeddedDiffEditorWidget is removed.
+ */
+let EmbeddedDiffEditorWidget2 = class EmbeddedDiffEditorWidget2 extends DiffEditorWidget2 {
+    constructor(domElement, options, codeEditorWidgetOptions, parentEditor, contextKeyService, instantiationService, codeEditorService, audioCueService) {
+        super(domElement, parentEditor.getRawOptions(), codeEditorWidgetOptions, contextKeyService, instantiationService, codeEditorService, audioCueService);
+        this._parentEditor = parentEditor;
+        this._overwriteOptions = options;
+        // Overwrite parent's options
+        super.updateOptions(this._overwriteOptions);
+        this._register(parentEditor.onDidChangeConfiguration(e => this._onParentConfigurationChanged(e)));
+    }
+    getParentEditor() {
+        return this._parentEditor;
+    }
+    _onParentConfigurationChanged(e) {
+        super.updateOptions(this._parentEditor.getRawOptions());
+        super.updateOptions(this._overwriteOptions);
+    }
+    updateOptions(newOptions) {
+        objects.mixin(this._overwriteOptions, newOptions, true);
+        super.updateOptions(this._overwriteOptions);
+    }
+};
+EmbeddedDiffEditorWidget2 = __decorate([
+    __param(4, IContextKeyService),
+    __param(5, IInstantiationService),
+    __param(6, ICodeEditorService),
+    __param(7, IAudioCueService)
+], EmbeddedDiffEditorWidget2);
+export { EmbeddedDiffEditorWidget2 };
diff -urN -x '*.map' a/vs/editor/common/config/editorOptions.js b/vs/editor/common/config/editorOptions.js
--- a/vs/editor/common/config/editorOptions.js	2023-09-05 08:43:04.470814226 +0000
+++ b/vs/editor/common/config/editorOptions.js	2023-09-05 08:45:14.353197150 +0000
@@ -402,6 +402,19 @@
      */
     TextEditorCursorStyle[TextEditorCursorStyle["UnderlineThin"] = 6] = "UnderlineThin";
 })(TextEditorCursorStyle || (TextEditorCursorStyle = {}));
+/**
+ * @internal
+ */
+export function cursorStyleToString(cursorStyle) {
+    switch (cursorStyle) {
+        case TextEditorCursorStyle.Line: return 'line';
+        case TextEditorCursorStyle.Block: return 'block';
+        case TextEditorCursorStyle.Underline: return 'underline';
+        case TextEditorCursorStyle.LineThin: return 'line-thin';
+        case TextEditorCursorStyle.BlockOutline: return 'block-outline';
+        case TextEditorCursorStyle.UnderlineThin: return 'underline-thin';
+    }
+}
 function _cursorStyleFromString(cursorStyle) {
     switch (cursorStyle) {
         case 'line': return TextEditorCursorStyle.Line;
diff -urN -x '*.map' a/vs/editor/common/config/fontInfo.js b/vs/editor/common/config/fontInfo.js
--- a/vs/editor/common/config/fontInfo.js	2023-09-05 08:43:04.470814226 +0000
+++ b/vs/editor/common/config/fontInfo.js	2023-09-05 08:45:14.353197150 +0000
@@ -3,7 +3,7 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import * as platform from '../../../base/common/platform.js';
-import { EditorFontVariations, EDITOR_FONT_DEFAULTS } from './editorOptions.js';
+import { EditorFontVariations, EditorOptions, EDITOR_FONT_DEFAULTS } from './editorOptions.js';
 import { EditorZoom } from './editorZoom.js';
 /**
  * Determined from empirical observations.
@@ -29,6 +29,19 @@
         return BareFontInfo._create(fontFamily, fontWeight, fontSize, fontFeatureSettings, fontVariationSettings, lineHeight, letterSpacing, pixelRatio, ignoreEditorZoom);
     }
     /**
+     * @internal
+     */
+    static createFromRawSettings(opts, pixelRatio, ignoreEditorZoom = false) {
+        const fontFamily = EditorOptions.fontFamily.validate(opts.fontFamily);
+        const fontWeight = EditorOptions.fontWeight.validate(opts.fontWeight);
+        const fontSize = EditorOptions.fontSize.validate(opts.fontSize);
+        const fontFeatureSettings = EditorOptions.fontLigatures2.validate(opts.fontLigatures);
+        const fontVariationSettings = EditorOptions.fontVariations.validate(opts.fontVariations);
+        const lineHeight = EditorOptions.lineHeight.validate(opts.lineHeight);
+        const letterSpacing = EditorOptions.letterSpacing.validate(opts.letterSpacing);
+        return BareFontInfo._create(fontFamily, fontWeight, fontSize, fontFeatureSettings, fontVariationSettings, lineHeight, letterSpacing, pixelRatio, ignoreEditorZoom);
+    }
+    /**
      * @internal
      */
     static _create(fontFamily, fontWeight, fontSize, fontFeatureSettings, fontVariationSettings, lineHeight, letterSpacing, pixelRatio, ignoreEditorZoom) {
diff -urN -x '*.map' a/vs/editor/common/core/cursorColumns.js b/vs/editor/common/core/cursorColumns.js
--- a/vs/editor/common/core/cursorColumns.js	2023-09-05 08:43:04.446813666 +0000
+++ b/vs/editor/common/core/cursorColumns.js	2023-09-05 08:45:14.345197036 +0000
@@ -46,6 +46,25 @@
         return result;
     }
     /**
+     * Returns the value to display as "Col" in the status bar.
+     * @see {@link CursorColumns}
+     */
+    static toStatusbarColumn(lineContent, column, tabSize) {
+        const text = lineContent.substring(0, Math.min(column - 1, lineContent.length));
+        const iterator = new strings.CodePointIterator(text);
+        let result = 0;
+        while (!iterator.eol()) {
+            const codePoint = iterator.nextCodePoint();
+            if (codePoint === 9 /* CharCode.Tab */) {
+                result = CursorColumns.nextRenderTabStop(result, tabSize);
+            }
+            else {
+                result = result + 1;
+            }
+        }
+        return result + 1;
+    }
+    /**
      * Returns a column from a visible column.
      * @see {@link CursorColumns}
      */
diff -urN -x '*.map' a/vs/editor/common/core/wordHelper.js b/vs/editor/common/core/wordHelper.js
--- a/vs/editor/common/core/wordHelper.js	2023-09-05 08:43:04.450813760 +0000
+++ b/vs/editor/common/core/wordHelper.js	2023-09-05 08:45:14.345197036 +0000
@@ -3,6 +3,7 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import { Iterable } from '../../../base/common/iterator.js';
+import { toDisposable } from '../../../base/common/lifecycle.js';
 import { LinkedList } from '../../../base/common/linkedList.js';
 export const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\|;:\'",.<>/?';
 /**
@@ -54,6 +55,10 @@
     windowSize: 15,
     timeBudget: 150
 });
+export function setDefaultGetWordAtTextConfig(value) {
+    const rm = _defaultConfig.unshift(value);
+    return toDisposable(rm);
+}
 export function getWordAtText(column, wordDefinition, text, textOffset, config) {
     if (!config) {
         config = Iterable.first(_defaultConfig);
diff -urN -x '*.map' a/vs/editor/common/cursor/cursor.js b/vs/editor/common/cursor/cursor.js
--- a/vs/editor/common/cursor/cursor.js	2023-09-05 08:43:04.450813760 +0000
+++ b/vs/editor/common/cursor/cursor.js	2023-09-05 08:45:14.345197036 +0000
@@ -235,6 +235,9 @@
     getSelections() {
         return this._cursors.getSelections();
     }
+    getPosition() {
+        return this._cursors.getPrimaryCursor().modelState.position;
+    }
     setSelections(eventsCollector, source, selections, reason) {
         this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));
     }
diff -urN -x '*.map' a/vs/editor/common/diff/algorithms/diffAlgorithm.js b/vs/editor/common/diff/algorithms/diffAlgorithm.js
--- a/vs/editor/common/diff/algorithms/diffAlgorithm.js	2023-09-05 08:43:04.454813853 +0000
+++ b/vs/editor/common/diff/algorithms/diffAlgorithm.js	2023-09-05 08:45:14.341196978 +0000
@@ -67,4 +67,9 @@
         }
         return this.valid;
     }
+    disable() {
+        this.timeout = Number.MAX_SAFE_INTEGER;
+        this.isValid = () => true;
+        this.valid = true;
+    }
 }
diff -urN -x '*.map' a/vs/editor/common/editorCommon.js b/vs/editor/common/editorCommon.js
--- a/vs/editor/common/editorCommon.js	2023-09-05 08:43:04.466814133 +0000
+++ b/vs/editor/common/editorCommon.js	2023-09-05 08:45:14.337196921 +0000
@@ -3,6 +3,12 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 /**
+ * @internal
+ */
+export function isThemeColor(o) {
+    return o && typeof o.id === 'string';
+}
+/**
  * The type of the `IEditor`.
  */
 export const EditorType = {
diff -urN -x '*.map' a/vs/editor/common/languages/supports/characterPair.js b/vs/editor/common/languages/supports/characterPair.js
--- a/vs/editor/common/languages/supports/characterPair.js	2023-09-05 08:43:04.438813480 +0000
+++ b/vs/editor/common/languages/supports/characterPair.js	2023-09-05 08:45:14.337196921 +0000
@@ -35,3 +35,4 @@
 }
 CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = ';:.,=}])> \n\t';
 CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = '\'"`;:.,=}])> \n\t';
+CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_WHITESPACE = ' \n\t';
diff -urN -x '*.map' a/vs/editor/common/languages/supports/tokenization.js b/vs/editor/common/languages/supports/tokenization.js
--- a/vs/editor/common/languages/supports/tokenization.js	2023-09-05 08:43:04.442813573 +0000
+++ b/vs/editor/common/languages/supports/tokenization.js	2023-09-05 08:45:14.337196921 +0000
@@ -145,6 +145,12 @@
     getColorMap() {
         return this._colorMap.getColorMap();
     }
+    /**
+     * used for testing purposes
+     */
+    getThemeTrieElement() {
+        return this._root.toExternalThemeTrieElement();
+    }
     _match(token) {
         return this._root.match(token);
     }
@@ -217,12 +223,36 @@
             | (this._background << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;
     }
 }
+export class ExternalThemeTrieElement {
+    constructor(mainRule, children = new Map()) {
+        this.mainRule = mainRule;
+        if (children instanceof Map) {
+            this.children = children;
+        }
+        else {
+            this.children = new Map();
+            for (const key in children) {
+                this.children.set(key, children[key]);
+            }
+        }
+    }
+}
 export class ThemeTrieElement {
     constructor(mainRule) {
         this._themeTrieElementBrand = undefined;
         this._mainRule = mainRule;
         this._children = new Map();
     }
+    /**
+     * used for testing purposes
+     */
+    toExternalThemeTrieElement() {
+        const children = new Map();
+        this._children.forEach((element, index) => {
+            children.set(index, element.toExternalThemeTrieElement());
+        });
+        return new ExternalThemeTrieElement(this._mainRule, children);
+    }
     match(token) {
         if (token === '') {
             return this._mainRule;
diff -urN -x '*.map' a/vs/editor/common/languages/textToHtmlTokenizer.js b/vs/editor/common/languages/textToHtmlTokenizer.js
--- a/vs/editor/common/languages/textToHtmlTokenizer.js	2023-09-05 08:43:04.446813666 +0000
+++ b/vs/editor/common/languages/textToHtmlTokenizer.js	2023-09-05 08:45:14.341196978 +0000
@@ -19,6 +19,9 @@
     getInitialState: () => NullState,
     tokenizeEncoded: (buffer, hasEOL, state) => nullTokenizeEncoded(0 /* LanguageId.Null */, state)
 };
+export function tokenizeToStringSync(languageService, text, languageId) {
+    return _tokenizeToString(text, languageService.languageIdCodec, TokenizationRegistry.get(languageId) || fallback);
+}
 export function tokenizeToString(languageService, text, languageId) {
     return __awaiter(this, void 0, void 0, function* () {
         if (!languageId) {
diff -urN -x '*.map' a/vs/editor/common/languages.js b/vs/editor/common/languages.js
--- a/vs/editor/common/languages.js	2023-09-05 08:43:04.470814226 +0000
+++ b/vs/editor/common/languages.js	2023-09-05 08:45:14.353197150 +0000
@@ -1,5 +1,10 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
 import { Codicon } from '../../base/common/codicons.js';
 import { URI } from '../../base/common/uri.js';
+import { EditOperation } from './core/editOperation.js';
 import { Range } from './core/range.js';
 import { TokenizationRegistry as TokenizationRegistryImpl } from './tokenizationRegistry.js';
 import { localize } from '../../nls.js';
@@ -278,6 +283,9 @@
 })(SymbolKinds || (SymbolKinds = {}));
 /** @internal */
 export class TextEdit {
+    static asEditOperation(edit) {
+        return EditOperation.replace(Range.lift(edit.range), edit.text);
+    }
 }
 export class FoldingRangeKind {
     /**
@@ -332,6 +340,44 @@
     }
     Command.is = is;
 })(Command || (Command = {}));
+/**
+ * @internal
+ */
+export var CommentThreadCollapsibleState;
+(function (CommentThreadCollapsibleState) {
+    /**
+     * Determines an item is collapsed
+     */
+    CommentThreadCollapsibleState[CommentThreadCollapsibleState["Collapsed"] = 0] = "Collapsed";
+    /**
+     * Determines an item is expanded
+     */
+    CommentThreadCollapsibleState[CommentThreadCollapsibleState["Expanded"] = 1] = "Expanded";
+})(CommentThreadCollapsibleState || (CommentThreadCollapsibleState = {}));
+/**
+ * @internal
+ */
+export var CommentThreadState;
+(function (CommentThreadState) {
+    CommentThreadState[CommentThreadState["Unresolved"] = 0] = "Unresolved";
+    CommentThreadState[CommentThreadState["Resolved"] = 1] = "Resolved";
+})(CommentThreadState || (CommentThreadState = {}));
+/**
+ * @internal
+ */
+export var CommentMode;
+(function (CommentMode) {
+    CommentMode[CommentMode["Editing"] = 0] = "Editing";
+    CommentMode[CommentMode["Preview"] = 1] = "Preview";
+})(CommentMode || (CommentMode = {}));
+/**
+ * @internal
+ */
+export var CommentState;
+(function (CommentState) {
+    CommentState[CommentState["Published"] = 0] = "Published";
+    CommentState[CommentState["Draft"] = 1] = "Draft";
+})(CommentState || (CommentState = {}));
 export var InlayHintKind;
 (function (InlayHintKind) {
     InlayHintKind[InlayHintKind["Type"] = 1] = "Type";
@@ -365,3 +411,13 @@
  * @internal
  */
 export const TokenizationRegistry = new TokenizationRegistryImpl();
+/**
+ * @internal
+ */
+export var ExternalUriOpenerPriority;
+(function (ExternalUriOpenerPriority) {
+    ExternalUriOpenerPriority[ExternalUriOpenerPriority["None"] = 0] = "None";
+    ExternalUriOpenerPriority[ExternalUriOpenerPriority["Option"] = 1] = "Option";
+    ExternalUriOpenerPriority[ExternalUriOpenerPriority["Default"] = 2] = "Default";
+    ExternalUriOpenerPriority[ExternalUriOpenerPriority["Preferred"] = 3] = "Preferred";
+})(ExternalUriOpenerPriority || (ExternalUriOpenerPriority = {}));
diff -urN -x '*.map' a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js
--- a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js	2023-09-05 08:43:04.430813293 +0000
+++ b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js	2023-09-05 08:45:14.349197093 +0000
@@ -88,6 +88,9 @@
         }
         return true;
     }
+    flattenLists() {
+        return PairAstNode.create(this.openingBracket.flattenLists(), this.child && this.child.flattenLists(), this.closingBracket && this.closingBracket.flattenLists());
+    }
     deepClone() {
         return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);
     }
@@ -118,6 +121,22 @@
             ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)
             : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);
     }
+    static create(items, immutable = false) {
+        if (items.length === 0) {
+            return this.getEmpty();
+        }
+        else {
+            let length = items[0].length;
+            let unopenedBrackets = items[0].missingOpeningBracketIds;
+            for (let i = 1; i < items.length; i++) {
+                length = lengthAdd(length, items[i].length);
+                unopenedBrackets = unopenedBrackets.merge(items[i].missingOpeningBracketIds);
+            }
+            return immutable
+                ? new ImmutableArrayListAstNode(length, items[0].listHeight + 1, items, unopenedBrackets)
+                : new ArrayListAstNode(length, items[0].listHeight + 1, items, unopenedBrackets);
+        }
+    }
     static getEmpty() {
         return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());
     }
@@ -198,6 +217,19 @@
         this._missingOpeningBracketIds = unopenedBrackets;
         this.cachedMinIndentation = -1;
     }
+    flattenLists() {
+        const items = [];
+        for (const c of this.children) {
+            const normalized = c.flattenLists();
+            if (normalized.kind === 4 /* AstNodeKind.List */) {
+                items.push(...normalized.children);
+            }
+            else {
+                items.push(normalized);
+            }
+        }
+        return ListAstNode.create(items);
+    }
     computeMinIndentation(offset, textModel) {
         if (this.cachedMinIndentation !== -1) {
             return this.cachedMinIndentation;
@@ -395,6 +427,9 @@
     get children() {
         return emptyArray;
     }
+    flattenLists() {
+        return this;
+    }
     deepClone() {
         return this;
     }
diff -urN -x '*.map' a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js
--- a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js	2023-09-05 08:43:04.430813293 +0000
+++ b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js	2023-09-05 08:45:14.349197093 +0000
@@ -102,4 +102,8 @@
         }
         return singleLanguageBracketTokens;
     }
+    getToken(value, languageId) {
+        const singleLanguageBracketTokens = this.getSingleLanguageBracketTokens(languageId);
+        return singleLanguageBracketTokens.getToken(value);
+    }
 }
diff -urN -x '*.map' a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js
--- a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js	2023-09-05 08:43:04.430813293 +0000
+++ b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js	2023-09-05 08:45:14.349197093 +0000
@@ -10,13 +10,56 @@
  * Prefer using {@link Length} for performance reasons.
 */
 export class LengthObj {
+    static lengthDiffNonNegative(start, end) {
+        if (end.isLessThan(start)) {
+            return LengthObj.zero;
+        }
+        if (start.lineCount === end.lineCount) {
+            return new LengthObj(0, end.columnCount - start.columnCount);
+        }
+        else {
+            return new LengthObj(end.lineCount - start.lineCount, end.columnCount);
+        }
+    }
     constructor(lineCount, columnCount) {
         this.lineCount = lineCount;
         this.columnCount = columnCount;
     }
+    isZero() {
+        return this.lineCount === 0 && this.columnCount === 0;
+    }
     toLength() {
         return toLength(this.lineCount, this.columnCount);
     }
+    isLessThan(other) {
+        if (this.lineCount !== other.lineCount) {
+            return this.lineCount < other.lineCount;
+        }
+        return this.columnCount < other.columnCount;
+    }
+    isGreaterThan(other) {
+        if (this.lineCount !== other.lineCount) {
+            return this.lineCount > other.lineCount;
+        }
+        return this.columnCount > other.columnCount;
+    }
+    equals(other) {
+        return this.lineCount === other.lineCount && this.columnCount === other.columnCount;
+    }
+    compare(other) {
+        if (this.lineCount !== other.lineCount) {
+            return this.lineCount - other.lineCount;
+        }
+        return this.columnCount - other.columnCount;
+    }
+    add(other) {
+        if (other.lineCount === 0) {
+            return new LengthObj(this.lineCount, this.columnCount + other.columnCount);
+        }
+        else {
+            return new LengthObj(this.lineCount + other.lineCount, other.columnCount);
+        }
+    }
     toString() {
         return `${this.lineCount},${this.columnCount}`;
     }
@@ -137,7 +180,25 @@
         return new LengthObj(range.endLineNumber - range.startLineNumber, range.endColumn - 1);
     }
 }
+export function lengthCompare(length1, length2) {
+    const l1 = length1;
+    const l2 = length2;
+    return l1 - l2;
+}
 export function lengthOfString(str) {
     const lines = splitLines(str);
     return toLength(lines.length - 1, lines[lines.length - 1].length);
 }
+export function lengthOfStringObj(str) {
+    const lines = splitLines(str);
+    return new LengthObj(lines.length - 1, lines[lines.length - 1].length);
+}
+/**
+ * Computes a numeric hash of the given length.
+*/
+export function lengthHash(length) {
+    return length;
+}
+export function lengthMax(length1, length2) {
+    return length1 > length2 ? length1 : length2;
+}
diff -urN -x '*.map' a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js
--- a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js	2023-09-05 08:43:04.430813293 +0000
+++ b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js	2023-09-05 08:45:14.349197093 +0000
@@ -19,6 +19,18 @@
  * Non incrementally built ASTs are immutable.
 */
 class Parser {
+    /**
+     * Reports how many nodes were constructed in the last parse operation.
+    */
+    get nodesConstructed() {
+        return this._itemsConstructed;
+    }
+    /**
+     * Reports how many nodes were reused in the last parse operation.
+    */
+    get nodesReused() {
+        return this._itemsFromCache;
+    }
     constructor(tokenizer, edits, oldNode, createImmutableLists) {
         this.tokenizer = tokenizer;
         this.createImmutableLists = createImmutableLists;
diff -urN -x '*.map' a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js
--- a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js	2023-09-05 08:43:04.430813293 +0000
+++ b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js	2023-09-05 08:45:14.349197093 +0000
@@ -46,6 +46,16 @@
         newItems[idx] |= 1 << (key & 31);
         return SmallImmutableSet.create(this.items, newItems);
     }
+    has(value, keyProvider) {
+        const key = keyProvider.getKey(value);
+        let idx = key >> 5; // divided by 32
+        if (idx === 0) {
+            // fast path
+            return (this.items & (1 << key)) !== 0;
+        }
+        idx--;
+        return ((this.additionalItems[idx] || 0) & (1 << (key & 31))) !== 0;
+    }
     merge(other) {
         const merged = this.items | other.items;
         if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {
@@ -78,6 +88,20 @@
         }
         return false;
     }
+    equals(other) {
+        if (this.items !== other.items) {
+            return false;
+        }
+        if (this.additionalItems.length !== other.additionalItems.length) {
+            return false;
+        }
+        for (let i = 0; i < this.additionalItems.length; i++) {
+            if (this.additionalItems[i] !== other.additionalItems[i]) {
+                return false;
+            }
+        }
+        return true;
+    }
 }
 SmallImmutableSet.cache = new Array(129);
 SmallImmutableSet.empty = SmallImmutableSet.create(0, emptyArr);
@@ -101,4 +125,20 @@
         }
         return existing;
     }
+    reverseLookup(value) {
+        var _a;
+        return (_a = [...this.items].find(([_key, v]) => v === value)) === null || _a === void 0 ? void 0 : _a[0];
+    }
+    reverseLookupSet(set) {
+        const result = [];
+        for (const [key] of this.items) {
+            if (set.has(key, this)) {
+                result.push(key);
+            }
+        }
+        return result;
+    }
+    keys() {
+        return this.items.keys();
+    }
 }
diff -urN -x '*.map' a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js
--- a/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js	2023-09-05 08:43:04.434813386 +0000
+++ b/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js	2023-09-05 08:45:14.349197093 +0000
@@ -45,6 +45,9 @@
     get length() {
         return toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);
     }
+    getText() {
+        return this.textModel.getValue();
+    }
     skip(length) {
         this.didPeek = false;
         this._offset = lengthAdd(this._offset, length);
@@ -295,4 +298,7 @@
     skip(length) {
         throw new NotSupportedError();
     }
+    getText() {
+        return this.text;
+    }
 }
diff -urN -x '*.map' a/vs/editor/common/model/bracketPairsTextModelPart/fixBrackets.js b/vs/editor/common/model/bracketPairsTextModelPart/fixBrackets.js
--- a/vs/editor/common/model/bracketPairsTextModelPart/fixBrackets.js	2023-09-05 08:43:04.434813386 +0000
+++ b/vs/editor/common/model/bracketPairsTextModelPart/fixBrackets.js	2023-09-05 08:45:14.349197093 +0000
@@ -57,6 +57,9 @@
             }
         };
     }
+    getValue() {
+        return this.lines.map(l => l.getLineContent()).join('\n');
+    }
     getLineCount() {
         return this.lines.length;
     }
diff -urN -x '*.map' a/vs/editor/common/model/decorationProvider.js b/vs/editor/common/model/decorationProvider.js
--- a/vs/editor/common/model/decorationProvider.js	2023-09-05 08:43:04.434813386 +0000
+++ b/vs/editor/common/model/decorationProvider.js	2023-09-05 08:45:14.349197093 +0000
@@ -1 +1,5 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
 export {};
diff -urN -x '*.map' a/vs/editor/common/model/editStack.js b/vs/editor/common/model/editStack.js
--- a/vs/editor/common/model/editStack.js	2023-09-05 08:43:04.434813386 +0000
+++ b/vs/editor/common/model/editStack.js	2023-09-05 08:45:14.349197093 +0000
@@ -217,11 +217,23 @@
         }
         this._delegate = null;
     }
+    setDelegate(delegate) {
+        this._delegate = delegate;
+    }
     prepareUndoRedo() {
         if (this._delegate) {
             return this._delegate.prepareUndoRedo(this);
         }
     }
+    getMissingModels() {
+        const result = [];
+        for (const editStackElement of this._editStackElementsArr) {
+            if (URI.isUri(editStackElement.model)) {
+                result.push(editStackElement.model);
+            }
+        }
+        return result;
+    }
     matchesResource(resource) {
         const key = uriGetComparisonKey(resource);
         return (this._editStackElementsMap.has(key));
diff -urN -x '*.map' a/vs/editor/common/model/intervalTree.js b/vs/editor/common/model/intervalTree.js
--- a/vs/editor/common/model/intervalTree.js	2023-09-05 08:43:04.434813386 +0000
+++ b/vs/editor/common/model/intervalTree.js	2023-09-05 08:45:14.349197093 +0000
@@ -38,6 +38,9 @@
 function setCollapseOnReplaceEdit(node, value) {
     node.metadata = ((node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */));
 }
+export function setNodeStickiness(node, stickiness) {
+    _setNodeStickiness(node, stickiness);
+}
 export class IntervalNode {
     constructor(id, start, end) {
         this.metadata = 0;
@@ -175,6 +178,9 @@
         }
         this._normalizeDeltaIfNecessary();
     }
+    getAllInOrder() {
+        return search(this, 0, false, 0, false);
+    }
     _normalizeDeltaIfNecessary() {
         if (!this.requestNormalizeDelta) {
             return;
diff -urN -x '*.map' a/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js b/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js
--- a/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js	2023-09-05 08:43:04.434813386 +0000
+++ b/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js	2023-09-05 08:45:14.353197150 +0000
@@ -269,6 +269,28 @@
     createSnapshot(BOM) {
         return new PieceTreeSnapshot(this, BOM);
     }
+    equal(other) {
+        if (this.getLength() !== other.getLength()) {
+            return false;
+        }
+        if (this.getLineCount() !== other.getLineCount()) {
+            return false;
+        }
+        let offset = 0;
+        const ret = this.iterate(this.root, node => {
+            if (node === SENTINEL) {
+                return true;
+            }
+            const str = this.getNodeContent(node);
+            const len = str.length;
+            const startPosition = other.nodeAt(offset);
+            const endPosition = other.nodeAt(offset + len);
+            const val = other.getValueInRange2(startPosition, endPosition);
+            offset += len;
+            return str === val;
+        });
+        return ret;
+    }
     getOffsetAt(lineNumber, column) {
         let leftLen = 0; // inorder
         let x = this.root;
@@ -499,6 +521,10 @@
         }
         return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;
     }
+    getCharCode(offset) {
+        const nodePos = this.nodeAt(offset);
+        return this._getCharCode(nodePos);
+    }
     findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {
         const buffer = this._buffers[node.piece.bufferIndex];
         const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);
@@ -944,6 +970,9 @@
         this._lastChangeBufferPos = endPos;
         return [newPiece];
     }
+    getLinesRawContent() {
+        return this.getContentOfSubTree(this.root);
+    }
     getLineRawContent(lineNumber, endOffset = 0) {
         let x = this.root;
         let ret = '';
@@ -1449,4 +1478,12 @@
         fixInsert(this, z);
         return z;
     }
+    getContentOfSubTree(node) {
+        let str = '';
+        this.iterate(node, node => {
+            str += this.getNodeContent(node);
+            return true;
+        });
+        return str;
+    }
 }
diff -urN -x '*.map' a/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js b/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js
--- a/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js	2023-09-05 08:43:04.438813480 +0000
+++ b/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js	2023-09-05 08:45:14.353197150 +0000
@@ -14,12 +14,26 @@
     constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {
         super();
         this._onDidChangeContent = this._register(new Emitter());
+        this.onDidChangeContent = this._onDidChangeContent.event;
         this._BOM = BOM;
         this._mightContainNonBasicASCII = !isBasicASCII;
         this._mightContainRTL = containsRTL;
         this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;
         this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);
     }
+    // #region TextBuffer
+    equals(other) {
+        if (!(other instanceof PieceTreeTextBuffer)) {
+            return false;
+        }
+        if (this._BOM !== other._BOM) {
+            return false;
+        }
+        if (this.getEOL() !== other.getEOL()) {
+            return false;
+        }
+        return this._pieceTree.equal(other._pieceTree);
+    }
     mightContainRTL() {
         return this._mightContainRTL;
     }
@@ -121,9 +135,18 @@
     getLineCharCode(lineNumber, index) {
         return this._pieceTree.getLineCharCode(lineNumber, index);
     }
+    getCharCode(offset) {
+        return this._pieceTree.getCharCode(offset);
+    }
     getLineLength(lineNumber) {
         return this._pieceTree.getLineLength(lineNumber);
     }
+    getLineMinColumn(lineNumber) {
+        return 1;
+    }
+    getLineMaxColumn(lineNumber) {
+        return this.getLineLength(lineNumber) + 1;
+    }
     getLineFirstNonWhitespaceColumn(lineNumber) {
         const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));
         if (result === -1) {
@@ -388,6 +411,35 @@
     findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {
         return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
     }
+    // #endregion
+    // #region helper
+    // testing purpose.
+    getPieceTree() {
+        return this._pieceTree;
+    }
+    static _getInverseEditRange(range, text) {
+        const startLineNumber = range.startLineNumber;
+        const startColumn = range.startColumn;
+        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);
+        let resultRange;
+        if (text.length > 0) {
+            // the operation inserts something
+            const lineCount = eolCount + 1;
+            if (lineCount === 1) {
+                // single line insert
+                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + firstLineLength);
+            }
+            else {
+                // multi line insert
+                resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, lastLineLength + 1);
+            }
+        }
+        else {
+            // There is nothing to insert
+            resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);
+        }
+        return resultRange;
+    }
     /**
      * Assumes `operations` are validated and sorted ascending
      */
diff -urN -x '*.map' a/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js b/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js
--- a/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js	2023-09-05 08:43:04.438813480 +0000
+++ b/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js	2023-09-05 08:45:14.353197150 +0000
@@ -47,6 +47,9 @@
         const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);
         return { textBuffer: textBuffer, disposable: textBuffer };
     }
+    getFirstLineText(lengthLimit) {
+        return this._chunks[0].buffer.substr(0, lengthLimit).split(/\r\n|\r|\n/)[0];
+    }
 }
 export class PieceTreeTextBufferBuilder {
     constructor() {
diff -urN -x '*.map' a/vs/editor/common/model/prefixSumComputer.js b/vs/editor/common/model/prefixSumComputer.js
--- a/vs/editor/common/model/prefixSumComputer.js	2023-09-05 08:43:04.438813480 +0000
+++ b/vs/editor/common/model/prefixSumComputer.js	2023-09-05 08:45:14.349197093 +0000
@@ -11,6 +11,9 @@
         this.prefixSumValidIndex = new Int32Array(1);
         this.prefixSumValidIndex[0] = -1;
     }
+    getCount() {
+        return this.values.length;
+    }
     insertValues(insertIndex, insertValues) {
         insertIndex = toUint32(insertIndex);
         const oldValues = this.values;
diff -urN -x '*.map' a/vs/editor/common/model/textModel.js b/vs/editor/common/model/textModel.js
--- a/vs/editor/common/model/textModel.js	2023-09-05 08:43:04.438813480 +0000
+++ b/vs/editor/common/model/textModel.js	2023-09-05 08:45:14.349197093 +0000
@@ -16,6 +16,7 @@
 import { BugIndicatingError, illegalArgument, onUnexpectedError } from '../../../base/common/errors.js';
 import { Emitter } from '../../../base/common/event.js';
 import { Disposable, MutableDisposable, combinedDisposable } from '../../../base/common/lifecycle.js';
+import { listenStream } from '../../../base/common/stream.js';
 import * as strings from '../../../base/common/strings.js';
 import { URI } from '../../../base/common/uri.js';
 import { countEOL } from '../core/eolCounter.js';
@@ -45,6 +46,29 @@
     builder.acceptChunk(text);
     return builder.finish();
 }
+export function createTextBufferFactoryFromStream(stream) {
+    return new Promise((resolve, reject) => {
+        const builder = new PieceTreeTextBufferBuilder();
+        let done = false;
+        listenStream(stream, {
+            onData: chunk => {
+                builder.acceptChunk((typeof chunk === 'string') ? chunk : chunk.toString());
+            },
+            onError: error => {
+                if (!done) {
+                    done = true;
+                    reject(error);
+                }
+            },
+            onEnd: () => {
+                if (!done) {
+                    done = true;
+                    resolve(builder.finish());
+                }
+            }
+        });
+    });
+}
 export function createTextBufferFactoryFromSnapshot(snapshot) {
     const builder = new PieceTreeTextBufferBuilder();
     let chunk;
@@ -222,11 +246,28 @@
         this._buffer = emptyDisposedTextBuffer;
         this._bufferDisposable = Disposable.None;
     }
+    _hasListeners() {
+        return (this._onWillDispose.hasListeners()
+            || this._onDidChangeDecorations.hasListeners()
+            || this._tokenizationTextModelPart._hasListeners()
+            || this._onDidChangeOptions.hasListeners()
+            || this._onDidChangeAttached.hasListeners()
+            || this._onDidChangeInjectedText.hasListeners()
+            || this._eventEmitter.hasListeners());
+    }
     _assertNotDisposed() {
         if (this._isDisposed) {
             throw new Error('Model is disposed!');
         }
     }
+    equalsTextBuffer(other) {
+        this._assertNotDisposed();
+        return this._buffer.equals(other);
+    }
+    getTextBuffer() {
+        this._assertNotDisposed();
+        return this._buffer;
+    }
     _emitContentChangedEvent(rawChange, change) {
         if (this.__isDisposing) {
             // Do not confuse listeners by emitting any event after disposing
@@ -1769,6 +1810,9 @@
         this._affectsOverviewRuler = false;
         this._affectsGlyphMargin = false;
     }
+    hasListeners() {
+        return this._actual.hasListeners();
+    }
     beginDeferredEmit() {
         this._deferredCnt++;
     }
@@ -1843,6 +1887,10 @@
         this._deferredCnt = 0;
         this._deferredEvent = null;
     }
+    hasListeners() {
+        return (this._fastEmitter.hasListeners()
+            || this._slowEmitter.hasListeners());
+    }
     beginDeferredEmit() {
         this._deferredCnt++;
     }
diff -urN -x '*.map' a/vs/editor/common/model/textModelTokens.js b/vs/editor/common/model/textModelTokens.js
--- a/vs/editor/common/model/textModelTokens.js	2023-09-05 08:43:04.438813480 +0000
+++ b/vs/editor/common/model/textModelTokens.js	2023-09-05 08:45:14.349197093 +0000
@@ -240,17 +240,39 @@
         }
         this._lineEndStates.replace(range.startLineNumber, length, newLineCount);
     }
+    acceptChanges(changes) {
+        for (const c of changes) {
+            const [eolCount] = countEOL(c.text);
+            this.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);
+        }
+    }
 }
 export class RangePriorityQueueImpl {
     constructor() {
         this._ranges = [];
     }
+    getRanges() {
+        return this._ranges;
+    }
     get min() {
         if (this._ranges.length === 0) {
             return null;
         }
         return this._ranges[0].start;
     }
+    removeMin() {
+        if (this._ranges.length === 0) {
+            return null;
+        }
+        const range = this._ranges[0];
+        if (range.start + 1 === range.endExclusive) {
+            this._ranges.shift();
+        }
+        else {
+            this._ranges[0] = new OffsetRange(range.start + 1, range.endExclusive);
+        }
+        return range.start;
+    }
     delete(value) {
         const idx = this._ranges.findIndex(r => r.contains(value));
         if (idx !== -1) {
diff -urN -x '*.map' a/vs/editor/common/model/tokenizationTextModelPart.js b/vs/editor/common/model/tokenizationTextModelPart.js
--- a/vs/editor/common/model/tokenizationTextModelPart.js	2023-09-05 08:43:04.438813480 +0000
+++ b/vs/editor/common/model/tokenizationTextModelPart.js	2023-09-05 08:45:14.349197093 +0000
@@ -46,6 +46,11 @@
             this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();
         }));
     }
+    _hasListeners() {
+        return (this._onDidChangeLanguage.hasListeners()
+            || this._onDidChangeLanguageConfiguration.hasListeners()
+            || this._onDidChangeTokens.hasListeners());
+    }
     handleDidChangeContent(e) {
         if (e.isFlush) {
             this._semanticTokens.flush();
diff -urN -x '*.map' a/vs/editor/common/services/editorSimpleWorker.js b/vs/editor/common/services/editorSimpleWorker.js
--- a/vs/editor/common/services/editorSimpleWorker.js	2023-09-05 08:43:04.458813946 +0000
+++ b/vs/editor/common/services/editorSimpleWorker.js	2023-09-05 08:45:14.337196921 +0000
@@ -22,8 +22,10 @@
 import { createMonacoBaseAPI } from './editorBaseApi.js';
 import { StopWatch } from '../../../base/common/stopwatch.js';
 import { UnicodeTextModelHighlighter } from './unicodeTextModelHighlighter.js';
+import { DiffComputer } from '../diff/smartLinesDiffComputer.js';
 import { linesDiffComputers } from '../diff/linesDiffComputers.js';
 import { createProxyObject, getAllMethodNames } from '../../../base/common/objects.js';
+import { BugIndicatingError } from '../../../base/common/errors.js';
 import { computeDefaultDocumentColors } from '../languages/defaultDocumentColorsComputer.js';
 /**
  * @internal
@@ -69,6 +71,21 @@
         }
         return null;
     }
+    getWordUntilPosition(position, wordDefinition) {
+        const wordAtPosition = this.getWordAtPosition(position, wordDefinition);
+        if (!wordAtPosition) {
+            return {
+                word: '',
+                startColumn: position.column,
+                endColumn: position.column
+            };
+        }
+        return {
+            word: this._lines[position.lineNumber - 1].substring(wordAtPosition.startColumn - 1, position.column - 1),
+            startColumn: wordAtPosition.startColumn,
+            endColumn: position.column
+        };
+    }
     words(wordDefinition) {
         const lines = this._lines;
         const wordenize = this._wordenize.bind(this);
@@ -315,6 +332,25 @@
         }
         return true;
     }
+    computeDirtyDiff(originalUrl, modifiedUrl, ignoreTrimWhitespace) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const original = this._getModel(originalUrl);
+            const modified = this._getModel(modifiedUrl);
+            if (!original || !modified) {
+                return null;
+            }
+            const originalLines = original.getLinesContent();
+            const modifiedLines = modified.getLinesContent();
+            const diffComputer = new DiffComputer(originalLines, modifiedLines, {
+                shouldComputeCharChanges: false,
+                shouldPostProcessCharChanges: false,
+                shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,
+                shouldMakePrettyDiff: true,
+                maxComputationTime: 1000
+            });
+            return diffComputer.computeDiff().changes;
+        });
+    }
     computeMoreMinimalEdits(modelUrl, edits, pretty) {
         return __awaiter(this, void 0, void 0, function* () {
             const model = this._getModel(modelUrl);
@@ -366,6 +402,89 @@
                     }
                 }
             }
+            if (typeof lastEol === 'number') {
+                result.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });
+            }
+            return result;
+        });
+    }
+    computeHumanReadableDiff(modelUrl, edits, options) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const model = this._getModel(modelUrl);
+            if (!model) {
+                return edits;
+            }
+            const result = [];
+            let lastEol = undefined;
+            edits = edits.slice(0).sort((a, b) => {
+                if (a.range && b.range) {
+                    return Range.compareRangesUsingStarts(a.range, b.range);
+                }
+                // eol only changes should go to the end
+                const aRng = a.range ? 0 : 1;
+                const bRng = b.range ? 0 : 1;
+                return aRng - bRng;
+            });
+            for (let { range, text, eol } of edits) {
+                if (typeof eol === 'number') {
+                    lastEol = eol;
+                }
+                if (Range.isEmpty(range) && !text) {
+                    // empty change
+                    continue;
+                }
+                const original = model.getValueInRange(range);
+                text = text.replace(/\r\n|\n|\r/g, model.eol);
+                if (original === text) {
+                    // noop
+                    continue;
+                }
+                // make sure diff won't take too long
+                if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {
+                    result.push({ range, text });
+                    continue;
+                }
+                // compute diff between original and edit.text
+                const originalLines = original.split(/\r\n|\n|\r/);
+                const modifiedLines = text.split(/\r\n|\n|\r/);
+                const diff = linesDiffComputers.getAdvanced().computeDiff(originalLines, modifiedLines, options);
+                const start = Range.lift(range).getStartPosition();
+                function addPositions(pos1, pos2) {
+                    return new Position(pos1.lineNumber + pos2.lineNumber - 1, pos2.lineNumber === 1 ? pos1.column + pos2.column - 1 : pos2.column);
+                }
+                function getText(lines, range) {
+                    const result = [];
+                    for (let i = range.startLineNumber; i <= range.endLineNumber; i++) {
+                        const line = lines[i - 1];
+                        if (i === range.startLineNumber && i === range.endLineNumber) {
+                            result.push(line.substring(range.startColumn - 1, range.endColumn - 1));
+                        }
+                        else if (i === range.startLineNumber) {
+                            result.push(line.substring(range.startColumn - 1));
+                        }
+                        else if (i === range.endLineNumber) {
+                            result.push(line.substring(0, range.endColumn - 1));
+                        }
+                        else {
+                            result.push(line);
+                        }
+                    }
+                    return result;
+                }
+                for (const c of diff.changes) {
+                    if (c.innerChanges) {
+                        for (const x of c.innerChanges) {
+                            result.push({
+                                range: Range.fromPositions(addPositions(start, x.originalRange.getStartPosition()), addPositions(start, x.originalRange.getEndPosition())),
+                                text: getText(modifiedLines, x.modifiedRange).join(model.eol)
+                            });
+                        }
+                    }
+                    else {
+                        throw new BugIndicatingError('The experimental diff algorithm always produces inner changes');
+                    }
+                }
+            }
             if (typeof lastEol === 'number') {
                 result.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });
             }
diff -urN -x '*.map' a/vs/editor/common/services/getIconClasses.js b/vs/editor/common/services/getIconClasses.js
--- a/vs/editor/common/services/getIconClasses.js	2023-09-05 08:43:04.462814039 +0000
+++ b/vs/editor/common/services/getIconClasses.js	2023-09-05 08:45:14.337196921 +0000
@@ -59,6 +59,9 @@
     }
     return classes;
 }
+export function getIconClassesForLanguageId(languageId) {
+    return ['file-icon', `${cssEscape(languageId)}-lang-file-icon`];
+}
 function detectLanguageId(modelService, languageService, resource) {
     if (!resource) {
         return null; // we need a resource at least
diff -urN -x '*.map' a/vs/editor/common/services/languageFeaturesService.js b/vs/editor/common/services/languageFeaturesService.js
--- a/vs/editor/common/services/languageFeaturesService.js	2023-09-05 08:43:04.462814039 +0000
+++ b/vs/editor/common/services/languageFeaturesService.js	2023-09-05 08:45:14.337196921 +0000
@@ -30,11 +30,16 @@
         this.inlineCompletionsProvider = new LanguageFeatureRegistry(this._score.bind(this));
         this.completionProvider = new LanguageFeatureRegistry(this._score.bind(this));
         this.linkedEditingRangeProvider = new LanguageFeatureRegistry(this._score.bind(this));
+        this.inlineValuesProvider = new LanguageFeatureRegistry(this._score.bind(this));
+        this.evaluatableExpressionProvider = new LanguageFeatureRegistry(this._score.bind(this));
         this.documentRangeSemanticTokensProvider = new LanguageFeatureRegistry(this._score.bind(this));
         this.documentSemanticTokensProvider = new LanguageFeatureRegistry(this._score.bind(this));
         this.documentOnDropEditProvider = new LanguageFeatureRegistry(this._score.bind(this));
         this.documentPasteEditProvider = new LanguageFeatureRegistry(this._score.bind(this));
     }
+    setNotebookTypeResolver(resolver) {
+        this._notebookTypeResolver = resolver;
+    }
     _score(uri) {
         var _a;
         return (_a = this._notebookTypeResolver) === null || _a === void 0 ? void 0 : _a.call(this, uri);
diff -urN -x '*.map' a/vs/editor/common/services/languageService.js b/vs/editor/common/services/languageService.js
--- a/vs/editor/common/services/languageService.js	2023-09-05 08:43:04.462814039 +0000
+++ b/vs/editor/common/services/languageService.js	2023-09-05 08:45:14.337196921 +0000
@@ -28,9 +28,36 @@
         LanguageService.instanceCount--;
         super.dispose();
     }
+    registerLanguage(def) {
+        return this._registry.registerLanguage(def);
+    }
     isRegisteredLanguageId(languageId) {
         return this._registry.isRegisteredLanguageId(languageId);
     }
+    getRegisteredLanguageIds() {
+        return this._registry.getRegisteredLanguageIds();
+    }
+    getSortedRegisteredLanguageNames() {
+        return this._registry.getSortedRegisteredLanguageNames();
+    }
+    getLanguageName(languageId) {
+        return this._registry.getLanguageName(languageId);
+    }
+    getMimeType(languageId) {
+        return this._registry.getMimeType(languageId);
+    }
+    getIcon(languageId) {
+        return this._registry.getIcon(languageId);
+    }
+    getExtensions(languageId) {
+        return this._registry.getExtensions(languageId);
+    }
+    getFilenames(languageId) {
+        return this._registry.getFilenames(languageId);
+    }
+    getConfigurationFiles(languageId) {
+        return this._registry.getConfigurationFiles(languageId);
+    }
     getLanguageIdByLanguageName(languageName) {
         return this._registry.getLanguageIdByLanguageName(languageName);
     }
@@ -46,6 +73,12 @@
             return this._createAndGetLanguageIdentifier(languageId);
         });
     }
+    createByMimeType(mimeType) {
+        return new LanguageSelection(this.onDidChange, () => {
+            const languageId = this.getLanguageIdByMimeType(mimeType);
+            return this._createAndGetLanguageIdentifier(languageId);
+        });
+    }
     createByFilepathOrFirstLine(resource, firstLine) {
         return new LanguageSelection(this.onDidChange, () => {
             const languageId = this.guessLanguageIdByFilepathOrFirstLine(resource, firstLine);
diff -urN -x '*.map' a/vs/editor/common/services/languagesAssociations.js b/vs/editor/common/services/languagesAssociations.js
--- a/vs/editor/common/services/languagesAssociations.js	2023-09-05 08:43:04.462814039 +0000
+++ b/vs/editor/common/services/languagesAssociations.js	2023-09-05 08:45:14.337196921 +0000
@@ -20,6 +20,14 @@
 export function registerPlatformLanguageAssociation(association, warnOnOverwrite = false) {
     _registerLanguageAssociation(association, false, warnOnOverwrite);
 }
+/**
+ * Associate a language to the registry (configured).
+ * * **NOTE**: This association will win over associations registered using `registerPlatformLanguageAssociation`.
+ * * **NOTE**: Use `clearConfiguredLanguageAssociations` to remove all associations registered using this function.
+ */
+export function registerConfiguredLanguageAssociation(association) {
+    _registerLanguageAssociation(association, true, false);
+}
 function _registerLanguageAssociation(association, userConfigured, warnOnOverwrite) {
     // Register
     const associationItem = toLanguageAssociationItem(association, userConfigured);
@@ -74,6 +82,20 @@
     nonUserRegisteredAssociations = [];
 }
 /**
+ * Clear language associations from the registry (configured).
+ */
+export function clearConfiguredLanguageAssociations() {
+    registeredAssociations = registeredAssociations.filter(a => !a.userConfigured);
+    userRegisteredAssociations = [];
+}
+/**
+ * Given a file, return the best matching mime types for it
+ * based on the registered language associations.
+ */
+export function getMimeTypes(resource, firstLine) {
+    return getAssociations(resource, firstLine).map(item => item.mime);
+}
+/**
  * @see `getMimeTypes`
  */
 export function getLanguageIds(resource, firstLine) {
diff -urN -x '*.map' a/vs/editor/common/services/languagesRegistry.js b/vs/editor/common/services/languagesRegistry.js
--- a/vs/editor/common/services/languagesRegistry.js	2023-09-05 08:43:04.462814039 +0000
+++ b/vs/editor/common/services/languagesRegistry.js	2023-09-05 08:45:14.337196921 +0000
@@ -4,7 +4,7 @@
  *--------------------------------------------------------------------------------------------*/
 import { Emitter } from '../../../base/common/event.js';
 import { Disposable } from '../../../base/common/lifecycle.js';
-import { regExpLeadsToEndlessLoop } from '../../../base/common/strings.js';
+import { compareIgnoreCase, regExpLeadsToEndlessLoop } from '../../../base/common/strings.js';
 import { clearPlatformLanguageAssociations, getLanguageIds, registerPlatformLanguageAssociation } from './languagesAssociations.js';
 import { ModesRegistry, PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';
 import { Extensions } from '../../../platform/configuration/common/configurationRegistry.js';
@@ -61,6 +61,10 @@
         LanguagesRegistry.instanceCount--;
         super.dispose();
     }
+    setDynamicLanguages(def) {
+        this._dynamicLanguages = def;
+        this._initializeFromRegistry();
+    }
     _initializeFromRegistry() {
         this._languages = {};
         this._mimeTypesMap = {};
@@ -70,6 +74,9 @@
         const desc = [].concat(ModesRegistry.getLanguages()).concat(this._dynamicLanguages);
         this._registerLanguages(desc);
     }
+    registerLanguage(desc) {
+        return ModesRegistry.registerLanguage(desc);
+    }
     _registerLanguages(desc) {
         for (const d of desc) {
             this._registerLanguage(d);
@@ -210,6 +217,57 @@
     getRegisteredLanguageIds() {
         return Object.keys(this._languages);
     }
+    getSortedRegisteredLanguageNames() {
+        const result = [];
+        for (const languageName in this._nameMap) {
+            if (hasOwnProperty.call(this._nameMap, languageName)) {
+                result.push({
+                    languageName: languageName,
+                    languageId: this._nameMap[languageName]
+                });
+            }
+        }
+        result.sort((a, b) => compareIgnoreCase(a.languageName, b.languageName));
+        return result;
+    }
+    getLanguageName(languageId) {
+        if (!hasOwnProperty.call(this._languages, languageId)) {
+            return null;
+        }
+        return this._languages[languageId].name;
+    }
+    getMimeType(languageId) {
+        if (!hasOwnProperty.call(this._languages, languageId)) {
+            return null;
+        }
+        const language = this._languages[languageId];
+        return (language.mimetypes[0] || null);
+    }
+    getExtensions(languageId) {
+        if (!hasOwnProperty.call(this._languages, languageId)) {
+            return [];
+        }
+        return this._languages[languageId].extensions;
+    }
+    getFilenames(languageId) {
+        if (!hasOwnProperty.call(this._languages, languageId)) {
+            return [];
+        }
+        return this._languages[languageId].filenames;
+    }
+    getIcon(languageId) {
+        if (!hasOwnProperty.call(this._languages, languageId)) {
+            return null;
+        }
+        const language = this._languages[languageId];
+        return (language.icons[0] || null);
+    }
+    getConfigurationFiles(languageId) {
+        if (!hasOwnProperty.call(this._languages, languageId)) {
+            return [];
+        }
+        return this._languages[languageId].configurationFiles || [];
+    }
     getLanguageIdByLanguageName(languageName) {
         const languageNameLower = languageName.toLowerCase();
         if (!hasOwnProperty.call(this._lowercaseNameMap, languageNameLower)) {
diff -urN -x '*.map' a/vs/editor/common/services/markerDecorationsService.js b/vs/editor/common/services/markerDecorationsService.js
--- a/vs/editor/common/services/markerDecorationsService.js	2023-09-05 08:43:04.462814039 +0000
+++ b/vs/editor/common/services/markerDecorationsService.js	2023-09-05 08:45:14.337196921 +0000
@@ -44,12 +44,23 @@
     getMarker(decoration) {
         return this._markersData.get(decoration.id);
     }
+    getMarkers() {
+        const res = [];
+        this._markersData.forEach((marker, id) => {
+            const range = this.model.getDecorationRange(id);
+            if (range) {
+                res.push([range, marker]);
+            }
+        });
+        return res;
+    }
 }
 let MarkerDecorationsService = class MarkerDecorationsService extends Disposable {
     constructor(modelService, _markerService) {
         super();
         this._markerService = _markerService;
         this._onDidChangeMarker = this._register(new Emitter());
+        this.onDidChangeMarker = this._onDidChangeMarker.event;
         this._markerDecorations = new ResourceMap();
         modelService.getModels().forEach(model => this._onModelAdded(model));
         this._register(modelService.onModelAdded(this._onModelAdded, this));
@@ -65,6 +76,10 @@
         const markerDecorations = this._markerDecorations.get(uri);
         return markerDecorations ? (markerDecorations.getMarker(decoration) || null) : null;
     }
+    getLiveMarkers(uri) {
+        const markerDecorations = this._markerDecorations.get(uri);
+        return markerDecorations ? markerDecorations.getMarkers() : [];
+    }
     _handleMarkerChange(changedResources) {
         changedResources.forEach((resource) => {
             const markerDecorations = this._markerDecorations.get(resource);
diff -urN -x '*.map' a/vs/editor/common/services/modelService.js b/vs/editor/common/services/modelService.js
--- a/vs/editor/common/services/modelService.js	2023-09-05 08:43:04.462814039 +0000
+++ b/vs/editor/common/services/modelService.js	2023-09-05 08:45:14.337196921 +0000
@@ -14,7 +14,9 @@
 import { Emitter } from '../../../base/common/event.js';
 import { Disposable, DisposableStore } from '../../../base/common/lifecycle.js';
 import * as platform from '../../../base/common/platform.js';
-import { TextModel } from '../model/textModel.js';
+import { EditOperation } from '../core/editOperation.js';
+import { Range } from '../core/range.js';
+import { TextModel, createTextBuffer } from '../model/textModel.js';
 import { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';
 import { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';
 import { ILanguageService } from '../languages/language.js';
@@ -297,6 +299,65 @@
         this._models[modelId] = modelData;
         return modelData;
     }
+    updateModel(model, value) {
+        const options = this.getCreationOptions(model.getLanguageId(), model.uri, model.isForSimpleWidget);
+        const { textBuffer, disposable } = createTextBuffer(value, options.defaultEOL);
+        // Return early if the text is already set in that form
+        if (model.equalsTextBuffer(textBuffer)) {
+            disposable.dispose();
+            return;
+        }
+        // Otherwise find a diff between the values and update model
+        model.pushStackElement();
+        model.pushEOL(textBuffer.getEOL() === '\r\n' ? 1 /* EndOfLineSequence.CRLF */ : 0 /* EndOfLineSequence.LF */);
+        model.pushEditOperations([], ModelService._computeEdits(model, textBuffer), () => []);
+        model.pushStackElement();
+        disposable.dispose();
+    }
+    static _commonPrefix(a, aLen, aDelta, b, bLen, bDelta) {
+        const maxResult = Math.min(aLen, bLen);
+        let result = 0;
+        for (let i = 0; i < maxResult && a.getLineContent(aDelta + i) === b.getLineContent(bDelta + i); i++) {
+            result++;
+        }
+        return result;
+    }
+    static _commonSuffix(a, aLen, aDelta, b, bLen, bDelta) {
+        const maxResult = Math.min(aLen, bLen);
+        let result = 0;
+        for (let i = 0; i < maxResult && a.getLineContent(aDelta + aLen - i) === b.getLineContent(bDelta + bLen - i); i++) {
+            result++;
+        }
+        return result;
+    }
+    /**
+     * Compute edits to bring `model` to the state of `textSource`.
+     */
+    static _computeEdits(model, textBuffer) {
+        const modelLineCount = model.getLineCount();
+        const textBufferLineCount = textBuffer.getLineCount();
+        const commonPrefix = this._commonPrefix(model, modelLineCount, 1, textBuffer, textBufferLineCount, 1);
+        if (modelLineCount === textBufferLineCount && commonPrefix === modelLineCount) {
+            // equality case
+            return [];
+        }
+        const commonSuffix = this._commonSuffix(model, modelLineCount - commonPrefix, commonPrefix, textBuffer, textBufferLineCount - commonPrefix, commonPrefix);
+        let oldRange;
+        let newRange;
+        if (commonSuffix > 0) {
+            oldRange = new Range(commonPrefix + 1, 1, modelLineCount - commonSuffix + 1, 1);
+            newRange = new Range(commonPrefix + 1, 1, textBufferLineCount - commonSuffix + 1, 1);
+        }
+        else if (commonPrefix > 0) {
+            oldRange = new Range(commonPrefix, model.getLineMaxColumn(commonPrefix), modelLineCount, model.getLineMaxColumn(modelLineCount));
+            newRange = new Range(commonPrefix, 1 + textBuffer.getLineLength(commonPrefix), textBufferLineCount, 1 + textBuffer.getLineLength(textBufferLineCount));
+        }
+        else {
+            oldRange = new Range(1, 1, modelLineCount, model.getLineMaxColumn(modelLineCount));
+            newRange = new Range(1, 1, textBufferLineCount, 1 + textBuffer.getLineLength(textBufferLineCount));
+        }
+        return [EditOperation.replaceMove(oldRange, textBuffer.getValueInRange(newRange, 0 /* EndOfLinePreference.TextDefined */))];
+    }
     createModel(value, languageSelection, resource, isForSimpleWidget = false) {
         let modelData;
         if (languageSelection) {
@@ -308,6 +369,14 @@
         this._onModelAdded.fire(modelData.model);
         return modelData.model;
     }
+    destroyModel(resource) {
+        // We need to support that not all models get disposed through this service (i.e. model.dispose() should work!)
+        const modelData = this._models[MODEL_ID(resource)];
+        if (!modelData) {
+            return;
+        }
+        modelData.model.dispose();
+    }
     getModels() {
         const ret = [];
         const keys = Object.keys(this._models);
diff -urN -x '*.map' a/vs/editor/common/services/resolverService.js b/vs/editor/common/services/resolverService.js
--- a/vs/editor/common/services/resolverService.js	2023-09-05 08:43:04.462814039 +0000
+++ b/vs/editor/common/services/resolverService.js	2023-09-05 08:45:14.337196921 +0000
@@ -1,2 +1,10 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
 import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';
 export const ITextModelService = createDecorator('textModelService');
+export function isResolvedTextEditorModel(model) {
+    const candidate = model;
+    return !!candidate.textEditorModel;
+}
diff -urN -x '*.map' a/vs/editor/common/services/semanticTokensDto.js b/vs/editor/common/services/semanticTokensDto.js
--- a/vs/editor/common/services/semanticTokensDto.js	2023-09-05 08:43:04.466814133 +0000
+++ b/vs/editor/common/services/semanticTokensDto.js	2023-09-05 08:45:14.337196921 +0000
@@ -25,6 +25,22 @@
     }
     return VSBuffer.wrap(uint8Arr);
 }
+function fromLittleEndianBuffer(buff) {
+    const uint8Arr = buff.buffer;
+    if (!platform.isLittleEndian()) {
+        // the byte order must be changed
+        reverseEndianness(uint8Arr);
+    }
+    if (uint8Arr.byteOffset % 4 === 0) {
+        return new Uint32Array(uint8Arr.buffer, uint8Arr.byteOffset, uint8Arr.length / 4);
+    }
+    else {
+        // unaligned memory access doesn't work on all platforms
+        const data = new Uint8Array(uint8Arr.byteLength);
+        data.set(uint8Arr);
+        return new Uint32Array(data.buffer, data.byteOffset, data.length / 4);
+    }
+}
 export function encodeSemanticTokensDto(semanticTokens) {
     const dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));
     let offset = 0;
@@ -77,3 +93,37 @@
     }
     return result;
 }
+export function decodeSemanticTokensDto(_buff) {
+    const src = fromLittleEndianBuffer(_buff);
+    let offset = 0;
+    const id = src[offset++];
+    const type = src[offset++];
+    if (type === 1 /* EncodedSemanticTokensType.Full */) {
+        const length = src[offset++];
+        const data = src.subarray(offset, offset + length);
+        offset += length;
+        return {
+            id: id,
+            type: 'full',
+            data: data
+        };
+    }
+    const deltaCount = src[offset++];
+    const deltas = [];
+    for (let i = 0; i < deltaCount; i++) {
+        const start = src[offset++];
+        const deleteCount = src[offset++];
+        const length = src[offset++];
+        let data;
+        if (length > 0) {
+            data = src.subarray(offset, offset + length);
+            offset += length;
+        }
+        deltas[i] = { start, deleteCount, data };
+    }
+    return {
+        id: id,
+        type: 'delta',
+        deltas: deltas
+    };
+}
diff -urN -x '*.map' a/vs/editor/common/services/textResourceConfiguration.js b/vs/editor/common/services/textResourceConfiguration.js
--- a/vs/editor/common/services/textResourceConfiguration.js	2023-09-05 08:43:04.466814133 +0000
+++ b/vs/editor/common/services/textResourceConfiguration.js	2023-09-05 08:45:14.337196921 +0000
@@ -1,3 +1,7 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
 import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';
 export const ITextResourceConfigurationService = createDecorator('textResourceConfigurationService');
 export const ITextResourcePropertiesService = createDecorator('textResourcePropertiesService');
diff -urN -x '*.map' a/vs/editor/common/services/treeViewsDnd.js b/vs/editor/common/services/treeViewsDnd.js
--- a/vs/editor/common/services/treeViewsDnd.js	2023-09-05 08:43:04.466814133 +0000
+++ b/vs/editor/common/services/treeViewsDnd.js	2023-09-05 08:45:14.337196921 +0000
@@ -14,6 +14,9 @@
         }
         return undefined;
     }
+    addDragOperationTransfer(uuid, transferPromise) {
+        this._dragOperations.set(uuid, transferPromise);
+    }
 }
 export class DraggedTreeItemsIdentifier {
     constructor(identifier) {
diff -urN -x '*.map' a/vs/editor/common/standaloneStrings.js b/vs/editor/common/standaloneStrings.js
--- a/vs/editor/common/standaloneStrings.js	2023-09-05 08:43:04.482814506 +0000
+++ b/vs/editor/common/standaloneStrings.js	2023-09-05 08:45:14.353197150 +0000
@@ -3,6 +3,26 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import * as nls from '../../nls.js';
+export var AccessibilityHelpNLS;
+(function (AccessibilityHelpNLS) {
+    AccessibilityHelpNLS.accessibilityHelpTitle = nls.localize('accessibilityHelpTitle', "Accessibility Help");
+    AccessibilityHelpNLS.openingDocs = nls.localize("openingDocs", "Now opening the Accessibility documentation page.");
+    AccessibilityHelpNLS.readonlyDiffEditor = nls.localize("readonlyDiffEditor", "You are in a read-only pane of a diff editor.");
+    AccessibilityHelpNLS.editableDiffEditor = nls.localize("editableDiffEditor", "You are in a pane of a diff editor.");
+    AccessibilityHelpNLS.readonlyEditor = nls.localize("readonlyEditor", "You are in a read-only code editor");
+    AccessibilityHelpNLS.editableEditor = nls.localize("editableEditor", "You are in a code editor");
+    AccessibilityHelpNLS.changeConfigToOnMac = nls.localize("changeConfigToOnMac", "To configure the application to be optimized for usage with a Screen Reader press Command+E now.");
+    AccessibilityHelpNLS.changeConfigToOnWinLinux = nls.localize("changeConfigToOnWinLinux", "To configure the application to be optimized for usage with a Screen Reader press Control+E now.");
+    AccessibilityHelpNLS.auto_on = nls.localize("auto_on", "The application is configured to be optimized for usage with a Screen Reader.");
+    AccessibilityHelpNLS.auto_off = nls.localize("auto_off", "The application is configured to never be optimized for usage with a Screen Reader");
+    AccessibilityHelpNLS.screenReaderModeEnabled = nls.localize("screenReaderModeEnabled", "Screen Reader Optimized Mode enabled.");
+    AccessibilityHelpNLS.screenReaderModeDisabled = nls.localize("screenReaderModeDisabled", "Screen Reader Optimized Mode disabled.");
+    AccessibilityHelpNLS.tabFocusModeOnMsg = nls.localize("tabFocusModeOnMsg", "Pressing Tab in the current editor will move focus to the next focusable element. Toggle this behavior by pressing {0}.");
+    AccessibilityHelpNLS.tabFocusModeOnMsgNoKb = nls.localize("tabFocusModeOnMsgNoKb", "Pressing Tab in the current editor will move focus to the next focusable element. The command {0} is currently not triggerable by a keybinding.");
+    AccessibilityHelpNLS.tabFocusModeOffMsg = nls.localize("tabFocusModeOffMsg", "Pressing Tab in the current editor will insert the tab character. Toggle this behavior by pressing {0}.");
+    AccessibilityHelpNLS.tabFocusModeOffMsgNoKb = nls.localize("tabFocusModeOffMsgNoKb", "Pressing Tab in the current editor will insert the tab character. The command {0} is currently not triggerable by a keybinding.");
+    AccessibilityHelpNLS.showAccessibilityHelpAction = nls.localize("showAccessibilityHelpAction", "Show Accessibility Help");
+})(AccessibilityHelpNLS || (AccessibilityHelpNLS = {}));
 export var InspectTokensNLS;
 (function (InspectTokensNLS) {
     InspectTokensNLS.inspectTokensAction = nls.localize('inspectTokens', "Developer: Inspect Tokens");
diff -urN -x '*.map' a/vs/editor/common/textModelBracketPairs.js b/vs/editor/common/textModelBracketPairs.js
--- a/vs/editor/common/textModelBracketPairs.js	2023-09-05 08:43:04.482814506 +0000
+++ b/vs/editor/common/textModelBracketPairs.js	2023-09-05 08:45:14.337196921 +0000
@@ -26,6 +26,10 @@
     get openingBracketInfo() {
         return this.bracketPairNode.openingBracket.bracketInfo;
     }
+    get closingBracketInfo() {
+        var _a;
+        return (_a = this.bracketPairNode.closingBracket) === null || _a === void 0 ? void 0 : _a.bracketInfo;
+    }
 }
 export class BracketPairWithMinIndentationInfo extends BracketPairInfo {
     constructor(range, openingBracketRange, closingBracketRange, 
diff -urN -x '*.map' a/vs/editor/common/textModelEvents.js b/vs/editor/common/textModelEvents.js
--- a/vs/editor/common/textModelEvents.js	2023-09-05 08:43:04.482814506 +0000
+++ b/vs/editor/common/textModelEvents.js	2023-09-05 08:45:14.345197036 +0000
@@ -58,6 +58,9 @@
         this.options = options;
         this.order = order;
     }
+    withText(text) {
+        return new LineInjectedText(this.ownerId, this.lineNumber, this.column, Object.assign(Object.assign({}, this.options), { content: text }), this.order);
+    }
 }
 /**
  * An event describing that a line has changed in a model.
diff -urN -x '*.map' a/vs/editor/common/tokens/contiguousMultilineTokens.js b/vs/editor/common/tokens/contiguousMultilineTokens.js
--- a/vs/editor/common/tokens/contiguousMultilineTokens.js	2023-09-05 08:43:04.450813760 +0000
+++ b/vs/editor/common/tokens/contiguousMultilineTokens.js	2023-09-05 08:45:14.353197150 +0000
@@ -1,7 +1,33 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import * as arrays from '../../../base/common/arrays.js';
+import { readUInt32BE, writeUInt32BE } from '../../../base/common/buffer.js';
+import { Position } from '../core/position.js';
+import { countEOL } from '../core/eolCounter.js';
+import { ContiguousTokensEditing } from './contiguousTokensEditing.js';
+import { LineRange } from '../core/lineRange.js';
 /**
  * Represents contiguous tokens over a contiguous range of lines.
  */
 export class ContiguousMultilineTokens {
+    static deserialize(buff, offset, result) {
+        const view32 = new Uint32Array(buff.buffer);
+        const startLineNumber = readUInt32BE(buff, offset);
+        offset += 4;
+        const count = readUInt32BE(buff, offset);
+        offset += 4;
+        const tokens = [];
+        for (let i = 0; i < count; i++) {
+            const byteCount = readUInt32BE(buff, offset);
+            offset += 4;
+            tokens.push(view32.subarray(offset / 4, offset / 4 + byteCount / 4));
+            offset += byteCount;
+        }
+        result.push(new ContiguousMultilineTokens(startLineNumber, tokens));
+        return offset;
+    }
     /**
      * (Inclusive) start line number for these tokens.
      */
@@ -18,6 +44,9 @@
         this._startLineNumber = startLineNumber;
         this._tokens = tokens;
     }
+    getLineRange() {
+        return new LineRange(this._startLineNumber, this._startLineNumber + this._tokens.length);
+    }
     /**
      * @see {@link _tokens}
      */
@@ -27,4 +56,131 @@
     appendLineTokens(lineTokens) {
         this._tokens.push(lineTokens);
     }
+    serializeSize() {
+        let result = 0;
+        result += 4; // 4 bytes for the start line number
+        result += 4; // 4 bytes for the line count
+        for (let i = 0; i < this._tokens.length; i++) {
+            const lineTokens = this._tokens[i];
+            if (!(lineTokens instanceof Uint32Array)) {
+                throw new Error(`Not supported!`);
+            }
+            result += 4; // 4 bytes for the byte count
+            result += lineTokens.byteLength;
+        }
+        return result;
+    }
+    serialize(destination, offset) {
+        writeUInt32BE(destination, this._startLineNumber, offset);
+        offset += 4;
+        writeUInt32BE(destination, this._tokens.length, offset);
+        offset += 4;
+        for (let i = 0; i < this._tokens.length; i++) {
+            const lineTokens = this._tokens[i];
+            if (!(lineTokens instanceof Uint32Array)) {
+                throw new Error(`Not supported!`);
+            }
+            writeUInt32BE(destination, lineTokens.byteLength, offset);
+            offset += 4;
+            destination.set(new Uint8Array(lineTokens.buffer), offset);
+            offset += lineTokens.byteLength;
+        }
+        return offset;
+    }
+    applyEdit(range, text) {
+        const [eolCount, firstLineLength] = countEOL(text);
+        this._acceptDeleteRange(range);
+        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);
+    }
+    _acceptDeleteRange(range) {
+        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {
+            // Nothing to delete
+            return;
+        }
+        const firstLineIndex = range.startLineNumber - this._startLineNumber;
+        const lastLineIndex = range.endLineNumber - this._startLineNumber;
+        if (lastLineIndex < 0) {
+            // this deletion occurs entirely before this block, so we only need to adjust line numbers
+            const deletedLinesCount = lastLineIndex - firstLineIndex;
+            this._startLineNumber -= deletedLinesCount;
+            return;
+        }
+        if (firstLineIndex >= this._tokens.length) {
+            // this deletion occurs entirely after this block, so there is nothing to do
+            return;
+        }
+        if (firstLineIndex < 0 && lastLineIndex >= this._tokens.length) {
+            // this deletion completely encompasses this block
+            this._startLineNumber = 0;
+            this._tokens = [];
+            return;
+        }
+        if (firstLineIndex === lastLineIndex) {
+            // a delete on a single line
+            this._tokens[firstLineIndex] = ContiguousTokensEditing.delete(this._tokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);
+            return;
+        }
+        if (firstLineIndex >= 0) {
+            // The first line survives
+            this._tokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._tokens[firstLineIndex], range.startColumn - 1);
+            if (lastLineIndex < this._tokens.length) {
+                // The last line survives
+                const lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._tokens[lastLineIndex], range.endColumn - 1);
+                // Take remaining text on last line and append it to remaining text on first line
+                this._tokens[firstLineIndex] = ContiguousTokensEditing.append(this._tokens[firstLineIndex], lastLineTokens);
+                // Delete middle lines
+                this._tokens.splice(firstLineIndex + 1, lastLineIndex - firstLineIndex);
+            }
+            else {
+                // The last line does not survive
+                // Take remaining text on last line and append it to remaining text on first line
+                this._tokens[firstLineIndex] = ContiguousTokensEditing.append(this._tokens[firstLineIndex], null);
+                // Delete lines
+                this._tokens = this._tokens.slice(0, firstLineIndex + 1);
+            }
+        }
+        else {
+            // The first line does not survive
+            const deletedBefore = -firstLineIndex;
+            this._startLineNumber -= deletedBefore;
+            // Remove beginning from last line
+            this._tokens[lastLineIndex] = ContiguousTokensEditing.deleteBeginning(this._tokens[lastLineIndex], range.endColumn - 1);
+            // Delete lines
+            this._tokens = this._tokens.slice(lastLineIndex);
+        }
+    }
+    _acceptInsertText(position, eolCount, firstLineLength) {
+        if (eolCount === 0 && firstLineLength === 0) {
+            // Nothing to insert
+            return;
+        }
+        const lineIndex = position.lineNumber - this._startLineNumber;
+        if (lineIndex < 0) {
+            // this insertion occurs before this block, so we only need to adjust line numbers
+            this._startLineNumber += eolCount;
+            return;
+        }
+        if (lineIndex >= this._tokens.length) {
+            // this insertion occurs after this block, so there is nothing to do
+            return;
+        }
+        if (eolCount === 0) {
+            // Inserting text on one line
+            this._tokens[lineIndex] = ContiguousTokensEditing.insert(this._tokens[lineIndex], position.column - 1, firstLineLength);
+            return;
+        }
+        this._tokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._tokens[lineIndex], position.column - 1);
+        this._tokens[lineIndex] = ContiguousTokensEditing.insert(this._tokens[lineIndex], position.column - 1, firstLineLength);
+        this._insertLines(position.lineNumber, eolCount);
+    }
+    _insertLines(insertIndex, insertCount) {
+        if (insertCount === 0) {
+            return;
+        }
+        const lineTokens = [];
+        for (let i = 0; i < insertCount; i++) {
+            lineTokens[i] = null;
+        }
+        this._tokens = arrays.arrayInsert(this._tokens, insertIndex, lineTokens);
+    }
 }
diff -urN -x '*.map' a/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js b/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js
--- a/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js	2023-09-05 08:43:04.450813760 +0000
+++ b/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js	2023-09-05 08:45:14.353197150 +0000
@@ -1,5 +1,20 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { readUInt32BE, writeUInt32BE } from '../../../base/common/buffer.js';
 import { ContiguousMultilineTokens } from './contiguousMultilineTokens.js';
 export class ContiguousMultilineTokensBuilder {
+    static deserialize(buff) {
+        let offset = 0;
+        const count = readUInt32BE(buff, offset);
+        offset += 4;
+        const result = [];
+        for (let i = 0; i < count; i++) {
+            offset = ContiguousMultilineTokens.deserialize(buff, offset, result);
+        }
+        return result;
+    }
     constructor() {
         this._tokens = [];
     }
@@ -17,4 +32,26 @@
     finalize() {
         return this._tokens;
     }
+    serialize() {
+        const size = this._serializeSize();
+        const result = new Uint8Array(size);
+        this._serialize(result);
+        return result;
+    }
+    _serializeSize() {
+        let result = 0;
+        result += 4; // 4 bytes for the count
+        for (let i = 0; i < this._tokens.length; i++) {
+            result += this._tokens[i].serializeSize();
+        }
+        return result;
+    }
+    _serialize(destination) {
+        let offset = 0;
+        writeUInt32BE(destination, this._tokens.length, offset);
+        offset += 4;
+        for (let i = 0; i < this._tokens.length; i++) {
+            offset = this._tokens[i].serialize(destination, offset);
+        }
+    }
 }
diff -urN -x '*.map' a/vs/editor/common/viewLayout/linesLayout.js b/vs/editor/common/viewLayout/linesLayout.js
--- a/vs/editor/common/viewLayout/linesLayout.js	2023-09-05 08:43:04.470814226 +0000
+++ b/vs/editor/common/viewLayout/linesLayout.js	2023-09-05 08:45:14.333196864 +0000
@@ -421,6 +421,13 @@
         return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;
     }
     /**
+     * Returns if there is any whitespace in the document.
+     */
+    hasWhitespace() {
+        this._checkPendingChanges();
+        return this.getWhitespacesCount() > 0;
+    }
+    /**
      * The maximum min width for all whitespaces.
      */
     getWhitespaceMinWidth() {
diff -urN -x '*.map' a/vs/editor/common/viewLayout/viewLineRenderer.js b/vs/editor/common/viewLayout/viewLineRenderer.js
--- a/vs/editor/common/viewLayout/viewLineRenderer.js	2023-09-05 08:43:04.474814319 +0000
+++ b/vs/editor/common/viewLayout/viewLineRenderer.js	2023-09-05 08:45:14.333196864 +0000
@@ -200,6 +200,17 @@
         }
         return max;
     }
+    inflate() {
+        const result = [];
+        for (let i = 0; i < this.length; i++) {
+            const partData = this._data[i];
+            const partIndex = CharacterMapping.getPartIndex(partData);
+            const charIndex = CharacterMapping.getCharIndex(partData);
+            const visibleColumn = this._horizontalOffset[i];
+            result.push([partIndex, charIndex, visibleColumn]);
+        }
+        return result;
+    }
 }
 export class RenderLineOutput {
     constructor(characterMapping, containsRTL, containsForeignElements) {
diff -urN -x '*.map' a/vs/editor/common/viewModel/viewModelLines.js b/vs/editor/common/viewModel/viewModelLines.js
--- a/vs/editor/common/viewModel/viewModelLines.js	2023-09-05 08:43:04.478814412 +0000
+++ b/vs/editor/common/viewModel/viewModelLines.js	2023-09-05 08:45:14.341196978 +0000
@@ -775,6 +775,9 @@
  * Represents a view line. Can be used to efficiently query more information about it.
  */
 class ViewLineInfo {
+    get isWrappedLineContinuation() {
+        return this.modelLineWrappedLineIdx > 0;
+    }
     constructor(modelLineNumber, modelLineWrappedLineIdx) {
         this.modelLineNumber = modelLineNumber;
         this.modelLineWrappedLineIdx = modelLineWrappedLineIdx;
diff -urN -x '*.map' a/vs/editor/contrib/codeAction/browser/codeAction.js b/vs/editor/contrib/codeAction/browser/codeAction.js
--- a/vs/editor/contrib/codeAction/browser/codeAction.js	2023-09-05 08:43:04.318810682 +0000
+++ b/vs/editor/contrib/codeAction/browser/codeAction.js	2023-09-05 08:45:14.377197494 +0000
@@ -32,6 +32,7 @@
 export const quickFixCommandId = 'editor.action.quickFix';
 export const autoFixCommandId = 'editor.action.autoFix';
 export const refactorCommandId = 'editor.action.refactor';
+export const refactorPreviewCommandId = 'editor.action.refactor.preview';
 export const sourceActionCommandId = 'editor.action.sourceAction';
 export const organizeImportsCommandId = 'editor.action.organizeImports';
 export const fixAllCommandId = 'editor.action.fixAll';
diff -urN -x '*.map' a/vs/editor/contrib/codeAction/browser/codeActionController.js b/vs/editor/contrib/codeAction/browser/codeActionController.js
--- a/vs/editor/contrib/codeAction/browser/codeActionController.js	2023-09-05 08:43:04.318810682 +0000
+++ b/vs/editor/contrib/codeAction/browser/codeActionController.js	2023-09-05 08:45:14.377197494 +0000
@@ -74,6 +74,9 @@
     showCodeActions(_trigger, actions, at) {
         return this.showCodeActionList(actions, at, { includeDisabledActions: false, fromLightbulb: false });
     }
+    hideCodeActions() {
+        this._actionWidgetService.hide();
+    }
     manualTriggerAtCurrentPosition(notAvailableMessage, triggerAction, filter, autoApply) {
         var _a;
         if (!this._editor.hasModel()) {
@@ -98,6 +101,10 @@
             }
         });
     }
+    hideLightBulbWidget() {
+        var _a;
+        (_a = this._lightBulbWidget.rawValue) === null || _a === void 0 ? void 0 : _a.hide();
+    }
     update(newState) {
         var _a, _b, _c, _d, _e, _f, _g;
         return __awaiter(this, void 0, void 0, function* () {
diff -urN -x '*.map' a/vs/editor/contrib/codelens/browser/codelensWidget.js b/vs/editor/contrib/codelens/browser/codelensWidget.js
--- a/vs/editor/contrib/codelens/browser/codelensWidget.js	2023-09-05 08:43:04.286809936 +0000
+++ b/vs/editor/contrib/codelens/browser/codelensWidget.js	2023-09-05 08:45:14.381197551 +0000
@@ -259,4 +259,7 @@
             }
         }
     }
+    getItems() {
+        return this._data;
+    }
 }
diff -urN -x '*.map' a/vs/editor/contrib/colorPicker/browser/colorContributions.js b/vs/editor/contrib/colorPicker/browser/colorContributions.js
--- a/vs/editor/contrib/colorPicker/browser/colorContributions.js	2023-09-05 08:43:04.290810029 +0000
+++ b/vs/editor/contrib/colorPicker/browser/colorContributions.js	2023-09-05 08:45:14.377197494 +0000
@@ -46,6 +46,7 @@
         }
     }
 }
-ColorContribution.ID = 'editor.contrib.colorContribution'; // ms
+ColorContribution.ID = 'editor.contrib.colorContribution';
+ColorContribution.RECOMPUTE_TIME = 1000; // ms
 registerEditorContribution(ColorContribution.ID, ColorContribution, 2 /* EditorContributionInstantiation.BeforeFirstInteraction */);
 HoverParticipantRegistry.register(ColorHoverParticipant);
diff -urN -x '*.map' a/vs/editor/contrib/colorPicker/browser/colorDetector.js b/vs/editor/contrib/colorPicker/browser/colorDetector.js
--- a/vs/editor/contrib/colorPicker/browser/colorDetector.js	2023-09-05 08:43:04.290810029 +0000
+++ b/vs/editor/contrib/colorPicker/browser/colorDetector.js	2023-09-05 08:45:14.377197494 +0000
@@ -93,6 +93,9 @@
         }
         return this._editor.getOption(19 /* EditorOption.colorDecorators */);
     }
+    get limitReporter() {
+        return this._decoratorLimitReporter;
+    }
     static get(editor) {
         return editor.getContribution(this.ID);
     }
@@ -238,9 +241,16 @@
 export class DecoratorLimitReporter {
     constructor() {
         this._onDidChange = new Emitter();
+        this.onDidChange = this._onDidChange.event;
         this._computed = 0;
         this._limited = false;
     }
+    get computed() {
+        return this._computed;
+    }
+    get limited() {
+        return this._limited;
+    }
     update(computed, limited) {
         if (computed !== this._computed || limited !== this._limited) {
             this._computed = computed;
diff -urN -x '*.map' a/vs/editor/contrib/colorPicker/browser/colorHoverParticipant.js b/vs/editor/contrib/colorPicker/browser/colorHoverParticipant.js
--- a/vs/editor/contrib/colorPicker/browser/colorHoverParticipant.js	2023-09-05 08:43:04.290810029 +0000
+++ b/vs/editor/contrib/colorPicker/browser/colorHoverParticipant.js	2023-09-05 08:45:14.377197494 +0000
@@ -103,6 +103,7 @@
     constructor(_editor, _themeService) {
         this._editor = _editor;
         this._themeService = _themeService;
+        this.hoverOrdinal = 2;
         this._color = null;
     }
     createColorHover(defaultColorInfo, defaultColorProvider, colorProviderRegistry) {
diff -urN -x '*.map' a/vs/editor/contrib/colorPicker/browser/colorPickerWidget.js b/vs/editor/contrib/colorPicker/browser/colorPickerWidget.js
--- a/vs/editor/contrib/colorPicker/browser/colorPickerWidget.js	2023-09-05 08:43:04.290810029 +0000
+++ b/vs/editor/contrib/colorPicker/browser/colorPickerWidget.js	2023-09-05 08:45:14.377197494 +0000
@@ -52,6 +52,9 @@
             this._closeButton = this._register(new CloseButton(this._domNode));
         }
     }
+    get domNode() {
+        return this._domNode;
+    }
     get closeButton() {
         return this._closeButton;
     }
@@ -135,6 +138,12 @@
     get saturationBox() {
         return this._saturationBox;
     }
+    get opacityStrip() {
+        return this._opacityStrip;
+    }
+    get hueStrip() {
+        return this._hueStrip;
+    }
     get enterButton() {
         return this._insertButton;
     }
@@ -170,6 +179,9 @@
     get domNode() {
         return this._domNode;
     }
+    get canvas() {
+        return this._canvas;
+    }
     onPointerDown(e) {
         if (!e.target || !(e.target instanceof Element)) {
             return;
@@ -340,7 +352,11 @@
         this.header = this._register(new ColorPickerHeader(element, this.model, themeService, standaloneColorPicker));
         this.body = this._register(new ColorPickerBody(element, this.model, this.pixelRatio, standaloneColorPicker));
     }
+    getId() {
+        return ColorPickerWidget.ID;
+    }
     layout() {
         this.body.layout();
     }
 }
+ColorPickerWidget.ID = 'editor.contrib.colorPickerWidget';
diff -urN -x '*.map' a/vs/editor/contrib/dnd/browser/dnd.js b/vs/editor/contrib/dnd/browser/dnd.js
--- a/vs/editor/contrib/dnd/browser/dnd.js	2023-09-05 08:43:04.294810122 +0000
+++ b/vs/editor/contrib/dnd/browser/dnd.js	2023-09-05 08:45:14.361197265 +0000
@@ -20,6 +20,9 @@
     }
 }
 export class DragAndDropController extends Disposable {
+    static get(editor) {
+        return editor.getContribution(DragAndDropController.ID);
+    }
     constructor(editor) {
         super();
         this._editor = editor;
diff -urN -x '*.map' a/vs/editor/contrib/documentSymbols/browser/outlineModel.js b/vs/editor/contrib/documentSymbols/browser/outlineModel.js
--- a/vs/editor/contrib/documentSymbols/browser/outlineModel.js	2023-09-05 08:43:04.354811521 +0000
+++ b/vs/editor/contrib/documentSymbols/browser/outlineModel.js	2023-09-05 08:45:14.365197322 +0000
@@ -20,11 +20,12 @@
         step((generator = generator.apply(thisArg, _arguments || [])).next());
     });
 };
-import { equals } from '../../../../base/common/arrays.js';
+import { binarySearch, coalesceInPlace, equals } from '../../../../base/common/arrays.js';
 import { CancellationTokenSource } from '../../../../base/common/cancellation.js';
 import { onUnexpectedExternalError } from '../../../../base/common/errors.js';
 import { Iterable } from '../../../../base/common/iterator.js';
 import { LRUCache } from '../../../../base/common/map.js';
+import { commonPrefixLength } from '../../../../base/common/strings.js';
 import { Position } from '../../../common/core/position.js';
 import { Range } from '../../../common/core/range.js';
 import { ILanguageFeatureDebounceService } from '../../../common/services/languageFeatureDebounce.js';
@@ -57,6 +58,32 @@
         }
         return id;
     }
+    static getElementById(id, element) {
+        if (!id) {
+            return undefined;
+        }
+        const len = commonPrefixLength(id, element.id);
+        if (len === id.length) {
+            return element;
+        }
+        if (len < element.id.length) {
+            return undefined;
+        }
+        for (const [, child] of element.children) {
+            const candidate = TreeElement.getElementById(id, child);
+            if (candidate) {
+                return candidate;
+            }
+        }
+        return undefined;
+    }
+    static size(element) {
+        let res = 1;
+        for (const [, child] of element.children) {
+            res += TreeElement.size(child);
+        }
+        return res;
+    }
     static empty(element) {
         return element.children.size === 0;
     }
@@ -79,6 +106,64 @@
         this.order = order;
         this.children = new Map();
     }
+    getItemEnclosingPosition(position) {
+        return position ? this._getItemEnclosingPosition(position, this.children) : undefined;
+    }
+    _getItemEnclosingPosition(position, children) {
+        for (const [, item] of children) {
+            if (!item.symbol.range || !Range.containsPosition(item.symbol.range, position)) {
+                continue;
+            }
+            return this._getItemEnclosingPosition(position, item.children) || item;
+        }
+        return undefined;
+    }
+    updateMarker(marker) {
+        for (const [, child] of this.children) {
+            this._updateMarker(marker, child);
+        }
+    }
+    _updateMarker(markers, item) {
+        item.marker = undefined;
+        // find the proper start index to check for item/marker overlap.
+        const idx = binarySearch(markers, item.symbol.range, Range.compareRangesUsingStarts);
+        let start;
+        if (idx < 0) {
+            start = ~idx;
+            if (start > 0 && Range.areIntersecting(markers[start - 1], item.symbol.range)) {
+                start -= 1;
+            }
+        }
+        else {
+            start = idx;
+        }
+        const myMarkers = [];
+        let myTopSev;
+        for (; start < markers.length && Range.areIntersecting(item.symbol.range, markers[start]); start++) {
+            // remove markers intersecting with this outline element
+            // and store them in a 'private' array.
+            const marker = markers[start];
+            myMarkers.push(marker);
+            markers[start] = undefined;
+            if (!myTopSev || marker.severity > myTopSev) {
+                myTopSev = marker.severity;
+            }
+        }
+        // Recurse into children and let them match markers that have matched
+        // this outline element. This might remove markers from this element and
+        // therefore we remember that we have had markers. That allows us to render
+        // the dot, saying 'this element has children with markers'
+        for (const [, child] of item.children) {
+            this._updateMarker(myMarkers, child);
+        }
+        if (myTopSev) {
+            item.marker = {
+                count: myMarkers.length,
+                topSev: myTopSev
+            };
+        }
+        coalesceInPlace(markers);
+    }
 }
 export class OutlineModel extends TreeElement {
     static create(registry, textModel, token) {
@@ -133,6 +218,15 @@
         }
         container.children.set(res.id, res);
     }
+    static get(element) {
+        while (element) {
+            if (element instanceof OutlineModel) {
+                return element;
+            }
+            element = element.parent;
+        }
+        return undefined;
+    }
     constructor(uri) {
         super();
         this.uri = uri;
@@ -167,6 +261,48 @@
         }
         return this;
     }
+    merge(other) {
+        if (this.uri.toString() !== other.uri.toString()) {
+            return false;
+        }
+        if (this._groups.size !== other._groups.size) {
+            return false;
+        }
+        this._groups = other._groups;
+        this.children = other.children;
+        return true;
+    }
+    getItemEnclosingPosition(position, context) {
+        let preferredGroup;
+        if (context) {
+            let candidate = context.parent;
+            while (candidate && !preferredGroup) {
+                if (candidate instanceof OutlineGroup) {
+                    preferredGroup = candidate;
+                }
+                candidate = candidate.parent;
+            }
+        }
+        let result = undefined;
+        for (const [, group] of this._groups) {
+            result = group.getItemEnclosingPosition(position);
+            if (result && (!preferredGroup || preferredGroup === group)) {
+                break;
+            }
+        }
+        return result;
+    }
+    getItemById(id) {
+        return TreeElement.getElementById(id, this);
+    }
+    updateMarker(marker) {
+        // sort markers by start range so that we can use
+        // outline element starts for quicker look up
+        marker.sort(Range.compareRangesUsingStarts);
+        for (const [, group] of this._groups) {
+            group.updateMarker(marker.slice(0));
+        }
+    }
     getTopLevelSymbols() {
         const roots = [];
         for (const child of this.children.values()) {
@@ -264,6 +400,9 @@
             }
         });
     }
+    getDebounceValue(textModel) {
+        return this._debounceInformation.get(textModel);
+    }
 };
 OutlineModelService = __decorate([
     __param(0, ILanguageFeaturesService),
diff -urN -x '*.map' a/vs/editor/contrib/dropOrPasteInto/browser/copyPasteController.js b/vs/editor/contrib/dropOrPasteInto/browser/copyPasteController.js
--- a/vs/editor/contrib/dropOrPasteInto/browser/copyPasteController.js	2023-09-05 08:43:04.326810868 +0000
+++ b/vs/editor/contrib/dropOrPasteInto/browser/copyPasteController.js	2023-09-05 08:45:14.357197207 +0000
@@ -79,6 +79,9 @@
             this._pasteAsActionContext = undefined;
         }
     }
+    clearWidgets() {
+        this._postPasteWidgetManager.clear();
+    }
     isPasteAsEnabled() {
         return this._editor.getOption(83 /* EditorOption.pasteAs */).enabled
             && !this._editor.getOption(89 /* EditorOption.readOnly */);
diff -urN -x '*.map' a/vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorController.js b/vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorController.js
--- a/vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorController.js	2023-09-05 08:43:04.330810962 +0000
+++ b/vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorController.js	2023-09-05 08:45:14.357197207 +0000
@@ -51,6 +51,9 @@
         this._postDropWidgetManager = this._register(instantiationService.createInstance(PostEditWidgetManager, 'dropIntoEditor', editor, dropWidgetVisibleCtx, { id: changeDropTypeCommandId, label: localize('postDropWidgetTitle', "Show drop options...") }));
         this._register(editor.onDropIntoEditor(e => this.onDropIntoEditor(editor, e.position, e.event)));
     }
+    clearWidgets() {
+        this._postDropWidgetManager.clear();
+    }
     changeDropType() {
         this._postDropWidgetManager.tryShowSelector();
     }
diff -urN -x '*.map' a/vs/editor/contrib/find/browser/findController.js b/vs/editor/contrib/find/browser/findController.js
--- a/vs/editor/contrib/find/browser/findController.js	2023-09-05 08:43:04.294810122 +0000
+++ b/vs/editor/contrib/find/browser/findController.js	2023-09-05 08:45:14.381197551 +0000
@@ -411,6 +411,14 @@
         this._widget = this._register(new FindWidget(this._editor, this, this._state, this._contextViewService, this._keybindingService, this._contextKeyService, this._themeService, this._storageService, this._notificationService));
         this._findOptionsWidget = this._register(new FindOptionsWidget(this._editor, this._state, this._keybindingService));
     }
+    saveViewState() {
+        var _a;
+        return (_a = this._widget) === null || _a === void 0 ? void 0 : _a.getViewState();
+    }
+    restoreViewState(state) {
+        var _a;
+        (_a = this._widget) === null || _a === void 0 ? void 0 : _a.setViewState(state);
+    }
 };
 FindController = __decorate([
     __param(1, IContextViewService),
diff -urN -x '*.map' a/vs/editor/contrib/find/browser/findState.js b/vs/editor/contrib/find/browser/findState.js
--- a/vs/editor/contrib/find/browser/findState.js	2023-09-05 08:43:04.294810122 +0000
+++ b/vs/editor/contrib/find/browser/findState.js	2023-09-05 08:45:14.381197551 +0000
@@ -32,6 +32,8 @@
     get matchesPosition() { return this._matchesPosition; }
     get matchesCount() { return this._matchesCount; }
     get currentMatch() { return this._currentMatch; }
+    get isSearching() { return this._isSearching; }
+    get filters() { return this._filters; }
     constructor() {
         super();
         this._onFindReplaceStateChange = this._register(new Emitter());
diff -urN -x '*.map' a/vs/editor/contrib/find/browser/findWidget.js b/vs/editor/contrib/find/browser/findWidget.js
--- a/vs/editor/contrib/find/browser/findWidget.js	2023-09-05 08:43:04.294810122 +0000
+++ b/vs/editor/contrib/find/browser/findWidget.js	2023-09-05 08:45:14.381197551 +0000
@@ -1055,6 +1055,25 @@
         const value = this._codeEditor.getOption(2 /* EditorOption.accessibilitySupport */);
         this._findInput.setFocusInputOnOptionClick(value !== 2 /* AccessibilitySupport.Enabled */);
     }
+    getViewState() {
+        let widgetViewZoneVisible = false;
+        if (this._viewZone && this._viewZoneId) {
+            widgetViewZoneVisible = this._viewZone.heightInPx > this._codeEditor.getScrollTop();
+        }
+        return {
+            widgetViewZoneVisible,
+            scrollTop: this._codeEditor.getScrollTop()
+        };
+    }
+    setViewState(state) {
+        if (!state) {
+            return;
+        }
+        if (state.widgetViewZoneVisible) {
+            // we should add the view zone
+            this._layoutViewZone(state.scrollTop);
+        }
+    }
 }
 FindWidget.ID = 'editor.contrib.findWidget';
 export class SimpleButton extends Widget {
diff -urN -x '*.map' a/vs/editor/contrib/find/browser/replacePattern.js b/vs/editor/contrib/find/browser/replacePattern.js
--- a/vs/editor/contrib/find/browser/replacePattern.js	2023-09-05 08:43:04.298810215 +0000
+++ b/vs/editor/contrib/find/browser/replacePattern.js	2023-09-05 08:45:14.381197551 +0000
@@ -119,6 +119,9 @@
     static staticValue(value) {
         return new ReplacePiece(value, -1, null);
     }
+    static matchIndex(index) {
+        return new ReplacePiece(null, index, null);
+    }
     static caseOps(index, caseOps) {
         return new ReplacePiece(null, index, caseOps);
     }
diff -urN -x '*.map' a/vs/editor/contrib/folding/browser/folding.js b/vs/editor/contrib/folding/browser/folding.js
--- a/vs/editor/contrib/folding/browser/folding.js	2023-09-05 08:43:04.298810215 +0000
+++ b/vs/editor/contrib/folding/browser/folding.js	2023-09-05 08:45:14.381197551 +0000
@@ -60,6 +60,10 @@
         const foldingRangeProviders = languageFeaturesService.foldingRangeProvider.ordered(model);
         return (_b = ((_a = FoldingController._foldingRangeSelector) === null || _a === void 0 ? void 0 : _a.call(FoldingController, foldingRangeProviders, model))) !== null && _b !== void 0 ? _b : foldingRangeProviders;
     }
+    static setFoldingRangeProviderSelector(foldingRangeSelector) {
+        FoldingController._foldingRangeSelector = foldingRangeSelector;
+        return { dispose: () => { FoldingController._foldingRangeSelector = undefined; } };
+    }
     constructor(editor, contextKeyService, languageConfigurationService, notificationService, languageFeatureDebounceService, languageFeaturesService) {
         super();
         this.contextKeyService = contextKeyService;
@@ -118,6 +122,9 @@
         }));
         this.onModelChanged();
     }
+    get limitReporter() {
+        return this._foldingLimitReporter;
+    }
     /**
      * Store view state.
      */
@@ -430,12 +437,19 @@
     constructor(editor) {
         this.editor = editor;
         this._onDidChange = new Emitter();
+        this.onDidChange = this._onDidChange.event;
         this._computed = 0;
         this._limited = false;
     }
     get limit() {
         return this.editor.getOptions().get(46 /* EditorOption.foldingMaximumRegions */);
     }
+    get computed() {
+        return this._computed;
+    }
+    get limited() {
+        return this._limited;
+    }
     update(computed, limited) {
         if (computed !== this._computed || limited !== this._limited) {
             this._computed = computed;
diff -urN -x '*.map' a/vs/editor/contrib/folding/browser/foldingModel.js b/vs/editor/contrib/folding/browser/foldingModel.js
--- a/vs/editor/contrib/folding/browser/foldingModel.js	2023-09-05 08:43:04.298810215 +0000
+++ b/vs/editor/contrib/folding/browser/foldingModel.js	2023-09-05 08:45:14.381197551 +0000
@@ -8,6 +8,7 @@
 export class FoldingModel {
     get regions() { return this._regions; }
     get textModel() { return this._textModel; }
+    get decorationProvider() { return this._decorationProvider; }
     constructor(textModel, decorationProvider) {
         this._updateEventEmitter = new Emitter();
         this.onDidChange = this._updateEventEmitter.event;
diff -urN -x '*.map' a/vs/editor/contrib/folding/browser/foldingRanges.js b/vs/editor/contrib/folding/browser/foldingRanges.js
--- a/vs/editor/contrib/folding/browser/foldingRanges.js	2023-09-05 08:43:04.298810215 +0000
+++ b/vs/editor/contrib/folding/browser/foldingRanges.js	2023-09-05 08:45:14.381197551 +0000
@@ -348,4 +348,7 @@
     containsLine(lineNumber) {
         return this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;
     }
+    hidesLine(lineNumber) {
+        return this.startLineNumber < lineNumber && lineNumber <= this.endLineNumber;
+    }
 }
diff -urN -x '*.map' a/vs/editor/contrib/gotoError/browser/gotoErrorWidget.js b/vs/editor/contrib/gotoError/browser/gotoErrorWidget.js
--- a/vs/editor/contrib/gotoError/browser/gotoErrorWidget.js	2023-09-05 08:43:04.310810495 +0000
+++ b/vs/editor/contrib/gotoError/browser/gotoErrorWidget.js	2023-09-05 08:45:14.365197322 +0000
@@ -243,6 +243,9 @@
         this._callOnDispose.dispose();
         super.dispose();
     }
+    focus() {
+        this._parentContainer.focus();
+    }
     _fillHead(container) {
         super._fillHead(container);
         this._disposables.add(this._actionbarWidget.actionRunner.onWillRun(e => this.editor.focus()));
diff -urN -x '*.map' a/vs/editor/contrib/gotoError/browser/markerNavigationService.js b/vs/editor/contrib/gotoError/browser/markerNavigationService.js
--- a/vs/editor/contrib/gotoError/browser/markerNavigationService.js	2023-09-05 08:43:04.310810495 +0000
+++ b/vs/editor/contrib/gotoError/browser/markerNavigationService.js	2023-09-05 08:45:14.365197322 +0000
@@ -13,7 +13,7 @@
 };
 import { binarySearch } from '../../../../base/common/arrays.js';
 import { Emitter } from '../../../../base/common/event.js';
-import { DisposableStore } from '../../../../base/common/lifecycle.js';
+import { DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';
 import { LinkedList } from '../../../../base/common/linkedList.js';
 import { compare } from '../../../../base/common/strings.js';
 import { URI } from '../../../../base/common/uri.js';
@@ -174,6 +174,10 @@
         this._configService = _configService;
         this._provider = new LinkedList();
     }
+    registerProvider(provider) {
+        const remove = this._provider.unshift(provider);
+        return toDisposable(() => remove());
+    }
     getMarkerList(resource) {
         for (const provider of this._provider) {
             const result = provider.getMarkerList(resource);
diff -urN -x '*.map' a/vs/editor/contrib/gotoSymbol/browser/peek/referencesTree.js b/vs/editor/contrib/gotoSymbol/browser/peek/referencesTree.js
--- a/vs/editor/contrib/gotoSymbol/browser/peek/referencesTree.js	2023-09-05 08:43:04.306810402 +0000
+++ b/vs/editor/contrib/gotoSymbol/browser/peek/referencesTree.js	2023-09-05 08:45:14.365197322 +0000
@@ -88,6 +88,9 @@
         // FileReferences or unresolved OneReference
         return basename(element.uri);
     }
+    mightProducePrintableCharacter(event) {
+        return this._keybindingService.mightProducePrintableCharacter(event);
+    }
 };
 StringRepresentationProvider = __decorate([
     __param(0, IKeybindingService)
diff -urN -x '*.map' a/vs/editor/contrib/hover/browser/contentHover.js b/vs/editor/contrib/hover/browser/contentHover.js
--- a/vs/editor/contrib/hover/browser/contentHover.js	2023-09-05 08:43:04.314810588 +0000
+++ b/vs/editor/contrib/hover/browser/contentHover.js	2023-09-05 08:45:14.365197322 +0000
@@ -29,6 +29,13 @@
 import { ResizableContentWidget } from './resizableContentWidget.js';
 const $ = dom.$;
 let ContentHoverController = class ContentHoverController extends Disposable {
+    getWidgetContent() {
+        const node = this._widget.getDomNode();
+        if (!node.textContent) {
+            return undefined;
+        }
+        return node.textContent;
+    }
     constructor(_editor, _instantiationService, _keybindingService) {
         super();
         this._editor = _editor;
diff -urN -x '*.map' a/vs/editor/contrib/hover/browser/hover.js b/vs/editor/contrib/hover/browser/hover.js
--- a/vs/editor/contrib/hover/browser/hover.js	2023-09-05 08:43:04.314810588 +0000
+++ b/vs/editor/contrib/hover/browser/hover.js	2023-09-05 08:45:14.365197322 +0000
@@ -37,6 +37,7 @@
 // sticky hover widget which doesn't disappear on focus out and such
 const _sticky = false;
 let ModesHoverController = class ModesHoverController {
+    getWidgetContent() { var _a; return (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.getWidgetContent(); }
     static get(editor) {
         return editor.getContribution(ModesHoverController.ID);
     }
diff -urN -x '*.map' a/vs/editor/contrib/inlayHints/browser/inlayHintsController.js b/vs/editor/contrib/inlayHints/browser/inlayHintsController.js
--- a/vs/editor/contrib/inlayHints/browser/inlayHintsController.js	2023-09-05 08:43:04.362811708 +0000
+++ b/vs/editor/contrib/inlayHints/browser/inlayHintsController.js	2023-09-05 08:45:14.369197379 +0000
@@ -547,6 +547,22 @@
         }
         this._decorationsMetadata.clear();
     }
+    // --- accessibility
+    getInlayHintsForLine(line) {
+        if (!this._editor.hasModel()) {
+            return [];
+        }
+        const set = new Set();
+        const result = [];
+        for (const deco of this._editor.getLineDecorations(line)) {
+            const data = this._decorationsMetadata.get(deco.id);
+            if (data && !set.has(data.item.hint)) {
+                set.add(data.item.hint);
+                result.push(data.item);
+            }
+        }
+        return result;
+    }
 };
 InlayHintsController.ID = 'editor.contrib.InlayHints';
 InlayHintsController._MAX_DECORATORS = 1500;
diff -urN -x '*.map' a/vs/editor/contrib/inlineCompletions/browser/ghostText.js b/vs/editor/contrib/inlineCompletions/browser/ghostText.js
--- a/vs/editor/contrib/inlineCompletions/browser/ghostText.js	2023-09-05 08:43:04.302810309 +0000
+++ b/vs/editor/contrib/inlineCompletions/browser/ghostText.js	2023-09-05 08:45:14.361197265 +0000
@@ -1,9 +1,31 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { Range } from '../../../common/core/range.js';
 import { applyEdits } from './utils.js';
 export class GhostText {
     constructor(lineNumber, parts) {
         this.lineNumber = lineNumber;
         this.parts = parts;
     }
+    equals(other) {
+        return this.lineNumber === other.lineNumber &&
+            this.parts.length === other.parts.length &&
+            this.parts.every((part, index) => part.equals(other.parts[index]));
+    }
+    /**
+     * Only used for testing/debugging.
+    */
+    render(documentText, debug = false) {
+        const l = this.lineNumber;
+        return applyEdits(documentText, [
+            ...this.parts.map(p => ({
+                range: { startLineNumber: l, endLineNumber: l, startColumn: p.column, endColumn: p.column },
+                text: debug ? `[${p.lines.join('\n')}]` : p.lines.join('\n')
+            })),
+        ]);
+    }
     renderForScreenReader(lineText) {
         if (this.parts.length === 0) {
             return '';
@@ -33,6 +55,11 @@
         this.lines = lines;
         this.preview = preview;
     }
+    equals(other) {
+        return this.column === other.column &&
+            this.lines.length === other.lines.length &&
+            this.lines.every((line, index) => line === other.lines[index]);
+    }
 }
 export class GhostTextReplacement {
     constructor(lineNumber, columnRange, newLines, additionalReservedLineCount = 0) {
@@ -47,6 +74,20 @@
     renderForScreenReader(_lineText) {
         return this.newLines.join('\n');
     }
+    render(documentText, debug = false) {
+        const replaceRange = this.columnRange.toRange(this.lineNumber);
+        if (debug) {
+            return applyEdits(documentText, [
+                { range: Range.fromPositions(replaceRange.getStartPosition()), text: `(` },
+                { range: Range.fromPositions(replaceRange.getEndPosition()), text: `)[${this.newLines.join('\n')}]` }
+            ]);
+        }
+        else {
+            return applyEdits(documentText, [
+                { range: replaceRange, text: this.newLines.join('\n') }
+            ]);
+        }
+    }
     get lineCount() {
         return this.newLines.length;
     }
diff -urN -x '*.map' a/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsController.js b/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsController.js
--- a/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsController.js	2023-09-05 08:43:04.302810309 +0000
+++ b/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsController.js	2023-09-05 08:45:14.361197265 +0000
@@ -188,6 +188,12 @@
     shouldShowHoverAtViewZone(viewZoneId) {
         return this.ghostTextWidget.ownsViewZone(viewZoneId);
     }
+    hide() {
+        transaction(tx => {
+            var _a;
+            (_a = this.model.get()) === null || _a === void 0 ? void 0 : _a.stop(tx);
+        });
+    }
 };
 InlineCompletionsController.ID = 'editor.contrib.inlineCompletionsController';
 InlineCompletionsController = __decorate([
diff -urN -x '*.map' a/vs/editor/contrib/inlineCompletions/browser/provideInlineCompletions.js b/vs/editor/contrib/inlineCompletions/browser/provideInlineCompletions.js
--- a/vs/editor/contrib/inlineCompletions/browser/provideInlineCompletions.js	2023-09-05 08:43:04.306810402 +0000
+++ b/vs/editor/contrib/inlineCompletions/browser/provideInlineCompletions.js	2023-09-05 08:45:14.357197207 +0000
@@ -18,6 +18,7 @@
 import { onUnexpectedExternalError } from '../../../../base/common/errors.js';
 import { Range } from '../../../common/core/range.js';
 import { fixBracketsInLine } from '../../../common/model/bracketPairsTextModelPart/fixBrackets.js';
+import { SingleTextEdit } from './singleTextEdit.js';
 import { getReadonlyEmptyArray } from './utils.js';
 import { SnippetParser, Text } from '../../snippet/browser/snippetParser.js';
 export function provideInlineCompletions(registry, position, model, context, token = CancellationToken.None, languageConfigurationService) {
@@ -229,6 +230,9 @@
     hash() {
         return JSON.stringify({ insertText: this.insertText, range: this.range.toString() });
     }
+    toSingleTextEdit() {
+        return new SingleTextEdit(this.range, this.insertText);
+    }
 }
 function getDefaultRange(position, model) {
     const word = model.getWordAtPosition(position);
diff -urN -x '*.map' a/vs/editor/contrib/linkedEditing/browser/linkedEditing.js b/vs/editor/contrib/linkedEditing/browser/linkedEditing.js
--- a/vs/editor/contrib/linkedEditing/browser/linkedEditing.js	2023-09-05 08:43:04.322810775 +0000
+++ b/vs/editor/contrib/linkedEditing/browser/linkedEditing.js	2023-09-05 08:45:14.365197322 +0000
@@ -205,6 +205,12 @@
             this._currentRequestPosition = null;
         }
     }
+    get currentUpdateTriggerPromise() {
+        return this._rangeUpdateTriggerPromise || Promise.resolve();
+    }
+    get currentSyncTriggerPromise() {
+        return this._rangeSyncTriggerPromise || Promise.resolve();
+    }
     updateRanges(force = false) {
         return __awaiter(this, void 0, void 0, function* () {
             if (!this._editor.hasModel()) {
@@ -287,6 +293,10 @@
             return request;
         });
     }
+    // for testing
+    setDebounceDuration(timeInMS) {
+        this._debounceDuration = timeInMS;
+    }
 };
 LinkedEditingContribution.ID = 'editor.contrib.linkedEditing';
 LinkedEditingContribution.DECORATION = ModelDecorationOptions.register({
diff -urN -x '*.map' a/vs/editor/contrib/longLinesHelper/browser/longLinesHelper.js b/vs/editor/contrib/longLinesHelper/browser/longLinesHelper.js
--- a/vs/editor/contrib/longLinesHelper/browser/longLinesHelper.js	2023-09-05 08:43:04.366811801 +0000
+++ b/vs/editor/contrib/longLinesHelper/browser/longLinesHelper.js	2023-09-05 08:45:14.357197207 +0000
@@ -5,6 +5,9 @@
 import { Disposable } from '../../../../base/common/lifecycle.js';
 import { registerEditorContribution } from '../../../browser/editorExtensions.js';
 class LongLinesHelper extends Disposable {
+    static get(editor) {
+        return editor.getContribution(LongLinesHelper.ID);
+    }
     constructor(_editor) {
         super();
         this._editor = _editor;
diff -urN -x '*.map' a/vs/editor/contrib/message/browser/messageController.js b/vs/editor/contrib/message/browser/messageController.js
--- a/vs/editor/contrib/message/browser/messageController.js	2023-09-05 08:43:04.326810868 +0000
+++ b/vs/editor/contrib/message/browser/messageController.js	2023-09-05 08:45:14.385197609 +0000
@@ -43,6 +43,9 @@
         this._messageWidget.dispose();
         this._visible.reset();
     }
+    isVisible() {
+        return this._visible.get();
+    }
     showMessage(message, position) {
         alert(isMarkdownString(message) ? message.value : message);
         this._visible.set(true);
diff -urN -x '*.map' a/vs/editor/contrib/multicursor/browser/multicursor.js b/vs/editor/contrib/multicursor/browser/multicursor.js
--- a/vs/editor/contrib/multicursor/browser/multicursor.js	2023-09-05 08:43:04.370811894 +0000
+++ b/vs/editor/contrib/multicursor/browser/multicursor.js	2023-09-05 08:45:14.365197322 +0000
@@ -550,6 +550,11 @@
             this._setSelections(matches.map(m => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn)));
         }
     }
+    selectAllUsingSelections(selections) {
+        if (selections.length > 0) {
+            this._setSelections(selections);
+        }
+    }
 }
 MultiCursorSelectionController.ID = 'editor.contrib.multiCursorController';
 export class MultiCursorSelectionControllerAction extends EditorAction {
diff -urN -x '*.map' a/vs/editor/contrib/semanticTokens/browser/viewportSemanticTokens.js b/vs/editor/contrib/semanticTokens/browser/viewportSemanticTokens.js
--- a/vs/editor/contrib/semanticTokens/browser/viewportSemanticTokens.js	2023-09-05 08:43:04.354811521 +0000
+++ b/vs/editor/contrib/semanticTokens/browser/viewportSemanticTokens.js	2023-09-05 08:45:14.381197551 +0000
@@ -24,6 +24,9 @@
 import { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';
 import { ISemanticTokensStylingService } from '../../../common/services/semanticTokensStyling.js';
 let ViewportSemanticTokensContribution = class ViewportSemanticTokensContribution extends Disposable {
+    static get(editor) {
+        return editor.getContribution(ViewportSemanticTokensContribution.ID);
+    }
     constructor(editor, _semanticTokensStylingService, _themeService, _configurationService, languageFeatureDebounceService, languageFeaturesService) {
         super();
         this._semanticTokensStylingService = _semanticTokensStylingService;
diff -urN -x '*.map' a/vs/editor/contrib/snippet/browser/snippetController2.js b/vs/editor/contrib/snippet/browser/snippetController2.js
--- a/vs/editor/contrib/snippet/browser/snippetController2.js	2023-09-05 08:43:04.334811055 +0000
+++ b/vs/editor/contrib/snippet/browser/snippetController2.js	2023-09-05 08:45:14.357197207 +0000
@@ -55,6 +55,18 @@
         (_a = this._session) === null || _a === void 0 ? void 0 : _a.dispose();
         this._snippetListener.dispose();
     }
+    apply(edits, opts) {
+        try {
+            this._doInsert(edits, typeof opts === 'undefined' ? _defaultOptions : Object.assign(Object.assign({}, _defaultOptions), opts));
+        }
+        catch (e) {
+            this.cancel();
+            this._logService.error(e);
+            this._logService.error('snippet_error');
+            this._logService.error('insert_edits=', edits);
+            this._logService.error('existing_template=', this._session ? this._session._logInfo() : '<no_session>');
+        }
+    }
     insert(template, opts) {
         // this is here to find out more about the yet-not-understood
         // error that sometimes happens when we fail to inserted a nested
@@ -233,6 +245,12 @@
     isInSnippet() {
         return Boolean(this._inSnippet.get());
     }
+    getSessionEnclosingRange() {
+        if (this._session) {
+            return this._session.getEnclosingRange();
+        }
+        return undefined;
+    }
 };
 SnippetController2.ID = 'snippetController2';
 SnippetController2.InSnippetMode = new RawContextKey('inSnippetMode', false, localize('inSnippetMode', "Whether the editor in current in snippet mode"));
diff -urN -x '*.map' a/vs/editor/contrib/snippet/browser/snippetParser.js b/vs/editor/contrib/snippet/browser/snippetParser.js
--- a/vs/editor/contrib/snippet/browser/snippetParser.js	2023-09-05 08:43:04.334811055 +0000
+++ b/vs/editor/contrib/snippet/browser/snippetParser.js	2023-09-05 08:45:14.357197207 +0000
@@ -140,6 +140,9 @@
     }
 }
 export class Text extends Marker {
+    static escape(value) {
+        return value.replace(/\$|}|\\/g, '\\$&');
+    }
     constructor(value) {
         super();
         this.value = value;
@@ -147,6 +150,9 @@
     toString() {
         return this.value;
     }
+    toTextmateString() {
+        return Text.escape(this.value);
+    }
     len() {
         return this.value.length;
     }
@@ -189,6 +195,24 @@
             ? this._children[0]
             : undefined;
     }
+    toTextmateString() {
+        let transformString = '';
+        if (this.transform) {
+            transformString = this.transform.toTextmateString();
+        }
+        if (this.children.length === 0 && !this.transform) {
+            return `\$${this.index}`;
+        }
+        else if (this.children.length === 0) {
+            return `\${${this.index}${transformString}}`;
+        }
+        else if (this.choice) {
+            return `\${${this.index}|${this.choice.toTextmateString()}|${transformString}}`;
+        }
+        else {
+            return `\${${this.index}:${this.children.map(child => child.toTextmateString()).join('')}${transformString}}`;
+        }
+    }
     clone() {
         const ret = new Placeholder(this.index);
         if (this.transform) {
@@ -213,6 +237,11 @@
     toString() {
         return this.options[0].value;
     }
+    toTextmateString() {
+        return this.options
+            .map(option => option.value.replace(/\||,|\\/g, '\\$&'))
+            .join(',');
+    }
     len() {
         return this.options[0].len();
     }
@@ -258,6 +287,9 @@
     toString() {
         return '';
     }
+    toTextmateString() {
+        return `/${this.regexp.source}/${this.children.map(c => c.toTextmateString())}/${(this.regexp.ignoreCase ? 'i' : '') + (this.regexp.global ? 'g' : '')}`;
+    }
     clone() {
         const ret = new Transform();
         ret.regexp = new RegExp(this.regexp.source, '' + (this.regexp.ignoreCase ? 'i' : '') + (this.regexp.global ? 'g' : ''));
@@ -322,6 +354,24 @@
         })
             .join('');
     }
+    toTextmateString() {
+        let value = '${';
+        value += this.index;
+        if (this.shorthandName) {
+            value += `:/${this.shorthandName}`;
+        }
+        else if (this.ifValue && this.elseValue) {
+            value += `:?${this.ifValue}:${this.elseValue}`;
+        }
+        else if (this.ifValue) {
+            value += `:+${this.ifValue}`;
+        }
+        else if (this.elseValue) {
+            value += `:-${this.elseValue}`;
+        }
+        value += '}';
+        return value;
+    }
     clone() {
         const ret = new FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);
         return ret;
@@ -343,6 +393,18 @@
         }
         return false;
     }
+    toTextmateString() {
+        let transformString = '';
+        if (this.transform) {
+            transformString = this.transform.toTextmateString();
+        }
+        if (this.children.length === 0) {
+            return `\${${this.name}${transformString}}`;
+        }
+        else {
+            return `\${${this.name}:${this.children.map(child => child.toTextmateString()).join('')}${transformString}}`;
+        }
+    }
     clone() {
         const ret = new Variable(this.name);
         if (this.transform) {
@@ -438,6 +500,9 @@
         this._placeholders = undefined;
         return super.replace(child, others);
     }
+    toTextmateString() {
+        return this.children.reduce((prev, cur) => prev + cur.toTextmateString(), '');
+    }
     clone() {
         const ret = new TextmateSnippet();
         this._children = this.children.map(child => child.clone());
@@ -455,6 +520,13 @@
     static escape(value) {
         return value.replace(/\$|}|\\/g, '\\$&');
     }
+    /**
+     * Takes a snippet and returns the insertable string, e.g return the snippet-string
+     * without any placeholder, tabstop, variables etc...
+     */
+    static asInsertText(value) {
+        return new SnippetParser().parse(value).toString();
+    }
     static guessNeedsClipboard(template) {
         return /\${?CLIPBOARD/.test(template);
     }
diff -urN -x '*.map' a/vs/editor/contrib/snippet/browser/snippetSession.js b/vs/editor/contrib/snippet/browser/snippetSession.js
--- a/vs/editor/contrib/snippet/browser/snippetSession.js	2023-09-05 08:43:04.334811055 +0000
+++ b/vs/editor/contrib/snippet/browser/snippetSession.js	2023-09-05 08:45:14.357197207 +0000
@@ -14,6 +14,7 @@
 import { groupBy } from '../../../../base/common/arrays.js';
 import { dispose } from '../../../../base/common/lifecycle.js';
 import { getLeadingWhitespace } from '../../../../base/common/strings.js';
+import { withNullAsUndefined } from '../../../../base/common/types.js';
 import './snippetSession.css';
 import { EditOperation } from '../../../common/core/editOperation.js';
 import { Range } from '../../../common/core/range.js';
@@ -280,6 +281,20 @@
             this._placeholderGroups = groupBy(this._snippet.placeholders, Placeholder.compareByIndex);
         });
     }
+    getEnclosingRange() {
+        let result;
+        const model = this._editor.getModel();
+        for (const decorationId of this._placeholderDecorations.values()) {
+            const placeholderRange = withNullAsUndefined(model.getDecorationRange(decorationId));
+            if (!result) {
+                result = placeholderRange;
+            }
+            else {
+                result = result.plusRange(placeholderRange);
+            }
+        }
+        return result;
+    }
 }
 OneSnippet._decor = {
     active: ModelDecorationOptions.register({ description: 'snippet-placeholder-1', stickiness: 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */, className: 'snippet-placeholder' }),
@@ -642,6 +657,19 @@
         // have any left, we don't have a selection anymore
         return allPossibleSelections.size > 0;
     }
+    getEnclosingRange() {
+        let result;
+        for (const snippet of this._snippets) {
+            const snippetRange = snippet.getEnclosingRange();
+            if (!result) {
+                result = snippetRange;
+            }
+            else {
+                result = result.plusRange(snippetRange);
+            }
+        }
+        return result;
+    }
 };
 SnippetSession = __decorate([
     __param(3, ILanguageConfigurationService)
diff -urN -x '*.map' a/vs/editor/contrib/stickyScroll/browser/stickyScrollController.js b/vs/editor/contrib/stickyScroll/browser/stickyScrollController.js
--- a/vs/editor/contrib/stickyScroll/browser/stickyScrollController.js	2023-09-05 08:43:04.334811055 +0000
+++ b/vs/editor/contrib/stickyScroll/browser/stickyScrollController.js	2023-09-05 08:45:14.381197551 +0000
@@ -95,6 +95,12 @@
             this._onMouseDown = true;
         }));
     }
+    get stickyScrollCandidateProvider() {
+        return this._stickyLineCandidateProvider;
+    }
+    get stickyScrollWidgetState() {
+        return this._widgetState;
+    }
     static get(editor) {
         return editor.getContribution(StickyScrollController.ID);
     }
diff -urN -x '*.map' a/vs/editor/contrib/stickyScroll/browser/stickyScrollModelProvider.js b/vs/editor/contrib/stickyScroll/browser/stickyScrollModelProvider.js
--- a/vs/editor/contrib/stickyScroll/browser/stickyScrollModelProvider.js	2023-09-05 08:43:04.334811055 +0000
+++ b/vs/editor/contrib/stickyScroll/browser/stickyScrollModelProvider.js	2023-09-05 08:45:14.381197551 +0000
@@ -170,6 +170,9 @@
         super();
         this._languageFeaturesService = _languageFeaturesService;
     }
+    get provider() {
+        return this._languageFeaturesService.documentSymbolProvider;
+    }
     createModelFromProvider(textModel, modelVersionId, token) {
         return OutlineModel.create(this._languageFeaturesService.documentSymbolProvider, textModel, token);
     }
@@ -306,6 +309,9 @@
         super(editor);
         this._languageConfigurationService = _languageConfigurationService;
     }
+    get provider() {
+        return null;
+    }
     createModelFromProvider(textModel, modelVersionId, token) {
         const provider = new IndentRangeProvider(textModel, this._languageConfigurationService, this._foldingLimitReporter);
         return provider.compute(token);
@@ -319,6 +325,9 @@
         super(editor);
         this._languageFeaturesService = _languageFeaturesService;
     }
+    get provider() {
+        return this._languageFeaturesService.foldingRangeProvider;
+    }
     isProviderValid(textModel) {
         const selectedProviders = FoldingController.getFoldingRangeProviders(this._languageFeaturesService, textModel);
         return selectedProviders.length > 0;
diff -urN -x '*.map' a/vs/editor/contrib/stickyScroll/browser/stickyScrollProvider.js b/vs/editor/contrib/stickyScroll/browser/stickyScrollProvider.js
--- a/vs/editor/contrib/stickyScroll/browser/stickyScrollProvider.js	2023-09-05 08:43:04.334811055 +0000
+++ b/vs/editor/contrib/stickyScroll/browser/stickyScrollProvider.js	2023-09-05 08:45:14.381197551 +0000
@@ -22,7 +22,7 @@
 };
 import { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';
 import { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';
-import { CancellationTokenSource } from '../../../../base/common/cancellation.js';
+import { CancellationTokenSource, } from '../../../../base/common/cancellation.js';
 import { RunOnceScheduler } from '../../../../base/common/async.js';
 import { binarySearch } from '../../../../base/common/arrays.js';
 import { isEqual } from '../../../../base/common/resources.js';
@@ -165,6 +165,7 @@
         return stickyLineCandidates;
     }
 };
+StickyLineCandidateProvider.ID = 'store.contrib.stickyScrollController';
 StickyLineCandidateProvider = __decorate([
     __param(1, ILanguageFeaturesService),
     __param(2, ILanguageConfigurationService)
diff -urN -x '*.map' a/vs/editor/contrib/stickyScroll/browser/stickyScrollWidget.js b/vs/editor/contrib/stickyScroll/browser/stickyScrollWidget.js
--- a/vs/editor/contrib/stickyScroll/browser/stickyScrollWidget.js	2023-09-05 08:43:04.338811148 +0000
+++ b/vs/editor/contrib/stickyScroll/browser/stickyScrollWidget.js	2023-09-05 08:45:14.381197551 +0000
@@ -44,6 +44,9 @@
     get lineNumbers() {
         return this._lineNumbers;
     }
+    get codeLineCount() {
+        return this._lineNumbers.length;
+    }
     getCurrentLines() {
         return this._lineNumbers;
     }
diff -urN -x '*.map' a/vs/editor/contrib/suggest/browser/suggest.js b/vs/editor/contrib/suggest/browser/suggest.js
--- a/vs/editor/contrib/suggest/browser/suggest.js	2023-09-05 08:43:04.338811148 +0000
+++ b/vs/editor/contrib/suggest/browser/suggest.js	2023-09-05 08:45:14.361197265 +0000
@@ -133,6 +133,11 @@
 export function getSnippetSuggestSupport() {
     return _snippetSuggestSupport;
 }
+export function setSnippetSuggestSupport(support) {
+    const old = _snippetSuggestSupport;
+    _snippetSuggestSupport = support;
+    return old;
+}
 export class CompletionItemModel {
     constructor(items, needsClipboard, durations, disposable) {
         this.items = items;
diff -urN -x '*.map' a/vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter.js b/vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter.js
--- a/vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter.js	2023-09-05 08:43:04.282809842 +0000
+++ b/vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter.js	2023-09-05 08:45:14.377197494 +0000
@@ -345,6 +345,18 @@
         };
     }
 }
+export class UnicodeHighlighterHover {
+    constructor(owner, range, decoration) {
+        this.owner = owner;
+        this.range = range;
+        this.decoration = decoration;
+    }
+    isValidForHoverAnchor(anchor) {
+        return (anchor.type === 1 /* HoverAnchorType.Range */
+            && this.range.startColumn <= anchor.range.startColumn
+            && this.range.endColumn >= anchor.range.endColumn);
+    }
+}
 let UnicodeHighlighterHoverParticipant = class UnicodeHighlighterHoverParticipant {
     constructor(_editor, _languageService, _openerService) {
         this._editor = _editor;
@@ -491,6 +503,7 @@
         });
     }
 }
+DisableHighlightingInCommentsAction.ID = 'editor.action.unicodeHighlight.disableHighlightingInComments';
 export class DisableHighlightingInStringsAction extends EditorAction {
     constructor() {
         super({
@@ -515,6 +528,7 @@
         });
     }
 }
+DisableHighlightingInStringsAction.ID = 'editor.action.unicodeHighlight.disableHighlightingInStrings';
 export class DisableHighlightingOfAmbiguousCharactersAction extends EditorAction {
     constructor() {
         super({
diff -urN -x '*.map' a/vs/editor/contrib/wordHighlighter/browser/wordHighlighter.js b/vs/editor/contrib/wordHighlighter/browser/wordHighlighter.js
--- a/vs/editor/contrib/wordHighlighter/browser/wordHighlighter.js	2023-09-05 08:43:04.314810588 +0000
+++ b/vs/editor/contrib/wordHighlighter/browser/wordHighlighter.js	2023-09-05 08:45:14.365197322 +0000
@@ -16,7 +16,7 @@
 import { createCancelablePromise, first, timeout } from '../../../../base/common/async.js';
 import { CancellationToken } from '../../../../base/common/cancellation.js';
 import { onUnexpectedError, onUnexpectedExternalError } from '../../../../base/common/errors.js';
-import { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';
+import { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';
 import { EditorAction, registerEditorAction, registerEditorContribution, registerModelAndPositionCommand } from '../../../browser/editorExtensions.js';
 import { Range } from '../../../common/core/range.js';
 import { EditorContextKeys } from '../../../common/editorContextKeys.js';
@@ -183,6 +183,12 @@
         }
         this._run();
     }
+    stop() {
+        if (!this.occurrencesHighlight) {
+            return;
+        }
+        this._stopAll();
+    }
     _getSortedHighlights() {
         return (this.decorations.getRanges()
             .sort(Range.compareRangesUsingStarts));
@@ -409,6 +415,22 @@
             this.wordHighlighter.restore();
         }
     }
+    stopHighlighting() {
+        var _a;
+        (_a = this.wordHighlighter) === null || _a === void 0 ? void 0 : _a.stop();
+    }
+    linkWordHighlighters(editor) {
+        const other = WordHighlighterContribution.get(editor);
+        if (!other) {
+            return Disposable.None;
+        }
+        this.linkedContributions.add(other);
+        other.linkedContributions.add(this);
+        return toDisposable(() => {
+            this.linkedContributions.delete(other);
+            other.linkedContributions.delete(this);
+        });
+    }
     dispose() {
         if (this.wordHighlighter) {
             this.wordHighlighter.dispose();
diff -urN -x '*.map' a/vs/editor/contrib/zoneWidget/browser/zoneWidget.js b/vs/editor/contrib/zoneWidget/browser/zoneWidget.js
--- a/vs/editor/contrib/zoneWidget/browser/zoneWidget.js	2023-09-05 08:43:04.342811241 +0000
+++ b/vs/editor/contrib/zoneWidget/browser/zoneWidget.js	2023-09-05 08:45:14.377197494 +0000
@@ -210,6 +210,9 @@
         }
         return range.getStartPosition();
     }
+    hasFocus() {
+        return this.domNode.contains(dom.getActiveElement());
+    }
     show(rangeOrPos, heightInLines) {
         const range = Range.isIRange(rangeOrPos) ? Range.lift(rangeOrPos) : Range.fromPositions(rangeOrPos);
         this._isShowing = true;
diff -urN -x '*.map' a/vs/editor/editor.main.js b/vs/editor/editor.main.js
--- a/vs/editor/editor.main.js	2023-09-05 08:43:04.486814599 +0000
+++ b/vs/editor/editor.main.js	2023-09-05 08:45:14.317196634 +0000
@@ -1,7 +1,7 @@
-import '../basic-languages/monaco.contribution';
-import '../language/css/monaco.contribution';
-import '../language/html/monaco.contribution';
-import '../language/json/monaco.contribution';
-import '../language/typescript/monaco.contribution';
-
-export * from './edcore.main';
\ No newline at end of file
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import './editor.all.js';
+import './standalone/browser/iPadShowKeyboard/iPadShowKeyboard.js';
+export * from './editor.api.js';
diff -urN -x '*.map' a/vs/editor/standalone/browser/quickInput/standaloneQuickInputService.js b/vs/editor/standalone/browser/quickInput/standaloneQuickInputService.js
--- a/vs/editor/standalone/browser/quickInput/standaloneQuickInputService.js	2023-09-05 08:43:04.418813013 +0000
+++ b/vs/editor/standalone/browser/quickInput/standaloneQuickInputService.js	2023-09-05 08:45:14.333196864 +0000
@@ -73,6 +73,9 @@
         return quickInputService;
     }
     get quickAccess() { return this.activeService.quickAccess; }
+    get backButton() { return this.activeService.backButton; }
+    get onShow() { return this.activeService.onShow; }
+    get onHide() { return this.activeService.onHide; }
     constructor(instantiationService, codeEditorService) {
         this.instantiationService = instantiationService;
         this.codeEditorService = codeEditorService;
@@ -81,12 +84,33 @@
     pick(picks, options = {}, token = CancellationToken.None) {
         return this.activeService /* TS fail */.pick(picks, options, token);
     }
+    input(options, token) {
+        return this.activeService.input(options, token);
+    }
     createQuickPick() {
         return this.activeService.createQuickPick();
     }
     createInputBox() {
         return this.activeService.createInputBox();
     }
+    focus() {
+        return this.activeService.focus();
+    }
+    toggle() {
+        return this.activeService.toggle();
+    }
+    navigate(next, quickNavigate) {
+        return this.activeService.navigate(next, quickNavigate);
+    }
+    accept() {
+        return this.activeService.accept();
+    }
+    back() {
+        return this.activeService.back();
+    }
+    cancel() {
+        return this.activeService.cancel();
+    }
 };
 StandaloneQuickInputService = __decorate([
     __param(0, IInstantiationService),
diff -urN -x '*.map' a/vs/editor/standalone/browser/standaloneServices.js b/vs/editor/standalone/browser/standaloneServices.js
--- a/vs/editor/standalone/browser/standaloneServices.js	2023-09-05 08:43:04.426813200 +0000
+++ b/vs/editor/standalone/browser/standaloneServices.js	2023-09-05 08:45:14.333196864 +0000
@@ -30,7 +30,7 @@
 import * as strings from '../../../base/common/strings.js';
 import * as dom from '../../../base/browser/dom.js';
 import { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';
-import { Emitter } from '../../../base/common/event.js';
+import { Emitter, Event } from '../../../base/common/event.js';
 import { KeyCodeChord, decodeKeybinding } from '../../../base/common/keybindings.js';
 import { ImmortalReference, toDisposable, DisposableStore, Disposable, combinedDisposable } from '../../../base/common/lifecycle.js';
 import { OS, isLinux, isMacintosh } from '../../../base/common/platform.js';
@@ -110,13 +110,34 @@
         this.model = model;
         this._onWillDispose = new Emitter();
     }
+    get onWillDispose() {
+        return this._onWillDispose.event;
+    }
+    resolve() {
+        return Promise.resolve();
+    }
     get textEditorModel() {
         return this.model;
     }
+    createSnapshot() {
+        return this.model.createSnapshot();
+    }
+    isReadonly() {
+        return false;
+    }
     dispose() {
         this.disposed = true;
         this._onWillDispose.fire();
     }
+    isDisposed() {
+        return this.disposed;
+    }
+    isResolved() {
+        return true;
+    }
+    getLanguageId() {
+        return this.model.getLanguageId();
+    }
 }
 let StandaloneTextModelService = class StandaloneTextModelService {
     constructor(modelService) {
@@ -129,6 +150,14 @@
         }
         return Promise.resolve(new ImmortalReference(new SimpleModel(model)));
     }
+    registerTextModelContentProvider(scheme, provider) {
+        return {
+            dispose: function () { }
+        };
+    }
+    canHandleResource(resource) {
+        return false;
+    }
 };
 StandaloneTextModelService = __decorate([
     __param(0, IModelService)
@@ -157,11 +186,40 @@
 }
 class StandaloneEnvironmentService {
     constructor() {
+        this.stateResource = URI.from({ scheme: 'monaco', authority: 'stateResource' });
+        this.userRoamingDataHome = URI.from({ scheme: 'monaco', authority: 'userRoamingDataHome' });
+        this.keyboardLayoutResource = URI.from({ scheme: 'monaco', authority: 'keyboardLayoutResource' });
+        this.argvResource = URI.from({ scheme: 'monaco', authority: 'argvResource' });
+        this.untitledWorkspacesHome = URI.from({ scheme: 'monaco', authority: 'untitledWorkspacesHome' });
+        this.workspaceStorageHome = URI.from({ scheme: 'monaco', authority: 'workspaceStorageHome' });
+        this.localHistoryHome = URI.from({ scheme: 'monaco', authority: 'localHistoryHome' });
+        this.cacheHome = URI.from({ scheme: 'monaco', authority: 'cacheHome' });
+        this.userDataSyncHome = URI.from({ scheme: 'monaco', authority: 'userDataSyncHome' });
+        this.sync = undefined;
+        this.continueOn = undefined;
+        this.editSessionId = undefined;
+        this.debugExtensionHost = { port: null, break: false };
         this.isExtensionDevelopment = false;
+        this.disableExtensions = false;
+        this.enableExtensions = undefined;
+        this.extensionDevelopmentLocationURI = undefined;
+        this.extensionDevelopmentKind = undefined;
+        this.extensionTestsLocationURI = undefined;
+        this.logsHome = URI.from({ scheme: 'monaco', authority: 'logsHome' });
+        this.logLevel = undefined;
+        this.extensionLogLevel = undefined;
+        this.verbose = false;
         this.isBuilt = false;
+        this.disableTelemetry = false;
+        this.serviceMachineIdResource = URI.from({ scheme: 'monaco', authority: 'serviceMachineIdResource' });
+        this.policyFile = undefined;
     }
 }
 class StandaloneDialogService {
+    constructor() {
+        this.onWillShowDialog = Event.None;
+        this.onDidShowDialog = Event.None;
+    }
     confirm(confirmation) {
         return __awaiter(this, void 0, void 0, function* () {
             const confirmed = this.doConfirm(confirmation.message, confirmation.detail);
@@ -193,13 +251,35 @@
             return { result };
         });
     }
+    info(message, detail) {
+        return __awaiter(this, void 0, void 0, function* () {
+            yield this.prompt({ type: Severity.Info, message, detail });
+        });
+    }
+    warn(message, detail) {
+        return __awaiter(this, void 0, void 0, function* () {
+            yield this.prompt({ type: Severity.Warning, message, detail });
+        });
+    }
     error(message, detail) {
         return __awaiter(this, void 0, void 0, function* () {
             yield this.prompt({ type: Severity.Error, message, detail });
         });
     }
+    input() {
+        return Promise.resolve({ confirmed: false }); // unsupported
+    }
+    about() {
+        return Promise.resolve(undefined);
+    }
 }
 export class StandaloneNotificationService {
+    constructor() {
+        this.onDidAddNotification = Event.None;
+        this.onDidRemoveNotification = Event.None;
+        this.onDidChangeDoNotDisturbMode = Event.None;
+        this.doNotDisturbMode = false;
+    }
     info(message) {
         return this.notify({ severity: Severity.Info, message });
     }
@@ -235,6 +315,7 @@
     constructor(instantiationService) {
         this._onWillExecuteCommand = new Emitter();
         this._onDidExecuteCommand = new Emitter();
+        this.onWillExecuteCommand = this._onWillExecuteCommand.event;
         this.onDidExecuteCommand = this._onDidExecuteCommand.event;
         this._instantiationService = instantiationService;
     }
@@ -358,10 +439,13 @@
         this._cachedResolver = null;
         this._onDidUpdateKeybindings.fire();
     }
+    getUserKeybindingItems() {
+        return this._toNormalizedKeybindingItems(this._dynamicKeybindings, false);
+    }
     _getResolver() {
         if (!this._cachedResolver) {
             const defaults = this._toNormalizedKeybindingItems(KeybindingsRegistry.getDefaultKeybindings(), true);
-            const overrides = this._toNormalizedKeybindingItems(this._dynamicKeybindings, false);
+            const overrides = this.getUserKeybindingItems();
             this._cachedResolver = new KeybindingResolver(defaults, overrides, (str) => this._log(str));
         }
         return this._cachedResolver;
@@ -388,10 +472,25 @@
         }
         return result;
     }
+    resolveKeybinding(keybinding) {
+        return USLayoutResolvedKeybinding.resolveKeybinding(keybinding, OS);
+    }
     resolveKeyboardEvent(keyboardEvent) {
         const chord = new KeyCodeChord(keyboardEvent.ctrlKey, keyboardEvent.shiftKey, keyboardEvent.altKey, keyboardEvent.metaKey, keyboardEvent.keyCode);
         return new USLayoutResolvedKeybinding([chord], OS);
     }
+    resolveUserBinding(userBinding) {
+        return [];
+    }
+    _dumpDebugInfo() {
+        return '';
+    }
+    _dumpDebugInfoJSON() {
+        return '';
+    }
+    registerSchemaContribution(contribution) {
+        // noop
+    }
 };
 StandaloneKeybindingService = __decorate([
     __param(0, IContextKeyService),
@@ -453,6 +552,27 @@
     inspect(key, options = {}) {
         return this._configuration.inspect(key, options, undefined);
     }
+    keys() {
+        return this._configuration.keys(undefined);
+    }
+    reloadConfiguration() {
+        return Promise.resolve(undefined);
+    }
+    getConfigurationData() {
+        const emptyModel = {
+            contents: {},
+            keys: [],
+            overrides: []
+        };
+        return {
+            defaults: emptyModel,
+            policy: emptyModel,
+            application: emptyModel,
+            user: emptyModel,
+            workspace: emptyModel,
+            folders: []
+        };
+    }
 }
 let StandaloneResourceConfigurationService = class StandaloneResourceConfigurationService {
     constructor(configurationService, modelService, languageService) {
@@ -460,6 +580,7 @@
         this.modelService = modelService;
         this.languageService = languageService;
         this._onDidChangeConfiguration = new Emitter();
+        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
         this.configurationService.onDidChangeConfiguration((e) => {
             this._onDidChangeConfiguration.fire({ affectedKeys: e.affectedKeys, affectsConfiguration: (resource, configuration) => e.affectsConfiguration(configuration) });
         });
@@ -479,6 +600,10 @@
             overrideIdentifier: language
         });
     }
+    inspect(resource, position, section) {
+        const language = resource ? this.getLanguage(resource, position) : undefined;
+        return this.configurationService.inspect(section, { resource, overrideIdentifier: language });
+    }
     getLanguage(resource, position) {
         const model = this.modelService.getModel(resource);
         if (model) {
@@ -486,6 +611,9 @@
         }
         return this.languageService.guessLanguageIdByFilepathOrFirstLine(resource);
     }
+    updateValue(resource, key, value, configurationTarget) {
+        return this.configurationService.updateValue(key, value, { resource }, configurationTarget);
+    }
 };
 StandaloneResourceConfigurationService = __decorate([
     __param(0, IConfigurationService),
@@ -508,19 +636,57 @@
     __param(0, IConfigurationService)
 ], StandaloneResourcePropertiesService);
 class StandaloneTelemetryService {
+    constructor() {
+        this.telemetryLevel = 0 /* TelemetryLevel.NONE */;
+        this.sessionId = 'someValue.sessionId';
+        this.machineId = 'someValue.machineId';
+        this.firstSessionDate = 'someValue.firstSessionDate';
+        this.sendErrorTelemetry = false;
+    }
+    setEnabled() { }
+    setExperimentProperty() { }
+    publicLog() { }
     publicLog2() { }
+    publicLogError() { }
+    publicLogError2() { }
 }
 class StandaloneWorkspaceContextService {
     constructor() {
+        this._onDidChangeWorkspaceName = new Emitter();
+        this.onDidChangeWorkspaceName = this._onDidChangeWorkspaceName.event;
+        this._onWillChangeWorkspaceFolders = new Emitter();
+        this.onWillChangeWorkspaceFolders = this._onWillChangeWorkspaceFolders.event;
+        this._onDidChangeWorkspaceFolders = new Emitter();
+        this.onDidChangeWorkspaceFolders = this._onDidChangeWorkspaceFolders.event;
+        this._onDidChangeWorkbenchState = new Emitter();
+        this.onDidChangeWorkbenchState = this._onDidChangeWorkbenchState.event;
         const resource = URI.from({ scheme: StandaloneWorkspaceContextService.SCHEME, authority: 'model', path: '/' });
         this.workspace = { id: STANDALONE_EDITOR_WORKSPACE_ID, folders: [new WorkspaceFolder({ uri: resource, name: '', index: 0 })] };
     }
+    getCompleteWorkspace() {
+        return Promise.resolve(this.getWorkspace());
+    }
     getWorkspace() {
         return this.workspace;
     }
+    getWorkbenchState() {
+        if (this.workspace) {
+            if (this.workspace.configuration) {
+                return 3 /* WorkbenchState.WORKSPACE */;
+            }
+            return 2 /* WorkbenchState.FOLDER */;
+        }
+        return 1 /* WorkbenchState.EMPTY */;
+    }
     getWorkspaceFolder(resource) {
         return resource && resource.scheme === StandaloneWorkspaceContextService.SCHEME ? this.workspace.folders[0] : null;
     }
+    isInsideWorkspace(resource) {
+        return resource && resource.scheme === StandaloneWorkspaceContextService.SCHEME;
+    }
+    isCurrentWorkspace(workspaceIdOrFolder) {
+        return true;
+    }
 }
 StandaloneWorkspaceContextService.SCHEME = 'inmemory';
 export function updateConfigurationService(configurationService, source, isDiffEditor) {
@@ -551,6 +717,9 @@
     hasPreviewHandler() {
         return false;
     }
+    setPreviewHandler() {
+        return Disposable.None;
+    }
     apply(editsIn, _options) {
         return __awaiter(this, void 0, void 0, function* () {
             const edits = Array.isArray(editsIn) ? editsIn : ResourceEdit.convert(editsIn);
@@ -593,6 +762,9 @@
     __param(0, IModelService)
 ], StandaloneBulkEditService);
 class StandaloneUriLabelService {
+    constructor() {
+        this.onDidChangeFormatters = Event.None;
+    }
     getUriLabel(resource, options) {
         if (resource.scheme === 'file') {
             return resource.fsPath;
@@ -602,6 +774,24 @@
     getUriBasenameLabel(resource) {
         return basename(resource);
     }
+    getWorkspaceLabel(workspace, options) {
+        return '';
+    }
+    getSeparator(scheme, authority) {
+        return '/';
+    }
+    registerFormatter(formatter) {
+        throw new Error('Not implemented');
+    }
+    registerCachedFormatter(formatter) {
+        return this.registerFormatter(formatter);
+    }
+    getHostLabel() {
+        return '';
+    }
+    getHostTooltip() {
+        return undefined;
+    }
 }
 let StandaloneContextViewService = class StandaloneContextViewService extends ContextViewService {
     constructor(layoutService, _codeEditorService) {
@@ -626,10 +816,52 @@
     constructor() {
         this._neverEmitter = new Emitter();
         this.onDidChangeTrust = this._neverEmitter.event;
+        this.onDidChangeTrustedFolders = this._neverEmitter.event;
+        this.workspaceResolved = Promise.resolve();
+        this.workspaceTrustInitialized = Promise.resolve();
+        this.acceptsOutOfWorkspaceFiles = true;
     }
     isWorkspaceTrusted() {
         return true;
     }
+    isWorkspaceTrustForced() {
+        return false;
+    }
+    canSetParentFolderTrust() {
+        return false;
+    }
+    setParentFolderTrust(trusted) {
+        return __awaiter(this, void 0, void 0, function* () {
+            // noop
+        });
+    }
+    canSetWorkspaceTrust() {
+        return false;
+    }
+    setWorkspaceTrust(trusted) {
+        return __awaiter(this, void 0, void 0, function* () {
+            // noop
+        });
+    }
+    getUriTrustInfo(uri) {
+        throw new Error('Method not supported.');
+    }
+    setUrisTrust(uri, trusted) {
+        return __awaiter(this, void 0, void 0, function* () {
+            // noop
+        });
+    }
+    getTrustedUris() {
+        return [];
+    }
+    setTrustedUris(uris) {
+        return __awaiter(this, void 0, void 0, function* () {
+            // noop
+        });
+    }
+    addWorkspaceTrustTransitionParticipant(participant) {
+        throw new Error('Method not supported.');
+    }
 }
 class StandaloneLanguageService extends LanguageService {
     constructor() {
@@ -660,6 +892,23 @@
         return __awaiter(this, void 0, void 0, function* () {
         });
     }
+    playAudioCues(cues) {
+        return __awaiter(this, void 0, void 0, function* () {
+        });
+    }
+    isEnabled(cue) {
+        return false;
+    }
+    onEnabledChanged(cue) {
+        return Event.None;
+    }
+    playSound(cue, allowManyInParallel) {
+        return __awaiter(this, void 0, void 0, function* () {
+        });
+    }
+    playAudioCueLoop(cue) {
+        return toDisposable(() => { });
+    }
 }
 registerSingleton(IConfigurationService, StandaloneConfigurationService, 0 /* InstantiationType.Eager */);
 registerSingleton(ITextResourceConfigurationService, StandaloneResourceConfigurationService, 0 /* InstantiationType.Eager */);
diff -urN -x '*.map' a/vs/editor/standalone/browser/standaloneThemeService.js b/vs/editor/standalone/browser/standaloneThemeService.js
--- a/vs/editor/standalone/browser/standaloneThemeService.js	2023-09-05 08:43:04.426813200 +0000
+++ b/vs/editor/standalone/browser/standaloneThemeService.js	2023-09-05 08:45:14.333196864 +0000
@@ -44,6 +44,9 @@
         this.defaultColors = Object.create(null);
         this._tokenTheme = null;
     }
+    get label() {
+        return this.themeName;
+    }
     get base() {
         return this.themeData.base;
     }
@@ -147,6 +150,9 @@
             strikethrough: Boolean(fontStyle & 8 /* FontStyle.Strikethrough */)
         };
     }
+    get tokenColorMap() {
+        return [];
+    }
 }
 function isBuiltinTheme(themeName) {
     return (themeName === VS_LIGHT_THEME_NAME
@@ -175,6 +181,8 @@
         super();
         this._onColorThemeChange = this._register(new Emitter());
         this.onDidColorThemeChange = this._onColorThemeChange.event;
+        this._onFileIconThemeChange = this._register(new Emitter());
+        this.onDidFileIconThemeChange = this._onFileIconThemeChange.event;
         this._onProductIconThemeChange = this._register(new Emitter());
         this.onDidProductIconThemeChange = this._onProductIconThemeChange.event;
         this._environment = Object.create(null);
diff -urN -x '*.map' a/vs/platform/accessibility/browser/accessibilityService.js b/vs/platform/accessibility/browser/accessibilityService.js
--- a/vs/platform/accessibility/browser/accessibilityService.js	2023-09-05 08:43:04.254809155 +0000
+++ b/vs/platform/accessibility/browser/accessibilityService.js	2023-09-05 08:45:14.305196462 +0000
@@ -12,6 +12,7 @@
     return function (target, key) { decorator(target, key, paramIndex); }
 };
 import { addDisposableListener } from '../../../base/browser/dom.js';
+import { alert } from '../../../base/browser/ui/aria/aria.js';
 import { Emitter } from '../../../base/common/event.js';
 import { Disposable } from '../../../base/common/lifecycle.js';
 import { CONTEXT_ACCESSIBILITY_MODE_ENABLED } from '../common/accessibility.js';
@@ -80,9 +81,22 @@
         const config = this._configMotionReduced;
         return config === 'on' || (config === 'auto' && this._systemMotionReduced);
     }
+    alwaysUnderlineAccessKeys() {
+        return Promise.resolve(false);
+    }
     getAccessibilitySupport() {
         return this._accessibilitySupport;
     }
+    setAccessibilitySupport(accessibilitySupport) {
+        if (this._accessibilitySupport === accessibilitySupport) {
+            return;
+        }
+        this._accessibilitySupport = accessibilitySupport;
+        this._onDidChangeScreenReaderOptimized.fire();
+    }
+    alert(message) {
+        alert(message);
+    }
 };
 AccessibilityService = __decorate([
     __param(0, IContextKeyService),
diff -urN -x '*.map' a/vs/platform/accessibility/common/accessibility.js b/vs/platform/accessibility/common/accessibility.js
--- a/vs/platform/accessibility/common/accessibility.js	2023-09-05 08:43:04.254809155 +0000
+++ b/vs/platform/accessibility/common/accessibility.js	2023-09-05 08:45:14.305196462 +0000
@@ -6,3 +6,8 @@
 import { createDecorator } from '../../instantiation/common/instantiation.js';
 export const IAccessibilityService = createDecorator('accessibilityService');
 export const CONTEXT_ACCESSIBILITY_MODE_ENABLED = new RawContextKey('accessibilityModeEnabled', false);
+export function isAccessibilityInformation(obj) {
+    return obj && typeof obj === 'object'
+        && typeof obj.label === 'string'
+        && (typeof obj.role === 'undefined' || typeof obj.role === 'string');
+}
diff -urN -x '*.map' a/vs/platform/actionWidget/browser/actionWidget.js b/vs/platform/actionWidget/browser/actionWidget.js
--- a/vs/platform/actionWidget/browser/actionWidget.js	2023-09-05 08:43:04.242808851 +0000
+++ b/vs/platform/actionWidget/browser/actionWidget.js	2023-09-05 08:45:14.309196520 +0000
@@ -69,6 +69,9 @@
         (_a = this._list.value) === null || _a === void 0 ? void 0 : _a.hide();
         this._list.clear();
     }
+    clear() {
+        this._list.clear();
+    }
     _renderWidget(element, list, actionBarActions) {
         var _a;
         const widget = document.createElement('div');
diff -urN -x '*.map' a/vs/platform/actions/browser/menuEntryActionViewItem.js b/vs/platform/actions/browser/menuEntryActionViewItem.js
--- a/vs/platform/actions/browser/menuEntryActionViewItem.js	2023-09-05 08:43:04.246808953 +0000
+++ b/vs/platform/actions/browser/menuEntryActionViewItem.js	2023-09-05 08:45:14.309196520 +0000
@@ -287,6 +287,9 @@
 ], SubmenuEntryActionViewItem);
 export { SubmenuEntryActionViewItem };
 let DropdownWithDefaultActionViewItem = class DropdownWithDefaultActionViewItem extends BaseActionViewItem {
+    get onDidChangeDropdownVisibility() {
+        return this._dropdown.onDidChangeVisibility;
+    }
     constructor(submenuAction, options, _keybindingService, _notificationService, _contextMenuService, _menuService, _instaService, _storageService) {
         var _a, _b, _c;
         super(null, submenuAction);
diff -urN -x '*.map' a/vs/platform/actions/browser/toolbar.js b/vs/platform/actions/browser/toolbar.js
--- a/vs/platform/actions/browser/toolbar.js	2023-09-05 08:43:04.246808953 +0000
+++ b/vs/platform/actions/browser/toolbar.js	2023-09-05 08:45:14.309196520 +0000
@@ -16,8 +16,11 @@
 import { ToolBar } from '../../../base/browser/ui/toolbar/toolbar.js';
 import { Separator, toAction } from '../../../base/common/actions.js';
 import { coalesceInPlace } from '../../../base/common/arrays.js';
+import { BugIndicatingError } from '../../../base/common/errors.js';
+import { Emitter } from '../../../base/common/event.js';
 import { DisposableStore } from '../../../base/common/lifecycle.js';
 import { localize } from '../../../nls.js';
+import { createAndFillInActionBarActions } from './menuEntryActionViewItem.js';
 import { IMenuService, MenuItemAction, SubmenuItemAction } from '../common/actions.js';
 import { IContextKeyService } from '../../contextkey/common/contextkey.js';
 import { IContextMenuService } from '../../contextview/browser/contextView.js';
@@ -181,3 +184,43 @@
     __param(6, ITelemetryService)
 ], WorkbenchToolBar);
 export { WorkbenchToolBar };
+/**
+ * A {@link WorkbenchToolBar workbench toolbar} that is purely driven from a {@link MenuId menu}-identifier.
+ *
+ * *Note* that Manual updates via `setActions` are NOT supported.
+ */
+let MenuWorkbenchToolBar = class MenuWorkbenchToolBar extends WorkbenchToolBar {
+    constructor(container, menuId, options, menuService, contextKeyService, contextMenuService, keybindingService, telemetryService) {
+        super(container, Object.assign({ resetMenu: menuId }, options), menuService, contextKeyService, contextMenuService, keybindingService, telemetryService);
+        this._onDidChangeMenuItems = this._store.add(new Emitter());
+        this.onDidChangeMenuItems = this._onDidChangeMenuItems.event;
+        // update logic
+        const menu = this._store.add(menuService.createMenu(menuId, contextKeyService, { emitEventsForSubmenuChanges: true }));
+        const updateToolbar = () => {
+            var _a, _b, _c;
+            const primary = [];
+            const secondary = [];
+            createAndFillInActionBarActions(menu, options === null || options === void 0 ? void 0 : options.menuOptions, { primary, secondary }, (_a = options === null || options === void 0 ? void 0 : options.toolbarOptions) === null || _a === void 0 ? void 0 : _a.primaryGroup, (_b = options === null || options === void 0 ? void 0 : options.toolbarOptions) === null || _b === void 0 ? void 0 : _b.shouldInlineSubmenu, (_c = options === null || options === void 0 ? void 0 : options.toolbarOptions) === null || _c === void 0 ? void 0 : _c.useSeparatorsInPrimaryActions);
+            super.setActions(primary, secondary);
+        };
+        this._store.add(menu.onDidChange(() => {
+            updateToolbar();
+            this._onDidChangeMenuItems.fire(this);
+        }));
+        updateToolbar();
+    }
+    /**
+     * @deprecated The WorkbenchToolBar does not support this method because it works with menus.
+     */
+    setActions() {
+        throw new BugIndicatingError('This toolbar is populated from a menu.');
+    }
+};
+MenuWorkbenchToolBar = __decorate([
+    __param(3, IMenuService),
+    __param(4, IContextKeyService),
+    __param(5, IContextMenuService),
+    __param(6, IKeybindingService),
+    __param(7, ITelemetryService)
+], MenuWorkbenchToolBar);
+export { MenuWorkbenchToolBar };
diff -urN -x '*.map' a/vs/platform/actions/common/actions.js b/vs/platform/actions/common/actions.js
--- a/vs/platform/actions/common/actions.js	2023-09-05 08:43:04.246808953 +0000
+++ b/vs/platform/actions/common/actions.js	2023-09-05 08:45:14.309196520 +0000
@@ -39,6 +39,13 @@
 }
 export class MenuId {
     /**
+     * Create or reuse a `MenuId` with the given identifier
+     */
+    static for(identifier) {
+        var _a;
+        return (_a = MenuId._instances.get(identifier)) !== null && _a !== void 0 ? _a : new MenuId(identifier);
+    }
+    /**
      * Create a new `MenuId` with the unique identifier. Will throw if a menu
      * with the identifier already exists, use `MenuId.for(ident)` or a unique
      * identifier
diff -urN -x '*.map' a/vs/platform/audioCues/browser/audioCueService.js b/vs/platform/audioCues/browser/audioCueService.js
--- a/vs/platform/audioCues/browser/audioCueService.js	2023-09-05 08:43:04.254809155 +0000
+++ b/vs/platform/audioCues/browser/audioCueService.js	2023-09-05 08:45:14.313196577 +0000
@@ -1,6 +1,171 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
+    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
+    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
+    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
+    return c > 3 && r && Object.defineProperty(target, key, r), r;
+};
+var __param = (this && this.__param) || function (paramIndex, decorator) {
+    return function (target, key) { decorator(target, key, paramIndex); }
+};
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+import { Disposable, toDisposable } from '../../../base/common/lifecycle.js';
+import { FileAccess } from '../../../base/common/network.js';
+import { IAccessibilityService } from '../../accessibility/common/accessibility.js';
+import { IConfigurationService } from '../../configuration/common/configuration.js';
 import { createDecorator } from '../../instantiation/common/instantiation.js';
+import { Event } from '../../../base/common/event.js';
 import { localize } from '../../../nls.js';
+import { observableFromEvent, derived } from '../../../base/common/observable.js';
 export const IAudioCueService = createDecorator('audioCue');
+let AudioCueService = class AudioCueService extends Disposable {
+    constructor(configurationService, accessibilityService) {
+        super();
+        this.configurationService = configurationService;
+        this.accessibilityService = accessibilityService;
+        this.sounds = new Map();
+        this.screenReaderAttached = observableFromEvent(this.accessibilityService.onDidChangeScreenReaderOptimized, () => /** @description accessibilityService.onDidChangeScreenReaderOptimized */ this.accessibilityService.isScreenReaderOptimized());
+        this.playingSounds = new Set();
+        this.obsoleteAudioCuesEnabled = observableFromEvent(Event.filter(this.configurationService.onDidChangeConfiguration, (e) => e.affectsConfiguration('audioCues.enabled')), () => /** @description config: audioCues.enabled */ this.configurationService.getValue('audioCues.enabled'));
+        this.isEnabledCache = new Cache((cue) => {
+            const settingObservable = observableFromEvent(Event.filter(this.configurationService.onDidChangeConfiguration, (e) => e.affectsConfiguration(cue.settingsKey)), () => this.configurationService.getValue(cue.settingsKey));
+            return derived('audio cue enabled', reader => {
+                const setting = settingObservable.read(reader);
+                if (setting === 'on' ||
+                    (setting === 'auto' && this.screenReaderAttached.read(reader))) {
+                    return true;
+                }
+                const obsoleteSetting = this.obsoleteAudioCuesEnabled.read(reader);
+                if (obsoleteSetting === 'on' ||
+                    (obsoleteSetting === 'auto' && this.screenReaderAttached.read(reader))) {
+                    return true;
+                }
+                return false;
+            });
+        });
+    }
+    playAudioCue(cue, allowManyInParallel = false) {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (this.isEnabled(cue)) {
+                yield this.playSound(cue.sound.getSound(), allowManyInParallel);
+            }
+        });
+    }
+    playAudioCues(cues) {
+        return __awaiter(this, void 0, void 0, function* () {
+            // Some audio cues might reuse sounds. Don't play the same sound twice.
+            const sounds = new Set(cues.filter(cue => this.isEnabled(cue)).map(cue => cue.sound.getSound()));
+            yield Promise.all(Array.from(sounds).map(sound => this.playSound(sound, true)));
+        });
+    }
+    getVolumeInPercent() {
+        const volume = this.configurationService.getValue('audioCues.volume');
+        if (typeof volume !== 'number') {
+            return 50;
+        }
+        return Math.max(Math.min(volume, 100), 0);
+    }
+    playSound(sound, allowManyInParallel = false) {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (!allowManyInParallel && this.playingSounds.has(sound)) {
+                return;
+            }
+            this.playingSounds.add(sound);
+            const url = FileAccess.asBrowserUri(`vs/platform/audioCues/browser/media/${sound.fileName}`).toString(true);
+            try {
+                const sound = this.sounds.get(url);
+                if (sound) {
+                    sound.volume = this.getVolumeInPercent() / 100;
+                    sound.currentTime = 0;
+                    yield sound.play();
+                }
+                else {
+                    const playedSound = yield playAudio(url, this.getVolumeInPercent() / 100);
+                    this.sounds.set(url, playedSound);
+                }
+            }
+            catch (e) {
+                console.error('Error while playing sound', e);
+            }
+            finally {
+                this.playingSounds.delete(sound);
+            }
+        });
+    }
+    playAudioCueLoop(cue, milliseconds) {
+        let playing = true;
+        const playSound = () => {
+            if (playing) {
+                this.playAudioCue(cue, true).finally(() => {
+                    setTimeout(() => {
+                        if (playing) {
+                            playSound();
+                        }
+                    }, milliseconds);
+                });
+            }
+        };
+        playSound();
+        return toDisposable(() => playing = false);
+    }
+    isEnabled(cue) {
+        return this.isEnabledCache.get(cue).get();
+    }
+    onEnabledChanged(cue) {
+        return Event.fromObservableLight(this.isEnabledCache.get(cue));
+    }
+};
+AudioCueService = __decorate([
+    __param(0, IConfigurationService),
+    __param(1, IAccessibilityService)
+], AudioCueService);
+export { AudioCueService };
+/**
+ * Play the given audio url.
+ * @volume value between 0 and 1
+ */
+function playAudio(url, volume) {
+    return new Promise((resolve, reject) => {
+        const audio = new Audio(url);
+        audio.volume = volume;
+        audio.addEventListener('ended', () => {
+            resolve(audio);
+        });
+        audio.addEventListener('error', (e) => {
+            // When the error event fires, ended might not be called
+            reject(e.error);
+        });
+        audio.play().catch(e => {
+            // When play fails, the error event is not fired.
+            reject(e);
+        });
+    });
+}
+class Cache {
+    constructor(getValue) {
+        this.getValue = getValue;
+        this.map = new Map();
+    }
+    get(arg) {
+        if (this.map.has(arg)) {
+            return this.map.get(arg);
+        }
+        const value = this.getValue(arg);
+        this.map.set(arg, value);
+        return value;
+    }
+}
 /**
  * Corresponds to the audio files in ./media.
 */
@@ -34,6 +199,15 @@
     constructor(randomOneOf) {
         this.randomOneOf = randomOneOf;
     }
+    getSound(deterministic = false) {
+        if (deterministic || this.randomOneOf.length === 1) {
+            return this.randomOneOf[0];
+        }
+        else {
+            const index = Math.floor(Math.random() * this.randomOneOf.length);
+            return this.randomOneOf[index];
+        }
+    }
 }
 export class AudioCue {
     static register(options) {
@@ -42,6 +216,9 @@
         AudioCue._audioCues.add(audioCue);
         return audioCue;
     }
+    static get allAudioCues() {
+        return [...this._audioCues];
+    }
     constructor(sound, name, settingsKey) {
         this.sound = sound;
         this.name = name;
diff -urN -x '*.map' a/vs/platform/clipboard/browser/clipboardService.js b/vs/platform/clipboard/browser/clipboardService.js
--- a/vs/platform/clipboard/browser/clipboardService.js	2023-09-05 08:43:04.254809155 +0000
+++ b/vs/platform/clipboard/browser/clipboardService.js	2023-09-05 08:45:14.305196462 +0000
@@ -152,6 +152,11 @@
             return this.resources;
         });
     }
+    hasResources() {
+        return __awaiter(this, void 0, void 0, function* () {
+            return this.resources.length > 0;
+        });
+    }
 };
 BrowserClipboardService = __decorate([
     __param(0, ILayoutService),
diff -urN -x '*.map' a/vs/platform/configuration/common/configuration.js b/vs/platform/configuration/common/configuration.js
--- a/vs/platform/configuration/common/configuration.js	2023-09-05 08:43:04.258809256 +0000
+++ b/vs/platform/configuration/common/configuration.js	2023-09-05 08:45:14.305196462 +0000
@@ -2,8 +2,43 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
+import * as types from '../../../base/common/types.js';
+import { URI } from '../../../base/common/uri.js';
 import { createDecorator } from '../../instantiation/common/instantiation.js';
 export const IConfigurationService = createDecorator('configurationService');
+export function isConfigurationOverrides(thing) {
+    return thing
+        && typeof thing === 'object'
+        && (!thing.overrideIdentifier || typeof thing.overrideIdentifier === 'string')
+        && (!thing.resource || thing.resource instanceof URI);
+}
+export function isConfigurationUpdateOverrides(thing) {
+    return thing
+        && typeof thing === 'object'
+        && (!thing.overrideIdentifiers || Array.isArray(thing.overrideIdentifiers))
+        && !thing.overrideIdentifier
+        && (!thing.resource || thing.resource instanceof URI);
+}
+export function ConfigurationTargetToString(configurationTarget) {
+    switch (configurationTarget) {
+        case 1 /* ConfigurationTarget.APPLICATION */: return 'APPLICATION';
+        case 2 /* ConfigurationTarget.USER */: return 'USER';
+        case 3 /* ConfigurationTarget.USER_LOCAL */: return 'USER_LOCAL';
+        case 4 /* ConfigurationTarget.USER_REMOTE */: return 'USER_REMOTE';
+        case 5 /* ConfigurationTarget.WORKSPACE */: return 'WORKSPACE';
+        case 6 /* ConfigurationTarget.WORKSPACE_FOLDER */: return 'WORKSPACE_FOLDER';
+        case 7 /* ConfigurationTarget.DEFAULT */: return 'DEFAULT';
+        case 8 /* ConfigurationTarget.MEMORY */: return 'MEMORY';
+    }
+}
+export function isConfigured(configValue) {
+    return configValue.applicationValue !== undefined ||
+        configValue.userValue !== undefined ||
+        configValue.userLocalValue !== undefined ||
+        configValue.userRemoteValue !== undefined ||
+        configValue.workspaceValue !== undefined ||
+        configValue.workspaceFolderValue !== undefined;
+}
 export function toValuesTree(properties, conflictReporter) {
     const root = Object.create(null);
     for (const key in properties) {
@@ -81,6 +116,23 @@
     const result = accessSetting(config, path);
     return typeof result === 'undefined' ? defaultValue : result;
 }
+export function merge(base, add, overwrite) {
+    Object.keys(add).forEach(key => {
+        if (key !== '__proto__') {
+            if (key in base) {
+                if (types.isObject(base[key]) && types.isObject(add[key])) {
+                    merge(base[key], add[key], overwrite);
+                }
+                else if (overwrite) {
+                    base[key] = add[key];
+                }
+            }
+            else {
+                base[key] = add[key];
+            }
+        }
+    });
+}
 export function getLanguageTagSettingPlainKey(settingKey) {
     return settingKey.replace(/[\[\]]/g, '');
 }
diff -urN -x '*.map' a/vs/platform/configuration/common/configurationModels.js b/vs/platform/configuration/common/configurationModels.js
--- a/vs/platform/configuration/common/configurationModels.js	2023-09-05 08:43:04.258809256 +0000
+++ b/vs/platform/configuration/common/configurationModels.js	2023-09-05 08:45:14.305196462 +0000
@@ -2,8 +2,20 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
 import * as arrays from '../../../base/common/arrays.js';
-import { ResourceMap } from '../../../base/common/map.js';
+import { Emitter, Event } from '../../../base/common/event.js';
+import * as json from '../../../base/common/json.js';
+import { Disposable } from '../../../base/common/lifecycle.js';
+import { getOrSet, ResourceMap } from '../../../base/common/map.js';
 import * as objects from '../../../base/common/objects.js';
 import * as types from '../../../base/common/types.js';
 import { URI } from '../../../base/common/uri.js';
@@ -69,6 +81,22 @@
             ? section ? getConfigurationValue(overrideContents, section) : overrideContents
             : undefined;
     }
+    getKeysForOverrideIdentifier(identifier) {
+        const keys = [];
+        for (const override of this.overrides) {
+            if (override.identifiers.includes(identifier)) {
+                keys.push(...override.keys);
+            }
+        }
+        return arrays.distinct(keys);
+    }
+    getAllOverrideIdentifiers() {
+        const result = [];
+        for (const override of this.overrides) {
+            result.push(...override.identifiers);
+        }
+        return arrays.distinct(result);
+    }
     override(identifier) {
         let overrideConfigurationModel = this.overrideConfigurations.get(identifier);
         if (!overrideConfigurationModel) {
@@ -215,16 +243,89 @@
         this._raw = null;
         this._configurationModel = null;
         this._restrictedConfigurations = [];
+        this._parseErrors = [];
     }
     get configurationModel() {
         return this._configurationModel || new ConfigurationModel();
     }
+    get restrictedConfigurations() {
+        return this._restrictedConfigurations;
+    }
+    get errors() {
+        return this._parseErrors;
+    }
+    parse(content, options) {
+        if (!types.isUndefinedOrNull(content)) {
+            const raw = this.doParseContent(content);
+            this.parseRaw(raw, options);
+        }
+    }
+    reparse(options) {
+        if (this._raw) {
+            this.parseRaw(this._raw, options);
+        }
+    }
     parseRaw(raw, options) {
         this._raw = raw;
         const { contents, keys, overrides, restricted, hasExcludedProperties } = this.doParseRaw(raw, options);
         this._configurationModel = new ConfigurationModel(contents, keys, overrides, hasExcludedProperties ? [raw] : undefined /* raw has not changed */);
         this._restrictedConfigurations = restricted || [];
     }
+    doParseContent(content) {
+        let raw = {};
+        let currentProperty = null;
+        let currentParent = [];
+        const previousParents = [];
+        const parseErrors = [];
+        function onValue(value) {
+            if (Array.isArray(currentParent)) {
+                currentParent.push(value);
+            }
+            else if (currentProperty !== null) {
+                currentParent[currentProperty] = value;
+            }
+        }
+        const visitor = {
+            onObjectBegin: () => {
+                const object = {};
+                onValue(object);
+                previousParents.push(currentParent);
+                currentParent = object;
+                currentProperty = null;
+            },
+            onObjectProperty: (name) => {
+                currentProperty = name;
+            },
+            onObjectEnd: () => {
+                currentParent = previousParents.pop();
+            },
+            onArrayBegin: () => {
+                const array = [];
+                onValue(array);
+                previousParents.push(currentParent);
+                currentParent = array;
+                currentProperty = null;
+            },
+            onArrayEnd: () => {
+                currentParent = previousParents.pop();
+            },
+            onLiteralValue: onValue,
+            onError: (error, offset, length) => {
+                parseErrors.push({ error, offset, length });
+            }
+        };
+        if (content) {
+            try {
+                json.visit(content, visitor);
+                raw = currentParent[0] || {};
+            }
+            catch (e) {
+                console.error(`Error while parsing settings file ${this._name}: ${e}`);
+                this._parseErrors = [e];
+            }
+        }
+        return raw;
+    }
     doParseRaw(raw, options) {
         const configurationProperties = Registry.as(Extensions.Configuration).getConfigurationProperties();
         const filtered = this.filter(raw, configurationProperties, true, options);
@@ -286,6 +387,43 @@
         return overrides;
     }
 }
+export class UserSettings extends Disposable {
+    constructor(userSettingsResource, parseOptions, extUri, fileService) {
+        super();
+        this.userSettingsResource = userSettingsResource;
+        this.parseOptions = parseOptions;
+        this.fileService = fileService;
+        this._onDidChange = this._register(new Emitter());
+        this.onDidChange = this._onDidChange.event;
+        this.parser = new ConfigurationModelParser(this.userSettingsResource.toString());
+        this._register(this.fileService.watch(extUri.dirname(this.userSettingsResource)));
+        // Also listen to the resource incase the resource is a symlink - https://github.com/microsoft/vscode/issues/118134
+        this._register(this.fileService.watch(this.userSettingsResource));
+        this._register(Event.any(Event.filter(this.fileService.onDidFilesChange, e => e.contains(this.userSettingsResource)), Event.filter(this.fileService.onDidRunOperation, e => (e.isOperation(0 /* FileOperation.CREATE */) || e.isOperation(3 /* FileOperation.COPY */) || e.isOperation(1 /* FileOperation.DELETE */) || e.isOperation(4 /* FileOperation.WRITE */)) && extUri.isEqual(e.resource, userSettingsResource)))(() => this._onDidChange.fire()));
+    }
+    loadConfiguration() {
+        return __awaiter(this, void 0, void 0, function* () {
+            try {
+                const content = yield this.fileService.readFile(this.userSettingsResource);
+                this.parser.parse(content.value.toString() || '{}', this.parseOptions);
+                return this.parser.configurationModel;
+            }
+            catch (e) {
+                return new ConfigurationModel();
+            }
+        });
+    }
+    reparse(parseOptions) {
+        if (parseOptions) {
+            this.parseOptions = parseOptions;
+        }
+        this.parser.reparse(this.parseOptions);
+        return this.parser.configurationModel;
+    }
+    getRestrictedSettings() {
+        return this.parser.restrictedConfigurations;
+    }
+}
 class ConfigurationInspectValue {
     constructor(key, overrides, _value, overrideIdentifiers, defaultConfiguration, policyConfiguration, applicationConfiguration, userConfiguration, localUserConfiguration, remoteUserConfiguration, workspaceConfiguration, folderConfigurationModel, memoryConfigurationModel) {
         this.key = key;
@@ -302,6 +440,9 @@
         this.folderConfigurationModel = folderConfigurationModel;
         this.memoryConfigurationModel = memoryConfigurationModel;
     }
+    get value() {
+        return freeze(this._value);
+    }
     inspect(model, section, overrideIdentifier) {
         const inspectValue = model.inspect(section, overrideIdentifier);
         return {
@@ -310,15 +451,122 @@
             get merged() { return freeze(inspectValue.merged); }
         };
     }
+    get defaultInspectValue() {
+        if (!this._defaultInspectValue) {
+            this._defaultInspectValue = this.inspect(this.defaultConfiguration, this.key, this.overrides.overrideIdentifier);
+        }
+        return this._defaultInspectValue;
+    }
+    get defaultValue() {
+        return this.defaultInspectValue.merged;
+    }
+    get default() {
+        return this.defaultInspectValue.value !== undefined || this.defaultInspectValue.override !== undefined ? { value: this.defaultInspectValue.value, override: this.defaultInspectValue.override } : undefined;
+    }
+    get policyInspectValue() {
+        if (this._policyInspectValue === undefined) {
+            this._policyInspectValue = this.policyConfiguration ? this.inspect(this.policyConfiguration, this.key) : null;
+        }
+        return this._policyInspectValue;
+    }
+    get policyValue() {
+        var _a;
+        return (_a = this.policyInspectValue) === null || _a === void 0 ? void 0 : _a.merged;
+    }
+    get policy() {
+        var _a;
+        return ((_a = this.policyInspectValue) === null || _a === void 0 ? void 0 : _a.value) !== undefined ? { value: this.policyInspectValue.value } : undefined;
+    }
+    get applicationInspectValue() {
+        if (this._applicationInspectValue === undefined) {
+            this._applicationInspectValue = this.applicationConfiguration ? this.inspect(this.applicationConfiguration, this.key) : null;
+        }
+        return this._applicationInspectValue;
+    }
+    get applicationValue() {
+        var _a;
+        return (_a = this.applicationInspectValue) === null || _a === void 0 ? void 0 : _a.merged;
+    }
+    get application() {
+        var _a, _b;
+        return ((_a = this.applicationInspectValue) === null || _a === void 0 ? void 0 : _a.value) !== undefined || ((_b = this.applicationInspectValue) === null || _b === void 0 ? void 0 : _b.override) !== undefined ? { value: this.applicationInspectValue.value, override: this.applicationInspectValue.override } : undefined;
+    }
     get userInspectValue() {
         if (!this._userInspectValue) {
             this._userInspectValue = this.inspect(this.userConfiguration, this.key, this.overrides.overrideIdentifier);
         }
         return this._userInspectValue;
     }
+    get userValue() {
+        return this.userInspectValue.merged;
+    }
     get user() {
         return this.userInspectValue.value !== undefined || this.userInspectValue.override !== undefined ? { value: this.userInspectValue.value, override: this.userInspectValue.override } : undefined;
     }
+    get userLocalInspectValue() {
+        if (!this._userLocalInspectValue) {
+            this._userLocalInspectValue = this.inspect(this.localUserConfiguration, this.key, this.overrides.overrideIdentifier);
+        }
+        return this._userLocalInspectValue;
+    }
+    get userLocalValue() {
+        return this.userLocalInspectValue.merged;
+    }
+    get userLocal() {
+        return this.userLocalInspectValue.value !== undefined || this.userLocalInspectValue.override !== undefined ? { value: this.userLocalInspectValue.value, override: this.userLocalInspectValue.override } : undefined;
+    }
+    get userRemoteInspectValue() {
+        if (!this._userRemoteInspectValue) {
+            this._userRemoteInspectValue = this.inspect(this.remoteUserConfiguration, this.key, this.overrides.overrideIdentifier);
+        }
+        return this._userRemoteInspectValue;
+    }
+    get userRemoteValue() {
+        return this.userRemoteInspectValue.merged;
+    }
+    get userRemote() {
+        return this.userRemoteInspectValue.value !== undefined || this.userRemoteInspectValue.override !== undefined ? { value: this.userRemoteInspectValue.value, override: this.userRemoteInspectValue.override } : undefined;
+    }
+    get workspaceInspectValue() {
+        if (this._workspaceInspectValue === undefined) {
+            this._workspaceInspectValue = this.workspaceConfiguration ? this.inspect(this.workspaceConfiguration, this.key, this.overrides.overrideIdentifier) : null;
+        }
+        return this._workspaceInspectValue;
+    }
+    get workspaceValue() {
+        var _a;
+        return (_a = this.workspaceInspectValue) === null || _a === void 0 ? void 0 : _a.merged;
+    }
+    get workspace() {
+        var _a, _b;
+        return ((_a = this.workspaceInspectValue) === null || _a === void 0 ? void 0 : _a.value) !== undefined || ((_b = this.workspaceInspectValue) === null || _b === void 0 ? void 0 : _b.override) !== undefined ? { value: this.workspaceInspectValue.value, override: this.workspaceInspectValue.override } : undefined;
+    }
+    get workspaceFolderInspectValue() {
+        if (this._workspaceFolderInspectValue === undefined) {
+            this._workspaceFolderInspectValue = this.folderConfigurationModel ? this.inspect(this.folderConfigurationModel, this.key, this.overrides.overrideIdentifier) : null;
+        }
+        return this._workspaceFolderInspectValue;
+    }
+    get workspaceFolderValue() {
+        var _a;
+        return (_a = this.workspaceFolderInspectValue) === null || _a === void 0 ? void 0 : _a.merged;
+    }
+    get workspaceFolder() {
+        var _a, _b;
+        return ((_a = this.workspaceFolderInspectValue) === null || _a === void 0 ? void 0 : _a.value) !== undefined || ((_b = this.workspaceFolderInspectValue) === null || _b === void 0 ? void 0 : _b.override) !== undefined ? { value: this.workspaceFolderInspectValue.value, override: this.workspaceFolderInspectValue.override } : undefined;
+    }
+    get memoryInspectValue() {
+        if (this._memoryInspectValue === undefined) {
+            this._memoryInspectValue = this.inspect(this.memoryConfigurationModel, this.key, this.overrides.overrideIdentifier);
+        }
+        return this._memoryInspectValue;
+    }
+    get memoryValue() {
+        return this.memoryInspectValue.merged;
+    }
+    get memory() {
+        return this.memoryInspectValue.value !== undefined || this.memoryInspectValue.override !== undefined ? { value: this.memoryInspectValue.value, override: this.memoryInspectValue.override } : undefined;
+    }
 }
 export class Configuration {
     constructor(_defaultConfiguration, _policyConfiguration, _applicationConfiguration, _localUserConfiguration, _remoteUserConfiguration = new ConfigurationModel(), _workspaceConfiguration = new ConfigurationModel(), _folderConfigurations = new ResourceMap(), _memoryConfiguration = new ConfigurationModel(), _memoryConfigurationByResource = new ResourceMap()) {
@@ -375,6 +623,135 @@
         }
         return new ConfigurationInspectValue(key, overrides, consolidateConfigurationModel.getValue(key), overrideIdentifiers.size ? [...overrideIdentifiers] : undefined, this._defaultConfiguration, this._policyConfiguration.isEmpty() ? undefined : this._policyConfiguration, this.applicationConfiguration.isEmpty() ? undefined : this.applicationConfiguration, this.userConfiguration, this.localUserConfiguration, this.remoteUserConfiguration, workspace ? this._workspaceConfiguration : undefined, folderConfigurationModel ? folderConfigurationModel : undefined, memoryConfigurationModel);
     }
+    keys(workspace) {
+        const folderConfigurationModel = this.getFolderConfigurationModelForResource(undefined, workspace);
+        return {
+            default: this._defaultConfiguration.keys.slice(0),
+            user: this.userConfiguration.keys.slice(0),
+            workspace: this._workspaceConfiguration.keys.slice(0),
+            workspaceFolder: folderConfigurationModel ? folderConfigurationModel.keys.slice(0) : []
+        };
+    }
+    updateDefaultConfiguration(defaultConfiguration) {
+        this._defaultConfiguration = defaultConfiguration;
+        this._workspaceConsolidatedConfiguration = null;
+        this._foldersConsolidatedConfigurations.clear();
+    }
+    updatePolicyConfiguration(policyConfiguration) {
+        this._policyConfiguration = policyConfiguration;
+    }
+    updateApplicationConfiguration(applicationConfiguration) {
+        this._applicationConfiguration = applicationConfiguration;
+        this._workspaceConsolidatedConfiguration = null;
+        this._foldersConsolidatedConfigurations.clear();
+    }
+    updateLocalUserConfiguration(localUserConfiguration) {
+        this._localUserConfiguration = localUserConfiguration;
+        this._userConfiguration = null;
+        this._workspaceConsolidatedConfiguration = null;
+        this._foldersConsolidatedConfigurations.clear();
+    }
+    updateRemoteUserConfiguration(remoteUserConfiguration) {
+        this._remoteUserConfiguration = remoteUserConfiguration;
+        this._userConfiguration = null;
+        this._workspaceConsolidatedConfiguration = null;
+        this._foldersConsolidatedConfigurations.clear();
+    }
+    updateWorkspaceConfiguration(workspaceConfiguration) {
+        this._workspaceConfiguration = workspaceConfiguration;
+        this._workspaceConsolidatedConfiguration = null;
+        this._foldersConsolidatedConfigurations.clear();
+    }
+    updateFolderConfiguration(resource, configuration) {
+        this._folderConfigurations.set(resource, configuration);
+        this._foldersConsolidatedConfigurations.delete(resource);
+    }
+    deleteFolderConfiguration(resource) {
+        this.folderConfigurations.delete(resource);
+        this._foldersConsolidatedConfigurations.delete(resource);
+    }
+    compareAndUpdateDefaultConfiguration(defaults, keys) {
+        const overrides = [];
+        if (!keys) {
+            const { added, updated, removed } = compare(this._defaultConfiguration, defaults);
+            keys = [...added, ...updated, ...removed];
+        }
+        for (const key of keys) {
+            for (const overrideIdentifier of overrideIdentifiersFromKey(key)) {
+                const fromKeys = this._defaultConfiguration.getKeysForOverrideIdentifier(overrideIdentifier);
+                const toKeys = defaults.getKeysForOverrideIdentifier(overrideIdentifier);
+                const keys = [
+                    ...toKeys.filter(key => fromKeys.indexOf(key) === -1),
+                    ...fromKeys.filter(key => toKeys.indexOf(key) === -1),
+                    ...fromKeys.filter(key => !objects.equals(this._defaultConfiguration.override(overrideIdentifier).getValue(key), defaults.override(overrideIdentifier).getValue(key)))
+                ];
+                overrides.push([overrideIdentifier, keys]);
+            }
+        }
+        this.updateDefaultConfiguration(defaults);
+        return { keys, overrides };
+    }
+    compareAndUpdatePolicyConfiguration(policyConfiguration) {
+        const { added, updated, removed } = compare(this._policyConfiguration, policyConfiguration);
+        const keys = [...added, ...updated, ...removed];
+        if (keys.length) {
+            this.updatePolicyConfiguration(policyConfiguration);
+        }
+        return { keys, overrides: [] };
+    }
+    compareAndUpdateApplicationConfiguration(application) {
+        const { added, updated, removed, overrides } = compare(this.applicationConfiguration, application);
+        const keys = [...added, ...updated, ...removed];
+        if (keys.length) {
+            this.updateApplicationConfiguration(application);
+        }
+        return { keys, overrides };
+    }
+    compareAndUpdateLocalUserConfiguration(user) {
+        const { added, updated, removed, overrides } = compare(this.localUserConfiguration, user);
+        const keys = [...added, ...updated, ...removed];
+        if (keys.length) {
+            this.updateLocalUserConfiguration(user);
+        }
+        return { keys, overrides };
+    }
+    compareAndUpdateRemoteUserConfiguration(user) {
+        const { added, updated, removed, overrides } = compare(this.remoteUserConfiguration, user);
+        const keys = [...added, ...updated, ...removed];
+        if (keys.length) {
+            this.updateRemoteUserConfiguration(user);
+        }
+        return { keys, overrides };
+    }
+    compareAndUpdateWorkspaceConfiguration(workspaceConfiguration) {
+        const { added, updated, removed, overrides } = compare(this.workspaceConfiguration, workspaceConfiguration);
+        const keys = [...added, ...updated, ...removed];
+        if (keys.length) {
+            this.updateWorkspaceConfiguration(workspaceConfiguration);
+        }
+        return { keys, overrides };
+    }
+    compareAndUpdateFolderConfiguration(resource, folderConfiguration) {
+        const currentFolderConfiguration = this.folderConfigurations.get(resource);
+        const { added, updated, removed, overrides } = compare(currentFolderConfiguration, folderConfiguration);
+        const keys = [...added, ...updated, ...removed];
+        if (keys.length || !currentFolderConfiguration) {
+            this.updateFolderConfiguration(resource, folderConfiguration);
+        }
+        return { keys, overrides };
+    }
+    compareAndDeleteFolderConfiguration(folder) {
+        const folderConfig = this.folderConfigurations.get(folder);
+        if (!folderConfig) {
+            throw new Error('Unknown folder');
+        }
+        this.deleteFolderConfiguration(folder);
+        const { added, updated, removed, overrides } = compare(folderConfig, undefined);
+        return { keys: [...added, ...updated, ...removed], overrides };
+    }
+    get defaults() {
+        return this._defaultConfiguration;
+    }
     get applicationConfiguration() {
         return this._applicationConfiguration;
     }
@@ -390,6 +767,12 @@
     get remoteUserConfiguration() {
         return this._remoteUserConfiguration;
     }
+    get workspaceConfiguration() {
+        return this._workspaceConfiguration;
+    }
+    get folderConfigurations() {
+        return this._folderConfigurations;
+    }
     getConsolidatedConfigurationModel(section, overrides, workspace) {
         let configurationModel = this.getConsolidatedConfigurationModelForResource(overrides, workspace);
         if (overrides.overrideIdentifier) {
@@ -478,6 +861,30 @@
             }, [])
         };
     }
+    allKeys() {
+        const keys = new Set();
+        this._defaultConfiguration.keys.forEach(key => keys.add(key));
+        this.userConfiguration.keys.forEach(key => keys.add(key));
+        this._workspaceConfiguration.keys.forEach(key => keys.add(key));
+        this._folderConfigurations.forEach(folderConfiguration => folderConfiguration.keys.forEach(key => keys.add(key)));
+        return [...keys.values()];
+    }
+    allOverrideIdentifiers() {
+        const keys = new Set();
+        this._defaultConfiguration.getAllOverrideIdentifiers().forEach(key => keys.add(key));
+        this.userConfiguration.getAllOverrideIdentifiers().forEach(key => keys.add(key));
+        this._workspaceConfiguration.getAllOverrideIdentifiers().forEach(key => keys.add(key));
+        this._folderConfigurations.forEach(folderConfiguration => folderConfiguration.getAllOverrideIdentifiers().forEach(key => keys.add(key)));
+        return [...keys.values()];
+    }
+    getAllKeysForOverrideIdentifier(overrideIdentifier) {
+        const keys = new Set();
+        this._defaultConfiguration.getKeysForOverrideIdentifier(overrideIdentifier).forEach(key => keys.add(key));
+        this.userConfiguration.getKeysForOverrideIdentifier(overrideIdentifier).forEach(key => keys.add(key));
+        this._workspaceConfiguration.getKeysForOverrideIdentifier(overrideIdentifier).forEach(key => keys.add(key));
+        this._folderConfigurations.forEach(folderConfiguration => folderConfiguration.getKeysForOverrideIdentifier(overrideIdentifier).forEach(key => keys.add(key)));
+        return [...keys.values()];
+    }
     static parse(data) {
         const defaultConfiguration = this.parseConfigurationModel(data.defaults);
         const policyConfiguration = this.parseConfigurationModel(data.policy);
@@ -494,6 +901,26 @@
         return new ConfigurationModel(model.contents, model.keys, model.overrides);
     }
 }
+export function mergeChanges(...changes) {
+    if (changes.length === 0) {
+        return { keys: [], overrides: [] };
+    }
+    if (changes.length === 1) {
+        return changes[0];
+    }
+    const keysSet = new Set();
+    const overridesMap = new Map();
+    for (const change of changes) {
+        change.keys.forEach(key => keysSet.add(key));
+        change.overrides.forEach(([identifier, keys]) => {
+            const result = getOrSet(overridesMap, identifier, new Set());
+            keys.forEach(key => result.add(key));
+        });
+    }
+    const overrides = [];
+    overridesMap.forEach((keys, identifier) => overrides.push([identifier, [...keys.values()]]));
+    return { keys: [...keysSet.values()], overrides };
+}
 export class ConfigurationChangeEvent {
     constructor(change, previous, currentConfiguraiton, currentWorkspace) {
         this.change = change;
@@ -552,3 +979,51 @@
         return true;
     }
 }
+function compare(from, to) {
+    const { added, removed, updated } = compareConfigurationContents(to === null || to === void 0 ? void 0 : to.rawConfiguration, from === null || from === void 0 ? void 0 : from.rawConfiguration);
+    const overrides = [];
+    const fromOverrideIdentifiers = (from === null || from === void 0 ? void 0 : from.getAllOverrideIdentifiers()) || [];
+    const toOverrideIdentifiers = (to === null || to === void 0 ? void 0 : to.getAllOverrideIdentifiers()) || [];
+    if (to) {
+        const addedOverrideIdentifiers = toOverrideIdentifiers.filter(key => !fromOverrideIdentifiers.includes(key));
+        for (const identifier of addedOverrideIdentifiers) {
+            overrides.push([identifier, to.getKeysForOverrideIdentifier(identifier)]);
+        }
+    }
+    if (from) {
+        const removedOverrideIdentifiers = fromOverrideIdentifiers.filter(key => !toOverrideIdentifiers.includes(key));
+        for (const identifier of removedOverrideIdentifiers) {
+            overrides.push([identifier, from.getKeysForOverrideIdentifier(identifier)]);
+        }
+    }
+    if (to && from) {
+        for (const identifier of fromOverrideIdentifiers) {
+            if (toOverrideIdentifiers.includes(identifier)) {
+                const result = compareConfigurationContents({ contents: from.getOverrideValue(undefined, identifier) || {}, keys: from.getKeysForOverrideIdentifier(identifier) }, { contents: to.getOverrideValue(undefined, identifier) || {}, keys: to.getKeysForOverrideIdentifier(identifier) });
+                overrides.push([identifier, [...result.added, ...result.removed, ...result.updated]]);
+            }
+        }
+    }
+    return { added, removed, updated, overrides };
+}
+function compareConfigurationContents(to, from) {
+    const added = to
+        ? from ? to.keys.filter(key => from.keys.indexOf(key) === -1) : [...to.keys]
+        : [];
+    const removed = from
+        ? to ? from.keys.filter(key => to.keys.indexOf(key) === -1) : [...from.keys]
+        : [];
+    const updated = [];
+    if (to && from) {
+        for (const key of from.keys) {
+            if (to.keys.indexOf(key) !== -1) {
+                const value1 = getConfigurationValue(from.contents, key);
+                const value2 = getConfigurationValue(to.contents, key);
+                if (!objects.equals(value1, value2)) {
+                    updated.push(key);
+                }
+            }
+        }
+    }
+    return { added, removed, updated };
+}
diff -urN -x '*.map' a/vs/platform/configuration/common/configurationRegistry.js b/vs/platform/configuration/common/configurationRegistry.js
--- a/vs/platform/configuration/common/configurationRegistry.js	2023-09-05 08:43:04.262809358 +0000
+++ b/vs/platform/configuration/common/configurationRegistry.js	2023-09-05 08:45:14.305196462 +0000
@@ -9,6 +9,11 @@
 import { getLanguageTagSettingPlainKey } from './configuration.js';
 import { Extensions as JSONExtensions } from '../../jsonschemas/common/jsonContributionRegistry.js';
 import { Registry } from '../../registry/common/platform.js';
+export var EditPresentationTypes;
+(function (EditPresentationTypes) {
+    EditPresentationTypes["Multiline"] = "multilineText";
+    EditPresentationTypes["Singleline"] = "singlelineText";
+})(EditPresentationTypes || (EditPresentationTypes = {}));
 export const Extensions = {
     Configuration: 'base.contributions.configuration'
 };
@@ -19,12 +24,15 @@
 export const windowSettings = { properties: {}, patternProperties: {} };
 export const resourceSettings = { properties: {}, patternProperties: {} };
 export const resourceLanguageSettingsSchemaId = 'vscode://schemas/settings/resourceLanguage';
+export const configurationDefaultsSchemaId = 'vscode://schemas/settings/configurationDefaults';
 const contributionRegistry = Registry.as(JSONExtensions.JSONContribution);
 class ConfigurationRegistry {
     constructor() {
         this.overrideIdentifiers = new Set();
         this._onDidSchemaChange = new Emitter();
+        this.onDidSchemaChange = this._onDidSchemaChange.event;
         this._onDidUpdateConfiguration = new Emitter();
+        this.onDidUpdateConfiguration = this._onDidUpdateConfiguration.event;
         this.configurationDefaultsOverrides = new Map();
         this.defaultLanguageConfigurationOverridesNode = {
             id: 'defaultOverrides',
@@ -55,6 +63,21 @@
         this._onDidSchemaChange.fire();
         this._onDidUpdateConfiguration.fire({ properties });
     }
+    deregisterConfigurations(configurations) {
+        const properties = new Set();
+        this.doDeregisterConfigurations(configurations, properties);
+        contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);
+        this._onDidSchemaChange.fire();
+        this._onDidUpdateConfiguration.fire({ properties });
+    }
+    updateConfigurations({ add, remove }) {
+        const properties = new Set();
+        this.doDeregisterConfigurations(remove, properties);
+        this.doRegisterConfigurations(add, false, properties);
+        contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);
+        this._onDidSchemaChange.fire();
+        this._onDidUpdateConfiguration.fire({ properties });
+    }
     registerDefaultConfigurations(configurationDefaults) {
         const properties = new Set();
         this.doRegisterDefaultConfigurations(configurationDefaults, properties);
@@ -103,6 +126,66 @@
         }
         this.doRegisterOverrideIdentifiers(overrideIdentifiers);
     }
+    deregisterDefaultConfigurations(defaultConfigurations) {
+        const properties = new Set();
+        this.doDeregisterDefaultConfigurations(defaultConfigurations, properties);
+        this._onDidSchemaChange.fire();
+        this._onDidUpdateConfiguration.fire({ properties, defaultsOverrides: true });
+    }
+    doDeregisterDefaultConfigurations(defaultConfigurations, bucket) {
+        var _a;
+        for (const { overrides, source } of defaultConfigurations) {
+            for (const key in overrides) {
+                const configurationDefaultsOverride = this.configurationDefaultsOverrides.get(key);
+                const id = types.isString(source) ? source : source === null || source === void 0 ? void 0 : source.id;
+                const configurationDefaultsOverrideSourceId = types.isString(configurationDefaultsOverride === null || configurationDefaultsOverride === void 0 ? void 0 : configurationDefaultsOverride.source) ? configurationDefaultsOverride === null || configurationDefaultsOverride === void 0 ? void 0 : configurationDefaultsOverride.source : (_a = configurationDefaultsOverride === null || configurationDefaultsOverride === void 0 ? void 0 : configurationDefaultsOverride.source) === null || _a === void 0 ? void 0 : _a.id;
+                if (id !== configurationDefaultsOverrideSourceId) {
+                    continue;
+                }
+                bucket.add(key);
+                this.configurationDefaultsOverrides.delete(key);
+                if (OVERRIDE_PROPERTY_REGEX.test(key)) {
+                    delete this.configurationProperties[key];
+                    delete this.defaultLanguageConfigurationOverridesNode.properties[key];
+                }
+                else {
+                    const property = this.configurationProperties[key];
+                    if (property) {
+                        this.updatePropertyDefaultValue(key, property);
+                        this.updateSchema(key, property);
+                    }
+                }
+            }
+        }
+        this.updateOverridePropertyPatternKey();
+    }
+    deltaConfiguration(delta) {
+        // defaults: remove
+        let defaultsOverrides = false;
+        const properties = new Set();
+        if (delta.removedDefaults) {
+            this.doDeregisterDefaultConfigurations(delta.removedDefaults, properties);
+            defaultsOverrides = true;
+        }
+        // defaults: add
+        if (delta.addedDefaults) {
+            this.doRegisterDefaultConfigurations(delta.addedDefaults, properties);
+            defaultsOverrides = true;
+        }
+        // configurations: remove
+        if (delta.removedConfigurations) {
+            this.doDeregisterConfigurations(delta.removedConfigurations, properties);
+        }
+        // configurations: add
+        if (delta.addedConfigurations) {
+            this.doRegisterConfigurations(delta.addedConfigurations, false, properties);
+        }
+        this._onDidSchemaChange.fire();
+        this._onDidUpdateConfiguration.fire({ properties, defaultsOverrides });
+    }
+    notifyConfigurationSchemaUpdated(...configurations) {
+        this._onDidSchemaChange.fire();
+    }
     registerOverrideIdentifiers(overrideIdentifiers) {
         this.doRegisterOverrideIdentifiers(overrideIdentifiers);
         this._onDidSchemaChange.fire();
@@ -120,6 +203,30 @@
             this.registerJSONConfiguration(configuration);
         });
     }
+    doDeregisterConfigurations(configurations, bucket) {
+        const deregisterConfiguration = (configuration) => {
+            var _a, _b;
+            if (configuration.properties) {
+                for (const key in configuration.properties) {
+                    bucket.add(key);
+                    const property = this.configurationProperties[key];
+                    if ((_a = property === null || property === void 0 ? void 0 : property.policy) === null || _a === void 0 ? void 0 : _a.name) {
+                        this.policyConfigurations.delete(property.policy.name);
+                    }
+                    delete this.configurationProperties[key];
+                    this.removeFromSchema(key, configuration.properties[key]);
+                }
+            }
+            (_b = configuration.allOf) === null || _b === void 0 ? void 0 : _b.forEach(node => deregisterConfiguration(node));
+        };
+        for (const configuration of configurations) {
+            deregisterConfiguration(configuration);
+            const index = this.configurationContributors.indexOf(configuration);
+            if (index !== -1) {
+                this.configurationContributors.splice(index, 1);
+            }
+        }
+    }
     validateAndRegisterProperties(configuration, validate = true, extensionInfo, restrictedProperties, scope = 3 /* ConfigurationScope.WINDOW */, bucket) {
         var _a;
         scope = types.isUndefinedOrNull(configuration.scope) ? scope : configuration.scope;
@@ -170,12 +277,22 @@
             }
         }
     }
+    // TODO: @sandy081 - Remove this method and include required info in getConfigurationProperties
+    getConfigurations() {
+        return this.configurationContributors;
+    }
     getConfigurationProperties() {
         return this.configurationProperties;
     }
     getPolicyConfigurations() {
         return this.policyConfigurations;
     }
+    getExcludedConfigurationProperties() {
+        return this.excludedConfigurationProperties;
+    }
+    getConfigurationDefaultsOverrides() {
+        return this.configurationDefaultsOverrides;
+    }
     registerJSONConfiguration(configuration) {
         const register = (configuration) => {
             const properties = configuration.properties;
@@ -213,6 +330,28 @@
                 break;
         }
     }
+    removeFromSchema(key, property) {
+        delete allSettings.properties[key];
+        switch (property.scope) {
+            case 1 /* ConfigurationScope.APPLICATION */:
+                delete applicationSettings.properties[key];
+                break;
+            case 2 /* ConfigurationScope.MACHINE */:
+                delete machineSettings.properties[key];
+                break;
+            case 6 /* ConfigurationScope.MACHINE_OVERRIDABLE */:
+                delete machineOverridableSettings.properties[key];
+                break;
+            case 3 /* ConfigurationScope.WINDOW */:
+                delete windowSettings.properties[key];
+                break;
+            case 4 /* ConfigurationScope.RESOURCE */:
+            case 5 /* ConfigurationScope.LANGUAGE_OVERRIDABLE */:
+                delete resourceSettings.properties[key];
+                delete this.resourceLanguageSettingsSchema.properties[key];
+                break;
+        }
+    }
     updateOverridePropertyPatternKey() {
         for (const overrideIdentifier of this.overrideIdentifiers.values()) {
             const overrideIdentifierProperty = `[${overrideIdentifier}]`;
@@ -279,6 +418,9 @@
     }
     return distinct(identifiers);
 }
+export function keyFromOverrideIdentifiers(overrideIdentifiers) {
+    return overrideIdentifiers.reduce((result, overrideIdentifier) => `${result}[${overrideIdentifier}]`, '');
+}
 export function getDefaultValue(type) {
     const t = Array.isArray(type) ? type[0] : type;
     switch (t) {
@@ -315,3 +457,13 @@
     }
     return null;
 }
+export function getScopes() {
+    const scopes = [];
+    const configurationProperties = configurationRegistry.getConfigurationProperties();
+    for (const key of Object.keys(configurationProperties)) {
+        scopes.push([key, configurationProperties[key].scope]);
+    }
+    scopes.push(['launch', 4 /* ConfigurationScope.RESOURCE */]);
+    scopes.push(['task', 4 /* ConfigurationScope.RESOURCE */]);
+    return scopes;
+}
diff -urN -x '*.map' a/vs/platform/configuration/common/configurations.js b/vs/platform/configuration/common/configurations.js
--- a/vs/platform/configuration/common/configurations.js	2023-09-05 08:43:04.262809358 +0000
+++ b/vs/platform/configuration/common/configurations.js	2023-09-05 08:45:14.305196462 +0000
@@ -1,19 +1,60 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
+    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
+    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
+    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
+    return c > 3 && r && Object.defineProperty(target, key, r), r;
+};
+var __param = (this && this.__param) || function (paramIndex, decorator) {
+    return function (target, key) { decorator(target, key, paramIndex); }
+};
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+import { coalesce } from '../../../base/common/arrays.js';
+import { Emitter, Event } from '../../../base/common/event.js';
 import { Disposable } from '../../../base/common/lifecycle.js';
+import { equals } from '../../../base/common/objects.js';
+import { isEmptyObject } from '../../../base/common/types.js';
 import { ConfigurationModel } from './configurationModels.js';
 import { Extensions } from './configurationRegistry.js';
+import { ILogService } from '../../log/common/log.js';
+import { IPolicyService } from '../../policy/common/policy.js';
 import { Registry } from '../../registry/common/platform.js';
 export class DefaultConfiguration extends Disposable {
     constructor() {
         super(...arguments);
+        this._onDidChangeConfiguration = this._register(new Emitter());
+        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
         this._configurationModel = new ConfigurationModel();
     }
     get configurationModel() {
         return this._configurationModel;
     }
+    initialize() {
+        return __awaiter(this, void 0, void 0, function* () {
+            this.resetConfigurationModel();
+            this._register(Registry.as(Extensions.Configuration).onDidUpdateConfiguration(({ properties, defaultsOverrides }) => this.onDidUpdateConfiguration(Array.from(properties), defaultsOverrides)));
+            return this.configurationModel;
+        });
+    }
     reload() {
         this.resetConfigurationModel();
         return this.configurationModel;
     }
+    onDidUpdateConfiguration(properties, defaultsOverrides) {
+        this.updateConfigurationModel(properties, Registry.as(Extensions.Configuration).getConfigurationProperties());
+        this._onDidChangeConfiguration.fire({ defaults: this.configurationModel, properties });
+    }
     getConfigurationDefaultOverrides() {
         return {};
     }
@@ -39,3 +80,112 @@
         }
     }
 }
+export class NullPolicyConfiguration {
+    constructor() {
+        this.onDidChangeConfiguration = Event.None;
+        this.configurationModel = new ConfigurationModel();
+    }
+    initialize() {
+        return __awaiter(this, void 0, void 0, function* () { return this.configurationModel; });
+    }
+}
+let PolicyConfiguration = class PolicyConfiguration extends Disposable {
+    get configurationModel() { return this._configurationModel; }
+    constructor(defaultConfiguration, policyService, logService) {
+        super();
+        this.defaultConfiguration = defaultConfiguration;
+        this.policyService = policyService;
+        this.logService = logService;
+        this._onDidChangeConfiguration = this._register(new Emitter());
+        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
+        this._configurationModel = new ConfigurationModel();
+    }
+    initialize() {
+        return __awaiter(this, void 0, void 0, function* () {
+            this.logService.trace('PolicyConfiguration#initialize');
+            this.update(yield this.updatePolicyDefinitions(this.defaultConfiguration.configurationModel.keys), false);
+            this._register(this.policyService.onDidChange(policyNames => this.onDidChangePolicies(policyNames)));
+            this._register(this.defaultConfiguration.onDidChangeConfiguration(({ properties }) => __awaiter(this, void 0, void 0, function* () { return this.update(yield this.updatePolicyDefinitions(properties), true); })));
+            return this._configurationModel;
+        });
+    }
+    updatePolicyDefinitions(properties) {
+        return __awaiter(this, void 0, void 0, function* () {
+            this.logService.trace('PolicyConfiguration#updatePolicyDefinitions', properties);
+            const policyDefinitions = {};
+            const keys = [];
+            const configurationProperties = Registry.as(Extensions.Configuration).getConfigurationProperties();
+            for (const key of properties) {
+                const config = configurationProperties[key];
+                if (!config) {
+                    // Config is removed. So add it to the list if in case it was registered as policy before
+                    keys.push(key);
+                    continue;
+                }
+                if (config.policy) {
+                    if (config.type !== 'string' && config.type !== 'number') {
+                        this.logService.warn(`Policy ${config.policy.name} has unsupported type ${config.type}`);
+                        continue;
+                    }
+                    keys.push(key);
+                    policyDefinitions[config.policy.name] = { type: config.type };
+                }
+            }
+            if (!isEmptyObject(policyDefinitions)) {
+                yield this.policyService.updatePolicyDefinitions(policyDefinitions);
+            }
+            return keys;
+        });
+    }
+    onDidChangePolicies(policyNames) {
+        this.logService.trace('PolicyConfiguration#onDidChangePolicies', policyNames);
+        const policyConfigurations = Registry.as(Extensions.Configuration).getPolicyConfigurations();
+        const keys = coalesce(policyNames.map(policyName => policyConfigurations.get(policyName)));
+        this.update(keys, true);
+    }
+    update(keys, trigger) {
+        var _a, _b;
+        this.logService.trace('PolicyConfiguration#update', keys);
+        const configurationProperties = Registry.as(Extensions.Configuration).getConfigurationProperties();
+        const changed = [];
+        const wasEmpty = this._configurationModel.isEmpty();
+        for (const key of keys) {
+            const policyName = (_b = (_a = configurationProperties[key]) === null || _a === void 0 ? void 0 : _a.policy) === null || _b === void 0 ? void 0 : _b.name;
+            if (policyName) {
+                const policyValue = this.policyService.getPolicyValue(policyName);
+                if (wasEmpty ? policyValue !== undefined : !equals(this._configurationModel.getValue(key), policyValue)) {
+                    changed.push([key, policyValue]);
+                }
+            }
+            else {
+                if (this._configurationModel.getValue(key) !== undefined) {
+                    changed.push([key, undefined]);
+                }
+            }
+        }
+        if (changed.length) {
+            this.logService.trace('PolicyConfiguration#changed', changed);
+            const old = this._configurationModel;
+            this._configurationModel = new ConfigurationModel();
+            for (const key of old.keys) {
+                this._configurationModel.setValue(key, old.getValue(key));
+            }
+            for (const [key, policyValue] of changed) {
+                if (policyValue === undefined) {
+                    this._configurationModel.removeValue(key);
+                }
+                else {
+                    this._configurationModel.setValue(key, policyValue);
+                }
+            }
+            if (trigger) {
+                this._onDidChangeConfiguration.fire(this._configurationModel);
+            }
+        }
+    }
+};
+PolicyConfiguration = __decorate([
+    __param(1, IPolicyService),
+    __param(2, ILogService)
+], PolicyConfiguration);
+export { PolicyConfiguration };
diff -urN -x '*.map' a/vs/platform/contextkey/browser/contextKeyService.js b/vs/platform/contextkey/browser/contextKeyService.js
--- a/vs/platform/contextkey/browser/contextKeyService.js	2023-09-05 08:43:04.262809358 +0000
+++ b/vs/platform/contextkey/browser/contextKeyService.js	2023-09-05 08:45:14.309196520 +0000
@@ -14,7 +14,7 @@
 import { PauseableEmitter } from '../../../base/common/event.js';
 import { Iterable } from '../../../base/common/iterator.js';
 import { DisposableStore, MutableDisposable } from '../../../base/common/lifecycle.js';
-import { cloneAndChange } from '../../../base/common/objects.js';
+import { cloneAndChange, distinct } from '../../../base/common/objects.js';
 import { TernarySearchTree } from '../../../base/common/ternarySearchTree.js';
 import { URI } from '../../../base/common/uri.js';
 import { localize } from '../../../nls.js';
@@ -55,6 +55,15 @@
         }
         return ret;
     }
+    updateParent(parent) {
+        this._parent = parent;
+    }
+    collectAllValues() {
+        let result = this._parent ? this._parent.collectAllValues() : Object.create(null);
+        result = Object.assign(Object.assign({}, result), this._value);
+        delete result['_contextId'];
+        return result;
+    }
 }
 class NullContext extends Context {
     constructor() {
@@ -69,6 +78,9 @@
     getValue(key) {
         return undefined;
     }
+    collectAllValues() {
+        return Object.create(null);
+    }
 }
 NullContext.INSTANCE = new NullContext();
 class ConfigAwareContextValuesContainer extends Context {
@@ -137,6 +149,11 @@
     removeValue(key) {
         return super.removeValue(key);
     }
+    collectAllValues() {
+        const result = Object.create(null);
+        this._values.forEach((value, index) => result[index] = value);
+        return Object.assign(Object.assign({}, result), super.collectAllValues());
+    }
 }
 ConfigAwareContextValuesContainer._keyPrefix = 'config.';
 class ContextKey {
@@ -214,6 +231,9 @@
         this._isDisposed = false;
         this._myContextId = myContextId;
     }
+    get contextId() {
+        return this._myContextId;
+    }
     createKey(key, defaultValue) {
         if (this._isDisposed) {
             throw new Error(`AbstractContextKeyService has been disposed`);
@@ -235,6 +255,12 @@
         }
         return new ScopedContextKeyService(this, domNode);
     }
+    createOverlay(overlay = Iterable.empty()) {
+        if (this._isDisposed) {
+            throw new Error(`AbstractContextKeyService has been disposed`);
+        }
+        return new OverlayContextKeyService(this, overlay);
+    }
     contextMatchesRules(rules) {
         if (this._isDisposed) {
             throw new Error(`AbstractContextKeyService has been disposed`);
@@ -323,6 +349,9 @@
             this._contexts.delete(contextId);
         }
     }
+    updateParent(_parentContextKeyService) {
+        throw new Error('Cannot update parent of root ContextKeyService');
+    }
 };
 ContextKeyService = __decorate([
     __param(0, IConfigurationService)
@@ -382,6 +411,72 @@
         }
         this._parent.disposeContext(contextId);
     }
+    updateParent(parentContextKeyService) {
+        if (this._parent === parentContextKeyService) {
+            return;
+        }
+        const thisContainer = this._parent.getContextValuesContainer(this._myContextId);
+        const oldAllValues = thisContainer.collectAllValues();
+        this._parent = parentContextKeyService;
+        this._updateParentChangeListener();
+        const newParentContainer = this._parent.getContextValuesContainer(this._parent.contextId);
+        thisContainer.updateParent(newParentContainer);
+        const newAllValues = thisContainer.collectAllValues();
+        const allValuesDiff = Object.assign(Object.assign({}, distinct(oldAllValues, newAllValues)), distinct(newAllValues, oldAllValues));
+        const changedKeys = Object.keys(allValuesDiff);
+        this._onDidChangeContext.fire(new ArrayContextKeyChangeEvent(changedKeys));
+    }
+}
+class OverlayContext {
+    constructor(parent, overlay) {
+        this.parent = parent;
+        this.overlay = overlay;
+    }
+    getValue(key) {
+        return this.overlay.has(key) ? this.overlay.get(key) : this.parent.getValue(key);
+    }
+}
+class OverlayContextKeyService {
+    get contextId() {
+        return this.parent.contextId;
+    }
+    get onDidChangeContext() {
+        return this.parent.onDidChangeContext;
+    }
+    constructor(parent, overlay) {
+        this.parent = parent;
+        this.overlay = new Map(overlay);
+    }
+    bufferChangeEvents(callback) {
+        this.parent.bufferChangeEvents(callback);
+    }
+    createKey() {
+        throw new Error('Not supported.');
+    }
+    getContext(target) {
+        return new OverlayContext(this.parent.getContext(target), this.overlay);
+    }
+    getContextValuesContainer(contextId) {
+        const parentContext = this.parent.getContextValuesContainer(contextId);
+        return new OverlayContext(parentContext, this.overlay);
+    }
+    contextMatchesRules(rules) {
+        const context = this.getContextValuesContainer(this.contextId);
+        const result = (rules ? rules.evaluate(context) : true);
+        return result;
+    }
+    getContextKeyValue(key) {
+        return this.overlay.has(key) ? this.overlay.get(key) : this.parent.getContextKeyValue(key);
+    }
+    createScoped() {
+        throw new Error('Not supported.');
+    }
+    createOverlay(overlay = Iterable.empty()) {
+        return new OverlayContextKeyService(this, overlay);
+    }
+    updateParent() {
+        throw new Error('Not supported.');
+    }
 }
 function findContextAttr(domNode) {
     while (domNode) {
diff -urN -x '*.map' a/vs/platform/contextkey/common/contextkey.js b/vs/platform/contextkey/common/contextkey.js
--- a/vs/platform/contextkey/common/contextkey.js	2023-09-05 08:43:04.262809358 +0000
+++ b/vs/platform/contextkey/common/contextkey.js	2023-09-05 08:45:14.309196520 +0000
@@ -7,6 +7,7 @@
 import { Scanner } from './scanner.js';
 import { createDecorator } from '../../instantiation/common/instantiation.js';
 import { localize } from '../../../nls.js';
+import { illegalArgument } from '../../../base/common/errors.js';
 const CONSTANT_VALUES = new Map();
 CONSTANT_VALUES.set('false', false);
 CONSTANT_VALUES.set('true', true);
@@ -19,6 +20,13 @@
 CONSTANT_VALUES.set('isFirefox', isFirefox);
 CONSTANT_VALUES.set('isChrome', isChrome);
 CONSTANT_VALUES.set('isSafari', isSafari);
+/** allow register constant context keys that are known only after startup; requires running `substituteConstants` on the context key - https://github.com/microsoft/vscode/issues/174218#issuecomment-1437972127 */
+export function setConstant(key, value) {
+    if (CONSTANT_VALUES.get(key) !== undefined) {
+        throw illegalArgument('contextkey.setConstant(k, v) invoked with already set constant `k`');
+    }
+    CONSTANT_VALUES.set(key, value);
+}
 const hasOwnProperty = Object.prototype.hasOwnProperty;
 const defaultConfig = {
     regexParsingWithErrorRecovery: true
@@ -49,6 +57,12 @@
  * ```
  */
 export class Parser {
+    get lexingErrors() {
+        return this._scanner.errors;
+    }
+    get parsingErrors() {
+        return this._parsingErrors;
+    }
     constructor(_config = defaultConfig) {
         this._config = _config;
         // lifetime note: `_scanner` lives as long as the parser does, i.e., is not reset between calls to `parse`
@@ -425,6 +439,18 @@
     static or(...expr) {
         return ContextKeyOrExpr.create(expr, null, true);
     }
+    static greater(key, value) {
+        return ContextKeyGreaterExpr.create(key, value);
+    }
+    static greaterEquals(key, value) {
+        return ContextKeyGreaterEqualsExpr.create(key, value);
+    }
+    static smaller(key, value) {
+        return ContextKeySmallerExpr.create(key, value);
+    }
+    static smallerEquals(key, value) {
+        return ContextKeySmallerEqualsExpr.create(key, value);
+    }
     static deserialize(serialized) {
         if (serialized === undefined || serialized === null) { // an empty string needs to be handled by the parser to get a corresponding parsing error reported
             return undefined;
@@ -434,6 +460,31 @@
     }
 }
 ContextKeyExpr._parser = new Parser({ regexParsingWithErrorRecovery: false });
+export function validateWhenClauses(whenClauses) {
+    const parser = new Parser({ regexParsingWithErrorRecovery: false }); // we run with no recovery to guide users to use correct regexes
+    return whenClauses.map(whenClause => {
+        parser.parse(whenClause);
+        if (parser.lexingErrors.length > 0) {
+            return parser.lexingErrors.map((se) => ({
+                errorMessage: se.additionalInfo ?
+                    localize('contextkey.scanner.errorForLinterWithHint', "Unexpected token. Hint: {0}", se.additionalInfo) :
+                    localize('contextkey.scanner.errorForLinter', "Unexpected token."),
+                offset: se.offset,
+                length: se.lexeme.length,
+            }));
+        }
+        else if (parser.parsingErrors.length > 0) {
+            return parser.parsingErrors.map((pe) => ({
+                errorMessage: pe.additionalInfo ? `${pe.message}. ${pe.additionalInfo}` : pe.message,
+                offset: pe.offset,
+                length: pe.lexeme.length,
+            }));
+        }
+        else {
+            return [];
+        }
+    });
+}
 export function expressionsAreEqualWithConstantSubstitution(a, b) {
     const aExpr = a ? a.substituteConstants() : undefined;
     const bExpr = b ? b.substituteConstants() : undefined;
@@ -470,6 +521,9 @@
     keys() {
         return [];
     }
+    map(mapFnc) {
+        return this;
+    }
     negate() {
         return ContextKeyTrueExpr.INSTANCE;
     }
@@ -497,6 +551,9 @@
     keys() {
         return [];
     }
+    map(mapFnc) {
+        return this;
+    }
     negate() {
         return ContextKeyFalseExpr.INSTANCE;
     }
@@ -543,6 +600,9 @@
     keys() {
         return [this.key];
     }
+    map(mapFnc) {
+        return mapFnc.mapDefined(this.key);
+    }
     negate() {
         if (!this.negated) {
             this.negated = ContextKeyNotExpr.create(this.key, this);
@@ -599,6 +659,9 @@
     keys() {
         return [this.key];
     }
+    map(mapFnc) {
+        return mapFnc.mapEquals(this.key, this.value);
+    }
     negate() {
         if (!this.negated) {
             this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);
@@ -648,6 +711,9 @@
     keys() {
         return [this.key, this.valueKey];
     }
+    map(mapFnc) {
+        return mapFnc.mapIn(this.key, this.valueKey);
+    }
     negate() {
         if (!this.negated) {
             this.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);
@@ -689,6 +755,9 @@
     keys() {
         return this._negated.keys();
     }
+    map(mapFnc) {
+        return mapFnc.mapNotIn(this.key, this.valueKey);
+    }
     negate() {
         return this._negated;
     }
@@ -745,6 +814,9 @@
     keys() {
         return [this.key];
     }
+    map(mapFnc) {
+        return mapFnc.mapNotEquals(this.key, this.value);
+    }
     negate() {
         if (!this.negated) {
             this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);
@@ -793,6 +865,9 @@
     keys() {
         return [this.key];
     }
+    map(mapFnc) {
+        return mapFnc.mapNot(this.key);
+    }
     negate() {
         if (!this.negated) {
             this.negated = ContextKeyDefinedExpr.create(this.key, this);
@@ -849,6 +924,9 @@
     keys() {
         return [this.key];
     }
+    map(mapFnc) {
+        return mapFnc.mapGreater(this.key, this.value);
+    }
     negate() {
         if (!this.negated) {
             this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);
@@ -893,6 +971,9 @@
     keys() {
         return [this.key];
     }
+    map(mapFnc) {
+        return mapFnc.mapGreaterEquals(this.key, this.value);
+    }
     negate() {
         if (!this.negated) {
             this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);
@@ -937,6 +1018,9 @@
     keys() {
         return [this.key];
     }
+    map(mapFnc) {
+        return mapFnc.mapSmaller(this.key, this.value);
+    }
     negate() {
         if (!this.negated) {
             this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);
@@ -981,6 +1065,9 @@
     keys() {
         return [this.key];
     }
+    map(mapFnc) {
+        return mapFnc.mapSmallerEquals(this.key, this.value);
+    }
     negate() {
         if (!this.negated) {
             this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);
@@ -1043,6 +1130,9 @@
     keys() {
         return [this.key];
     }
+    map(mapFnc) {
+        return mapFnc.mapRegex(this.key, this.regexp);
+    }
     negate() {
         if (!this.negated) {
             this.negated = ContextKeyNotRegexExpr.create(this);
@@ -1083,6 +1173,9 @@
     keys() {
         return this._actual.keys();
     }
+    map(mapFnc) {
+        return new ContextKeyNotRegexExpr(this._actual.map(mapFnc));
+    }
     negate() {
         return this._actual;
     }
@@ -1261,6 +1354,9 @@
         }
         return result;
     }
+    map(mapFnc) {
+        return new ContextKeyAndExpr(this.expr.map(expr => expr.map(mapFnc)), null);
+    }
     negate() {
         if (!this.negated) {
             const result = [];
@@ -1400,6 +1496,9 @@
         }
         return result;
     }
+    map(mapFnc) {
+        return new ContextKeyOrExpr(this.expr.map(expr => expr.map(mapFnc)), null);
+    }
     negate() {
         if (!this.negated) {
             const result = [];
@@ -1451,6 +1550,9 @@
     isEqualTo(value) {
         return ContextKeyEqualsExpr.create(this.key, value);
     }
+    notEqualsTo(value) {
+        return ContextKeyNotEqualsExpr.create(this.key, value);
+    }
 }
 RawContextKey._info = [];
 export const IContextKeyService = createDecorator('contextKeyService');
diff -urN -x '*.map' a/vs/platform/contextkey/common/scanner.js b/vs/platform/contextkey/common/scanner.js
--- a/vs/platform/contextkey/common/scanner.js	2023-09-05 08:43:04.262809358 +0000
+++ b/vs/platform/contextkey/common/scanner.js	2023-09-05 08:45:14.309196520 +0000
@@ -91,6 +91,9 @@
                 throw illegalState(`unhandled token type: ${JSON.stringify(token)}; have you forgotten to add a case?`);
         }
     }
+    get errors() {
+        return this._errors;
+    }
     reset(value) {
         this._input = value;
         this._start = 0;
diff -urN -x '*.map' a/vs/platform/contextview/browser/contextMenuService.js b/vs/platform/contextview/browser/contextMenuService.js
--- a/vs/platform/contextview/browser/contextMenuService.js	2023-09-05 08:43:04.262809358 +0000
+++ b/vs/platform/contextview/browser/contextMenuService.js	2023-09-05 08:45:14.309196520 +0000
@@ -40,7 +40,9 @@
         this.contextKeyService = contextKeyService;
         this._contextMenuHandler = undefined;
         this._onDidShowContextMenu = this._store.add(new Emitter());
+        this.onDidShowContextMenu = this._onDidShowContextMenu.event;
         this._onDidHideContextMenu = this._store.add(new Emitter());
+        this.onDidHideContextMenu = this._onDidHideContextMenu.event;
     }
     configure(options) {
         this.contextMenuHandler.configure(options);
diff -urN -x '*.map' a/vs/platform/dialogs/common/dialogs.js b/vs/platform/dialogs/common/dialogs.js
--- a/vs/platform/dialogs/common/dialogs.js	2023-09-05 08:43:04.266809459 +0000
+++ b/vs/platform/dialogs/common/dialogs.js	2023-09-05 08:45:14.317196634 +0000
@@ -1,2 +1,221 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+import { basename } from '../../../base/common/resources.js';
+import Severity from '../../../base/common/severity.js';
+import { localize } from '../../../nls.js';
 import { createDecorator } from '../../instantiation/common/instantiation.js';
+import { mnemonicButtonLabel } from '../../../base/common/labels.js';
+import { isLinux, isMacintosh, isWindows } from '../../../base/common/platform.js';
+import { deepClone } from '../../../base/common/objects.js';
 export const IDialogService = createDecorator('dialogService');
+var DialogKind;
+(function (DialogKind) {
+    DialogKind[DialogKind["Confirmation"] = 1] = "Confirmation";
+    DialogKind[DialogKind["Prompt"] = 2] = "Prompt";
+    DialogKind[DialogKind["Input"] = 3] = "Input";
+})(DialogKind || (DialogKind = {}));
+export class AbstractDialogHandler {
+    getConfirmationButtons(dialog) {
+        return this.getButtons(dialog, DialogKind.Confirmation);
+    }
+    getPromptButtons(dialog) {
+        return this.getButtons(dialog, DialogKind.Prompt);
+    }
+    getInputButtons(dialog) {
+        return this.getButtons(dialog, DialogKind.Input);
+    }
+    getButtons(dialog, kind) {
+        // We put buttons in the order of "default" button first and "cancel"
+        // button last. There maybe later processing when presenting the buttons
+        // based on OS standards.
+        const buttons = [];
+        switch (kind) {
+            case DialogKind.Confirmation: {
+                const confirmationDialog = dialog;
+                if (confirmationDialog.primaryButton) {
+                    buttons.push(confirmationDialog.primaryButton);
+                }
+                else {
+                    buttons.push(localize({ key: 'yesButton', comment: ['&& denotes a mnemonic'] }, "&&Yes"));
+                }
+                if (confirmationDialog.cancelButton) {
+                    buttons.push(confirmationDialog.cancelButton);
+                }
+                else {
+                    buttons.push(localize('cancelButton', "Cancel"));
+                }
+                break;
+            }
+            case DialogKind.Prompt: {
+                const promptDialog = dialog;
+                if (Array.isArray(promptDialog.buttons) && promptDialog.buttons.length > 0) {
+                    buttons.push(...promptDialog.buttons.map(button => button.label));
+                }
+                if (promptDialog.cancelButton) {
+                    if (promptDialog.cancelButton === true) {
+                        buttons.push(localize('cancelButton', "Cancel"));
+                    }
+                    else if (typeof promptDialog.cancelButton === 'string') {
+                        buttons.push(promptDialog.cancelButton);
+                    }
+                    else {
+                        if (promptDialog.cancelButton.label) {
+                            buttons.push(promptDialog.cancelButton.label);
+                        }
+                        else {
+                            buttons.push(localize('cancelButton', "Cancel"));
+                        }
+                    }
+                }
+                if (buttons.length === 0) {
+                    buttons.push(localize({ key: 'okButton', comment: ['&& denotes a mnemonic'] }, "&&OK"));
+                }
+                break;
+            }
+            case DialogKind.Input: {
+                const inputDialog = dialog;
+                if (inputDialog.primaryButton) {
+                    buttons.push(inputDialog.primaryButton);
+                }
+                else {
+                    buttons.push(localize({ key: 'okButton', comment: ['&& denotes a mnemonic'] }, "&&OK"));
+                }
+                if (inputDialog.cancelButton) {
+                    buttons.push(inputDialog.cancelButton);
+                }
+                else {
+                    buttons.push(localize('cancelButton', "Cancel"));
+                }
+                break;
+            }
+        }
+        return buttons;
+    }
+    getDialogType(type) {
+        if (typeof type === 'string') {
+            return type;
+        }
+        if (typeof type === 'number') {
+            return (type === Severity.Info) ? 'info' : (type === Severity.Error) ? 'error' : (type === Severity.Warning) ? 'warning' : 'none';
+        }
+        return undefined;
+    }
+    getPromptResult(prompt, buttonIndex, checkboxChecked) {
+        var _a, _b;
+        return __awaiter(this, void 0, void 0, function* () {
+            const promptButtons = [...((_a = prompt.buttons) !== null && _a !== void 0 ? _a : [])];
+            if (prompt.cancelButton && typeof prompt.cancelButton !== 'string' && typeof prompt.cancelButton !== 'boolean') {
+                promptButtons.push(prompt.cancelButton);
+            }
+            const result = yield ((_b = promptButtons[buttonIndex]) === null || _b === void 0 ? void 0 : _b.run({ checkboxChecked }));
+            return { result, checkboxChecked };
+        });
+    }
+}
+export const IFileDialogService = createDecorator('fileDialogService');
+const MAX_CONFIRM_FILES = 10;
+export function getFileNamesMessage(fileNamesOrResources) {
+    const message = [];
+    message.push(...fileNamesOrResources.slice(0, MAX_CONFIRM_FILES).map(fileNameOrResource => typeof fileNameOrResource === 'string' ? fileNameOrResource : basename(fileNameOrResource)));
+    if (fileNamesOrResources.length > MAX_CONFIRM_FILES) {
+        if (fileNamesOrResources.length - MAX_CONFIRM_FILES === 1) {
+            message.push(localize('moreFile', "...1 additional file not shown"));
+        }
+        else {
+            message.push(localize('moreFiles', "...{0} additional files not shown", fileNamesOrResources.length - MAX_CONFIRM_FILES));
+        }
+    }
+    message.push('');
+    return message.join('\n');
+}
+/**
+ * A utility method to ensure the options for the message box dialog
+ * are using properties that are consistent across all platforms and
+ * specific to the platform where necessary.
+ */
+export function massageMessageBoxOptions(options, productService) {
+    var _a, _b;
+    const massagedOptions = deepClone(options);
+    let buttons = ((_a = massagedOptions.buttons) !== null && _a !== void 0 ? _a : []).map(button => mnemonicButtonLabel(button));
+    let buttonIndeces = (options.buttons || []).map((button, index) => index);
+    let defaultId = 0; // by default the first button is default button
+    let cancelId = (_b = massagedOptions.cancelId) !== null && _b !== void 0 ? _b : buttons.length - 1; // by default the last button is cancel button
+    // Apply HIG per OS when more than one button is used
+    if (buttons.length > 1) {
+        const cancelButton = typeof cancelId === 'number' ? buttons[cancelId] : undefined;
+        if (isLinux || isMacintosh) {
+            // Linux: the GNOME HIG (https://developer.gnome.org/hig/patterns/feedback/dialogs.html?highlight=dialog)
+            // recommend the following:
+            // "Always ensure that the cancel button appears first, before the affirmative button. In left-to-right
+            //  locales, this is on the left. This button order ensures that users become aware of, and are reminded
+            //  of, the ability to cancel prior to encountering the affirmative button."
+            //
+            // Electron APIs do not reorder buttons for us, so we ensure a reverse order of buttons and a position
+            // of the cancel button (if provided) that matches the HIG
+            // macOS: the HIG (https://developer.apple.com/design/human-interface-guidelines/components/presentation/alerts)
+            // recommend the following:
+            // "Place buttons where people expect. In general, place the button people are most likely to choose on the trailing side in a
+            //  row of buttons or at the top in a stack of buttons. Always place the default button on the trailing side of a row or at the
+            //  top of a stack. Cancel buttons are typically on the leading side of a row or at the bottom of a stack."
+            //
+            // However: it seems that older macOS versions where 3 buttons were presented in a row differ from this
+            // recommendation. In fact, cancel buttons were placed to the left of the default button and secondary
+            // buttons on the far left. To support these older macOS versions we have to manually shuffle the cancel
+            // button in the same way as we do on Linux. This will not have any impact on newer macOS versions where
+            // shuffling is done for us.
+            if (typeof cancelButton === 'string' && buttons.length > 1 && cancelId !== 1) {
+                buttons.splice(cancelId, 1);
+                buttons.splice(1, 0, cancelButton);
+                const cancelButtonIndex = buttonIndeces[cancelId];
+                buttonIndeces.splice(cancelId, 1);
+                buttonIndeces.splice(1, 0, cancelButtonIndex);
+                cancelId = 1;
+            }
+            if (isLinux && buttons.length > 1) {
+                buttons = buttons.reverse();
+                buttonIndeces = buttonIndeces.reverse();
+                defaultId = buttons.length - 1;
+                if (typeof cancelButton === 'string') {
+                    cancelId = defaultId - 1;
+                }
+            }
+        }
+        else if (isWindows) {
+            // Windows: the HIG (https://learn.microsoft.com/en-us/windows/win32/uxguide/win-dialog-box)
+            // recommend the following:
+            // "One of the following sets of concise commands: Yes/No, Yes/No/Cancel, [Do it]/Cancel,
+            //  [Do it]/[Don't do it], [Do it]/[Don't do it]/Cancel."
+            //
+            // Electron APIs do not reorder buttons for us, so we ensure the position of the cancel button
+            // (if provided) that matches the HIG
+            if (typeof cancelButton === 'string' && buttons.length > 1 && cancelId !== buttons.length - 1 /* last action */) {
+                buttons.splice(cancelId, 1);
+                buttons.push(cancelButton);
+                const buttonIndex = buttonIndeces[cancelId];
+                buttonIndeces.splice(cancelId, 1);
+                buttonIndeces.push(buttonIndex);
+                cancelId = buttons.length - 1;
+            }
+        }
+    }
+    massagedOptions.buttons = buttons;
+    massagedOptions.defaultId = defaultId;
+    massagedOptions.cancelId = cancelId;
+    massagedOptions.noLink = true;
+    massagedOptions.title = massagedOptions.title || productService.nameLong;
+    return {
+        options: massagedOptions,
+        buttonIndeces
+    };
+}
diff -urN -x '*.map' a/vs/platform/dnd/browser/dnd.js b/vs/platform/dnd/browser/dnd.js
--- a/vs/platform/dnd/browser/dnd.js	2023-09-05 08:43:04.266809459 +0000
+++ b/vs/platform/dnd/browser/dnd.js	2023-09-05 08:45:14.305196462 +0000
@@ -1,10 +1,280 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+import { DataTransfers } from '../../../base/browser/dnd.js';
+import { coalesce } from '../../../base/common/arrays.js';
+import { DeferredPromise } from '../../../base/common/async.js';
+import { VSBuffer } from '../../../base/common/buffer.js';
+import { ResourceMap } from '../../../base/common/map.js';
+import { parse } from '../../../base/common/marshalling.js';
+import { Schemas } from '../../../base/common/network.js';
+import { isWeb } from '../../../base/common/platform.js';
+import { withNullAsUndefined } from '../../../base/common/types.js';
+import { URI } from '../../../base/common/uri.js';
+import { localize } from '../../../nls.js';
+import { IDialogService } from '../../dialogs/common/dialogs.js';
+import { HTMLFileSystemProvider } from '../../files/browser/htmlFileSystemProvider.js';
+import { WebFileSystemAccess } from '../../files/browser/webFileSystemAccess.js';
+import { ByteSize, IFileService } from '../../files/common/files.js';
+import { IInstantiationService } from '../../instantiation/common/instantiation.js';
+import { extractSelection } from '../../opener/common/opener.js';
 import { Registry } from '../../registry/common/platform.js';
 //#region Editor / Resources DND
 export const CodeDataTransfers = {
     EDITORS: 'CodeEditors',
     FILES: 'CodeFiles'
 };
+export function extractEditorsDropData(e) {
+    var _a;
+    const editors = [];
+    if (e.dataTransfer && e.dataTransfer.types.length > 0) {
+        // Data Transfer: Code Editors
+        const rawEditorsData = e.dataTransfer.getData(CodeDataTransfers.EDITORS);
+        if (rawEditorsData) {
+            try {
+                editors.push(...parse(rawEditorsData));
+            }
+            catch (error) {
+                // Invalid transfer
+            }
+        }
+        // Data Transfer: Resources
+        else {
+            try {
+                const rawResourcesData = e.dataTransfer.getData(DataTransfers.RESOURCES);
+                editors.push(...createDraggedEditorInputFromRawResourcesData(rawResourcesData));
+            }
+            catch (error) {
+                // Invalid transfer
+            }
+        }
+        // Check for native file transfer
+        if ((_a = e.dataTransfer) === null || _a === void 0 ? void 0 : _a.files) {
+            for (let i = 0; i < e.dataTransfer.files.length; i++) {
+                const file = e.dataTransfer.files[i];
+                if (file && file.path /* Electron only */) {
+                    try {
+                        editors.push({ resource: URI.file(file.path), isExternal: true, allowWorkspaceOpen: true });
+                    }
+                    catch (error) {
+                        // Invalid URI
+                    }
+                }
+            }
+        }
+        // Check for CodeFiles transfer
+        const rawCodeFiles = e.dataTransfer.getData(CodeDataTransfers.FILES);
+        if (rawCodeFiles) {
+            try {
+                const codeFiles = JSON.parse(rawCodeFiles);
+                for (const codeFile of codeFiles) {
+                    editors.push({ resource: URI.file(codeFile), isExternal: true, allowWorkspaceOpen: true });
+                }
+            }
+            catch (error) {
+                // Invalid transfer
+            }
+        }
+        // Workbench contributions
+        const contributions = Registry.as(Extensions.DragAndDropContribution).getAll();
+        for (const contribution of contributions) {
+            const data = e.dataTransfer.getData(contribution.dataFormatKey);
+            if (data) {
+                try {
+                    editors.push(...contribution.getEditorInputs(data));
+                }
+                catch (error) {
+                    // Invalid transfer
+                }
+            }
+        }
+    }
+    // Prevent duplicates: it is possible that we end up with the same
+    // dragged editor multiple times because multiple data transfers
+    // are being used (https://github.com/microsoft/vscode/issues/128925)
+    const coalescedEditors = [];
+    const seen = new ResourceMap();
+    for (const editor of editors) {
+        if (!editor.resource) {
+            coalescedEditors.push(editor);
+        }
+        else if (!seen.has(editor.resource)) {
+            coalescedEditors.push(editor);
+            seen.set(editor.resource, true);
+        }
+    }
+    return coalescedEditors;
+}
+export function extractEditorsAndFilesDropData(accessor, e) {
+    var _a;
+    return __awaiter(this, void 0, void 0, function* () {
+        const editors = extractEditorsDropData(e);
+        // Web: Check for file transfer
+        if (e.dataTransfer && isWeb && containsDragType(e, DataTransfers.FILES)) {
+            const files = e.dataTransfer.items;
+            if (files) {
+                const instantiationService = accessor.get(IInstantiationService);
+                const filesData = yield instantiationService.invokeFunction(accessor => extractFilesDropData(accessor, e));
+                for (const fileData of filesData) {
+                    editors.push({ resource: fileData.resource, contents: (_a = fileData.contents) === null || _a === void 0 ? void 0 : _a.toString(), isExternal: true, allowWorkspaceOpen: fileData.isDirectory });
+                }
+            }
+        }
+        return editors;
+    });
+}
+export function createDraggedEditorInputFromRawResourcesData(rawResourcesData) {
+    const editors = [];
+    if (rawResourcesData) {
+        const resourcesRaw = JSON.parse(rawResourcesData);
+        for (const resourceRaw of resourcesRaw) {
+            if (resourceRaw.indexOf(':') > 0) { // mitigate https://github.com/microsoft/vscode/issues/124946
+                const { selection, uri } = extractSelection(URI.parse(resourceRaw));
+                editors.push({ resource: uri, options: { selection } });
+            }
+        }
+    }
+    return editors;
+}
+function extractFilesDropData(accessor, event) {
+    var _a, _b;
+    return __awaiter(this, void 0, void 0, function* () {
+        // Try to extract via `FileSystemHandle`
+        if (WebFileSystemAccess.supported(window)) {
+            const items = (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.items;
+            if (items) {
+                return extractFileTransferData(accessor, items);
+            }
+        }
+        // Try to extract via `FileList`
+        const files = (_b = event.dataTransfer) === null || _b === void 0 ? void 0 : _b.files;
+        if (!files) {
+            return [];
+        }
+        return extractFileListData(accessor, files);
+    });
+}
+function extractFileTransferData(accessor, items) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const fileSystemProvider = accessor.get(IFileService).getProvider(Schemas.file);
+        if (!(fileSystemProvider instanceof HTMLFileSystemProvider)) {
+            return []; // only supported when running in web
+        }
+        const results = [];
+        for (let i = 0; i < items.length; i++) {
+            const file = items[i];
+            if (file) {
+                const result = new DeferredPromise();
+                results.push(result);
+                (() => __awaiter(this, void 0, void 0, function* () {
+                    try {
+                        const handle = yield file.getAsFileSystemHandle();
+                        if (!handle) {
+                            result.complete(undefined);
+                            return;
+                        }
+                        if (WebFileSystemAccess.isFileSystemFileHandle(handle)) {
+                            result.complete({
+                                resource: yield fileSystemProvider.registerFileHandle(handle),
+                                isDirectory: false
+                            });
+                        }
+                        else if (WebFileSystemAccess.isFileSystemDirectoryHandle(handle)) {
+                            result.complete({
+                                resource: yield fileSystemProvider.registerDirectoryHandle(handle),
+                                isDirectory: true
+                            });
+                        }
+                        else {
+                            result.complete(undefined);
+                        }
+                    }
+                    catch (error) {
+                        result.complete(undefined);
+                    }
+                }))();
+            }
+        }
+        return coalesce(yield Promise.all(results.map(result => result.p)));
+    });
+}
+export function extractFileListData(accessor, files) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const dialogService = accessor.get(IDialogService);
+        const results = [];
+        for (let i = 0; i < files.length; i++) {
+            const file = files.item(i);
+            if (file) {
+                // Skip for very large files because this operation is unbuffered
+                if (file.size > 100 * ByteSize.MB) {
+                    dialogService.warn(localize('fileTooLarge', "File is too large to open as untitled editor. Please upload it first into the file explorer and then try again."));
+                    continue;
+                }
+                const result = new DeferredPromise();
+                results.push(result);
+                const reader = new FileReader();
+                reader.onerror = () => result.complete(undefined);
+                reader.onabort = () => result.complete(undefined);
+                reader.onload = (event) => __awaiter(this, void 0, void 0, function* () {
+                    var _a;
+                    const name = file.name;
+                    const loadResult = withNullAsUndefined((_a = event.target) === null || _a === void 0 ? void 0 : _a.result);
+                    if (typeof name !== 'string' || typeof loadResult === 'undefined') {
+                        result.complete(undefined);
+                        return;
+                    }
+                    result.complete({
+                        resource: URI.from({ scheme: Schemas.untitled, path: name }),
+                        contents: typeof loadResult === 'string' ? VSBuffer.fromString(loadResult) : VSBuffer.wrap(new Uint8Array(loadResult))
+                    });
+                });
+                // Start reading
+                reader.readAsArrayBuffer(file);
+            }
+        }
+        return coalesce(yield Promise.all(results.map(result => result.p)));
+    });
+}
+//#endregion
+export function containsDragType(event, ...dragTypesToFind) {
+    if (!event.dataTransfer) {
+        return false;
+    }
+    const dragTypes = event.dataTransfer.types;
+    const lowercaseDragTypes = [];
+    for (let i = 0; i < dragTypes.length; i++) {
+        lowercaseDragTypes.push(dragTypes[i].toLowerCase()); // somehow the types are lowercase
+    }
+    for (const dragType of dragTypesToFind) {
+        if (lowercaseDragTypes.indexOf(dragType.toLowerCase()) >= 0) {
+            return true;
+        }
+    }
+    return false;
+}
 class DragAndDropContributionRegistry {
+    constructor() {
+        this._contributions = new Map();
+    }
+    register(contribution) {
+        if (this._contributions.has(contribution.dataFormatKey)) {
+            throw new Error(`A drag and drop contributiont with key '${contribution.dataFormatKey}' was already registered.`);
+        }
+        this._contributions.set(contribution.dataFormatKey, contribution);
+    }
+    getAll() {
+        return this._contributions.values();
+    }
 }
 export const Extensions = {
     DragAndDropContribution: 'workbench.contributions.dragAndDrop'
@@ -25,12 +295,24 @@
     hasData(proto) {
         return proto && proto === this.proto;
     }
+    clearData(proto) {
+        if (this.hasData(proto)) {
+            this.proto = undefined;
+            this.data = undefined;
+        }
+    }
     getData(proto) {
         if (this.hasData(proto)) {
             return this.data;
         }
         return undefined;
     }
+    setData(data, proto) {
+        if (proto) {
+            this.data = data;
+            this.proto = proto;
+        }
+    }
 }
 LocalSelectionTransfer.INSTANCE = new LocalSelectionTransfer();
 //#endregion
diff -urN -x '*.map' a/vs/platform/editor/common/editor.js b/vs/platform/editor/common/editor.js
--- a/vs/platform/editor/common/editor.js	2023-09-05 08:43:04.266809459 +0000
+++ b/vs/platform/editor/common/editor.js	2023-09-05 08:45:14.317196634 +0000
@@ -1,3 +1,42 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+export var EditorActivation;
+(function (EditorActivation) {
+    /**
+     * Activate the editor after it opened. This will automatically restore
+     * the editor if it is minimized.
+     */
+    EditorActivation[EditorActivation["ACTIVATE"] = 1] = "ACTIVATE";
+    /**
+     * Only restore the editor if it is minimized but do not activate it.
+     *
+     * Note: will only work in combination with the `preserveFocus: true` option.
+     * Otherwise, if focus moves into the editor, it will activate and restore
+     * automatically.
+     */
+    EditorActivation[EditorActivation["RESTORE"] = 2] = "RESTORE";
+    /**
+     * Preserve the current active editor.
+     *
+     * Note: will only work in combination with the `preserveFocus: true` option.
+     * Otherwise, if focus moves into the editor, it will activate and restore
+     * automatically.
+     */
+    EditorActivation[EditorActivation["PRESERVE"] = 3] = "PRESERVE";
+})(EditorActivation || (EditorActivation = {}));
+export var EditorResolution;
+(function (EditorResolution) {
+    /**
+     * Displays a picker and allows the user to decide which editor to use.
+     */
+    EditorResolution[EditorResolution["PICK"] = 0] = "PICK";
+    /**
+     * Only exclusive editors are considered.
+     */
+    EditorResolution[EditorResolution["EXCLUSIVE_ONLY"] = 1] = "EXCLUSIVE_ONLY";
+})(EditorResolution || (EditorResolution = {}));
 export var EditorOpenSource;
 (function (EditorOpenSource) {
     /**
diff -urN -x '*.map' a/vs/platform/environment/common/argv.js b/vs/platform/environment/common/argv.js
--- a/vs/platform/environment/common/argv.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/platform/environment/common/argv.js	2023-09-05 08:45:14.317196634 +0000
@@ -0,0 +1,5 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+export {};
diff -urN -x '*.map' a/vs/platform/environment/common/environment.js b/vs/platform/environment/common/environment.js
--- a/vs/platform/environment/common/environment.js	2023-09-05 08:43:04.270809563 +0000
+++ b/vs/platform/environment/common/environment.js	2023-09-05 08:45:14.313196577 +0000
@@ -1,2 +1,7 @@
-import { createDecorator } from '../../instantiation/common/instantiation.js';
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { createDecorator, refineServiceDecorator } from '../../instantiation/common/instantiation.js';
 export const IEnvironmentService = createDecorator('environmentService');
+export const INativeEnvironmentService = refineServiceDecorator(IEnvironmentService);
diff -urN -x '*.map' a/vs/platform/extensions/common/extensions.js b/vs/platform/extensions/common/extensions.js
--- a/vs/platform/extensions/common/extensions.js	2023-09-05 08:43:04.270809563 +0000
+++ b/vs/platform/extensions/common/extensions.js	2023-09-05 08:45:14.313196577 +0000
@@ -1,3 +1,42 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import * as strings from '../../../base/common/strings.js';
+import { createDecorator } from '../../instantiation/common/instantiation.js';
+import { getRemoteName } from '../../remote/common/remoteHosts.js';
+export const USER_MANIFEST_CACHE_FILE = 'extensions.user.cache';
+export const BUILTIN_MANIFEST_CACHE_FILE = 'extensions.builtin.cache';
+export const UNDEFINED_PUBLISHER = 'undefined_publisher';
+export const ALL_EXTENSION_KINDS = ['ui', 'workspace', 'web'];
+export function getWorkspaceSupportTypeMessage(supportType) {
+    if (typeof supportType === 'object' && supportType !== null) {
+        if (supportType.supported !== true) {
+            return supportType.description;
+        }
+    }
+    return undefined;
+}
+export const EXTENSION_CATEGORIES = [
+    'Azure',
+    'Data Science',
+    'Debuggers',
+    'Extension Packs',
+    'Education',
+    'Formatters',
+    'Keymaps',
+    'Language Packs',
+    'Linters',
+    'Machine Learning',
+    'Notebooks',
+    'Programming Languages',
+    'SCM Providers',
+    'Snippets',
+    'Testing',
+    'Themes',
+    'Visualization',
+    'Other',
+];
 /**
  * **!Do not construct directly!**
  *
@@ -19,6 +58,23 @@
         this.value = value;
         this._lower = value.toLowerCase();
     }
+    static equals(a, b) {
+        if (typeof a === 'undefined' || a === null) {
+            return (typeof b === 'undefined' || b === null);
+        }
+        if (typeof b === 'undefined' || b === null) {
+            return false;
+        }
+        if (typeof a === 'string' || typeof b === 'string') {
+            // At least one of the arguments is an extension id in string form,
+            // so we have to use the string comparison which ignores case.
+            const aValue = (typeof a === 'string' ? a : a.value);
+            const bValue = (typeof b === 'string' ? b : b.value);
+            return strings.equalsIgnoreCase(aValue, bValue);
+        }
+        // Now we know both arguments are ExtensionIdentifier
+        return (a._lower === b._lower);
+    }
     /**
      * Gives the value by which to index (for equality).
      */
@@ -30,6 +86,9 @@
     }
 }
 export class ExtensionIdentifierSet {
+    get size() {
+        return this._set.size;
+    }
     constructor(iterable) {
         this._set = new Set();
         if (iterable) {
@@ -41,7 +100,57 @@
     add(id) {
         this._set.add(ExtensionIdentifier.toKey(id));
     }
+    delete(extensionId) {
+        return this._set.delete(ExtensionIdentifier.toKey(extensionId));
+    }
     has(id) {
         return this._set.has(ExtensionIdentifier.toKey(id));
     }
 }
+export class ExtensionIdentifierMap {
+    constructor() {
+        this._map = new Map();
+    }
+    clear() {
+        this._map.clear();
+    }
+    delete(id) {
+        this._map.delete(ExtensionIdentifier.toKey(id));
+    }
+    get(id) {
+        return this._map.get(ExtensionIdentifier.toKey(id));
+    }
+    has(id) {
+        return this._map.has(ExtensionIdentifier.toKey(id));
+    }
+    set(id, value) {
+        this._map.set(ExtensionIdentifier.toKey(id), value);
+    }
+    values() {
+        return this._map.values();
+    }
+    forEach(callbackfn) {
+        this._map.forEach(callbackfn);
+    }
+    [Symbol.iterator]() {
+        return this._map[Symbol.iterator]();
+    }
+}
+export function isApplicationScopedExtension(manifest) {
+    return isLanguagePackExtension(manifest);
+}
+export function isLanguagePackExtension(manifest) {
+    return manifest.contributes && manifest.contributes.localizations ? manifest.contributes.localizations.length > 0 : false;
+}
+export function isAuthenticationProviderExtension(manifest) {
+    return manifest.contributes && manifest.contributes.authentication ? manifest.contributes.authentication.length > 0 : false;
+}
+export function isResolverExtension(manifest, remoteAuthority) {
+    var _a;
+    if (remoteAuthority) {
+        const activationEvent = `onResolveRemoteAuthority:${getRemoteName(remoteAuthority)}`;
+        return !!((_a = manifest.activationEvents) === null || _a === void 0 ? void 0 : _a.includes(activationEvent));
+    }
+    return false;
+}
+export const IBuiltinExtensionsScannerService = createDecorator('IBuiltinExtensionsScannerService');
diff -urN -x '*.map' a/vs/platform/files/browser/htmlFileSystemProvider.js b/vs/platform/files/browser/htmlFileSystemProvider.js
--- a/vs/platform/files/browser/htmlFileSystemProvider.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/platform/files/browser/htmlFileSystemProvider.js	2023-09-05 08:45:14.313196577 +0000
@@ -0,0 +1,433 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __asyncValues = (this && this.__asyncValues) || function (o) {
+    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
+    var m = o[Symbol.asyncIterator], i;
+    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
+    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
+    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
+};
+import { localize } from '../../../nls.js';
+import { URI } from '../../../base/common/uri.js';
+import { VSBuffer } from '../../../base/common/buffer.js';
+import { Event } from '../../../base/common/event.js';
+import { Disposable } from '../../../base/common/lifecycle.js';
+import { Schemas } from '../../../base/common/network.js';
+import { basename, extname, normalize } from '../../../base/common/path.js';
+import { isLinux } from '../../../base/common/platform.js';
+import { extUri, extUriIgnorePathCase } from '../../../base/common/resources.js';
+import { newWriteableStream } from '../../../base/common/stream.js';
+import { createFileSystemProviderError, FileSystemProviderError, FileSystemProviderErrorCode, FileType } from '../common/files.js';
+import { WebFileSystemAccess } from './webFileSystemAccess.js';
+export class HTMLFileSystemProvider {
+    get capabilities() {
+        if (!this._capabilities) {
+            this._capabilities =
+                2 /* FileSystemProviderCapabilities.FileReadWrite */ |
+                    16 /* FileSystemProviderCapabilities.FileReadStream */;
+            if (isLinux) {
+                this._capabilities |= 1024 /* FileSystemProviderCapabilities.PathCaseSensitive */;
+            }
+        }
+        return this._capabilities;
+    }
+    //#endregion
+    constructor(indexedDB, store, logService) {
+        this.indexedDB = indexedDB;
+        this.store = store;
+        this.logService = logService;
+        //#region Events (unsupported)
+        this.onDidChangeCapabilities = Event.None;
+        this.onDidChangeFile = Event.None;
+        //#endregion
+        //#region File Capabilities
+        this.extUri = isLinux ? extUri : extUriIgnorePathCase;
+        //#endregion
+        //#region File/Directoy Handle Registry
+        this._files = new Map();
+        this._directories = new Map();
+    }
+    //#region File Metadata Resolving
+    stat(resource) {
+        return __awaiter(this, void 0, void 0, function* () {
+            try {
+                const handle = yield this.getHandle(resource);
+                if (!handle) {
+                    throw this.createFileSystemProviderError(resource, 'No such file or directory, stat', FileSystemProviderErrorCode.FileNotFound);
+                }
+                if (WebFileSystemAccess.isFileSystemFileHandle(handle)) {
+                    const file = yield handle.getFile();
+                    return {
+                        type: FileType.File,
+                        mtime: file.lastModified,
+                        ctime: 0,
+                        size: file.size
+                    };
+                }
+                return {
+                    type: FileType.Directory,
+                    mtime: 0,
+                    ctime: 0,
+                    size: 0
+                };
+            }
+            catch (error) {
+                throw this.toFileSystemProviderError(error);
+            }
+        });
+    }
+    readdir(resource) {
+        var _a, e_1, _b, _c;
+        return __awaiter(this, void 0, void 0, function* () {
+            try {
+                const handle = yield this.getDirectoryHandle(resource);
+                if (!handle) {
+                    throw this.createFileSystemProviderError(resource, 'No such file or directory, readdir', FileSystemProviderErrorCode.FileNotFound);
+                }
+                const result = [];
+                try {
+                    for (var _d = true, handle_1 = __asyncValues(handle), handle_1_1; handle_1_1 = yield handle_1.next(), _a = handle_1_1.done, !_a; _d = true) {
+                        _c = handle_1_1.value;
+                        _d = false;
+                        const [name, child] = _c;
+                        result.push([name, WebFileSystemAccess.isFileSystemFileHandle(child) ? FileType.File : FileType.Directory]);
+                    }
+                }
+                catch (e_1_1) { e_1 = { error: e_1_1 }; }
+                finally {
+                    try {
+                        if (!_d && !_a && (_b = handle_1.return)) yield _b.call(handle_1);
+                    }
+                    finally { if (e_1) throw e_1.error; }
+                }
+                return result;
+            }
+            catch (error) {
+                throw this.toFileSystemProviderError(error);
+            }
+        });
+    }
+    //#endregion
+    //#region File Reading/Writing
+    readFileStream(resource, opts, token) {
+        const stream = newWriteableStream(data => VSBuffer.concat(data.map(data => VSBuffer.wrap(data))).buffer, {
+            // Set a highWaterMark to prevent the stream
+            // for file upload to produce large buffers
+            // in-memory
+            highWaterMark: 10
+        });
+        (() => __awaiter(this, void 0, void 0, function* () {
+            try {
+                const handle = yield this.getFileHandle(resource);
+                if (!handle) {
+                    throw this.createFileSystemProviderError(resource, 'No such file or directory, readFile', FileSystemProviderErrorCode.FileNotFound);
+                }
+                const file = yield handle.getFile();
+                // Partial file: implemented simply via `readFile`
+                if (typeof opts.length === 'number' || typeof opts.position === 'number') {
+                    let buffer = new Uint8Array(yield file.arrayBuffer());
+                    if (typeof (opts === null || opts === void 0 ? void 0 : opts.position) === 'number') {
+                        buffer = buffer.slice(opts.position);
+                    }
+                    if (typeof (opts === null || opts === void 0 ? void 0 : opts.length) === 'number') {
+                        buffer = buffer.slice(0, opts.length);
+                    }
+                    stream.end(buffer);
+                }
+                // Entire file
+                else {
+                    const reader = file.stream().getReader();
+                    let res = yield reader.read();
+                    while (!res.done) {
+                        if (token.isCancellationRequested) {
+                            break;
+                        }
+                        // Write buffer into stream but make sure to wait
+                        // in case the `highWaterMark` is reached
+                        yield stream.write(res.value);
+                        if (token.isCancellationRequested) {
+                            break;
+                        }
+                        res = yield reader.read();
+                    }
+                    stream.end(undefined);
+                }
+            }
+            catch (error) {
+                stream.error(this.toFileSystemProviderError(error));
+                stream.end();
+            }
+        }))();
+        return stream;
+    }
+    readFile(resource) {
+        return __awaiter(this, void 0, void 0, function* () {
+            try {
+                const handle = yield this.getFileHandle(resource);
+                if (!handle) {
+                    throw this.createFileSystemProviderError(resource, 'No such file or directory, readFile', FileSystemProviderErrorCode.FileNotFound);
+                }
+                const file = yield handle.getFile();
+                return new Uint8Array(yield file.arrayBuffer());
+            }
+            catch (error) {
+                throw this.toFileSystemProviderError(error);
+            }
+        });
+    }
+    writeFile(resource, content, opts) {
+        return __awaiter(this, void 0, void 0, function* () {
+            try {
+                let handle = yield this.getFileHandle(resource);
+                // Validate target unless { create: true, overwrite: true }
+                if (!opts.create || !opts.overwrite) {
+                    if (handle) {
+                        if (!opts.overwrite) {
+                            throw this.createFileSystemProviderError(resource, 'File already exists, writeFile', FileSystemProviderErrorCode.FileExists);
+                        }
+                    }
+                    else {
+                        if (!opts.create) {
+                            throw this.createFileSystemProviderError(resource, 'No such file, writeFile', FileSystemProviderErrorCode.FileNotFound);
+                        }
+                    }
+                }
+                // Create target as needed
+                if (!handle) {
+                    const parent = yield this.getDirectoryHandle(this.extUri.dirname(resource));
+                    if (!parent) {
+                        throw this.createFileSystemProviderError(resource, 'No such parent directory, writeFile', FileSystemProviderErrorCode.FileNotFound);
+                    }
+                    handle = yield parent.getFileHandle(this.extUri.basename(resource), { create: true });
+                    if (!handle) {
+                        throw this.createFileSystemProviderError(resource, 'Unable to create file , writeFile', FileSystemProviderErrorCode.Unknown);
+                    }
+                }
+                // Write to target overwriting any existing contents
+                const writable = yield handle.createWritable();
+                yield writable.write(content);
+                yield writable.close();
+            }
+            catch (error) {
+                throw this.toFileSystemProviderError(error);
+            }
+        });
+    }
+    //#endregion
+    //#region Move/Copy/Delete/Create Folder
+    mkdir(resource) {
+        return __awaiter(this, void 0, void 0, function* () {
+            try {
+                const parent = yield this.getDirectoryHandle(this.extUri.dirname(resource));
+                if (!parent) {
+                    throw this.createFileSystemProviderError(resource, 'No such parent directory, mkdir', FileSystemProviderErrorCode.FileNotFound);
+                }
+                yield parent.getDirectoryHandle(this.extUri.basename(resource), { create: true });
+            }
+            catch (error) {
+                throw this.toFileSystemProviderError(error);
+            }
+        });
+    }
+    delete(resource, opts) {
+        return __awaiter(this, void 0, void 0, function* () {
+            try {
+                const parent = yield this.getDirectoryHandle(this.extUri.dirname(resource));
+                if (!parent) {
+                    throw this.createFileSystemProviderError(resource, 'No such parent directory, delete', FileSystemProviderErrorCode.FileNotFound);
+                }
+                return parent.removeEntry(this.extUri.basename(resource), { recursive: opts.recursive });
+            }
+            catch (error) {
+                throw this.toFileSystemProviderError(error);
+            }
+        });
+    }
+    rename(from, to, opts) {
+        return __awaiter(this, void 0, void 0, function* () {
+            try {
+                if (this.extUri.isEqual(from, to)) {
+                    return; // no-op if the paths are the same
+                }
+                // Implement file rename by write + delete
+                const fileHandle = yield this.getFileHandle(from);
+                if (fileHandle) {
+                    const file = yield fileHandle.getFile();
+                    const contents = new Uint8Array(yield file.arrayBuffer());
+                    yield this.writeFile(to, contents, { create: true, overwrite: opts.overwrite, unlock: false, atomic: false });
+                    yield this.delete(from, { recursive: false, useTrash: false, atomic: false });
+                }
+                // File API does not support any real rename otherwise
+                else {
+                    throw this.createFileSystemProviderError(from, localize('fileSystemRenameError', "Rename is only supported for files."), FileSystemProviderErrorCode.Unavailable);
+                }
+            }
+            catch (error) {
+                throw this.toFileSystemProviderError(error);
+            }
+        });
+    }
+    //#endregion
+    //#region File Watching (unsupported)
+    watch(resource, opts) {
+        return Disposable.None;
+    }
+    registerFileHandle(handle) {
+        return this.registerHandle(handle, this._files);
+    }
+    registerDirectoryHandle(handle) {
+        return this.registerHandle(handle, this._directories);
+    }
+    get directories() {
+        return this._directories.values();
+    }
+    registerHandle(handle, map) {
+        var _a, _b, _c;
+        return __awaiter(this, void 0, void 0, function* () {
+            let handleId = `/${handle.name}`;
+            // Compute a valid handle ID in case this exists already
+            if (map.has(handleId) && !(yield ((_a = map.get(handleId)) === null || _a === void 0 ? void 0 : _a.isSameEntry(handle)))) {
+                const fileExt = extname(handle.name);
+                const fileName = basename(handle.name, fileExt);
+                let handleIdCounter = 1;
+                do {
+                    handleId = `/${fileName}-${handleIdCounter++}${fileExt}`;
+                } while (map.has(handleId) && !(yield ((_b = map.get(handleId)) === null || _b === void 0 ? void 0 : _b.isSameEntry(handle))));
+            }
+            map.set(handleId, handle);
+            // Remember in IndexDB for future lookup
+            try {
+                yield ((_c = this.indexedDB) === null || _c === void 0 ? void 0 : _c.runInTransaction(this.store, 'readwrite', objectStore => objectStore.put(handle, handleId)));
+            }
+            catch (error) {
+                this.logService.error(error);
+            }
+            return URI.from({ scheme: Schemas.file, path: handleId });
+        });
+    }
+    getHandle(resource) {
+        return __awaiter(this, void 0, void 0, function* () {
+            // First: try to find a well known handle first
+            let handle = yield this.doGetHandle(resource);
+            // Second: walk up parent directories and resolve handle if possible
+            if (!handle) {
+                const parent = yield this.getDirectoryHandle(this.extUri.dirname(resource));
+                if (parent) {
+                    const name = extUri.basename(resource);
+                    try {
+                        handle = yield parent.getFileHandle(name);
+                    }
+                    catch (error) {
+                        try {
+                            handle = yield parent.getDirectoryHandle(name);
+                        }
+                        catch (error) {
+                            // Ignore
+                        }
+                    }
+                }
+            }
+            return handle;
+        });
+    }
+    getFileHandle(resource) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const handle = yield this.doGetHandle(resource);
+            if (handle instanceof FileSystemFileHandle) {
+                return handle;
+            }
+            const parent = yield this.getDirectoryHandle(this.extUri.dirname(resource));
+            try {
+                return yield (parent === null || parent === void 0 ? void 0 : parent.getFileHandle(extUri.basename(resource)));
+            }
+            catch (error) {
+                return undefined; // guard against possible DOMException
+            }
+        });
+    }
+    getDirectoryHandle(resource) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const handle = yield this.doGetHandle(resource);
+            if (handle instanceof FileSystemDirectoryHandle) {
+                return handle;
+            }
+            const parentUri = this.extUri.dirname(resource);
+            if (this.extUri.isEqual(parentUri, resource)) {
+                return undefined; // return when root is reached to prevent infinite recursion
+            }
+            const parent = yield this.getDirectoryHandle(parentUri);
+            try {
+                return yield (parent === null || parent === void 0 ? void 0 : parent.getDirectoryHandle(extUri.basename(resource)));
+            }
+            catch (error) {
+                return undefined; // guard against possible DOMException
+            }
+        });
+    }
+    doGetHandle(resource) {
+        var _a, _b;
+        return __awaiter(this, void 0, void 0, function* () {
+            // We store file system handles with the `handle.name`
+            // and as such require the resource to be on the root
+            if (this.extUri.dirname(resource).path !== '/') {
+                return undefined;
+            }
+            const handleId = resource.path.replace(/\/$/, ''); // remove potential slash from the end of the path
+            // First: check if we have a known handle stored in memory
+            const inMemoryHandle = (_a = this._files.get(handleId)) !== null && _a !== void 0 ? _a : this._directories.get(handleId);
+            if (inMemoryHandle) {
+                return inMemoryHandle;
+            }
+            // Second: check if we have a persisted handle in IndexedDB
+            const persistedHandle = yield ((_b = this.indexedDB) === null || _b === void 0 ? void 0 : _b.runInTransaction(this.store, 'readonly', store => store.get(handleId)));
+            if (WebFileSystemAccess.isFileSystemHandle(persistedHandle)) {
+                let hasPermissions = (yield persistedHandle.queryPermission()) === 'granted';
+                try {
+                    if (!hasPermissions) {
+                        hasPermissions = (yield persistedHandle.requestPermission()) === 'granted';
+                    }
+                }
+                catch (error) {
+                    this.logService.error(error); // this can fail with a DOMException
+                }
+                if (hasPermissions) {
+                    if (WebFileSystemAccess.isFileSystemFileHandle(persistedHandle)) {
+                        this._files.set(handleId, persistedHandle);
+                    }
+                    else if (WebFileSystemAccess.isFileSystemDirectoryHandle(persistedHandle)) {
+                        this._directories.set(handleId, persistedHandle);
+                    }
+                    return persistedHandle;
+                }
+            }
+            // Third: fail with an error
+            throw this.createFileSystemProviderError(resource, 'No file system handle registered', FileSystemProviderErrorCode.Unavailable);
+        });
+    }
+    //#endregion
+    toFileSystemProviderError(error) {
+        if (error instanceof FileSystemProviderError) {
+            return error; // avoid double conversion
+        }
+        let code = FileSystemProviderErrorCode.Unknown;
+        if (error.name === 'NotAllowedError') {
+            error = new Error(localize('fileSystemNotAllowedError', "Insufficient permissions. Please retry and allow the operation."));
+            code = FileSystemProviderErrorCode.Unavailable;
+        }
+        return createFileSystemProviderError(error, code);
+    }
+    createFileSystemProviderError(resource, msg, code) {
+        return createFileSystemProviderError(new Error(`${msg} (${normalize(resource.path)})`), code);
+    }
+}
diff -urN -x '*.map' a/vs/platform/files/browser/webFileSystemAccess.js b/vs/platform/files/browser/webFileSystemAccess.js
--- a/vs/platform/files/browser/webFileSystemAccess.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/platform/files/browser/webFileSystemAccess.js	2023-09-05 08:45:14.313196577 +0000
@@ -0,0 +1,35 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+/**
+ * Typings for the https://wicg.github.io/file-system-access
+ *
+ * Use `supported(window)` to find out if the browser supports this kind of API.
+ */
+export var WebFileSystemAccess;
+(function (WebFileSystemAccess) {
+    function supported(obj) {
+        if (typeof (obj === null || obj === void 0 ? void 0 : obj.showDirectoryPicker) === 'function') {
+            return true;
+        }
+        return false;
+    }
+    WebFileSystemAccess.supported = supported;
+    function isFileSystemHandle(handle) {
+        const candidate = handle;
+        if (!candidate) {
+            return false;
+        }
+        return typeof candidate.kind === 'string' && typeof candidate.queryPermission === 'function' && typeof candidate.requestPermission === 'function';
+    }
+    WebFileSystemAccess.isFileSystemHandle = isFileSystemHandle;
+    function isFileSystemFileHandle(handle) {
+        return handle.kind === 'file';
+    }
+    WebFileSystemAccess.isFileSystemFileHandle = isFileSystemFileHandle;
+    function isFileSystemDirectoryHandle(handle) {
+        return handle.kind === 'directory';
+    }
+    WebFileSystemAccess.isFileSystemDirectoryHandle = isFileSystemDirectoryHandle;
+})(WebFileSystemAccess || (WebFileSystemAccess = {}));
diff -urN -x '*.map' a/vs/platform/files/common/files.js b/vs/platform/files/common/files.js
--- a/vs/platform/files/common/files.js	2023-09-05 08:43:04.270809563 +0000
+++ b/vs/platform/files/common/files.js	2023-09-05 08:45:14.313196577 +0000
@@ -1,3 +1,386 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+import { TernarySearchTree } from '../../../base/common/ternarySearchTree.js';
+import { sep } from '../../../base/common/path.js';
+import { startsWithIgnoreCase } from '../../../base/common/strings.js';
+import { isNumber } from '../../../base/common/types.js';
+import { URI } from '../../../base/common/uri.js';
+import { localize } from '../../../nls.js';
+import { createDecorator } from '../../instantiation/common/instantiation.js';
+import { isWeb } from '../../../base/common/platform.js';
+import { Schemas } from '../../../base/common/network.js';
+//#region file service & providers
+export const IFileService = createDecorator('fileService');
+export function isFileOpenForWriteOptions(options) {
+    return options.create === true;
+}
+export var FileType;
+(function (FileType) {
+    /**
+     * File is unknown (neither file, directory nor symbolic link).
+     */
+    FileType[FileType["Unknown"] = 0] = "Unknown";
+    /**
+     * File is a normal file.
+     */
+    FileType[FileType["File"] = 1] = "File";
+    /**
+     * File is a directory.
+     */
+    FileType[FileType["Directory"] = 2] = "Directory";
+    /**
+     * File is a symbolic link.
+     *
+     * Note: even when the file is a symbolic link, you can test for
+     * `FileType.File` and `FileType.Directory` to know the type of
+     * the target the link points to.
+     */
+    FileType[FileType["SymbolicLink"] = 64] = "SymbolicLink";
+})(FileType || (FileType = {}));
+export var FilePermission;
+(function (FilePermission) {
+    /**
+     * File is readonly. Components like editors should not
+     * offer to edit the contents.
+     */
+    FilePermission[FilePermission["Readonly"] = 1] = "Readonly";
+    /**
+     * File is locked. Components like editors should offer
+     * to edit the contents and ask the user upon saving to
+     * remove the lock.
+     */
+    FilePermission[FilePermission["Locked"] = 2] = "Locked";
+})(FilePermission || (FilePermission = {}));
+export function hasReadWriteCapability(provider) {
+    return !!(provider.capabilities & 2 /* FileSystemProviderCapabilities.FileReadWrite */);
+}
+export function hasFileFolderCopyCapability(provider) {
+    return !!(provider.capabilities & 8 /* FileSystemProviderCapabilities.FileFolderCopy */);
+}
+export function hasFileCloneCapability(provider) {
+    return !!(provider.capabilities & 131072 /* FileSystemProviderCapabilities.FileClone */);
+}
+export function hasOpenReadWriteCloseCapability(provider) {
+    return !!(provider.capabilities & 4 /* FileSystemProviderCapabilities.FileOpenReadWriteClose */);
+}
+export function hasFileReadStreamCapability(provider) {
+    return !!(provider.capabilities & 16 /* FileSystemProviderCapabilities.FileReadStream */);
+}
+export function hasFileAtomicReadCapability(provider) {
+    if (!hasReadWriteCapability(provider)) {
+        return false; // we require the `FileReadWrite` capability too
+    }
+    return !!(provider.capabilities & 16384 /* FileSystemProviderCapabilities.FileAtomicRead */);
+}
+export function hasFileAtomicWriteCapability(provider) {
+    if (!hasReadWriteCapability(provider)) {
+        return false; // we require the `FileReadWrite` capability too
+    }
+    return !!(provider.capabilities & 32768 /* FileSystemProviderCapabilities.FileAtomicWrite */);
+}
+export function hasFileAtomicDeleteCapability(provider) {
+    return !!(provider.capabilities & 65536 /* FileSystemProviderCapabilities.FileAtomicDelete */);
+}
+export function hasReadonlyCapability(provider) {
+    return !!(provider.capabilities & 2048 /* FileSystemProviderCapabilities.Readonly */);
+}
+export var FileSystemProviderErrorCode;
+(function (FileSystemProviderErrorCode) {
+    FileSystemProviderErrorCode["FileExists"] = "EntryExists";
+    FileSystemProviderErrorCode["FileNotFound"] = "EntryNotFound";
+    FileSystemProviderErrorCode["FileNotADirectory"] = "EntryNotADirectory";
+    FileSystemProviderErrorCode["FileIsADirectory"] = "EntryIsADirectory";
+    FileSystemProviderErrorCode["FileExceedsStorageQuota"] = "EntryExceedsStorageQuota";
+    FileSystemProviderErrorCode["FileTooLarge"] = "EntryTooLarge";
+    FileSystemProviderErrorCode["FileWriteLocked"] = "EntryWriteLocked";
+    FileSystemProviderErrorCode["NoPermissions"] = "NoPermissions";
+    FileSystemProviderErrorCode["Unavailable"] = "Unavailable";
+    FileSystemProviderErrorCode["Unknown"] = "Unknown";
+})(FileSystemProviderErrorCode || (FileSystemProviderErrorCode = {}));
+export class FileSystemProviderError extends Error {
+    static create(error, code) {
+        const providerError = new FileSystemProviderError(error.toString(), code);
+        markAsFileSystemProviderError(providerError, code);
+        return providerError;
+    }
+    constructor(message, code) {
+        super(message);
+        this.code = code;
+    }
+}
+export function createFileSystemProviderError(error, code) {
+    return FileSystemProviderError.create(error, code);
+}
+export function ensureFileSystemProviderError(error) {
+    if (!error) {
+        return createFileSystemProviderError(localize('unknownError', "Unknown Error"), FileSystemProviderErrorCode.Unknown); // https://github.com/microsoft/vscode/issues/72798
+    }
+    return error;
+}
+export function markAsFileSystemProviderError(error, code) {
+    error.name = code ? `${code} (FileSystemError)` : `FileSystemError`;
+    return error;
+}
+export function toFileSystemProviderErrorCode(error) {
+    // Guard against abuse
+    if (!error) {
+        return FileSystemProviderErrorCode.Unknown;
+    }
+    // FileSystemProviderError comes with the code
+    if (error instanceof FileSystemProviderError) {
+        return error.code;
+    }
+    // Any other error, check for name match by assuming that the error
+    // went through the markAsFileSystemProviderError() method
+    const match = /^(.+) \(FileSystemError\)$/.exec(error.name);
+    if (!match) {
+        return FileSystemProviderErrorCode.Unknown;
+    }
+    switch (match[1]) {
+        case FileSystemProviderErrorCode.FileExists: return FileSystemProviderErrorCode.FileExists;
+        case FileSystemProviderErrorCode.FileIsADirectory: return FileSystemProviderErrorCode.FileIsADirectory;
+        case FileSystemProviderErrorCode.FileNotADirectory: return FileSystemProviderErrorCode.FileNotADirectory;
+        case FileSystemProviderErrorCode.FileNotFound: return FileSystemProviderErrorCode.FileNotFound;
+        case FileSystemProviderErrorCode.FileTooLarge: return FileSystemProviderErrorCode.FileTooLarge;
+        case FileSystemProviderErrorCode.FileWriteLocked: return FileSystemProviderErrorCode.FileWriteLocked;
+        case FileSystemProviderErrorCode.NoPermissions: return FileSystemProviderErrorCode.NoPermissions;
+        case FileSystemProviderErrorCode.Unavailable: return FileSystemProviderErrorCode.Unavailable;
+    }
+    return FileSystemProviderErrorCode.Unknown;
+}
+export function toFileOperationResult(error) {
+    // FileSystemProviderError comes with the result already
+    if (error instanceof FileOperationError) {
+        return error.fileOperationResult;
+    }
+    // Otherwise try to find from code
+    switch (toFileSystemProviderErrorCode(error)) {
+        case FileSystemProviderErrorCode.FileNotFound:
+            return 1 /* FileOperationResult.FILE_NOT_FOUND */;
+        case FileSystemProviderErrorCode.FileIsADirectory:
+            return 0 /* FileOperationResult.FILE_IS_DIRECTORY */;
+        case FileSystemProviderErrorCode.FileNotADirectory:
+            return 9 /* FileOperationResult.FILE_NOT_DIRECTORY */;
+        case FileSystemProviderErrorCode.FileWriteLocked:
+            return 5 /* FileOperationResult.FILE_WRITE_LOCKED */;
+        case FileSystemProviderErrorCode.NoPermissions:
+            return 6 /* FileOperationResult.FILE_PERMISSION_DENIED */;
+        case FileSystemProviderErrorCode.FileExists:
+            return 4 /* FileOperationResult.FILE_MOVE_CONFLICT */;
+        case FileSystemProviderErrorCode.FileTooLarge:
+            return 7 /* FileOperationResult.FILE_TOO_LARGE */;
+        default:
+            return 10 /* FileOperationResult.FILE_OTHER_ERROR */;
+    }
+}
+export class FileOperationEvent {
+    constructor(resource, operation, target) {
+        this.resource = resource;
+        this.operation = operation;
+        this.target = target;
+    }
+    isOperation(operation) {
+        return this.operation === operation;
+    }
+}
+export class FileChangesEvent {
+    constructor(changes, ignorePathCasing) {
+        this.added = undefined;
+        this.updated = undefined;
+        this.deleted = undefined;
+        /**
+         * @deprecated use the `contains` or `affects` method to efficiently find
+         * out if the event relates to a given resource. these methods ensure:
+         * - that there is no expensive lookup needed (by using a `TernarySearchTree`)
+         * - correctly handles `FileChangeType.DELETED` events
+         */
+        this.rawAdded = [];
+        /**
+        * @deprecated use the `contains` or `affects` method to efficiently find
+        * out if the event relates to a given resource. these methods ensure:
+        * - that there is no expensive lookup needed (by using a `TernarySearchTree`)
+        * - correctly handles `FileChangeType.DELETED` events
+        */
+        this.rawUpdated = [];
+        /**
+        * @deprecated use the `contains` or `affects` method to efficiently find
+        * out if the event relates to a given resource. these methods ensure:
+        * - that there is no expensive lookup needed (by using a `TernarySearchTree`)
+        * - correctly handles `FileChangeType.DELETED` events
+        */
+        this.rawDeleted = [];
+        const entriesByType = new Map();
+        for (const change of changes) {
+            const array = entriesByType.get(change.type);
+            if (array) {
+                array.push([change.resource, change]);
+            }
+            else {
+                entriesByType.set(change.type, [[change.resource, change]]);
+            }
+            switch (change.type) {
+                case 1 /* FileChangeType.ADDED */:
+                    this.rawAdded.push(change.resource);
+                    break;
+                case 0 /* FileChangeType.UPDATED */:
+                    this.rawUpdated.push(change.resource);
+                    break;
+                case 2 /* FileChangeType.DELETED */:
+                    this.rawDeleted.push(change.resource);
+                    break;
+            }
+        }
+        for (const [key, value] of entriesByType) {
+            switch (key) {
+                case 1 /* FileChangeType.ADDED */:
+                    this.added = TernarySearchTree.forUris(() => ignorePathCasing);
+                    this.added.fill(value);
+                    break;
+                case 0 /* FileChangeType.UPDATED */:
+                    this.updated = TernarySearchTree.forUris(() => ignorePathCasing);
+                    this.updated.fill(value);
+                    break;
+                case 2 /* FileChangeType.DELETED */:
+                    this.deleted = TernarySearchTree.forUris(() => ignorePathCasing);
+                    this.deleted.fill(value);
+                    break;
+            }
+        }
+    }
+    /**
+     * Find out if the file change events match the provided resource.
+     *
+     * Note: when passing `FileChangeType.DELETED`, we consider a match
+     * also when the parent of the resource got deleted.
+     */
+    contains(resource, ...types) {
+        return this.doContains(resource, { includeChildren: false }, ...types);
+    }
+    /**
+     * Find out if the file change events either match the provided
+     * resource, or contain a child of this resource.
+     */
+    affects(resource, ...types) {
+        return this.doContains(resource, { includeChildren: true }, ...types);
+    }
+    doContains(resource, options, ...types) {
+        var _a, _b, _c, _d, _e, _f;
+        if (!resource) {
+            return false;
+        }
+        const hasTypesFilter = types.length > 0;
+        // Added
+        if (!hasTypesFilter || types.includes(1 /* FileChangeType.ADDED */)) {
+            if ((_a = this.added) === null || _a === void 0 ? void 0 : _a.get(resource)) {
+                return true;
+            }
+            if (options.includeChildren && ((_b = this.added) === null || _b === void 0 ? void 0 : _b.findSuperstr(resource))) {
+                return true;
+            }
+        }
+        // Updated
+        if (!hasTypesFilter || types.includes(0 /* FileChangeType.UPDATED */)) {
+            if ((_c = this.updated) === null || _c === void 0 ? void 0 : _c.get(resource)) {
+                return true;
+            }
+            if (options.includeChildren && ((_d = this.updated) === null || _d === void 0 ? void 0 : _d.findSuperstr(resource))) {
+                return true;
+            }
+        }
+        // Deleted
+        if (!hasTypesFilter || types.includes(2 /* FileChangeType.DELETED */)) {
+            if ((_e = this.deleted) === null || _e === void 0 ? void 0 : _e.findSubstr(resource) /* deleted also considers parent folders */) {
+                return true;
+            }
+            if (options.includeChildren && ((_f = this.deleted) === null || _f === void 0 ? void 0 : _f.findSuperstr(resource))) {
+                return true;
+            }
+        }
+        return false;
+    }
+    /**
+     * Returns if this event contains added files.
+     */
+    gotAdded() {
+        return !!this.added;
+    }
+    /**
+     * Returns if this event contains deleted files.
+     */
+    gotDeleted() {
+        return !!this.deleted;
+    }
+    /**
+     * Returns if this event contains updated files.
+     */
+    gotUpdated() {
+        return !!this.updated;
+    }
+}
+export function isParent(path, candidate, ignoreCase) {
+    if (!path || !candidate || path === candidate) {
+        return false;
+    }
+    if (candidate.length > path.length) {
+        return false;
+    }
+    if (candidate.charAt(candidate.length - 1) !== sep) {
+        candidate += sep;
+    }
+    if (ignoreCase) {
+        return startsWithIgnoreCase(path, candidate);
+    }
+    return path.indexOf(candidate) === 0;
+}
+export class FileOperationError extends Error {
+    constructor(message, fileOperationResult, options) {
+        super(message);
+        this.fileOperationResult = fileOperationResult;
+        this.options = options;
+    }
+}
+export class TooLargeFileOperationError extends FileOperationError {
+    constructor(message, fileOperationResult, size, options) {
+        super(message, fileOperationResult, options);
+        this.fileOperationResult = fileOperationResult;
+        this.size = size;
+    }
+}
+export class NotModifiedSinceFileOperationError extends FileOperationError {
+    constructor(message, stat, options) {
+        super(message, 2 /* FileOperationResult.FILE_NOT_MODIFIED_SINCE */, options);
+        this.stat = stat;
+    }
+}
+//#endregion
+//#region Settings
+export const AutoSaveConfiguration = {
+    OFF: 'off',
+    AFTER_DELAY: 'afterDelay',
+    ON_FOCUS_CHANGE: 'onFocusChange',
+    ON_WINDOW_CHANGE: 'onWindowChange'
+};
+export const HotExitConfiguration = {
+    OFF: 'off',
+    ON_EXIT: 'onExit',
+    ON_EXIT_AND_WINDOW_CLOSE: 'onExitAndWindowClose'
+};
+export const FILES_ASSOCIATIONS_CONFIG = 'files.associations';
+export const FILES_EXCLUDE_CONFIG = 'files.exclude';
+export const FILES_READONLY_INCLUDE_CONFIG = 'files.readonlyInclude';
+export const FILES_READONLY_EXCLUDE_CONFIG = 'files.readonlyExclude';
+export const FILES_READONLY_FROM_PERMISSIONS_CONFIG = 'files.readonlyFromPermissions';
 //#endregion
 //#region Utilities
 export var FileKind;
@@ -6,4 +389,77 @@
     FileKind[FileKind["FOLDER"] = 1] = "FOLDER";
     FileKind[FileKind["ROOT_FOLDER"] = 2] = "ROOT_FOLDER";
 })(FileKind || (FileKind = {}));
+/**
+ * A hint to disable etag checking for reading/writing.
+ */
+export const ETAG_DISABLED = '';
+export function etag(stat) {
+    if (typeof stat.size !== 'number' || typeof stat.mtime !== 'number') {
+        return undefined;
+    }
+    return stat.mtime.toString(29) + stat.size.toString(31);
+}
+export function whenProviderRegistered(file, fileService) {
+    return __awaiter(this, void 0, void 0, function* () {
+        if (fileService.hasProvider(URI.from({ scheme: file.scheme }))) {
+            return;
+        }
+        return new Promise(resolve => {
+            const disposable = fileService.onDidChangeFileSystemProviderRegistrations(e => {
+                if (e.scheme === file.scheme && e.added) {
+                    disposable.dispose();
+                    resolve();
+                }
+            });
+        });
+    });
+}
+/**
+ * Helper to format a raw byte size into a human readable label.
+ */
+export class ByteSize {
+    static formatSize(size) {
+        if (!isNumber(size)) {
+            size = 0;
+        }
+        if (size < ByteSize.KB) {
+            return localize('sizeB', "{0}B", size.toFixed(0));
+        }
+        if (size < ByteSize.MB) {
+            return localize('sizeKB', "{0}KB", (size / ByteSize.KB).toFixed(2));
+        }
+        if (size < ByteSize.GB) {
+            return localize('sizeMB', "{0}MB", (size / ByteSize.MB).toFixed(2));
+        }
+        if (size < ByteSize.TB) {
+            return localize('sizeGB', "{0}GB", (size / ByteSize.GB).toFixed(2));
+        }
+        return localize('sizeTB', "{0}TB", (size / ByteSize.TB).toFixed(2));
+    }
+}
+ByteSize.KB = 1024;
+ByteSize.MB = ByteSize.KB * ByteSize.KB;
+ByteSize.GB = ByteSize.MB * ByteSize.KB;
+ByteSize.TB = ByteSize.GB * ByteSize.KB;
+export function getLargeFileConfirmationLimit(arg) {
+    const isRemote = typeof arg === 'string' || (arg === null || arg === void 0 ? void 0 : arg.scheme) === Schemas.vscodeRemote;
+    const isLocal = typeof arg !== 'string' && (arg === null || arg === void 0 ? void 0 : arg.scheme) === Schemas.file;
+    if (isLocal) {
+        // Local almost has no limit in file size
+        return 1024 * ByteSize.MB;
+    }
+    if (isRemote) {
+        // With a remote, pick a low limit to avoid
+        // potentially costly file transfers
+        return 10 * ByteSize.MB;
+    }
+    if (isWeb) {
+        // Web: we cannot know for sure if a cost
+        // is associated with the file transfer
+        // so we pick a reasonably small limit
+        return 50 * ByteSize.MB;
+    }
+    // Local desktop: almost no limit in file size
+    return 1024 * ByteSize.MB;
+}
 //#endregion
diff -urN -x '*.map' a/vs/platform/history/browser/contextScopedHistoryWidget.js b/vs/platform/history/browser/contextScopedHistoryWidget.js
--- a/vs/platform/history/browser/contextScopedHistoryWidget.js	2023-09-05 08:43:04.262809358 +0000
+++ b/vs/platform/history/browser/contextScopedHistoryWidget.js	2023-09-05 08:45:14.313196577 +0000
@@ -13,6 +13,7 @@
 };
 import { FindInput } from '../../../base/browser/ui/findinput/findInput.js';
 import { ReplaceInput } from '../../../base/browser/ui/findinput/replaceInput.js';
+import { HistoryInputBox } from '../../../base/browser/ui/inputbox/inputBox.js';
 import { ContextKeyExpr, IContextKeyService, RawContextKey } from '../../contextkey/common/contextkey.js';
 import { KeybindingsRegistry } from '../../keybinding/common/keybindingsRegistry.js';
 import { localize } from '../../../nls.js';
@@ -60,6 +61,17 @@
         }
     };
 }
+let ContextScopedHistoryInputBox = class ContextScopedHistoryInputBox extends HistoryInputBox {
+    constructor(container, contextViewProvider, options, contextKeyService) {
+        super(container, contextViewProvider, options);
+        const scopedContextKeyService = this._register(contextKeyService.createScoped(this.element));
+        this._register(registerAndCreateHistoryNavigationContext(scopedContextKeyService, this));
+    }
+};
+ContextScopedHistoryInputBox = __decorate([
+    __param(3, IContextKeyService)
+], ContextScopedHistoryInputBox);
+export { ContextScopedHistoryInputBox };
 let ContextScopedFindInput = class ContextScopedFindInput extends FindInput {
     constructor(container, contextViewProvider, options, contextKeyService) {
         super(container, contextViewProvider, options);
diff -urN -x '*.map' a/vs/platform/instantiation/common/graph.js b/vs/platform/instantiation/common/graph.js
--- a/vs/platform/instantiation/common/graph.js	2023-09-05 08:43:04.266809459 +0000
+++ b/vs/platform/instantiation/common/graph.js	2023-09-05 08:45:14.313196577 +0000
@@ -48,6 +48,9 @@
         }
         return node;
     }
+    lookup(data) {
+        return this._nodes.get(this._hashFn(data));
+    }
     isEmpty() {
         return this._nodes.size === 0;
     }
diff -urN -x '*.map' a/vs/platform/instantiation/common/instantiation.js b/vs/platform/instantiation/common/instantiation.js
--- a/vs/platform/instantiation/common/instantiation.js	2023-09-05 08:43:04.266809459 +0000
+++ b/vs/platform/instantiation/common/instantiation.js	2023-09-05 08:45:14.313196577 +0000
@@ -40,3 +40,6 @@
     _util.serviceIds.set(serviceId, id);
     return id;
 }
+export function refineServiceDecorator(serviceIdentifier) {
+    return serviceIdentifier;
+}
diff -urN -x '*.map' a/vs/platform/instantiation/common/serviceCollection.js b/vs/platform/instantiation/common/serviceCollection.js
--- a/vs/platform/instantiation/common/serviceCollection.js	2023-09-05 08:43:04.266809459 +0000
+++ b/vs/platform/instantiation/common/serviceCollection.js	2023-09-05 08:45:14.313196577 +0000
@@ -14,6 +14,9 @@
         this._entries.set(id, instanceOrDescriptor);
         return result;
     }
+    has(id) {
+        return this._entries.has(id);
+    }
     get(id) {
         return this._entries.get(id);
     }
diff -urN -x '*.map' a/vs/platform/jsonschemas/common/jsonContributionRegistry.js b/vs/platform/jsonschemas/common/jsonContributionRegistry.js
--- a/vs/platform/jsonschemas/common/jsonContributionRegistry.js	2023-09-05 08:43:04.270809563 +0000
+++ b/vs/platform/jsonschemas/common/jsonContributionRegistry.js	2023-09-05 08:45:14.313196577 +0000
@@ -16,6 +16,7 @@
 class JSONContributionRegistry {
     constructor() {
         this._onDidChangeSchema = new Emitter();
+        this.onDidChangeSchema = this._onDidChangeSchema.event;
         this.schemasById = {};
     }
     registerSchema(uri, unresolvedSchemaContent) {
@@ -25,6 +26,11 @@
     notifySchemaChanged(uri) {
         this._onDidChangeSchema.fire(uri);
     }
+    getSchemaContributions() {
+        return {
+            schemas: this.schemasById,
+        };
+    }
 }
 const jsonContributionRegistry = new JSONContributionRegistry();
 platform.Registry.add(Extensions.JSONContribution, jsonContributionRegistry);
diff -urN -x '*.map' a/vs/platform/keybinding/common/abstractKeybindingService.js b/vs/platform/keybinding/common/abstractKeybindingService.js
--- a/vs/platform/keybinding/common/abstractKeybindingService.js	2023-09-05 08:43:04.254809155 +0000
+++ b/vs/platform/keybinding/common/abstractKeybindingService.js	2023-09-05 08:45:14.313196577 +0000
@@ -2,6 +2,7 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
+import * as arrays from '../../../base/common/arrays.js';
 import { IntervalTimer, TimeoutTimer } from '../../../base/common/async.js';
 import { illegalState } from '../../../base/common/errors.js';
 import { Emitter, Event } from '../../../base/common/event.js';
@@ -36,14 +37,30 @@
     dispose() {
         super.dispose();
     }
+    getDefaultKeybindingsContent() {
+        return '';
+    }
+    toggleLogging() {
+        this._logging = !this._logging;
+        return this._logging;
+    }
     _log(str) {
         if (this._logging) {
             this._logService.info(`[KeybindingService]: ${str}`);
         }
     }
+    getDefaultKeybindings() {
+        return this._getResolver().getDefaultKeybindings();
+    }
     getKeybindings() {
         return this._getResolver().getKeybindings();
     }
+    customKeybindingsCount() {
+        return 0;
+    }
+    lookupKeybindings(commandId) {
+        return arrays.coalesce(this._getResolver().lookupKeybindings(commandId).map(item => item.resolvedKeybinding));
+    }
     lookupKeybinding(commandId, context) {
         const result = this._getResolver().lookupPrimaryKeybinding(commandId, context || this._contextKeyService);
         if (!result) {
@@ -115,6 +132,16 @@
         this._currentChords = [];
         IME.enable();
     }
+    dispatchByUserSettingsLabel(userSettingsLabel, target) {
+        this._log(`/ Dispatching keybinding triggered via menu entry accelerator - ${userSettingsLabel}`);
+        const keybindings = this.resolveUserBinding(userSettingsLabel);
+        if (keybindings.length === 0) {
+            this._log(`\\ Could not resolve - ${userSettingsLabel}`);
+        }
+        else {
+            this._doDispatch(keybindings[0], target, /*isSingleModiferChord*/ false);
+        }
+    }
     _dispatch(e, target) {
         return this._doDispatch(this.resolveKeyboardEvent(e), target, /*isSingleModiferChord*/ false);
     }
diff -urN -x '*.map' a/vs/platform/keybinding/common/baseResolvedKeybinding.js b/vs/platform/keybinding/common/baseResolvedKeybinding.js
--- a/vs/platform/keybinding/common/baseResolvedKeybinding.js	2023-09-05 08:43:04.254809155 +0000
+++ b/vs/platform/keybinding/common/baseResolvedKeybinding.js	2023-09-05 08:45:14.313196577 +0000
@@ -35,6 +35,9 @@
     getUserSettingsLabel() {
         return UserSettingsLabelProvider.toLabel(this._os, this._chords, (keybinding) => this._getUserSettingsLabel(keybinding));
     }
+    isWYSIWYG() {
+        return this._chords.every((keybinding) => this._isWYSIWYG(keybinding));
+    }
     hasMultipleChords() {
         return (this._chords.length > 1);
     }
diff -urN -x '*.map' a/vs/platform/keybinding/common/keybindingResolver.js b/vs/platform/keybinding/common/keybindingResolver.js
--- a/vs/platform/keybinding/common/keybindingResolver.js	2023-09-05 08:43:04.254809155 +0000
+++ b/vs/platform/keybinding/common/keybindingResolver.js	2023-09-05 08:45:14.313196577 +0000
@@ -196,9 +196,28 @@
         }
         return implies(a, b);
     }
+    getDefaultBoundCommands() {
+        return this._defaultBoundCommands;
+    }
+    getDefaultKeybindings() {
+        return this._defaultKeybindings;
+    }
     getKeybindings() {
         return this._keybindings;
     }
+    lookupKeybindings(commandId) {
+        const items = this._lookupMap.get(commandId);
+        if (typeof items === 'undefined' || items.length === 0) {
+            return [];
+        }
+        // Reverse to get the most specific item first
+        const result = [];
+        let resultLen = 0;
+        for (let i = items.length - 1; i >= 0; i--) {
+            result[resultLen++] = items[i];
+        }
+        return result;
+    }
     lookupPrimaryKeybinding(commandId, context) {
         const items = this._lookupMap.get(commandId);
         if (typeof items === 'undefined' || items.length === 0) {
diff -urN -x '*.map' a/vs/platform/keybinding/common/keybindingsRegistry.js b/vs/platform/keybinding/common/keybindingsRegistry.js
--- a/vs/platform/keybinding/common/keybindingsRegistry.js	2023-09-05 08:43:04.254809155 +0000
+++ b/vs/platform/keybinding/common/keybindingsRegistry.js	2023-09-05 08:45:14.313196577 +0000
@@ -58,6 +58,26 @@
         }
         return result;
     }
+    setExtensionKeybindings(rules) {
+        const result = [];
+        let keybindingsLen = 0;
+        for (const rule of rules) {
+            if (rule.keybinding) {
+                result[keybindingsLen++] = {
+                    keybinding: rule.keybinding,
+                    command: rule.id,
+                    commandArgs: rule.args,
+                    when: rule.when,
+                    weight1: rule.weight,
+                    weight2: 0,
+                    extensionId: rule.extensionId || null,
+                    isBuiltinExtension: rule.isBuiltinExtension || false
+                };
+            }
+        }
+        this._extensionKeybindings = result;
+        this._cachedMergedKeybindings = null;
+    }
     registerCommandAndKeybindingRule(desc) {
         return combinedDisposable(this.registerKeybindingRule(desc), CommandsRegistry.registerCommand(desc));
     }
diff -urN -x '*.map' a/vs/platform/keybinding/common/usLayoutResolvedKeybinding.js b/vs/platform/keybinding/common/usLayoutResolvedKeybinding.js
--- a/vs/platform/keybinding/common/usLayoutResolvedKeybinding.js	2023-09-05 08:43:04.254809155 +0000
+++ b/vs/platform/keybinding/common/usLayoutResolvedKeybinding.js	2023-09-05 08:45:14.313196577 +0000
@@ -50,6 +50,9 @@
         const result = KeyCodeUtils.toUserSettingsUS(chord.keyCode);
         return (result ? result.toLowerCase() : result);
     }
+    _isWYSIWYG() {
+        return true;
+    }
     _getChordDispatch(chord) {
         return USLayoutResolvedKeybinding.getDispatchStr(chord);
     }
diff -urN -x '*.map' a/vs/platform/label/common/label.js b/vs/platform/label/common/label.js
--- a/vs/platform/label/common/label.js	2023-09-05 08:43:04.274809656 +0000
+++ b/vs/platform/label/common/label.js	2023-09-05 08:45:14.309196520 +0000
@@ -1,2 +1,6 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
 import { createDecorator } from '../../instantiation/common/instantiation.js';
 export const ILabelService = createDecorator('labelService');
diff -urN -x '*.map' a/vs/platform/list/browser/listService.js b/vs/platform/list/browser/listService.js
--- a/vs/platform/list/browser/listService.js	2023-09-05 08:43:04.274809656 +0000
+++ b/vs/platform/list/browser/listService.js	2023-09-05 08:45:14.305196462 +0000
@@ -179,6 +179,7 @@
     return [result, disposables];
 }
 let WorkbenchList = class WorkbenchList extends List {
+    get onDidOpen() { return this.navigator.onDidOpen; }
     constructor(user, container, delegate, renderers, options, contextKeyService, listService, configurationService, instantiationService) {
         const horizontalScrolling = typeof options.horizontalScrolling !== 'undefined' ? options.horizontalScrolling : Boolean(configurationService.getValue(horizontalScrollingKey));
         const [workbenchListOptions, workbenchListOptionsDisposable] = instantiationService.invokeFunction(toWorkbenchListOptions, options);
@@ -256,6 +257,9 @@
     updateStyles(styles) {
         this.style(styles ? getListStyles(styles) : defaultListStyles);
     }
+    get useAltAsMultipleSelectionModifier() {
+        return this._useAltAsMultipleSelectionModifier;
+    }
 };
 WorkbenchList = __decorate([
     __param(5, IContextKeyService),
@@ -265,6 +269,7 @@
 ], WorkbenchList);
 export { WorkbenchList };
 let WorkbenchPagedList = class WorkbenchPagedList extends PagedList {
+    get onDidOpen() { return this.navigator.onDidOpen; }
     constructor(user, container, delegate, renderers, options, contextKeyService, listService, configurationService, instantiationService) {
         const horizontalScrolling = typeof options.horizontalScrolling !== 'undefined' ? options.horizontalScrolling : Boolean(configurationService.getValue(horizontalScrollingKey));
         const [workbenchListOptions, workbenchListOptionsDisposable] = instantiationService.invokeFunction(toWorkbenchListOptions, options);
@@ -326,6 +331,9 @@
     updateStyles(styles) {
         this.style(styles ? getListStyles(styles) : defaultListStyles);
     }
+    get useAltAsMultipleSelectionModifier() {
+        return this._useAltAsMultipleSelectionModifier;
+    }
     dispose() {
         this.disposables.dispose();
         super.dispose();
@@ -339,6 +347,7 @@
 ], WorkbenchPagedList);
 export { WorkbenchPagedList };
 let WorkbenchTable = class WorkbenchTable extends Table {
+    get onDidOpen() { return this.navigator.onDidOpen; }
     constructor(user, container, delegate, columns, renderers, options, contextKeyService, listService, configurationService, instantiationService) {
         const horizontalScrolling = typeof options.horizontalScrolling !== 'undefined' ? options.horizontalScrolling : Boolean(configurationService.getValue(horizontalScrollingKey));
         const [workbenchListOptions, workbenchListOptionsDisposable] = instantiationService.invokeFunction(toWorkbenchListOptions, options);
@@ -416,6 +425,9 @@
     updateStyles(styles) {
         this.style(styles ? getListStyles(styles) : defaultListStyles);
     }
+    get useAltAsMultipleSelectionModifier() {
+        return this._useAltAsMultipleSelectionModifier;
+    }
     dispose() {
         this.disposables.dispose();
         super.dispose();
@@ -428,6 +440,13 @@
     __param(9, IInstantiationService)
 ], WorkbenchTable);
 export { WorkbenchTable };
+export function getSelectionKeyboardEvent(typeArg = 'keydown', preserveFocus, pinned) {
+    const e = new KeyboardEvent(typeArg);
+    e.preserveFocus = preserveFocus;
+    e.pinned = pinned;
+    e.__forceEvent = true;
+    return e;
+}
 class ResourceNavigator extends Disposable {
     constructor(widget, options) {
         var _a;
@@ -552,6 +571,9 @@
     };
 }
 let WorkbenchObjectTree = class WorkbenchObjectTree extends ObjectTree {
+    get contextKeyService() { return this.internals.contextKeyService; }
+    get useAltAsMultipleSelectionModifier() { return this.internals.useAltAsMultipleSelectionModifier; }
+    get onDidOpen() { return this.internals.onDidOpen; }
     constructor(user, container, delegate, renderers, options, instantiationService, contextKeyService, listService, configurationService) {
         const { options: treeOptions, getTypeNavigationMode, disposable } = instantiationService.invokeFunction(workbenchTreeDataPreamble, options);
         super(user, container, delegate, renderers, treeOptions);
@@ -572,6 +594,9 @@
 ], WorkbenchObjectTree);
 export { WorkbenchObjectTree };
 let WorkbenchCompressibleObjectTree = class WorkbenchCompressibleObjectTree extends CompressibleObjectTree {
+    get contextKeyService() { return this.internals.contextKeyService; }
+    get useAltAsMultipleSelectionModifier() { return this.internals.useAltAsMultipleSelectionModifier; }
+    get onDidOpen() { return this.internals.onDidOpen; }
     constructor(user, container, delegate, renderers, options, instantiationService, contextKeyService, listService, configurationService) {
         const { options: treeOptions, getTypeNavigationMode, disposable } = instantiationService.invokeFunction(workbenchTreeDataPreamble, options);
         super(user, container, delegate, renderers, treeOptions);
@@ -595,6 +620,9 @@
 ], WorkbenchCompressibleObjectTree);
 export { WorkbenchCompressibleObjectTree };
 let WorkbenchDataTree = class WorkbenchDataTree extends DataTree {
+    get contextKeyService() { return this.internals.contextKeyService; }
+    get useAltAsMultipleSelectionModifier() { return this.internals.useAltAsMultipleSelectionModifier; }
+    get onDidOpen() { return this.internals.onDidOpen; }
     constructor(user, container, delegate, renderers, dataSource, options, instantiationService, contextKeyService, listService, configurationService) {
         const { options: treeOptions, getTypeNavigationMode, disposable } = instantiationService.invokeFunction(workbenchTreeDataPreamble, options);
         super(user, container, delegate, renderers, dataSource, treeOptions);
@@ -618,6 +646,8 @@
 ], WorkbenchDataTree);
 export { WorkbenchDataTree };
 let WorkbenchAsyncDataTree = class WorkbenchAsyncDataTree extends AsyncDataTree {
+    get contextKeyService() { return this.internals.contextKeyService; }
+    get useAltAsMultipleSelectionModifier() { return this.internals.useAltAsMultipleSelectionModifier; }
     get onDidOpen() { return this.internals.onDidOpen; }
     constructor(user, container, delegate, renderers, dataSource, options, instantiationService, contextKeyService, listService, configurationService) {
         const { options: treeOptions, getTypeNavigationMode, disposable } = instantiationService.invokeFunction(workbenchTreeDataPreamble, options);
@@ -642,6 +672,9 @@
 ], WorkbenchAsyncDataTree);
 export { WorkbenchAsyncDataTree };
 let WorkbenchCompressibleAsyncDataTree = class WorkbenchCompressibleAsyncDataTree extends CompressibleAsyncDataTree {
+    get contextKeyService() { return this.internals.contextKeyService; }
+    get useAltAsMultipleSelectionModifier() { return this.internals.useAltAsMultipleSelectionModifier; }
+    get onDidOpen() { return this.internals.onDidOpen; }
     constructor(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, options, instantiationService, contextKeyService, listService, configurationService) {
         const { options: treeOptions, getTypeNavigationMode, disposable } = instantiationService.invokeFunction(workbenchTreeDataPreamble, options);
         super(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, treeOptions);
@@ -840,6 +873,9 @@
         this.navigator = new TreeResourceNavigator(tree, Object.assign({ configurationService }, options));
         this.disposables.push(this.navigator);
     }
+    get useAltAsMultipleSelectionModifier() {
+        return this._useAltAsMultipleSelectionModifier;
+    }
     updateOptions(options) {
         if (options.multipleSelectionSupport !== undefined) {
             this.listSupportsMultiSelect.set(!!options.multipleSelectionSupport);
diff -urN -x '*.map' a/vs/platform/log/common/log.js b/vs/platform/log/common/log.js
--- a/vs/platform/log/common/log.js	2023-09-05 08:43:04.274809656 +0000
+++ b/vs/platform/log/common/log.js	2023-09-05 08:45:14.309196520 +0000
@@ -1,8 +1,26 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { toErrorMessage } from '../../../base/common/errorMessage.js';
 import { Emitter } from '../../../base/common/event.js';
+import { hash } from '../../../base/common/hash.js';
 import { Disposable } from '../../../base/common/lifecycle.js';
+import { ResourceMap } from '../../../base/common/map.js';
+import { isWindows } from '../../../base/common/platform.js';
+import { joinPath } from '../../../base/common/resources.js';
+import { isNumber, isString } from '../../../base/common/types.js';
+import { URI } from '../../../base/common/uri.js';
 import { RawContextKey } from '../../contextkey/common/contextkey.js';
 import { createDecorator } from '../../instantiation/common/instantiation.js';
 export const ILogService = createDecorator('logService');
+export const ILoggerService = createDecorator('loggerService');
+function now() {
+    return new Date().toISOString();
+}
+export function isLogLevel(thing) {
+    return isNumber(thing);
+}
 export var LogLevel;
 (function (LogLevel) {
     LogLevel[LogLevel["Off"] = 0] = "Off";
@@ -13,6 +31,44 @@
     LogLevel[LogLevel["Error"] = 5] = "Error";
 })(LogLevel || (LogLevel = {}));
 export const DEFAULT_LOG_LEVEL = LogLevel.Info;
+export function log(logger, level, message) {
+    switch (level) {
+        case LogLevel.Trace:
+            logger.trace(message);
+            break;
+        case LogLevel.Debug:
+            logger.debug(message);
+            break;
+        case LogLevel.Info:
+            logger.info(message);
+            break;
+        case LogLevel.Warning:
+            logger.warn(message);
+            break;
+        case LogLevel.Error:
+            logger.error(message);
+            break;
+        case LogLevel.Off: /* do nothing */ break;
+        default: throw new Error(`Invalid log level ${level}`);
+    }
+}
+function format(args, verbose = false) {
+    let result = '';
+    for (let i = 0; i < args.length; i++) {
+        let a = args[i];
+        if (a instanceof Error) {
+            a = toErrorMessage(a, verbose);
+        }
+        if (typeof a === 'object') {
+            try {
+                a = JSON.stringify(a);
+            }
+            catch (e) { }
+        }
+        result += (i > 0 ? ' ' : '') + a;
+    }
+    return result;
+}
 export class AbstractLogger extends Disposable {
     constructor() {
         super(...arguments);
@@ -33,6 +89,111 @@
         return this.level !== LogLevel.Off && this.level <= level;
     }
 }
+export class AbstractMessageLogger extends AbstractLogger {
+    constructor(logAlways) {
+        super();
+        this.logAlways = logAlways;
+    }
+    checkLogLevel(level) {
+        return this.logAlways || super.checkLogLevel(level);
+    }
+    trace(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Trace)) {
+            this.log(LogLevel.Trace, format([message, ...args], true));
+        }
+    }
+    debug(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Debug)) {
+            this.log(LogLevel.Debug, format([message, ...args]));
+        }
+    }
+    info(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Info)) {
+            this.log(LogLevel.Info, format([message, ...args]));
+        }
+    }
+    warn(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Warning)) {
+            this.log(LogLevel.Warning, format([message, ...args]));
+        }
+    }
+    error(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Error)) {
+            if (message instanceof Error) {
+                const array = Array.prototype.slice.call(arguments);
+                array[0] = message.stack;
+                this.log(LogLevel.Error, format(array));
+            }
+            else {
+                this.log(LogLevel.Error, format([message, ...args]));
+            }
+        }
+    }
+    flush() { }
+}
+export class ConsoleMainLogger extends AbstractLogger {
+    constructor(logLevel = DEFAULT_LOG_LEVEL) {
+        super();
+        this.setLevel(logLevel);
+        this.useColors = !isWindows;
+    }
+    trace(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Trace)) {
+            if (this.useColors) {
+                console.log(`\x1b[90m[main ${now()}]\x1b[0m`, message, ...args);
+            }
+            else {
+                console.log(`[main ${now()}]`, message, ...args);
+            }
+        }
+    }
+    debug(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Debug)) {
+            if (this.useColors) {
+                console.log(`\x1b[90m[main ${now()}]\x1b[0m`, message, ...args);
+            }
+            else {
+                console.log(`[main ${now()}]`, message, ...args);
+            }
+        }
+    }
+    info(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Info)) {
+            if (this.useColors) {
+                console.log(`\x1b[90m[main ${now()}]\x1b[0m`, message, ...args);
+            }
+            else {
+                console.log(`[main ${now()}]`, message, ...args);
+            }
+        }
+    }
+    warn(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Warning)) {
+            if (this.useColors) {
+                console.warn(`\x1b[93m[main ${now()}]\x1b[0m`, message, ...args);
+            }
+            else {
+                console.warn(`[main ${now()}]`, message, ...args);
+            }
+        }
+    }
+    error(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Error)) {
+            if (this.useColors) {
+                console.error(`\x1b[91m[main ${now()}]\x1b[0m`, message, ...args);
+            }
+            else {
+                console.error(`[main ${now()}]`, message, ...args);
+            }
+        }
+    }
+    dispose() {
+        // noop
+    }
+    flush() {
+        // noop
+    }
+}
 export class ConsoleLogger extends AbstractLogger {
     constructor(logLevel = DEFAULT_LOG_LEVEL, useColors = true) {
         super();
@@ -92,6 +253,53 @@
     dispose() {
         // noop
     }
+    flush() {
+        // noop
+    }
+}
+export class AdapterLogger extends AbstractLogger {
+    constructor(adapter, logLevel = DEFAULT_LOG_LEVEL) {
+        super();
+        this.adapter = adapter;
+        this.setLevel(logLevel);
+    }
+    trace(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Trace)) {
+            this.adapter.log(LogLevel.Trace, [this.extractMessage(message), ...args]);
+        }
+    }
+    debug(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Debug)) {
+            this.adapter.log(LogLevel.Debug, [this.extractMessage(message), ...args]);
+        }
+    }
+    info(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Info)) {
+            this.adapter.log(LogLevel.Info, [this.extractMessage(message), ...args]);
+        }
+    }
+    warn(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Warning)) {
+            this.adapter.log(LogLevel.Warning, [this.extractMessage(message), ...args]);
+        }
+    }
+    error(message, ...args) {
+        if (this.checkLogLevel(LogLevel.Error)) {
+            this.adapter.log(LogLevel.Error, [this.extractMessage(message), ...args]);
+        }
+    }
+    extractMessage(msg) {
+        if (typeof msg === 'string') {
+            return msg;
+        }
+        return toErrorMessage(msg, this.checkLogLevel(LogLevel.Trace));
+    }
+    dispose() {
+        // noop
+    }
+    flush() {
+        // noop
+    }
 }
 export class MultiplexLogger extends AbstractLogger {
     constructor(loggers) {
@@ -132,12 +340,171 @@
             logger.error(message, ...args);
         }
     }
+    flush() {
+        for (const logger of this.loggers) {
+            logger.flush();
+        }
+    }
     dispose() {
         for (const logger of this.loggers) {
             logger.dispose();
         }
     }
 }
+export class AbstractLoggerService extends Disposable {
+    constructor(logLevel, logsHome, loggerResources) {
+        super();
+        this.logLevel = logLevel;
+        this.logsHome = logsHome;
+        this._loggers = new ResourceMap();
+        this._onDidChangeLoggers = this._register(new Emitter);
+        this.onDidChangeLoggers = this._onDidChangeLoggers.event;
+        this._onDidChangeLogLevel = this._register(new Emitter);
+        this.onDidChangeLogLevel = this._onDidChangeLogLevel.event;
+        this._onDidChangeVisibility = this._register(new Emitter);
+        this.onDidChangeVisibility = this._onDidChangeVisibility.event;
+        if (loggerResources) {
+            for (const loggerResource of loggerResources) {
+                this._loggers.set(loggerResource.resource, { logger: undefined, info: loggerResource });
+            }
+        }
+    }
+    getLoggerEntry(resourceOrId) {
+        if (isString(resourceOrId)) {
+            return [...this._loggers.values()].find(logger => logger.info.id === resourceOrId);
+        }
+        return this._loggers.get(resourceOrId);
+    }
+    getLogger(resourceOrId) {
+        var _a;
+        return (_a = this.getLoggerEntry(resourceOrId)) === null || _a === void 0 ? void 0 : _a.logger;
+    }
+    createLogger(idOrResource, options) {
+        var _a, _b, _c;
+        const resource = this.toResource(idOrResource);
+        const id = isString(idOrResource) ? idOrResource : ((_a = options === null || options === void 0 ? void 0 : options.id) !== null && _a !== void 0 ? _a : hash(resource.toString()).toString(16));
+        let logger = (_b = this._loggers.get(resource)) === null || _b === void 0 ? void 0 : _b.logger;
+        const logLevel = (options === null || options === void 0 ? void 0 : options.logLevel) === 'always' ? LogLevel.Trace : options === null || options === void 0 ? void 0 : options.logLevel;
+        if (!logger) {
+            logger = this.doCreateLogger(resource, (_c = logLevel !== null && logLevel !== void 0 ? logLevel : this.getLogLevel(resource)) !== null && _c !== void 0 ? _c : this.logLevel, Object.assign(Object.assign({}, options), { id }));
+        }
+        const loggerEntry = {
+            logger,
+            info: { resource, id, logLevel, name: options === null || options === void 0 ? void 0 : options.name, hidden: options === null || options === void 0 ? void 0 : options.hidden, extensionId: options === null || options === void 0 ? void 0 : options.extensionId, when: options === null || options === void 0 ? void 0 : options.when }
+        };
+        this.registerLogger(loggerEntry.info);
+        // TODO: @sandy081 Remove this once registerLogger can take ILogger
+        this._loggers.set(resource, loggerEntry);
+        return logger;
+    }
+    toResource(idOrResource) {
+        return isString(idOrResource) ? joinPath(this.logsHome, `${idOrResource}.log`) : idOrResource;
+    }
+    setLogLevel(arg1, arg2) {
+        var _a, _b, _c;
+        if (URI.isUri(arg1)) {
+            const resource = arg1;
+            const logLevel = arg2;
+            const logger = this._loggers.get(resource);
+            if (logger && logLevel !== logger.info.logLevel) {
+                logger.info.logLevel = logLevel === this.logLevel ? undefined : logLevel;
+                (_a = logger.logger) === null || _a === void 0 ? void 0 : _a.setLevel(logLevel);
+                this._loggers.set(logger.info.resource, logger);
+                this._onDidChangeLogLevel.fire([resource, logLevel]);
+            }
+        }
+        else {
+            this.logLevel = arg1;
+            for (const [resource, logger] of this._loggers.entries()) {
+                if (((_b = this._loggers.get(resource)) === null || _b === void 0 ? void 0 : _b.info.logLevel) === undefined) {
+                    (_c = logger.logger) === null || _c === void 0 ? void 0 : _c.setLevel(this.logLevel);
+                }
+            }
+            this._onDidChangeLogLevel.fire(this.logLevel);
+        }
+    }
+    setVisibility(resourceOrId, visibility) {
+        const logger = this.getLoggerEntry(resourceOrId);
+        if (logger && visibility !== !logger.info.hidden) {
+            logger.info.hidden = !visibility;
+            this._loggers.set(logger.info.resource, logger);
+            this._onDidChangeVisibility.fire([logger.info.resource, visibility]);
+        }
+    }
+    getLogLevel(resource) {
+        var _a;
+        let logLevel;
+        if (resource) {
+            logLevel = (_a = this._loggers.get(resource)) === null || _a === void 0 ? void 0 : _a.info.logLevel;
+        }
+        return logLevel !== null && logLevel !== void 0 ? logLevel : this.logLevel;
+    }
+    registerLogger(resource) {
+        const existing = this._loggers.get(resource.resource);
+        if (existing) {
+            if (existing.info.hidden !== resource.hidden) {
+                this.setVisibility(resource.resource, !resource.hidden);
+            }
+        }
+        else {
+            this._loggers.set(resource.resource, { info: resource, logger: undefined });
+            this._onDidChangeLoggers.fire({ added: [resource], removed: [] });
+        }
+    }
+    deregisterLogger(resource) {
+        const existing = this._loggers.get(resource);
+        if (existing) {
+            if (existing.logger) {
+                existing.logger.dispose();
+            }
+            this._loggers.delete(resource);
+            this._onDidChangeLoggers.fire({ added: [], removed: [existing.info] });
+        }
+    }
+    *getRegisteredLoggers() {
+        for (const entry of this._loggers.values()) {
+            yield entry.info;
+        }
+    }
+    getRegisteredLogger(resource) {
+        var _a;
+        return (_a = this._loggers.get(resource)) === null || _a === void 0 ? void 0 : _a.info;
+    }
+    dispose() {
+        this._loggers.forEach(logger => { var _a; return (_a = logger.logger) === null || _a === void 0 ? void 0 : _a.dispose(); });
+        this._loggers.clear();
+        super.dispose();
+    }
+}
+export class NullLogger {
+    constructor() {
+        this.onDidChangeLogLevel = new Emitter().event;
+    }
+    setLevel(level) { }
+    getLevel() { return LogLevel.Info; }
+    trace(message, ...args) { }
+    debug(message, ...args) { }
+    info(message, ...args) { }
+    warn(message, ...args) { }
+    error(message, ...args) { }
+    critical(message, ...args) { }
+    dispose() { }
+    flush() { }
+}
+export class NullLogService extends NullLogger {
+}
+export function getLogLevel(environmentService) {
+    if (environmentService.verbose) {
+        return LogLevel.Trace;
+    }
+    if (typeof environmentService.logLevel === 'string') {
+        const logLevel = parseLogLevel(environmentService.logLevel.toLowerCase());
+        if (logLevel !== undefined) {
+            return logLevel;
+        }
+    }
+    return DEFAULT_LOG_LEVEL;
+}
 export function LogLevelToString(logLevel) {
     switch (logLevel) {
         case LogLevel.Trace: return 'trace';
@@ -148,5 +515,24 @@
         case LogLevel.Off: return 'off';
     }
 }
+export function parseLogLevel(logLevel) {
+    switch (logLevel) {
+        case 'trace':
+            return LogLevel.Trace;
+        case 'debug':
+            return LogLevel.Debug;
+        case 'info':
+            return LogLevel.Info;
+        case 'warn':
+            return LogLevel.Warning;
+        case 'error':
+            return LogLevel.Error;
+        case 'critical':
+            return LogLevel.Error;
+        case 'off':
+            return LogLevel.Off;
+    }
+    return undefined;
+}
 // Contexts
 export const CONTEXT_LOG_LEVEL = new RawContextKey('logLevel', LogLevelToString(LogLevel.Info));
diff -urN -x '*.map' a/vs/platform/log/common/logService.js b/vs/platform/log/common/logService.js
--- a/vs/platform/log/common/logService.js	2023-09-05 08:43:04.278809749 +0000
+++ b/vs/platform/log/common/logService.js	2023-09-05 08:45:14.309196520 +0000
@@ -34,4 +34,7 @@
     error(message, ...args) {
         this.logger.error(message, ...args);
     }
+    flush() {
+        this.logger.flush();
+    }
 }
diff -urN -x '*.map' a/vs/platform/markers/common/markerService.js b/vs/platform/markers/common/markerService.js
--- a/vs/platform/markers/common/markerService.js	2023-09-05 08:43:04.278809749 +0000
+++ b/vs/platform/markers/common/markerService.js	2023-09-05 08:45:14.317196634 +0000
@@ -133,6 +133,9 @@
         this._stats.dispose();
         this._onMarkerChanged.dispose();
     }
+    getStatistics() {
+        return this._stats;
+    }
     remove(owner, resources) {
         for (const resource of resources || []) {
             this.changeOne(owner, resource, []);
diff -urN -x '*.map' a/vs/platform/notification/common/notification.js b/vs/platform/notification/common/notification.js
--- a/vs/platform/notification/common/notification.js	2023-09-05 08:43:04.278809749 +0000
+++ b/vs/platform/notification/common/notification.js	2023-09-05 08:45:14.305196462 +0000
@@ -1,6 +1,74 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { Event } from '../../../base/common/event.js';
 import BaseSeverity from '../../../base/common/severity.js';
 import { createDecorator } from '../../instantiation/common/instantiation.js';
 export var Severity = BaseSeverity;
 export const INotificationService = createDecorator('notificationService');
+export var NotificationPriority;
+(function (NotificationPriority) {
+    /**
+     * Default priority: notification will be visible unless do not disturb mode is enabled.
+     */
+    NotificationPriority[NotificationPriority["DEFAULT"] = 0] = "DEFAULT";
+    /**
+     * Silent priority: notification will only be visible from the notifications center.
+     */
+    NotificationPriority[NotificationPriority["SILENT"] = 1] = "SILENT";
+    /**
+     * Urgent priority: notification will be visible even when do not disturb mode is enabled.
+     */
+    NotificationPriority[NotificationPriority["URGENT"] = 2] = "URGENT";
+})(NotificationPriority || (NotificationPriority = {}));
+export var NeverShowAgainScope;
+(function (NeverShowAgainScope) {
+    /**
+     * Will never show this notification on the current workspace again.
+     */
+    NeverShowAgainScope[NeverShowAgainScope["WORKSPACE"] = 0] = "WORKSPACE";
+    /**
+     * Will never show this notification on any workspace of the same
+     * profile again.
+     */
+    NeverShowAgainScope[NeverShowAgainScope["PROFILE"] = 1] = "PROFILE";
+    /**
+     * Will never show this notification on any workspace across all
+     * profiles again.
+     */
+    NeverShowAgainScope[NeverShowAgainScope["APPLICATION"] = 2] = "APPLICATION";
+})(NeverShowAgainScope || (NeverShowAgainScope = {}));
+export var NotificationsFilter;
+(function (NotificationsFilter) {
+    /**
+     * No filter is enabled.
+     */
+    NotificationsFilter[NotificationsFilter["OFF"] = 0] = "OFF";
+    /**
+     * All notifications are configured as silent. See
+     * `INotificationProperties.silent` for more info.
+     */
+    NotificationsFilter[NotificationsFilter["SILENT"] = 1] = "SILENT";
+    /**
+     * All notifications are silent except error notifications.
+    */
+    NotificationsFilter[NotificationsFilter["ERROR"] = 2] = "ERROR";
+})(NotificationsFilter || (NotificationsFilter = {}));
 export class NoOpNotification {
+    constructor() {
+        this.progress = new NoOpProgress();
+        this.onDidClose = Event.None;
+        this.onDidChangeVisibility = Event.None;
+    }
+    updateSeverity(severity) { }
+    updateMessage(message) { }
+    updateActions(actions) { }
+    close() { }
+}
+export class NoOpProgress {
+    infinite() { }
+    done() { }
+    total(value) { }
+    worked(value) { }
 }
diff -urN -x '*.map' a/vs/platform/opener/browser/link.js b/vs/platform/opener/browser/link.js
--- a/vs/platform/opener/browser/link.js	2023-09-05 08:43:04.242808851 +0000
+++ b/vs/platform/opener/browser/link.js	2023-09-05 08:45:14.309196520 +0000
@@ -11,7 +11,7 @@
 var __param = (this && this.__param) || function (paramIndex, decorator) {
     return function (target, key) { decorator(target, key, paramIndex); }
 };
-import { $, append, EventHelper } from '../../../base/browser/dom.js';
+import { $, append, EventHelper, clearNode } from '../../../base/browser/dom.js';
 import { DomEmitter } from '../../../base/browser/event.js';
 import { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';
 import { EventType as TouchEventType, Gesture } from '../../../base/browser/touch.js';
@@ -42,6 +42,23 @@
         }
         this._enabled = enabled;
     }
+    set link(link) {
+        if (typeof link.label === 'string') {
+            this.el.textContent = link.label;
+        }
+        else {
+            clearNode(this.el);
+            this.el.appendChild(link.label);
+        }
+        this.el.href = link.href;
+        if (typeof link.tabIndex !== 'undefined') {
+            this.el.tabIndex = link.tabIndex;
+        }
+        if (typeof link.title !== 'undefined') {
+            this.el.title = link.title;
+        }
+        this._link = link;
+    }
     constructor(container, _link, options = {}, openerService) {
         var _a;
         super();
diff -urN -x '*.map' a/vs/platform/opener/common/opener.js b/vs/platform/opener/common/opener.js
--- a/vs/platform/opener/common/opener.js	2023-09-05 08:43:04.242808851 +0000
+++ b/vs/platform/opener/common/opener.js	2023-09-05 08:45:14.309196520 +0000
@@ -18,6 +18,16 @@
     return schemes.some(scheme => matchesScheme(target, scheme));
 }
 /**
+ * Encodes selection into the `URI`.
+ *
+ * IMPORTANT: you MUST use `extractSelection` to separate the selection
+ * again from the original `URI` before passing the `URI` into any
+ * component that is not aware of selections.
+ */
+export function withSelection(uri, selection) {
+    return uri.with({ fragment: `${selection.startLineNumber},${selection.startColumn}${selection.endLineNumber ? `-${selection.endLineNumber}${selection.endColumn ? `,${selection.endColumn}` : ''}` : ''}` });
+}
+/**
  * file:///some/file.js#73
  * file:///some/file.js#L73
  * file:///some/file.js#73,84
diff -urN -x '*.map' a/vs/platform/policy/common/policy.js b/vs/platform/policy/common/policy.js
--- a/vs/platform/policy/common/policy.js	2023-09-05 08:43:04.278809749 +0000
+++ b/vs/platform/policy/common/policy.js	2023-09-05 08:45:14.309196520 +0000
@@ -1 +1,53 @@
-export {};
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+import { Emitter, Event } from '../../../base/common/event.js';
+import { Iterable } from '../../../base/common/iterator.js';
+import { Disposable } from '../../../base/common/lifecycle.js';
+import { createDecorator } from '../../instantiation/common/instantiation.js';
+export const IPolicyService = createDecorator('policy');
+export class AbstractPolicyService extends Disposable {
+    constructor() {
+        super(...arguments);
+        this.policyDefinitions = {};
+        this.policies = new Map();
+        this._onDidChange = this._register(new Emitter());
+        this.onDidChange = this._onDidChange.event;
+    }
+    updatePolicyDefinitions(policyDefinitions) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const size = Object.keys(this.policyDefinitions).length;
+            this.policyDefinitions = Object.assign(Object.assign({}, policyDefinitions), this.policyDefinitions);
+            if (size !== Object.keys(this.policyDefinitions).length) {
+                yield this._updatePolicyDefinitions(policyDefinitions);
+            }
+            return Iterable.reduce(this.policies.entries(), (r, [name, value]) => (Object.assign(Object.assign({}, r), { [name]: value })), {});
+        });
+    }
+    getPolicyValue(name) {
+        return this.policies.get(name);
+    }
+    serialize() {
+        return Iterable.reduce(Object.entries(this.policyDefinitions), (r, [name, definition]) => (Object.assign(Object.assign({}, r), { [name]: { definition, value: this.policies.get(name) } })), {});
+    }
+}
+export class NullPolicyService {
+    constructor() {
+        this.onDidChange = Event.None;
+    }
+    updatePolicyDefinitions() {
+        return __awaiter(this, void 0, void 0, function* () { return {}; });
+    }
+    getPolicyValue() { return undefined; }
+    serialize() { return undefined; }
+}
diff -urN -x '*.map' a/vs/platform/product/common/productService.js b/vs/platform/product/common/productService.js
--- a/vs/platform/product/common/productService.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/platform/product/common/productService.js	2023-09-05 08:45:14.309196520 +0000
@@ -0,0 +1,7 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { createDecorator } from '../../instantiation/common/instantiation.js';
+export const IProductService = createDecorator('productService');
+export const productSchemaId = 'vscode://schemas/vscode-product';
diff -urN -x '*.map' a/vs/platform/progress/common/progress.js b/vs/platform/progress/common/progress.js
--- a/vs/platform/progress/common/progress.js	2023-09-05 08:43:04.278809749 +0000
+++ b/vs/platform/progress/common/progress.js	2023-09-05 08:45:14.313196577 +0000
@@ -1,3 +1,19 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
+    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
+    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
+    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
+    return c > 3 && r && Object.defineProperty(target, key, r), r;
+};
+var __param = (this && this.__param) || function (paramIndex, decorator) {
+    return function (target, key) { decorator(target, key, paramIndex); }
+};
+import { DeferredPromise } from '../../../base/common/async.js';
+import { CancellationTokenSource } from '../../../base/common/cancellation.js';
+import { Disposable, DisposableStore, toDisposable } from '../../../base/common/lifecycle.js';
 import { createDecorator } from '../../instantiation/common/instantiation.js';
 export const IProgressService = createDecorator('progressService');
 export const emptyProgressRunner = Object.freeze({
@@ -6,6 +22,7 @@
     done() { }
 });
 export class Progress {
+    get value() { return this._value; }
     constructor(callback, opts) {
         this.callback = callback;
         this.report = (opts === null || opts === void 0 ? void 0 : opts.async)
@@ -25,4 +42,71 @@
     }
 }
 Progress.None = Object.freeze({ report() { } });
+/**
+ * RAII-style progress instance that allows imperative reporting and hides
+ * once `dispose()` is called.
+ */
+let UnmanagedProgress = class UnmanagedProgress extends Disposable {
+    constructor(options, progressService) {
+        super();
+        this.deferred = new DeferredPromise();
+        progressService.withProgress(options, reporter => {
+            this.reporter = reporter;
+            if (this.lastStep) {
+                reporter.report(this.lastStep);
+            }
+            return this.deferred.p;
+        });
+        this._register(toDisposable(() => this.deferred.complete()));
+    }
+    report(step) {
+        if (this.reporter) {
+            this.reporter.report(step);
+        }
+        else {
+            this.lastStep = step;
+        }
+    }
+};
+UnmanagedProgress = __decorate([
+    __param(1, IProgressService)
+], UnmanagedProgress);
+export { UnmanagedProgress };
+export class LongRunningOperation extends Disposable {
+    constructor(progressIndicator) {
+        super();
+        this.progressIndicator = progressIndicator;
+        this.currentOperationId = 0;
+        this.currentOperationDisposables = this._register(new DisposableStore());
+    }
+    start(progressDelay) {
+        // Stop any previous operation
+        this.stop();
+        // Start new
+        const newOperationId = ++this.currentOperationId;
+        const newOperationToken = new CancellationTokenSource();
+        this.currentProgressTimeout = setTimeout(() => {
+            if (newOperationId === this.currentOperationId) {
+                this.currentProgressRunner = this.progressIndicator.show(true);
+            }
+        }, progressDelay);
+        this.currentOperationDisposables.add(toDisposable(() => clearTimeout(this.currentProgressTimeout)));
+        this.currentOperationDisposables.add(toDisposable(() => newOperationToken.cancel()));
+        this.currentOperationDisposables.add(toDisposable(() => this.currentProgressRunner ? this.currentProgressRunner.done() : undefined));
+        return {
+            id: newOperationId,
+            token: newOperationToken.token,
+            stop: () => this.doStop(newOperationId),
+            isCurrent: () => this.currentOperationId === newOperationId
+        };
+    }
+    stop() {
+        this.doStop(this.currentOperationId);
+    }
+    doStop(operationId) {
+        if (this.currentOperationId === operationId) {
+            this.currentOperationDisposables.clear();
+        }
+    }
+}
 export const IEditorProgressService = createDecorator('editorProgressService');
diff -urN -x '*.map' a/vs/platform/quickinput/browser/quickAccess.js b/vs/platform/quickinput/browser/quickAccess.js
--- a/vs/platform/quickinput/browser/quickAccess.js	2023-09-05 08:43:04.250809054 +0000
+++ b/vs/platform/quickinput/browser/quickAccess.js	2023-09-05 08:45:14.313196577 +0000
@@ -29,6 +29,9 @@
         this.lastAcceptedPickerValues = new Map();
         this.visibleQuickAccess = undefined;
     }
+    pick(value = '', options) {
+        return this.doShowOrPick(value, true, options);
+    }
     show(value = '', options) {
         this.doShowOrPick(value, false, options);
     }
diff -urN -x '*.map' a/vs/platform/quickinput/browser/quickInput.js b/vs/platform/quickinput/browser/quickInput.js
--- a/vs/platform/quickinput/browser/quickInput.js	2023-09-05 08:43:04.250809054 +0000
+++ b/vs/platform/quickinput/browser/quickInput.js	2023-09-05 08:45:14.313196577 +0000
@@ -23,12 +23,12 @@
 import { TimeoutTimer } from '../../../base/common/async.js';
 import { CancellationToken } from '../../../base/common/cancellation.js';
 import { Codicon } from '../../../base/common/codicons.js';
-import { Emitter } from '../../../base/common/event.js';
+import { Emitter, Event } from '../../../base/common/event.js';
 import { Disposable, DisposableStore, dispose } from '../../../base/common/lifecycle.js';
 import { isIOS } from '../../../base/common/platform.js';
 import Severity from '../../../base/common/severity.js';
 import { ThemeIcon } from '../../../base/common/themables.js';
-import { withNullAsUndefined, withUndefinedAsNull } from '../../../base/common/types.js';
+import { isString, withNullAsUndefined, withUndefinedAsNull } from '../../../base/common/types.js';
 import './media/quickInput.css';
 import { localize } from '../../../nls.js';
 import { ItemActivation, NO_KEY_MODS, QuickInputHideReason } from '../common/quickInput.js';
@@ -60,7 +60,9 @@
         this.onDidHideEmitter = this._register(new Emitter());
         this.onDisposeEmitter = this._register(new Emitter());
         this.visibleDisposables = this._register(new DisposableStore());
+        this.onDidTriggerButton = this.onDidTriggerButtonEmitter.event;
         this.onDidHide = this.onDidHideEmitter.event;
+        this.onDispose = this.onDisposeEmitter.event;
     }
     get title() {
         return this._title;
@@ -76,6 +78,19 @@
         this._description = description;
         this.update();
     }
+    get widget() {
+        return this._widget;
+    }
+    set widget(widget) {
+        if (!(widget instanceof HTMLElement)) {
+            return;
+        }
+        if (this._widget !== widget) {
+            this._widget = widget;
+            this._widgetUpdated = true;
+            this.update();
+        }
+    }
     get step() {
         return this._steps;
     }
@@ -363,6 +378,7 @@
         this.onDidChangeValue = this.onDidChangeValueEmitter.event;
         this.onWillAccept = this.onWillAcceptEmitter.event;
         this.onDidAccept = this.onDidAcceptEmitter.event;
+        this.onDidCustom = this.onDidCustomEmitter.event;
         this.onDidChangeActive = this.onDidChangeActiveEmitter.event;
         this.onDidChangeSelection = this.onDidChangeSelectionEmitter.event;
         this.onDidTriggerItemButton = this.onDidTriggerItemButtonEmitter.event;
@@ -550,6 +566,12 @@
         this._ok = showOkButton;
         this.update();
     }
+    inputHasFocus() {
+        return this.visible ? this.ui.inputBox.hasFocus() : false;
+    }
+    focusOnInput() {
+        this.ui.inputBox.setFocus();
+    }
     get hideInput() {
         return !!this._hideInput;
     }
@@ -557,6 +579,20 @@
         this._hideInput = hideInput;
         this.update();
     }
+    get hideCountBadge() {
+        return !!this._hideCountBadge;
+    }
+    set hideCountBadge(hideCountBadge) {
+        this._hideCountBadge = hideCountBadge;
+        this.update();
+    }
+    get hideCheckAll() {
+        return !!this._hideCheckAll;
+    }
+    set hideCheckAll(hideCheckAll) {
+        this._hideCheckAll = hideCheckAll;
+        this.update();
+    }
     trySelectFirst() {
         if (this.autoFocusOnList) {
             if (!this.canSelectMany) {
@@ -891,6 +927,11 @@
         this._value = value || '';
         this.update();
     }
+    set valueSelection(valueSelection) {
+        this._valueSelection = valueSelection;
+        this.valueSelectionUpdated = true;
+        this.update();
+    }
     get placeholder() {
         return this._placeholder;
     }
@@ -905,6 +946,16 @@
         this._password = password;
         this.update();
     }
+    get prompt() {
+        return this._prompt;
+    }
+    set prompt(prompt) {
+        this._prompt = prompt;
+        this.noValidationMessage = prompt
+            ? localize('inputModeEntryDescription', "{0} (Press 'Enter' to confirm or 'Escape' to cancel)", prompt)
+            : QuickInput.noPromptMessage;
+        this.update();
+    }
     show() {
         if (!this.visible) {
             this.visibleDisposables.add(this.ui.inputBox.onDidChange(value => {
@@ -962,6 +1013,7 @@
         this.onShow = this.onShowEmitter.event;
         this.onHideEmitter = this._register(new Emitter());
         this.onHide = this.onHideEmitter.event;
+        this.backButton = backButton;
         this.idPrefix = options.idPrefix;
         this.parentElement = options.container;
         this.styles = options.styles;
@@ -1278,6 +1330,78 @@
             });
         });
     }
+    setValidationOnInput(input, validationResult) {
+        if (validationResult && isString(validationResult)) {
+            input.severity = Severity.Error;
+            input.validationMessage = validationResult;
+        }
+        else if (validationResult && !isString(validationResult)) {
+            input.severity = validationResult.severity;
+            input.validationMessage = validationResult.content;
+        }
+        else {
+            input.severity = Severity.Ignore;
+            input.validationMessage = undefined;
+        }
+    }
+    input(options = {}, token = CancellationToken.None) {
+        return new Promise((resolve) => {
+            if (token.isCancellationRequested) {
+                resolve(undefined);
+                return;
+            }
+            const input = this.createInputBox();
+            const validateInput = options.validateInput || (() => Promise.resolve(undefined));
+            const onDidValueChange = Event.debounce(input.onDidChangeValue, (last, cur) => cur, 100);
+            let validationValue = options.value || '';
+            let validation = Promise.resolve(validateInput(validationValue));
+            const disposables = [
+                input,
+                onDidValueChange(value => {
+                    if (value !== validationValue) {
+                        validation = Promise.resolve(validateInput(value));
+                        validationValue = value;
+                    }
+                    validation.then(result => {
+                        if (value === validationValue) {
+                            this.setValidationOnInput(input, result);
+                        }
+                    });
+                }),
+                input.onDidAccept(() => {
+                    const value = input.value;
+                    if (value !== validationValue) {
+                        validation = Promise.resolve(validateInput(value));
+                        validationValue = value;
+                    }
+                    validation.then(result => {
+                        if (!result || (!isString(result) && result.severity !== Severity.Error)) {
+                            resolve(value);
+                            input.hide();
+                        }
+                        else if (value === validationValue) {
+                            this.setValidationOnInput(input, result);
+                        }
+                    });
+                }),
+                token.onCancellationRequested(() => {
+                    input.hide();
+                }),
+                input.onDidHide(() => {
+                    dispose(disposables);
+                    resolve(undefined);
+                }),
+            ];
+            input.title = options.title;
+            input.value = options.value || '';
+            input.valueSelection = options.valueSelection;
+            input.prompt = options.prompt;
+            input.placeholder = options.placeHolder;
+            input.password = !!options.password;
+            input.ignoreFocusOut = !!options.ignoreFocusLost;
+            input.show();
+        });
+    }
     createQuickPick() {
         const ui = this.getUI();
         return new QuickPick(ui);
@@ -1379,6 +1503,51 @@
             controller.didHide(reason);
         }
     }
+    focus() {
+        if (this.isDisplayed()) {
+            const ui = this.getUI();
+            if (ui.inputBox.enabled) {
+                ui.inputBox.setFocus();
+            }
+            else {
+                ui.list.domFocus();
+            }
+        }
+    }
+    toggle() {
+        if (this.isDisplayed() && this.controller instanceof QuickPick && this.controller.canSelectMany) {
+            this.getUI().list.toggleCheckbox();
+        }
+    }
+    navigate(next, quickNavigate) {
+        if (this.isDisplayed() && this.getUI().list.isDisplayed()) {
+            this.getUI().list.focus(next ? QuickInputListFocus.Next : QuickInputListFocus.Previous);
+            if (quickNavigate && this.controller instanceof QuickPick) {
+                this.controller.quickNavigate = quickNavigate;
+            }
+        }
+    }
+    accept(keyMods = { alt: false, ctrlCmd: false }) {
+        return __awaiter(this, void 0, void 0, function* () {
+            // When accepting the item programmatically, it is important that
+            // we update `keyMods` either from the provided set or unset it
+            // because the accept did not happen from mouse or keyboard
+            // interaction on the list itself
+            this.keyMods.alt = keyMods.alt;
+            this.keyMods.ctrlCmd = keyMods.ctrlCmd;
+            this.onDidAcceptEmitter.fire();
+        });
+    }
+    back() {
+        return __awaiter(this, void 0, void 0, function* () {
+            this.onDidTriggerButtonEmitter.fire(this.backButton);
+        });
+    }
+    cancel() {
+        return __awaiter(this, void 0, void 0, function* () {
+            this.hide();
+        });
+    }
     layout(dimension, titleBarOffset) {
         this.dimension = dimension;
         this.titleBarOffset = titleBarOffset;
diff -urN -x '*.map' a/vs/platform/quickinput/browser/quickInputBox.js b/vs/platform/quickinput/browser/quickInputBox.js
--- a/vs/platform/quickinput/browser/quickInputBox.js	2023-09-05 08:43:04.250809054 +0000
+++ b/vs/platform/quickinput/browser/quickInputBox.js	2023-09-05 08:45:14.313196577 +0000
@@ -47,6 +47,9 @@
     isSelectionAtEnd() {
         return this.findInput.inputBox.isSelectionAtEnd();
     }
+    setPlaceholder(placeholder) {
+        this.findInput.inputBox.setPlaceHolder(placeholder);
+    }
     get placeholder() {
         return this.findInput.inputBox.inputElement.getAttribute('placeholder') || '';
     }
@@ -73,9 +76,15 @@
     set toggles(toggles) {
         this.findInput.setAdditionalToggles(toggles);
     }
+    hasFocus() {
+        return this.findInput.inputBox.hasFocus();
+    }
     setAttribute(name, value) {
         this.findInput.inputBox.inputElement.setAttribute(name, value);
     }
+    removeAttribute(name) {
+        this.findInput.inputBox.inputElement.removeAttribute(name);
+    }
     showDecoration(decoration) {
         if (decoration === Severity.Ignore) {
             this.findInput.clearMessage();
diff -urN -x '*.map' a/vs/platform/quickinput/browser/quickInputList.js b/vs/platform/quickinput/browser/quickInputList.js
--- a/vs/platform/quickinput/browser/quickInputList.js	2023-09-05 08:43:04.250809054 +0000
+++ b/vs/platform/quickinput/browser/quickInputList.js	2023-09-05 08:45:14.313196577 +0000
@@ -321,6 +321,7 @@
         this.matchOnDetail = false;
         this.matchOnLabel = true;
         this.matchOnLabelMode = 'fuzzy';
+        this.matchOnMeta = true;
         this.sortByLabel = true;
         this._onChangedAllVisibleChecked = new Emitter();
         this.onChangedAllVisibleChecked = this._onChangedAllVisibleChecked.event;
@@ -556,6 +557,9 @@
         this.list.splice(0, this.list.length, this.elements);
         this._onChangedVisibleCount.fire(this.elements.length);
     }
+    getElementsCount() {
+        return this.inputElements.length;
+    }
     getFocusedElements() {
         return this.list.getFocusedElements()
             .map(e => e.item);
@@ -574,6 +578,10 @@
     getActiveDescendant() {
         return this.list.getHTMLElement().getAttribute('aria-activedescendant');
     }
+    getSelectedElements() {
+        return this.list.getSelectedElements()
+            .map(e => e.item);
+    }
     setSelectedElements(items) {
         this.list.setSelection(items
             .filter(item => this.elementsToIndexes.has(item))
diff -urN -x '*.map' a/vs/platform/quickinput/browser/quickInputService.js b/vs/platform/quickinput/browser/quickInputService.js
--- a/vs/platform/quickinput/browser/quickInputService.js	2023-09-05 08:43:04.250809054 +0000
+++ b/vs/platform/quickinput/browser/quickInputService.js	2023-09-05 08:45:14.313196577 +0000
@@ -24,6 +24,7 @@
 import { IThemeService, Themable } from '../../theme/common/themeService.js';
 import { QuickInputController } from './quickInput.js';
 let QuickInputService = class QuickInputService extends Themable {
+    get backButton() { return this.controller.backButton; }
     get controller() {
         if (!this._controller) {
             this._controller = this._register(this.createController());
@@ -43,7 +44,9 @@
         this.contextKeyService = contextKeyService;
         this.layoutService = layoutService;
         this._onShow = this._register(new Emitter());
+        this.onShow = this._onShow.event;
         this._onHide = this._register(new Emitter());
+        this.onHide = this._onHide.event;
         this.contexts = new Map();
     }
     createController(host = this.layoutService, options) {
@@ -111,12 +114,33 @@
     pick(picks, options = {}, token = CancellationToken.None) {
         return this.controller.pick(picks, options, token);
     }
+    input(options = {}, token = CancellationToken.None) {
+        return this.controller.input(options, token);
+    }
     createQuickPick() {
         return this.controller.createQuickPick();
     }
     createInputBox() {
         return this.controller.createInputBox();
     }
+    focus() {
+        this.controller.focus();
+    }
+    toggle() {
+        this.controller.toggle();
+    }
+    navigate(next, quickNavigate) {
+        this.controller.navigate(next, quickNavigate);
+    }
+    accept(keyMods) {
+        return this.controller.accept(keyMods);
+    }
+    back() {
+        return this.controller.back();
+    }
+    cancel() {
+        return this.controller.cancel();
+    }
     updateStyles() {
         if (this.hasController) {
             this.controller.applyStyles(this.computeStyles());
diff -urN -x '*.map' a/vs/platform/quickinput/common/quickAccess.js b/vs/platform/quickinput/common/quickAccess.js
--- a/vs/platform/quickinput/common/quickAccess.js	2023-09-05 08:43:04.250809054 +0000
+++ b/vs/platform/quickinput/common/quickAccess.js	2023-09-05 08:45:14.313196577 +0000
@@ -49,5 +49,15 @@
         const result = prefix ? (this.providers.find(provider => prefix.startsWith(provider.prefix)) || undefined) : undefined;
         return result || this.defaultProvider;
     }
+    clear() {
+        const providers = [...this.providers];
+        const defaultProvider = this.defaultProvider;
+        this.providers = [];
+        this.defaultProvider = undefined;
+        return () => {
+            this.providers = providers;
+            this.defaultProvider = defaultProvider;
+        };
+    }
 }
 Registry.add(Extensions.Quickaccess, new QuickAccessRegistry());
diff -urN -x '*.map' a/vs/platform/quickinput/common/quickInput.js b/vs/platform/quickinput/common/quickInput.js
--- a/vs/platform/quickinput/common/quickInput.js	2023-09-05 08:43:04.250809054 +0000
+++ b/vs/platform/quickinput/common/quickInput.js	2023-09-05 08:45:14.313196577 +0000
@@ -3,6 +3,7 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import { createDecorator } from '../../instantiation/common/instantiation.js';
+import { Schemas } from '../../../base/common/network.js';
 export const NO_KEY_MODS = { ctrlCmd: false, alt: false };
 export var QuickInputHideReason;
 (function (QuickInputHideReason) {
@@ -30,6 +31,26 @@
     constructor(options) {
         this.options = options;
     }
+    getItemLabel(entry) {
+        return entry.label;
+    }
+    getItemDescription(entry) {
+        var _a;
+        if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.skipDescription) {
+            return undefined;
+        }
+        return entry.description;
+    }
+    getItemPath(entry) {
+        var _a, _b, _c;
+        if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.skipPath) {
+            return undefined;
+        }
+        if (((_b = entry.resource) === null || _b === void 0 ? void 0 : _b.scheme) === Schemas.file) {
+            return entry.resource.fsPath;
+        }
+        return (_c = entry.resource) === null || _c === void 0 ? void 0 : _c.path;
+    }
 }
 export const quickPickItemScorerAccessor = new QuickPickItemScorerAccessor();
 //#endregion
diff -urN -x '*.map' a/vs/platform/registry/common/platform.js b/vs/platform/registry/common/platform.js
--- a/vs/platform/registry/common/platform.js	2023-09-05 08:43:04.278809749 +0000
+++ b/vs/platform/registry/common/platform.js	2023-09-05 08:45:14.309196520 +0000
@@ -14,6 +14,9 @@
         Assert.ok(!this.data.has(id), 'There is already an extension with this id');
         this.data.set(id, data);
     }
+    knows(id) {
+        return this.data.has(id);
+    }
     as(id) {
         return this.data.get(id) || null;
     }
diff -urN -x '*.map' a/vs/platform/remote/common/remoteHosts.js b/vs/platform/remote/common/remoteHosts.js
--- a/vs/platform/remote/common/remoteHosts.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/platform/remote/common/remoteHosts.js	2023-09-05 08:45:14.309196520 +0000
@@ -0,0 +1,61 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { Schemas } from '../../../base/common/network.js';
+export function getRemoteAuthority(uri) {
+    return uri.scheme === Schemas.vscodeRemote ? uri.authority : undefined;
+}
+export function getRemoteName(authority) {
+    if (!authority) {
+        return undefined;
+    }
+    const pos = authority.indexOf('+');
+    if (pos < 0) {
+        // e.g. localhost:8000
+        return authority;
+    }
+    return authority.substr(0, pos);
+}
+/**
+ * The root path to use when accessing the remote server. The path contains the quality and commit of the current build.
+ * @param product
+ * @returns
+ */
+export function getRemoteServerRootPath(product) {
+    var _a, _b;
+    return `/${(_a = product.quality) !== null && _a !== void 0 ? _a : 'oss'}-${(_b = product.commit) !== null && _b !== void 0 ? _b : 'dev'}`;
+}
+export function parseAuthorityWithPort(authority) {
+    const { host, port } = parseAuthority(authority);
+    if (typeof port === 'undefined') {
+        throw new Error(`Remote authority doesn't contain a port!`);
+    }
+    return { host, port };
+}
+export function parseAuthorityWithOptionalPort(authority, defaultPort) {
+    let { host, port } = parseAuthority(authority);
+    if (typeof port === 'undefined') {
+        port = defaultPort;
+    }
+    return { host, port };
+}
+function parseAuthority(authority) {
+    // check for ipv6 with port
+    const m1 = authority.match(/^(\[[0-9a-z:]+\]):(\d+)$/);
+    if (m1) {
+        return { host: m1[1], port: parseInt(m1[2], 10) };
+    }
+    // check for ipv6 without port
+    const m2 = authority.match(/^(\[[0-9a-z:]+\])$/);
+    if (m2) {
+        return { host: m2[1], port: undefined };
+    }
+    // anything with a trailing port
+    const m3 = authority.match(/(.*):(\d+)$/);
+    if (m3) {
+        return { host: m3[1], port: parseInt(m3[2], 10) };
+    }
+    // doesn't contain a port
+    return { host: authority, port: undefined };
+}
diff -urN -x '*.map' a/vs/platform/storage/common/storage.js b/vs/platform/storage/common/storage.js
--- a/vs/platform/storage/common/storage.js	2023-09-05 08:43:04.278809749 +0000
+++ b/vs/platform/storage/common/storage.js	2023-09-05 08:45:14.309196520 +0000
@@ -1,8 +1,25 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+import { Promises, RunOnceScheduler, runWhenIdle } from '../../../base/common/async.js';
 import { Emitter, PauseableEmitter } from '../../../base/common/event.js';
-import { Disposable } from '../../../base/common/lifecycle.js';
+import { Disposable, dispose, MutableDisposable } from '../../../base/common/lifecycle.js';
+import { mark } from '../../../base/common/performance.js';
 import { isUndefinedOrNull } from '../../../base/common/types.js';
 import { InMemoryStorageDatabase, Storage, StorageHint } from '../../../base/parts/storage/common/storage.js';
 import { createDecorator } from '../../instantiation/common/instantiation.js';
+import { isUserDataProfile } from '../../userDataProfile/common/userDataProfile.js';
+export const IS_NEW_KEY = '__$__isNewStorageMarker';
 export const TARGET_KEY = '__$__targetStorageMarker';
 export const IStorageService = createDecorator('storageService');
 export var WillSaveStateReason;
@@ -35,12 +52,54 @@
         this._onDidChangeValue = this._register(new PauseableEmitter());
         this.onDidChangeValue = this._onDidChangeValue.event;
         this._onDidChangeTarget = this._register(new PauseableEmitter());
+        this.onDidChangeTarget = this._onDidChangeTarget.event;
         this._onWillSaveState = this._register(new Emitter());
         this.onWillSaveState = this._onWillSaveState.event;
+        this.flushWhenIdleScheduler = this._register(new RunOnceScheduler(() => this.doFlushWhenIdle(), this.options.flushInterval));
+        this.runFlushWhenIdle = this._register(new MutableDisposable());
         this._workspaceKeyTargets = undefined;
         this._profileKeyTargets = undefined;
         this._applicationKeyTargets = undefined;
     }
+    doFlushWhenIdle() {
+        this.runFlushWhenIdle.value = runWhenIdle(() => {
+            if (this.shouldFlushWhenIdle()) {
+                this.flush();
+            }
+            // repeat
+            this.flushWhenIdleScheduler.schedule();
+        });
+    }
+    shouldFlushWhenIdle() {
+        return true;
+    }
+    stopFlushWhenIdle() {
+        dispose([this.runFlushWhenIdle, this.flushWhenIdleScheduler]);
+    }
+    initialize() {
+        if (!this.initializationPromise) {
+            this.initializationPromise = (() => __awaiter(this, void 0, void 0, function* () {
+                // Init all storage locations
+                mark('code/willInitStorage');
+                try {
+                    yield this.doInitialize(); // Ask subclasses to initialize storage
+                }
+                finally {
+                    mark('code/didInitStorage');
+                }
+                // On some OS we do not get enough time to persist state on shutdown (e.g. when
+                // Windows restarts after applying updates). In other cases, VSCode might crash,
+                // so we periodically save state to reduce the chance of loosing any state.
+                // In the browser we do not have support for long running unload sequences. As such,
+                // we cannot ask for saving state in that moment, because that would result in a
+                // long running operation.
+                // Instead, periodically ask customers to save save. The library will be clever enough
+                // to only save state that has actually changed.
+                this.flushWhenIdleScheduler.schedule();
+            }))();
+        }
+        return this.initializationPromise;
+    }
     emitDidChangeValue(scope, event) {
         const { key, external } = event;
         // Specially handle `TARGET_KEY`
@@ -65,6 +124,9 @@
             this._onDidChangeValue.fire({ scope, key, target: this.getKeyTargets(scope)[key], external });
         }
     }
+    emitWillSaveState(reason) {
+        this._onWillSaveState.fire({ reason });
+    }
     get(key, scope, fallbackValue) {
         var _a;
         return (_a = this.getStorage(scope)) === null || _a === void 0 ? void 0 : _a.get(key, fallbackValue);
@@ -77,6 +139,17 @@
         var _a;
         return (_a = this.getStorage(scope)) === null || _a === void 0 ? void 0 : _a.getNumber(key, fallbackValue);
     }
+    getObject(key, scope, fallbackValue) {
+        var _a;
+        return (_a = this.getStorage(scope)) === null || _a === void 0 ? void 0 : _a.getObject(key, fallbackValue);
+    }
+    storeAll(entries, external) {
+        this.withPausedEmitters(() => {
+            for (const entry of entries) {
+                this.store(entry.key, entry.value, entry.scope, entry.target, external);
+            }
+        });
+    }
     store(key, value, scope, target, external = false) {
         // We remove the key for undefined/null values
         if (isUndefinedOrNull(value)) {
@@ -115,6 +188,17 @@
             this._onDidChangeTarget.resume();
         }
     }
+    keys(scope, target) {
+        const keys = [];
+        const keyTargets = this.getKeyTargets(scope);
+        for (const key of Object.keys(keyTargets)) {
+            const keyTarget = keyTargets[key];
+            if (keyTarget === target) {
+                keys.push(key);
+            }
+        }
+        return keys;
+    }
     updateKeyTarget(key, scope, target, external = false) {
         var _a, _b;
         // Add
@@ -165,8 +249,90 @@
         const storage = this.getStorage(scope);
         return storage ? loadKeyTargets(storage) : Object.create(null);
     }
+    isNew(scope) {
+        return this.getBoolean(IS_NEW_KEY, scope) === true;
+    }
+    flush(reason = WillSaveStateReason.NONE) {
+        var _a, _b, _c, _d, _e, _f;
+        return __awaiter(this, void 0, void 0, function* () {
+            // Signal event to collect changes
+            this._onWillSaveState.fire({ reason });
+            const applicationStorage = this.getStorage(-1 /* StorageScope.APPLICATION */);
+            const profileStorage = this.getStorage(0 /* StorageScope.PROFILE */);
+            const workspaceStorage = this.getStorage(1 /* StorageScope.WORKSPACE */);
+            switch (reason) {
+                // Unspecific reason: just wait when data is flushed
+                case WillSaveStateReason.NONE:
+                    yield Promises.settled([
+                        (_a = applicationStorage === null || applicationStorage === void 0 ? void 0 : applicationStorage.whenFlushed()) !== null && _a !== void 0 ? _a : Promise.resolve(),
+                        (_b = profileStorage === null || profileStorage === void 0 ? void 0 : profileStorage.whenFlushed()) !== null && _b !== void 0 ? _b : Promise.resolve(),
+                        (_c = workspaceStorage === null || workspaceStorage === void 0 ? void 0 : workspaceStorage.whenFlushed()) !== null && _c !== void 0 ? _c : Promise.resolve()
+                    ]);
+                    break;
+                // Shutdown: we want to flush as soon as possible
+                // and not hit any delays that might be there
+                case WillSaveStateReason.SHUTDOWN:
+                    yield Promises.settled([
+                        (_d = applicationStorage === null || applicationStorage === void 0 ? void 0 : applicationStorage.flush(0)) !== null && _d !== void 0 ? _d : Promise.resolve(),
+                        (_e = profileStorage === null || profileStorage === void 0 ? void 0 : profileStorage.flush(0)) !== null && _e !== void 0 ? _e : Promise.resolve(),
+                        (_f = workspaceStorage === null || workspaceStorage === void 0 ? void 0 : workspaceStorage.flush(0)) !== null && _f !== void 0 ? _f : Promise.resolve()
+                    ]);
+                    break;
+            }
+        });
+    }
+    log() {
+        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
+        return __awaiter(this, void 0, void 0, function* () {
+            const applicationItems = (_b = (_a = this.getStorage(-1 /* StorageScope.APPLICATION */)) === null || _a === void 0 ? void 0 : _a.items) !== null && _b !== void 0 ? _b : new Map();
+            const profileItems = (_d = (_c = this.getStorage(0 /* StorageScope.PROFILE */)) === null || _c === void 0 ? void 0 : _c.items) !== null && _d !== void 0 ? _d : new Map();
+            const workspaceItems = (_f = (_e = this.getStorage(1 /* StorageScope.WORKSPACE */)) === null || _e === void 0 ? void 0 : _e.items) !== null && _f !== void 0 ? _f : new Map();
+            return logStorage(applicationItems, profileItems, workspaceItems, (_g = this.getLogDetails(-1 /* StorageScope.APPLICATION */)) !== null && _g !== void 0 ? _g : '', (_h = this.getLogDetails(0 /* StorageScope.PROFILE */)) !== null && _h !== void 0 ? _h : '', (_j = this.getLogDetails(1 /* StorageScope.WORKSPACE */)) !== null && _j !== void 0 ? _j : '');
+        });
+    }
+    switch(to, preserveData) {
+        return __awaiter(this, void 0, void 0, function* () {
+            // Signal as event so that clients can store data before we switch
+            this.emitWillSaveState(WillSaveStateReason.NONE);
+            if (isUserDataProfile(to)) {
+                return this.switchToProfile(to, preserveData);
+            }
+            return this.switchToWorkspace(to, preserveData);
+        });
+    }
+    canSwitchProfile(from, to) {
+        if (from.id === to.id) {
+            return false; // both profiles are same
+        }
+        if (isProfileUsingDefaultStorage(to) && isProfileUsingDefaultStorage(from)) {
+            return false; // both profiles are using default
+        }
+        return true;
+    }
+    switchData(oldStorage, newStorage, scope) {
+        this.withPausedEmitters(() => {
+            // Signal storage keys that have changed
+            const handledkeys = new Set();
+            for (const [key, oldValue] of oldStorage) {
+                handledkeys.add(key);
+                const newValue = newStorage.get(key);
+                if (newValue !== oldValue) {
+                    this.emitDidChangeValue(scope, { key, external: true });
+                }
+            }
+            for (const [key] of newStorage.items) {
+                if (!handledkeys.has(key)) {
+                    this.emitDidChangeValue(scope, { key, external: true });
+                }
+            }
+        });
+    }
 }
 AbstractStorageService.DEFAULT_FLUSH_INTERVAL = 60 * 1000; // every minute
+export function isProfileUsingDefaultStorage(profile) {
+    var _a;
+    return profile.isDefault || !!((_a = profile.useDefaultFlags) === null || _a === void 0 ? void 0 : _a.globalState);
+}
 export class InMemoryStorageService extends AbstractStorageService {
     constructor() {
         super();
@@ -187,4 +353,91 @@
                 return this.workspaceStorage;
         }
     }
+    getLogDetails(scope) {
+        switch (scope) {
+            case -1 /* StorageScope.APPLICATION */:
+                return 'inMemory (application)';
+            case 0 /* StorageScope.PROFILE */:
+                return 'inMemory (profile)';
+            default:
+                return 'inMemory (workspace)';
+        }
+    }
+    doInitialize() {
+        return __awaiter(this, void 0, void 0, function* () { });
+    }
+    switchToProfile() {
+        return __awaiter(this, void 0, void 0, function* () {
+            // no-op when in-memory
+        });
+    }
+    switchToWorkspace() {
+        return __awaiter(this, void 0, void 0, function* () {
+            // no-op when in-memory
+        });
+    }
+    hasScope(scope) {
+        return false;
+    }
+}
+export function logStorage(application, profile, workspace, applicationPath, profilePath, workspacePath) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const safeParse = (value) => {
+            try {
+                return JSON.parse(value);
+            }
+            catch (error) {
+                return value;
+            }
+        };
+        const applicationItems = new Map();
+        const applicationItemsParsed = new Map();
+        application.forEach((value, key) => {
+            applicationItems.set(key, value);
+            applicationItemsParsed.set(key, safeParse(value));
+        });
+        const profileItems = new Map();
+        const profileItemsParsed = new Map();
+        profile.forEach((value, key) => {
+            profileItems.set(key, value);
+            profileItemsParsed.set(key, safeParse(value));
+        });
+        const workspaceItems = new Map();
+        const workspaceItemsParsed = new Map();
+        workspace.forEach((value, key) => {
+            workspaceItems.set(key, value);
+            workspaceItemsParsed.set(key, safeParse(value));
+        });
+        if (applicationPath !== profilePath) {
+            console.group(`Storage: Application (path: ${applicationPath})`);
+        }
+        else {
+            console.group(`Storage: Application & Profile (path: ${applicationPath}, default profile)`);
+        }
+        const applicationValues = [];
+        applicationItems.forEach((value, key) => {
+            applicationValues.push({ key, value });
+        });
+        console.table(applicationValues);
+        console.groupEnd();
+        console.log(applicationItemsParsed);
+        if (applicationPath !== profilePath) {
+            console.group(`Storage: Profile (path: ${profilePath}, profile specific)`);
+            const profileValues = [];
+            profileItems.forEach((value, key) => {
+                profileValues.push({ key, value });
+            });
+            console.table(profileValues);
+            console.groupEnd();
+            console.log(profileItemsParsed);
+        }
+        console.group(`Storage: Workspace (path: ${workspacePath})`);
+        const workspaceValues = [];
+        workspaceItems.forEach((value, key) => {
+            workspaceValues.push({ key, value });
+        });
+        console.table(workspaceValues);
+        console.groupEnd();
+        console.log(workspaceItemsParsed);
+    });
 }
diff -urN -x '*.map' a/vs/platform/telemetry/common/telemetry.js b/vs/platform/telemetry/common/telemetry.js
--- a/vs/platform/telemetry/common/telemetry.js	2023-09-05 08:43:04.270809563 +0000
+++ b/vs/platform/telemetry/common/telemetry.js	2023-09-05 08:45:14.309196520 +0000
@@ -4,3 +4,14 @@
  *--------------------------------------------------------------------------------------------*/
 import { createDecorator } from '../../instantiation/common/instantiation.js';
 export const ITelemetryService = createDecorator('telemetryService');
+export const ICustomEndpointTelemetryService = createDecorator('customEndpointTelemetryService');
+// Keys
+export const currentSessionDateStorageKey = 'telemetry.currentSessionDate';
+export const firstSessionDateStorageKey = 'telemetry.firstSessionDate';
+export const lastSessionDateStorageKey = 'telemetry.lastSessionDate';
+export const machineIdKey = 'telemetry.machineId';
+// Configuration Keys
+export const TELEMETRY_SECTION_ID = 'telemetry';
+export const TELEMETRY_SETTING_ID = 'telemetry.telemetryLevel';
+export const TELEMETRY_CRASH_REPORTER_SETTING_ID = 'telemetry.enableCrashReporter';
+export const TELEMETRY_OLD_SETTING_ID = 'telemetry.enableTelemetry';
diff -urN -x '*.map' a/vs/platform/theme/browser/defaultStyles.js b/vs/platform/theme/browser/defaultStyles.js
--- a/vs/platform/theme/browser/defaultStyles.js	2023-09-05 08:43:04.258809256 +0000
+++ b/vs/platform/theme/browser/defaultStyles.js	2023-09-05 08:45:14.309196520 +0000
@@ -15,6 +15,9 @@
     keybindingLabelBottomBorder: asCssVariable(keybindingLabelBottomBorder),
     keybindingLabelShadow: asCssVariable(widgetShadow)
 };
+export function getKeybindingLabelStyles(override) {
+    return overrideStyles(override, defaultKeybindingLabelStyles);
+}
 export const defaultButtonStyles = {
     buttonForeground: asCssVariable(buttonForeground),
     buttonSeparator: asCssVariable(buttonSeparator),
@@ -25,19 +28,31 @@
     buttonSecondaryHoverBackground: asCssVariable(buttonSecondaryHoverBackground),
     buttonBorder: asCssVariable(buttonBorder),
 };
+export function getButtonStyles(override) {
+    return overrideStyles(override, defaultButtonStyles);
+}
 export const defaultProgressBarStyles = {
     progressBarBackground: asCssVariable(progressBarBackground)
 };
+export function getProgressBarStyles(override) {
+    return overrideStyles(override, defaultProgressBarStyles);
+}
 export const defaultToggleStyles = {
     inputActiveOptionBorder: asCssVariable(inputActiveOptionBorder),
     inputActiveOptionForeground: asCssVariable(inputActiveOptionForeground),
     inputActiveOptionBackground: asCssVariable(inputActiveOptionBackground)
 };
+export function getToggleStyles(override) {
+    return overrideStyles(override, defaultToggleStyles);
+}
 export const defaultCheckboxStyles = {
     checkboxBackground: asCssVariable(checkboxBackground),
     checkboxBorder: asCssVariable(checkboxBorder),
     checkboxForeground: asCssVariable(checkboxForeground)
 };
+export function getCheckboxStyles(override) {
+    return overrideStyles(override, defaultCheckboxStyles);
+}
 export const defaultDialogStyles = {
     dialogBackground: asCssVariable(editorWidgetBackground),
     dialogForeground: asCssVariable(editorWidgetForeground),
@@ -48,6 +63,9 @@
     infoIconForeground: asCssVariable(problemsInfoIconForeground),
     textLinkForeground: asCssVariable(textLinkForeground)
 };
+export function getDialogStyle(override) {
+    return overrideStyles(override, defaultDialogStyles);
+}
 export const defaultInputBoxStyles = {
     inputBackground: asCssVariable(inputBackground),
     inputForeground: asCssVariable(inputForeground),
@@ -62,6 +80,9 @@
     inputValidationErrorBackground: asCssVariable(inputValidationErrorBackground),
     inputValidationErrorForeground: asCssVariable(inputValidationErrorForeground)
 };
+export function getInputBoxStyle(override) {
+    return overrideStyles(override, defaultInputBoxStyles);
+}
 export const defaultFindWidgetStyles = {
     listFilterWidgetBackground: asCssVariable(listFilterWidgetBackground),
     listFilterWidgetOutline: asCssVariable(listFilterWidgetOutline),
@@ -75,6 +96,9 @@
     badgeForeground: asCssVariable(badgeForeground),
     badgeBorder: asCssVariable(contrastBorder)
 };
+export function getCountBadgeStyle(override) {
+    return overrideStyles(override, defaultCountBadgeStyles);
+}
 export const defaultBreadcrumbsWidgetStyles = {
     breadcrumbsBackground: asCssVariable(breadcrumbsBackground),
     breadcrumbsForeground: asCssVariable(breadcrumbsForeground),
@@ -82,6 +106,9 @@
     breadcrumbsFocusForeground: asCssVariable(breadcrumbsFocusForeground),
     breadcrumbsFocusAndSelectionForeground: asCssVariable(breadcrumbsActiveSelectionForeground)
 };
+export function getBreadcrumbsWidgetStyles(override) {
+    return overrideStyles(override, defaultBreadcrumbsWidgetStyles);
+}
 export const defaultListStyles = {
     listBackground: undefined,
     listInactiveFocusForeground: undefined,
@@ -146,6 +173,9 @@
     treeIndentGuidesStroke: undefined,
     treeInactiveIndentGuidesStroke: undefined,
 };
+export function getSelectBoxStyles(override) {
+    return overrideStyles(override, defaultSelectBoxStyles);
+}
 export const defaultMenuStyles = {
     shadowColor: asCssVariable(widgetShadow),
     borderColor: asCssVariable(menuBorder),
@@ -160,3 +190,6 @@
     scrollbarSliderHoverBackground: asCssVariable(scrollbarSliderHoverBackground),
     scrollbarSliderActiveBackground: asCssVariable(scrollbarSliderActiveBackground)
 };
+export function getMenuStyles(override) {
+    return overrideStyles(override, defaultMenuStyles);
+}
diff -urN -x '*.map' a/vs/platform/theme/common/colorRegistry.js b/vs/platform/theme/common/colorRegistry.js
--- a/vs/platform/theme/common/colorRegistry.js	2023-09-05 08:43:04.258809256 +0000
+++ b/vs/platform/theme/common/colorRegistry.js	2023-09-05 08:45:14.309196520 +0000
@@ -49,6 +49,16 @@
         this._onDidChangeSchema.fire();
         return id;
     }
+    deregisterColor(id) {
+        delete this.colorsById[id];
+        delete this.colorSchema.properties[id];
+        const index = this.colorReferenceSchema.enum.indexOf(id);
+        if (index !== -1) {
+            this.colorReferenceSchema.enum.splice(index, 1);
+            this.colorReferenceSchema.enumDescriptions.splice(index, 1);
+        }
+        this._onDidChangeSchema.fire();
+    }
     getColors() {
         return Object.keys(this.colorsById).map(id => this.colorsById[id]);
     }
@@ -63,6 +73,9 @@
     getColorSchema() {
         return this.colorSchema;
     }
+    getColorReferenceSchema() {
+        return this.colorReferenceSchema;
+    }
     toString() {
         const sorter = (a, b) => {
             const cat1 = a.indexOf('.') === -1 ? 0 : 1;
@@ -80,6 +93,9 @@
 export function registerColor(id, defaults, description, needsTransparency, deprecationMessage) {
     return colorRegistry.registerColor(id, defaults, description, needsTransparency, deprecationMessage);
 }
+export function getColorRegistry() {
+    return colorRegistry;
+}
 // ----- base colors
 export const foreground = registerColor('foreground', { dark: '#CCCCCC', light: '#616161', hcDark: '#FFFFFF', hcLight: '#292929' }, nls.localize('foreground', "Overall foreground color. This color is only used if not overridden by a component."));
 export const disabledForeground = registerColor('disabledForeground', { dark: '#CCCCCC80', light: '#61616180', hcDark: '#A5A5A5', hcLight: '#7F7F7F' }, nls.localize('disabledForeground', "Overall foreground for disabled elements. This color is only used if not overridden by a component."));
@@ -436,6 +452,9 @@
 export function transparent(colorValue, factor) {
     return { op: 2 /* ColorTransformType.Transparent */, value: colorValue, factor };
 }
+export function opaque(colorValue, background) {
+    return { op: 3 /* ColorTransformType.Opaque */, value: colorValue, background };
+}
 export function oneOf(...colorValues) {
     return { op: 4 /* ColorTransformType.OneOf */, values: colorValues };
 }
diff -urN -x '*.map' a/vs/platform/theme/common/iconRegistry.js b/vs/platform/theme/common/iconRegistry.js
--- a/vs/platform/theme/common/iconRegistry.js	2023-09-05 08:43:04.258809256 +0000
+++ b/vs/platform/theme/common/iconRegistry.js	2023-09-05 08:45:14.309196520 +0000
@@ -106,6 +106,16 @@
         this._onDidChange.fire();
         return { id };
     }
+    deregisterIcon(id) {
+        delete this.iconsById[id];
+        delete this.iconSchema.properties[id];
+        const index = this.iconReferenceSchema.enum.indexOf(id);
+        if (index !== -1) {
+            this.iconReferenceSchema.enum.splice(index, 1);
+            this.iconReferenceSchema.enumDescriptions.splice(index, 1);
+        }
+        this._onDidChange.fire();
+    }
     getIcons() {
         return Object.keys(this.iconsById).map(id => this.iconsById[id]);
     }
@@ -115,6 +125,24 @@
     getIconSchema() {
         return this.iconSchema;
     }
+    getIconReferenceSchema() {
+        return this.iconReferenceSchema;
+    }
+    registerIconFont(id, definition) {
+        const existing = this.iconFontsById[id];
+        if (existing) {
+            return existing;
+        }
+        this.iconFontsById[id] = definition;
+        this._onDidChange.fire();
+        return definition;
+    }
+    deregisterIconFont(id) {
+        delete this.iconFontsById[id];
+    }
+    getIconFont(id) {
+        return this.iconFontsById[id];
+    }
     toString() {
         const sorter = (i1, i2) => {
             return i1.id.localeCompare(i2.id);
diff -urN -x '*.map' a/vs/platform/theme/common/themeService.js b/vs/platform/theme/common/themeService.js
--- a/vs/platform/theme/common/themeService.js	2023-09-05 08:43:04.258809256 +0000
+++ b/vs/platform/theme/common/themeService.js	2023-09-05 08:45:14.309196520 +0000
@@ -1,3 +1,8 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { Codicon } from '../../../base/common/codicons.js';
 import { Emitter } from '../../../base/common/event.js';
 import { Disposable, toDisposable } from '../../../base/common/lifecycle.js';
 import { createDecorator } from '../../instantiation/common/instantiation.js';
@@ -7,6 +12,8 @@
 export function themeColorFromId(id) {
     return { id };
 }
+export const FileThemeIcon = Codicon.file;
+export const FolderThemeIcon = Codicon.folder;
 export function getThemeTypeSelector(type) {
     switch (type) {
         case ColorScheme.DARK: return 'vs-dark';
@@ -33,6 +40,9 @@
             this.themingParticipants.splice(idx, 1);
         });
     }
+    get onThemingParticipantAdded() {
+        return this.onThemingParticipantAddedEmitter.event;
+    }
     getThemingParticipants() {
         return this.themingParticipants;
     }
@@ -60,4 +70,11 @@
     updateStyles() {
         // Subclasses to override
     }
+    getColor(id, modify) {
+        let color = this.theme.getColor(id);
+        if (color && modify) {
+            color = modify(color, this.theme);
+        }
+        return color ? color.toString() : null;
+    }
 }
diff -urN -x '*.map' a/vs/platform/undoRedo/common/undoRedoService.js b/vs/platform/undoRedo/common/undoRedoService.js
--- a/vs/platform/undoRedo/common/undoRedoService.js	2023-09-05 08:43:04.278809749 +0000
+++ b/vs/platform/undoRedo/common/undoRedoService.js	2023-09-05 08:45:14.305196462 +0000
@@ -186,6 +186,24 @@
         this._future = [];
         this.versionId++;
     }
+    setElementsIsValid(isValid) {
+        for (const element of this._past) {
+            if (element.type === 1 /* UndoRedoElementType.Workspace */) {
+                element.setValid(this.resourceLabel, this.strResource, isValid);
+            }
+            else {
+                element.setValid(isValid);
+            }
+        }
+        for (const element of this._future) {
+            if (element.type === 1 /* UndoRedoElementType.Workspace */) {
+                element.setValid(this.resourceLabel, this.strResource, isValid);
+            }
+            else {
+                element.setValid(isValid);
+            }
+        }
+    }
     _setElementValidFlag(element, isValid) {
         if (element.type === 1 /* UndoRedoElementType.Workspace */) {
             element.setValid(this.resourceLabel, this.strResource, isValid);
@@ -365,6 +383,19 @@
         this._editStacks = new Map();
         this._uriComparisonKeyComputers = [];
     }
+    registerUriComparisonKeyComputer(scheme, uriComparisonKeyComputer) {
+        this._uriComparisonKeyComputers.push([scheme, uriComparisonKeyComputer]);
+        return {
+            dispose: () => {
+                for (let i = 0, len = this._uriComparisonKeyComputers.length; i < len; i++) {
+                    if (this._uriComparisonKeyComputers[i][1] === uriComparisonKeyComputer) {
+                        this._uriComparisonKeyComputers.splice(i, 1);
+                        return;
+                    }
+                }
+            }
+        };
+    }
     getUriComparisonKey(resource) {
         for (const uriComparisonKeyComputer of this._uriComparisonKeyComputers) {
             if (uriComparisonKeyComputer[0] === resource.scheme) {
@@ -495,6 +526,14 @@
             this._print('setElementsValidFlag');
         }
     }
+    hasElements(resource) {
+        const strResource = this.getUriComparisonKey(resource);
+        if (this._editStacks.has(strResource)) {
+            const editStack = this._editStacks.get(strResource);
+            return (editStack.hasPastElements() || editStack.hasFutureElements());
+        }
+        return false;
+    }
     createSnapshot(resource) {
         const strResource = this.getUriComparisonKey(resource);
         if (this._editStacks.has(strResource)) {
diff -urN -x '*.map' a/vs/platform/uriIdentity/common/uriIdentity.js b/vs/platform/uriIdentity/common/uriIdentity.js
--- a/vs/platform/uriIdentity/common/uriIdentity.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/platform/uriIdentity/common/uriIdentity.js	2023-09-05 08:45:14.313196577 +0000
@@ -0,0 +1,6 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import { createDecorator } from '../../instantiation/common/instantiation.js';
+export const IUriIdentityService = createDecorator('IUriIdentityService');
diff -urN -x '*.map' a/vs/platform/userDataProfile/common/userDataProfile.js b/vs/platform/userDataProfile/common/userDataProfile.js
--- a/vs/platform/userDataProfile/common/userDataProfile.js	1970-01-01 00:00:00.000000000 +0000
+++ b/vs/platform/userDataProfile/common/userDataProfile.js	2023-09-05 08:45:14.309196520 +0000
@@ -0,0 +1,503 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
+    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
+    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
+    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
+    return c > 3 && r && Object.defineProperty(target, key, r), r;
+};
+var __param = (this && this.__param) || function (paramIndex, decorator) {
+    return function (target, key) { decorator(target, key, paramIndex); }
+};
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+import { hash } from '../../../base/common/hash.js';
+import { Emitter } from '../../../base/common/event.js';
+import { Disposable } from '../../../base/common/lifecycle.js';
+import { basename, joinPath } from '../../../base/common/resources.js';
+import { URI } from '../../../base/common/uri.js';
+import { localize } from '../../../nls.js';
+import { IEnvironmentService } from '../../environment/common/environment.js';
+import { IFileService, toFileOperationResult } from '../../files/common/files.js';
+import { createDecorator } from '../../instantiation/common/instantiation.js';
+import { ILogService } from '../../log/common/log.js';
+import { isSingleFolderWorkspaceIdentifier, isWorkspaceIdentifier } from '../../workspace/common/workspace.js';
+import { ResourceMap } from '../../../base/common/map.js';
+import { IUriIdentityService } from '../../uriIdentity/common/uriIdentity.js';
+import { Promises } from '../../../base/common/async.js';
+import { generateUuid } from '../../../base/common/uuid.js';
+import { escapeRegExpCharacters } from '../../../base/common/strings.js';
+import { isString } from '../../../base/common/types.js';
+export function isUserDataProfile(thing) {
+    const candidate = thing;
+    return !!(candidate && typeof candidate === 'object'
+        && typeof candidate.id === 'string'
+        && typeof candidate.isDefault === 'boolean'
+        && typeof candidate.name === 'string'
+        && URI.isUri(candidate.location)
+        && URI.isUri(candidate.globalStorageHome)
+        && URI.isUri(candidate.settingsResource)
+        && URI.isUri(candidate.keybindingsResource)
+        && URI.isUri(candidate.tasksResource)
+        && URI.isUri(candidate.snippetsHome)
+        && URI.isUri(candidate.extensionsResource));
+}
+export const IUserDataProfilesService = createDecorator('IUserDataProfilesService');
+export function reviveProfile(profile, scheme) {
+    return {
+        id: profile.id,
+        isDefault: profile.isDefault,
+        name: profile.name,
+        shortName: profile.shortName,
+        location: URI.revive(profile.location).with({ scheme }),
+        globalStorageHome: URI.revive(profile.globalStorageHome).with({ scheme }),
+        settingsResource: URI.revive(profile.settingsResource).with({ scheme }),
+        keybindingsResource: URI.revive(profile.keybindingsResource).with({ scheme }),
+        tasksResource: URI.revive(profile.tasksResource).with({ scheme }),
+        snippetsHome: URI.revive(profile.snippetsHome).with({ scheme }),
+        extensionsResource: URI.revive(profile.extensionsResource).with({ scheme }),
+        cacheHome: URI.revive(profile.cacheHome).with({ scheme }),
+        useDefaultFlags: profile.useDefaultFlags,
+        isTransient: profile.isTransient,
+    };
+}
+export function toUserDataProfile(id, name, location, profilesCacheHome, options, defaultProfile) {
+    var _a, _b, _c, _d, _e, _f;
+    return {
+        id,
+        name,
+        location,
+        isDefault: false,
+        shortName: options === null || options === void 0 ? void 0 : options.shortName,
+        globalStorageHome: defaultProfile && ((_a = options === null || options === void 0 ? void 0 : options.useDefaultFlags) === null || _a === void 0 ? void 0 : _a.globalState) ? defaultProfile.globalStorageHome : joinPath(location, 'globalStorage'),
+        settingsResource: defaultProfile && ((_b = options === null || options === void 0 ? void 0 : options.useDefaultFlags) === null || _b === void 0 ? void 0 : _b.settings) ? defaultProfile.settingsResource : joinPath(location, 'settings.json'),
+        keybindingsResource: defaultProfile && ((_c = options === null || options === void 0 ? void 0 : options.useDefaultFlags) === null || _c === void 0 ? void 0 : _c.keybindings) ? defaultProfile.keybindingsResource : joinPath(location, 'keybindings.json'),
+        tasksResource: defaultProfile && ((_d = options === null || options === void 0 ? void 0 : options.useDefaultFlags) === null || _d === void 0 ? void 0 : _d.tasks) ? defaultProfile.tasksResource : joinPath(location, 'tasks.json'),
+        snippetsHome: defaultProfile && ((_e = options === null || options === void 0 ? void 0 : options.useDefaultFlags) === null || _e === void 0 ? void 0 : _e.snippets) ? defaultProfile.snippetsHome : joinPath(location, 'snippets'),
+        extensionsResource: defaultProfile && ((_f = options === null || options === void 0 ? void 0 : options.useDefaultFlags) === null || _f === void 0 ? void 0 : _f.extensions) ? defaultProfile.extensionsResource : joinPath(location, 'extensions.json'),
+        cacheHome: joinPath(profilesCacheHome, id),
+        useDefaultFlags: options === null || options === void 0 ? void 0 : options.useDefaultFlags,
+        isTransient: options === null || options === void 0 ? void 0 : options.transient
+    };
+}
+let UserDataProfilesService = class UserDataProfilesService extends Disposable {
+    get defaultProfile() { return this.profiles[0]; }
+    get profiles() { return [...this.profilesObject.profiles, ...this.transientProfilesObject.profiles]; }
+    constructor(environmentService, fileService, uriIdentityService, logService) {
+        super();
+        this.environmentService = environmentService;
+        this.fileService = fileService;
+        this.uriIdentityService = uriIdentityService;
+        this.logService = logService;
+        this.enabled = true;
+        this._onDidChangeProfiles = this._register(new Emitter());
+        this.onDidChangeProfiles = this._onDidChangeProfiles.event;
+        this._onWillCreateProfile = this._register(new Emitter());
+        this.onWillCreateProfile = this._onWillCreateProfile.event;
+        this._onWillRemoveProfile = this._register(new Emitter());
+        this.onWillRemoveProfile = this._onWillRemoveProfile.event;
+        this._onDidResetWorkspaces = this._register(new Emitter());
+        this.onDidResetWorkspaces = this._onDidResetWorkspaces.event;
+        this.profileCreationPromises = new Map();
+        this.transientProfilesObject = {
+            profiles: [],
+            workspaces: new ResourceMap(),
+            emptyWindows: new Map()
+        };
+        this.profilesHome = joinPath(this.environmentService.userRoamingDataHome, 'profiles');
+        this.profilesCacheHome = joinPath(this.environmentService.cacheHome, 'CachedProfilesData');
+    }
+    init() {
+        this._profilesObject = undefined;
+    }
+    setEnablement(enabled) {
+        if (this.enabled !== enabled) {
+            this._profilesObject = undefined;
+            this.enabled = enabled;
+        }
+    }
+    isEnabled() {
+        return this.enabled;
+    }
+    get profilesObject() {
+        if (!this._profilesObject) {
+            const defaultProfile = this.createDefaultProfile();
+            const profiles = [defaultProfile];
+            if (this.enabled) {
+                try {
+                    for (const storedProfile of this.getStoredProfiles()) {
+                        if (!storedProfile.name || !isString(storedProfile.name) || !storedProfile.location) {
+                            this.logService.warn('Skipping the invalid stored profile', storedProfile.location || storedProfile.name);
+                            continue;
+                        }
+                        profiles.push(toUserDataProfile(basename(storedProfile.location), storedProfile.name, storedProfile.location, this.profilesCacheHome, { shortName: storedProfile.shortName, useDefaultFlags: storedProfile.useDefaultFlags }, defaultProfile));
+                    }
+                }
+                catch (error) {
+                    this.logService.error(error);
+                }
+            }
+            const workspaces = new ResourceMap();
+            const emptyWindows = new Map();
+            if (profiles.length) {
+                try {
+                    const profileAssociaitions = this.getStoredProfileAssociations();
+                    if (profileAssociaitions.workspaces) {
+                        for (const [workspacePath, profileId] of Object.entries(profileAssociaitions.workspaces)) {
+                            const workspace = URI.parse(workspacePath);
+                            const profile = profiles.find(p => p.id === profileId);
+                            if (profile) {
+                                workspaces.set(workspace, profile);
+                            }
+                        }
+                    }
+                    if (profileAssociaitions.emptyWindows) {
+                        for (const [windowId, profileId] of Object.entries(profileAssociaitions.emptyWindows)) {
+                            const profile = profiles.find(p => p.id === profileId);
+                            if (profile) {
+                                emptyWindows.set(windowId, profile);
+                            }
+                        }
+                    }
+                }
+                catch (error) {
+                    this.logService.error(error);
+                }
+            }
+            this._profilesObject = { profiles, workspaces, emptyWindows };
+        }
+        return this._profilesObject;
+    }
+    createDefaultProfile() {
+        var _a;
+        const defaultProfile = toUserDataProfile('__default__profile__', localize('defaultProfile', "Default"), this.environmentService.userRoamingDataHome, this.profilesCacheHome);
+        return Object.assign(Object.assign({}, defaultProfile), { extensionsResource: (_a = this.getDefaultProfileExtensionsLocation()) !== null && _a !== void 0 ? _a : defaultProfile.extensionsResource, isDefault: true });
+    }
+    createTransientProfile(workspaceIdentifier) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const namePrefix = `Temp`;
+            const nameRegEx = new RegExp(`${escapeRegExpCharacters(namePrefix)}\\s(\\d+)`);
+            let nameIndex = 0;
+            for (const profile of this.profiles) {
+                const matches = nameRegEx.exec(profile.name);
+                const index = matches ? parseInt(matches[1]) : 0;
+                nameIndex = index > nameIndex ? index : nameIndex;
+            }
+            const name = `${namePrefix} ${nameIndex + 1}`;
+            return this.createProfile(hash(generateUuid()).toString(16), name, { transient: true }, workspaceIdentifier);
+        });
+    }
+    createNamedProfile(name, options, workspaceIdentifier) {
+        return __awaiter(this, void 0, void 0, function* () {
+            return this.createProfile(hash(generateUuid()).toString(16), name, options, workspaceIdentifier);
+        });
+    }
+    createProfile(id, name, options, workspaceIdentifier) {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (!this.enabled) {
+                throw new Error(`Profiles are disabled in the current environment.`);
+            }
+            const profile = yield this.doCreateProfile(id, name, options);
+            if (workspaceIdentifier) {
+                yield this.setProfileForWorkspace(workspaceIdentifier, profile);
+            }
+            return profile;
+        });
+    }
+    doCreateProfile(id, name, options) {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (!isString(name) || !name) {
+                throw new Error('Name of the profile is mandatory and must be of type `string`');
+            }
+            let profileCreationPromise = this.profileCreationPromises.get(name);
+            if (!profileCreationPromise) {
+                profileCreationPromise = (() => __awaiter(this, void 0, void 0, function* () {
+                    try {
+                        const existing = this.profiles.find(p => p.name === name || p.id === id);
+                        if (existing) {
+                            return existing;
+                        }
+                        const profile = toUserDataProfile(id, name, joinPath(this.profilesHome, id), this.profilesCacheHome, options, this.defaultProfile);
+                        yield this.fileService.createFolder(profile.location);
+                        const joiners = [];
+                        this._onWillCreateProfile.fire({
+                            profile,
+                            join(promise) {
+                                joiners.push(promise);
+                            }
+                        });
+                        yield Promises.settled(joiners);
+                        this.updateProfiles([profile], [], []);
+                        return profile;
+                    }
+                    finally {
+                        this.profileCreationPromises.delete(name);
+                    }
+                }))();
+                this.profileCreationPromises.set(name, profileCreationPromise);
+            }
+            return profileCreationPromise;
+        });
+    }
+    updateProfile(profileToUpdate, options) {
+        var _a, _b, _c, _d;
+        return __awaiter(this, void 0, void 0, function* () {
+            if (!this.enabled) {
+                throw new Error(`Profiles are disabled in the current environment.`);
+            }
+            let profile = this.profiles.find(p => p.id === profileToUpdate.id);
+            if (!profile) {
+                throw new Error(`Profile '${profileToUpdate.name}' does not exist`);
+            }
+            profile = toUserDataProfile(profile.id, (_a = options.name) !== null && _a !== void 0 ? _a : profile.name, profile.location, this.profilesCacheHome, { shortName: (_b = options.shortName) !== null && _b !== void 0 ? _b : profile.shortName, transient: (_c = options.transient) !== null && _c !== void 0 ? _c : profile.isTransient, useDefaultFlags: (_d = options.useDefaultFlags) !== null && _d !== void 0 ? _d : profile.useDefaultFlags }, this.defaultProfile);
+            this.updateProfiles([], [], [profile]);
+            return profile;
+        });
+    }
+    removeProfile(profileToRemove) {
+        var _a, _b;
+        return __awaiter(this, void 0, void 0, function* () {
+            if (!this.enabled) {
+                throw new Error(`Profiles are disabled in the current environment.`);
+            }
+            if (profileToRemove.isDefault) {
+                throw new Error('Cannot remove default profile');
+            }
+            const profile = this.profiles.find(p => p.id === profileToRemove.id);
+            if (!profile) {
+                throw new Error(`Profile '${profileToRemove.name}' does not exist`);
+            }
+            const joiners = [];
+            this._onWillRemoveProfile.fire({
+                profile,
+                join(promise) {
+                    joiners.push(promise);
+                }
+            });
+            try {
+                yield Promise.allSettled(joiners);
+            }
+            catch (error) {
+                this.logService.error(error);
+            }
+            for (const windowId of [...this.profilesObject.emptyWindows.keys()]) {
+                if (profile.id === ((_a = this.profilesObject.emptyWindows.get(windowId)) === null || _a === void 0 ? void 0 : _a.id)) {
+                    this.profilesObject.emptyWindows.delete(windowId);
+                }
+            }
+            for (const workspace of [...this.profilesObject.workspaces.keys()]) {
+                if (profile.id === ((_b = this.profilesObject.workspaces.get(workspace)) === null || _b === void 0 ? void 0 : _b.id)) {
+                    this.profilesObject.workspaces.delete(workspace);
+                }
+            }
+            this.updateStoredProfileAssociations();
+            this.updateProfiles([], [profile], []);
+            try {
+                yield this.fileService.del(profile.cacheHome, { recursive: true });
+            }
+            catch (error) {
+                if (toFileOperationResult(error) !== 1 /* FileOperationResult.FILE_NOT_FOUND */) {
+                    this.logService.error(error);
+                }
+            }
+        });
+    }
+    setProfileForWorkspace(workspaceIdentifier, profileToSet) {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (!this.enabled) {
+                throw new Error(`Profiles are disabled in the current environment.`);
+            }
+            const profile = this.profiles.find(p => p.id === profileToSet.id);
+            if (!profile) {
+                throw new Error(`Profile '${profileToSet.name}' does not exist`);
+            }
+            this.updateWorkspaceAssociation(workspaceIdentifier, profile);
+        });
+    }
+    unsetWorkspace(workspaceIdentifier, transient) {
+        if (!this.enabled) {
+            throw new Error(`Profiles are disabled in the current environment.`);
+        }
+        this.updateWorkspaceAssociation(workspaceIdentifier, undefined, transient);
+    }
+    resetWorkspaces() {
+        return __awaiter(this, void 0, void 0, function* () {
+            this.transientProfilesObject.workspaces.clear();
+            this.transientProfilesObject.emptyWindows.clear();
+            this.profilesObject.workspaces.clear();
+            this.profilesObject.emptyWindows.clear();
+            this.updateStoredProfileAssociations();
+            this._onDidResetWorkspaces.fire();
+        });
+    }
+    cleanUp() {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (!this.enabled) {
+                return;
+            }
+            if (yield this.fileService.exists(this.profilesHome)) {
+                const stat = yield this.fileService.resolve(this.profilesHome);
+                yield Promise.all((stat.children || [])
+                    .filter(child => child.isDirectory && this.profiles.every(p => !this.uriIdentityService.extUri.isEqual(p.location, child.resource)))
+                    .map(child => this.fileService.del(child.resource, { recursive: true })));
+            }
+        });
+    }
+    cleanUpTransientProfiles() {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (!this.enabled) {
+                return;
+            }
+            const unAssociatedTransientProfiles = this.transientProfilesObject.profiles.filter(p => !this.isProfileAssociatedToWorkspace(p));
+            yield Promise.allSettled(unAssociatedTransientProfiles.map(p => this.removeProfile(p)));
+        });
+    }
+    getProfileForWorkspace(workspaceIdentifier) {
+        var _a, _b;
+        const workspace = this.getWorkspace(workspaceIdentifier);
+        return URI.isUri(workspace) ? (_a = this.transientProfilesObject.workspaces.get(workspace)) !== null && _a !== void 0 ? _a : this.profilesObject.workspaces.get(workspace) : (_b = this.transientProfilesObject.emptyWindows.get(workspace)) !== null && _b !== void 0 ? _b : this.profilesObject.emptyWindows.get(workspace);
+    }
+    getWorkspace(workspaceIdentifier) {
+        if (isSingleFolderWorkspaceIdentifier(workspaceIdentifier)) {
+            return workspaceIdentifier.uri;
+        }
+        if (isWorkspaceIdentifier(workspaceIdentifier)) {
+            return workspaceIdentifier.configPath;
+        }
+        return workspaceIdentifier.id;
+    }
+    isProfileAssociatedToWorkspace(profile) {
+        if ([...this.transientProfilesObject.emptyWindows.values()].some(windowProfile => this.uriIdentityService.extUri.isEqual(windowProfile.location, profile.location))) {
+            return true;
+        }
+        if ([...this.transientProfilesObject.workspaces.values()].some(workspaceProfile => this.uriIdentityService.extUri.isEqual(workspaceProfile.location, profile.location))) {
+            return true;
+        }
+        if ([...this.profilesObject.emptyWindows.values()].some(windowProfile => this.uriIdentityService.extUri.isEqual(windowProfile.location, profile.location))) {
+            return true;
+        }
+        if ([...this.profilesObject.workspaces.values()].some(workspaceProfile => this.uriIdentityService.extUri.isEqual(workspaceProfile.location, profile.location))) {
+            return true;
+        }
+        return false;
+    }
+    updateProfiles(added, removed, updated) {
+        var _a;
+        const allProfiles = [...this.profiles, ...added];
+        const storedProfiles = [];
+        this.transientProfilesObject.profiles = [];
+        for (let profile of allProfiles) {
+            if (profile.isDefault) {
+                continue;
+            }
+            if (removed.some(p => profile.id === p.id)) {
+                continue;
+            }
+            profile = (_a = updated.find(p => profile.id === p.id)) !== null && _a !== void 0 ? _a : profile;
+            if (profile.isTransient) {
+                this.transientProfilesObject.profiles.push(profile);
+            }
+            else {
+                storedProfiles.push({ location: profile.location, name: profile.name, shortName: profile.shortName, useDefaultFlags: profile.useDefaultFlags });
+            }
+        }
+        this.saveStoredProfiles(storedProfiles);
+        this._profilesObject = undefined;
+        this.triggerProfilesChanges(added, removed, updated);
+    }
+    triggerProfilesChanges(added, removed, updated) {
+        this._onDidChangeProfiles.fire({ added, removed, updated, all: this.profiles });
+    }
+    updateWorkspaceAssociation(workspaceIdentifier, newProfile, transient) {
+        // Force transient if the new profile to associate is transient
+        transient = (newProfile === null || newProfile === void 0 ? void 0 : newProfile.isTransient) ? true : transient;
+        if (!transient) {
+            // Unset the transiet workspace association if any
+            this.updateWorkspaceAssociation(workspaceIdentifier, undefined, true);
+        }
+        const workspace = this.getWorkspace(workspaceIdentifier);
+        const profilesObject = transient ? this.transientProfilesObject : this.profilesObject;
+        // Folder or Multiroot workspace
+        if (URI.isUri(workspace)) {
+            profilesObject.workspaces.delete(workspace);
+            if (newProfile) {
+                profilesObject.workspaces.set(workspace, newProfile);
+            }
+        }
+        // Empty Window
+        else {
+            profilesObject.emptyWindows.delete(workspace);
+            if (newProfile) {
+                profilesObject.emptyWindows.set(workspace, newProfile);
+            }
+        }
+        if (!transient) {
+            this.updateStoredProfileAssociations();
+        }
+    }
+    updateStoredProfileAssociations() {
+        const workspaces = {};
+        for (const [workspace, profile] of this.profilesObject.workspaces.entries()) {
+            workspaces[workspace.toString()] = profile.id;
+        }
+        const emptyWindows = {};
+        for (const [windowId, profile] of this.profilesObject.emptyWindows.entries()) {
+            emptyWindows[windowId.toString()] = profile.id;
+        }
+        this.saveStoredProfileAssociations({ workspaces, emptyWindows });
+        this._profilesObject = undefined;
+    }
+    // TODO: @sandy081 Remove migration after couple of releases
+    migrateStoredProfileAssociations(storedProfileAssociations) {
+        const workspaces = {};
+        const defaultProfile = this.createDefaultProfile();
+        if (storedProfileAssociations.workspaces) {
+            for (const [workspace, location] of Object.entries(storedProfileAssociations.workspaces)) {
+                const uri = URI.parse(location);
+                workspaces[workspace] = this.uriIdentityService.extUri.isEqual(uri, defaultProfile.location) ? defaultProfile.id : this.uriIdentityService.extUri.basename(uri);
+            }
+        }
+        const emptyWindows = {};
+        if (storedProfileAssociations.emptyWindows) {
+            for (const [workspace, location] of Object.entries(storedProfileAssociations.emptyWindows)) {
+                const uri = URI.parse(location);
+                emptyWindows[workspace] = this.uriIdentityService.extUri.isEqual(uri, defaultProfile.location) ? defaultProfile.id : this.uriIdentityService.extUri.basename(uri);
+            }
+        }
+        return { workspaces, emptyWindows };
+    }
+    getStoredProfiles() { return []; }
+    saveStoredProfiles(storedProfiles) { throw new Error('not implemented'); }
+    getStoredProfileAssociations() { return {}; }
+    saveStoredProfileAssociations(storedProfileAssociations) { throw new Error('not implemented'); }
+    getDefaultProfileExtensionsLocation() { return undefined; }
+};
+UserDataProfilesService.PROFILES_KEY = 'userDataProfiles';
+UserDataProfilesService.PROFILE_ASSOCIATIONS_KEY = 'profileAssociations';
+UserDataProfilesService = __decorate([
+    __param(0, IEnvironmentService),
+    __param(1, IFileService),
+    __param(2, IUriIdentityService),
+    __param(3, ILogService)
+], UserDataProfilesService);
+export { UserDataProfilesService };
+export class InMemoryUserDataProfilesService extends UserDataProfilesService {
+    constructor() {
+        super(...arguments);
+        this.storedProfiles = [];
+        this.storedProfileAssociations = {};
+    }
+    getStoredProfiles() { return this.storedProfiles; }
+    saveStoredProfiles(storedProfiles) { this.storedProfiles = storedProfiles; }
+    getStoredProfileAssociations() { return this.storedProfileAssociations; }
+    saveStoredProfileAssociations(storedProfileAssociations) { this.storedProfileAssociations = storedProfileAssociations; }
+}
diff -urN -x '*.map' a/vs/platform/workspace/common/workspace.js b/vs/platform/workspace/common/workspace.js
--- a/vs/platform/workspace/common/workspace.js	2023-09-05 08:43:04.282809842 +0000
+++ b/vs/platform/workspace/common/workspace.js	2023-09-05 08:45:14.313196577 +0000
@@ -3,10 +3,12 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 import { localize } from '../../../nls.js';
-import { basename } from '../../../base/common/path.js';
+import { basename, extname } from '../../../base/common/path.js';
 import { TernarySearchTree } from '../../../base/common/ternarySearchTree.js';
+import { extname as resourceExtname, basenameOrAuthority, joinPath, extUriBiasedIgnorePathCase } from '../../../base/common/resources.js';
 import { URI } from '../../../base/common/uri.js';
 import { createDecorator } from '../../instantiation/common/instantiation.js';
+import { Schemas } from '../../../base/common/network.js';
 export const IWorkspaceContextService = createDecorator('contextService');
 export function isSingleFolderWorkspaceIdentifier(obj) {
     const singleFolderIdentifier = obj;
@@ -61,6 +63,36 @@
     const workspaceIdentifier = obj;
     return typeof (workspaceIdentifier === null || workspaceIdentifier === void 0 ? void 0 : workspaceIdentifier.id) === 'string' && URI.isUri(workspaceIdentifier.configPath);
 }
+export function reviveIdentifier(identifier) {
+    // Single Folder
+    const singleFolderIdentifierCandidate = identifier;
+    if (singleFolderIdentifierCandidate === null || singleFolderIdentifierCandidate === void 0 ? void 0 : singleFolderIdentifierCandidate.uri) {
+        return { id: singleFolderIdentifierCandidate.id, uri: URI.revive(singleFolderIdentifierCandidate.uri) };
+    }
+    // Multi folder
+    const workspaceIdentifierCandidate = identifier;
+    if (workspaceIdentifierCandidate === null || workspaceIdentifierCandidate === void 0 ? void 0 : workspaceIdentifierCandidate.configPath) {
+        return { id: workspaceIdentifierCandidate.id, configPath: URI.revive(workspaceIdentifierCandidate.configPath) };
+    }
+    // Empty
+    if (identifier === null || identifier === void 0 ? void 0 : identifier.id) {
+        return { id: identifier.id };
+    }
+    return undefined;
+}
+export function isWorkspace(thing) {
+    const candidate = thing;
+    return !!(candidate && typeof candidate === 'object'
+        && typeof candidate.id === 'string'
+        && Array.isArray(candidate.folders));
+}
+export function isWorkspaceFolder(thing) {
+    const candidate = thing;
+    return !!(candidate && typeof candidate === 'object'
+        && URI.isUri(candidate.uri)
+        && typeof candidate.name === 'string'
+        && typeof candidate.toResource === 'function');
+}
 export class Workspace {
     constructor(_id, folders, _transient, _configuration, _ignorePathCasing) {
         this._id = _id;
@@ -70,6 +102,13 @@
         this._foldersMap = TernarySearchTree.forUris(this._ignorePathCasing, () => true);
         this.folders = folders;
     }
+    update(workspace) {
+        this._id = workspace.id;
+        this._configuration = workspace.configuration;
+        this._transient = workspace.transient;
+        this._ignorePathCasing = workspace._ignorePathCasing;
+        this.folders = workspace.folders;
+    }
     get folders() {
         return this._folders;
     }
@@ -120,13 +159,41 @@
         this.index = data.index;
         this.name = data.name;
     }
+    toResource(relativePath) {
+        return joinPath(this.uri, relativePath);
+    }
     toJSON() {
         return { uri: this.uri, name: this.name, index: this.index };
     }
 }
+export function toWorkspaceFolder(resource) {
+    return new WorkspaceFolder({ uri: resource, index: 0, name: basenameOrAuthority(resource) }, { uri: resource.toString() });
+}
 export const WORKSPACE_EXTENSION = 'code-workspace';
+export const WORKSPACE_SUFFIX = `.${WORKSPACE_EXTENSION}`;
 export const WORKSPACE_FILTER = [{ name: localize('codeWorkspace', "Code Workspace"), extensions: [WORKSPACE_EXTENSION] }];
+export const UNTITLED_WORKSPACE_NAME = 'workspace.json';
+export function isUntitledWorkspace(path, environmentService) {
+    return extUriBiasedIgnorePathCase.isEqualOrParent(path, environmentService.untitledWorkspacesHome);
+}
+export function isTemporaryWorkspace(arg1) {
+    let path;
+    if (URI.isUri(arg1)) {
+        path = arg1;
+    }
+    else {
+        path = arg1.configuration;
+    }
+    return (path === null || path === void 0 ? void 0 : path.scheme) === Schemas.tmp;
+}
 export const STANDALONE_EDITOR_WORKSPACE_ID = '4064f6ec-cb38-4ad0-af64-ee6467e63c82';
 export function isStandaloneEditorWorkspace(workspace) {
     return workspace.id === STANDALONE_EDITOR_WORKSPACE_ID;
 }
+export function isSavedWorkspace(path, environmentService) {
+    return !isUntitledWorkspace(path, environmentService) && !isTemporaryWorkspace(path);
+}
+export function hasWorkspaceFileExtension(path) {
+    const ext = (typeof path === 'string') ? extname(path) : resourceExtname(path);
+    return ext === WORKSPACE_SUFFIX;
+}
diff -urN -x '*.map' a/vs/platform/workspace/common/workspaceTrust.js b/vs/platform/workspace/common/workspaceTrust.js
--- a/vs/platform/workspace/common/workspaceTrust.js	2023-09-05 08:43:04.282809842 +0000
+++ b/vs/platform/workspace/common/workspaceTrust.js	2023-09-05 08:45:14.313196577 +0000
@@ -2,5 +2,21 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
+import { localize } from '../../../nls.js';
 import { createDecorator } from '../../instantiation/common/instantiation.js';
+export var WorkspaceTrustScope;
+(function (WorkspaceTrustScope) {
+    WorkspaceTrustScope[WorkspaceTrustScope["Local"] = 0] = "Local";
+    WorkspaceTrustScope[WorkspaceTrustScope["Remote"] = 1] = "Remote";
+})(WorkspaceTrustScope || (WorkspaceTrustScope = {}));
+export function workspaceTrustToString(trustState) {
+    if (trustState) {
+        return localize('trusted', "Trusted");
+    }
+    else {
+        return localize('untrusted', "Restricted Mode");
+    }
+}
+export const IWorkspaceTrustEnablementService = createDecorator('workspaceTrustEnablementService');
 export const IWorkspaceTrustManagementService = createDecorator('workspaceTrustManagementService');
+export const IWorkspaceTrustRequestService = createDecorator('workspaceTrustRequestService');
