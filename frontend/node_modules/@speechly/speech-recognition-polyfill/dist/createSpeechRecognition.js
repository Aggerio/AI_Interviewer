"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSpeechlySpeechRecognition = void 0;
const browser_client_1 = require("@speechly/browser-client");
const types_1 = require("./types");
/**
 * Returns a SpeechRecognition implementation that uses a given Speechly app ID
 * to generate transcriptions using the Speechly API
 *
 * @param appId - Speechly app ID
 * @returns Class that implements the SpeechRecognition interface
 * @public
 */
const createSpeechlySpeechRecognition = (appId) => {
    var _a;
    var _b;
    const browserSupportsAudioApis = typeof window !== 'undefined' &&
        ((_a = window.navigator) === null || _a === void 0 ? void 0 : _a.mediaDevices) !== undefined &&
        (window.AudioContext !== undefined || window.webkitAudioContext !== undefined);
    return _b = class SpeechlySpeechRecognition {
            constructor() {
                this.aborted = false;
                this.transcribing = false;
                this.taskQueue = null;
                this.continuous = false;
                this.interimResults = false;
                this.onresult = () => { };
                this.onend = () => { };
                this.onerror = () => { };
                this.start = () => __awaiter(this, void 0, void 0, function* () {
                    try {
                        this.aborted = false;
                        yield this._start();
                    }
                    catch (e) {
                        if (e === browser_client_1.ErrNoAudioConsent) {
                            this.onerror(types_1.MicrophoneNotAllowedError);
                        }
                        else {
                            this.onerror(types_1.SpeechRecognitionFailedError);
                        }
                    }
                });
                this.stop = () => __awaiter(this, void 0, void 0, function* () {
                    yield this._stop();
                });
                this.abort = () => __awaiter(this, void 0, void 0, function* () {
                    this.aborted = true;
                    yield this._stop();
                });
                this._start = () => __awaiter(this, void 0, void 0, function* () {
                    if (this.transcribing) {
                        return;
                    }
                    this.transcribing = true;
                    const startTask = () => __awaiter(this, void 0, void 0, function* () {
                        yield this.microphone.initialize();
                        const { mediaStream } = this.microphone;
                        if (mediaStream === null || mediaStream === undefined) {
                            throw browser_client_1.ErrDeviceNotSupported;
                        }
                        yield this.client.attach(mediaStream);
                        yield this.client.start();
                    });
                    yield this.enqueueTask(startTask);
                });
                this._stop = () => __awaiter(this, void 0, void 0, function* () {
                    if (!this.transcribing) {
                        return;
                    }
                    this.transcribing = false;
                    const stopTask = () => __awaiter(this, void 0, void 0, function* () {
                        try {
                            yield this.client.stop();
                            yield this.client.detach();
                            yield this.microphone.close();
                            this.onend();
                        }
                        catch (e) {
                            // swallow errors
                        }
                    });
                    yield this.enqueueTask(stopTask);
                });
                this.enqueueTask = (task) => __awaiter(this, void 0, void 0, function* () {
                    const queuedTask = () => __awaiter(this, void 0, void 0, function* () {
                        // Wait for earlier task(s) to complete, effectively adding to a task queue
                        yield this.taskQueue;
                        yield task();
                    });
                    this.taskQueue = queuedTask();
                    yield this.taskQueue;
                });
                this.handleResult = (segment) => {
                    if (this.aborted) {
                        return;
                    }
                    if (!this.interimResults && !segment.isFinal) {
                        return;
                    }
                    const transcript = segment.words
                        .map(x => x.value)
                        .filter(x => x)
                        .join(' ');
                    const results = [
                        {
                            0: {
                                transcript,
                                confidence: 1,
                            },
                            isFinal: segment.isFinal,
                        },
                    ];
                    this.onresult({ results, resultIndex: 0 });
                    if (!this.continuous && segment.isFinal) {
                        this.abort().catch(() => { }); // swallow errors
                    }
                };
                this.client = new browser_client_1.BrowserClient({ appId });
                this.microphone = new browser_client_1.BrowserMicrophone();
                this.client.onSegmentChange(this.handleResult);
            }
        },
        _b.hasBrowserSupport = browserSupportsAudioApis,
        _b;
};
exports.createSpeechlySpeechRecognition = createSpeechlySpeechRecognition;
exports.default = exports.createSpeechlySpeechRecognition;
//# sourceMappingURL=createSpeechRecognition.js.map