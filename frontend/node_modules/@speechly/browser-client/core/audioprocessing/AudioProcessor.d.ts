import EnergyThresholdVAD from './EnergyThresholdVAD';
/**
 * @internal
 */
declare class AudioProcessor {
    vad?: EnergyThresholdVAD;
    /**
     * Sending state. If true, AudioProcessor is currently sending audio via onSendAudio callback
     */
    isSending: boolean;
    /**
     * Current count of downsampled and continuously processed samples (thru ProcessAudio) from start of stream
     */
    streamSamplePos: number;
    samplesSent: number;
    utteranceSerial: number;
    onSendAudio: (samples: Float32Array, startIndex: number, length: number) => void;
    onVadStateChange: (isSignalDetected: boolean) => void;
    private inputSampleRate;
    private readonly internalSampleRate;
    private sampleRingBuffer;
    private readonly historyFrames;
    private readonly frameMillis;
    private readonly frameSamples;
    private currentFrameNumber;
    private frameSamplePos;
    private streamFramePos;
    private wasSignalDetected;
    constructor(inputSampleRate: number, outputSampleRate: number, frameMillis: number, historyFrames: number);
    /**
     * Process speech audio samples from a microphone or other audio source.
     *
     * You can control when to start and stop process speech either manually with <see cref="StartContext"/> and <see cref="StopContext"/> or
     * automatically by providing a voice activity detection (VAD) field to <see cref="SpeechlyClient"/>.
     *
     * The audio is handled as follows:
     * - Downsample to 16kHz if needed
     * - Add to history ringbuffer
     * - Calculate energy (VAD)
     * - Automatic Start/StopContext (VAD)
     * - Send utterance audio to Speechly SLU decoder
     *
     * @param floats - Array of float containing samples to feed to the audio pipeline. Each sample needs to be in range -1f..1f.
     * @param start - Start index of audio to process in samples (default: `0`).
     * @param length - Length of audio to process in samples or `-1` to process the whole array (default: `-1`).
     * @param eos_at_end - StopStream internally uses this to force processing of last subframe at end of audio stream (default: `false`).
     * @returns
     */
    processAudio(floats: Float32Array, start?: number, length?: number, eos_at_end?: boolean): void;
    setSendAudio(active: boolean): void;
    reset(inputSampleRate?: number): void;
    /**
     * @returns current position in stream in milliseconds
     */
    getStreamPosition(): number;
    eos(): void;
    private processFrame;
    private processEos;
}
export default AudioProcessor;
